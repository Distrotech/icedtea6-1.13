diff -Nru openjdk.orig/jdk/make/sun/awt/FILES_c_unix.gmk openjdk/jdk/make/sun/awt/FILES_c_unix.gmk
--- openjdk.orig/jdk/make/sun/awt/FILES_c_unix.gmk	2014-04-08 05:27:03.554876623 +0100
+++ openjdk/jdk/make/sun/awt/FILES_c_unix.gmk	2014-04-10 02:56:51.238477367 +0100
@@ -142,59 +142,59 @@
 # These files rely on motif to be built, and should not be included
 # in a headless build.
 
-FILES_MOTIF_c = \
-	awt_AWTEvent.c \
-	awt_Button.c \
-	awt_Canvas.c \
-	awt_Checkbox.c \
-	awt_Component.c \
-	awt_Cursor.c \
-	awt_DataTransferer.c \
-	awt_DrawingSurface.c \
-	awt_Event.c \
-	awt_FileDialog.c \
-	awt_GlobalCursorManager.c \
-	awt_GraphicsEnv.c \
-	awt_InputMethod.c \
-	awt_Insets.c \
-	awt_KeyboardFocusManager.c \
-	awt_Label.c \
-	awt_List.c \
-	awt_Menu.c \
-	awt_MenuBar.c \
-	awt_MenuComponent.c \
-	awt_MenuItem.c \
-	awt_motif.c \
-	awt_Plugin.c \
-	awt_PopupMenu.c \
-	awt_Robot.c \
-	awt_Scrollbar.c \
-	awt_ScrollPane.c \
-	awt_Selection.c \
-	awt_UNIXToolkit.c \
-	awt_TextArea.c \
-	awt_TextField.c \
-	awt_TopLevel.c \
-	awt_mgrsel.c \
-	awt_util.c \
-	awt_wm.c \
-	awt_XmDnD.c \
-	awt_dnd.c \
-	awt_dnd_ds.c \
-	awt_dnd_dt.c \
-	canvas.c \
-	cursor.c \
-	multi_font.c \
-	robot_common.c \
-        list.c \
-        multiVis.c \
-	XDrawingArea.c \
-	MouseInfo.c \
-	awt_xembed.c \
-	awt_xembed_server.c \
-        gtk2_interface.c \
-        swing_GTKEngine.c \
-        swing_GTKStyle.c
+#FILES_MOTIF_c = \
+#keep	awt_AWTEvent.c \
+#	awt_Button.c \
+#	awt_Canvas.c \
+#	awt_Checkbox.c \
+#keep .h	awt_Component.c \
+#keep .h	awt_Cursor.c \
+#	awt_DataTransferer.c \
+#	awt_DrawingSurface.c \
+#	awt_Event.c \
+#	awt_FileDialog.c \
+#	awt_GlobalCursorManager.c \
+#	awt_GraphicsEnv.c \
+#	awt_InputMethod.c \
+#keep	awt_Insets.c \
+#	awt_KeyboardFocusManager.c \
+#	awt_Label.c \
+#	awt_List.c \
+#	awt_Menu.c \
+#	awt_MenuBar.c \
+#	awt_MenuComponent.c \
+#	awt_MenuItem.c \
+#	awt_motif.c \
+#	awt_Plugin.c \
+#	awt_PopupMenu.c \
+#	awt_Robot.c \
+#	awt_Scrollbar.c \
+#	awt_ScrollPane.c \
+#	awt_Selection.c \
+#	awt_UNIXToolkit.c \
+#	awt_TextArea.c \
+#	awt_TextField.c \
+#	awt_TopLevel.c \
+#	awt_mgrsel.c \
+#	awt_util.c \
+#	awt_wm.c \
+#	awt_XmDnD.c \
+#	awt_dnd.c \
+#	awt_dnd_ds.c \
+#	awt_dnd_dt.c \
+#	canvas.c \
+#	cursor.c \
+#	multi_font.c \
+#	robot_common.c \
+#        list.c \
+#        multiVis.c \
+#	XDrawingArea.c \
+#	MouseInfo.c \
+#	awt_xembed.c \
+#	awt_xembed_server.c \
+#        gtk2_interface.c \
+#        swing_GTKEngine.c \
+#        swing_GTKStyle.c
 
 
 # These files are required to be built, with or without motif.  Some of
diff -Nru openjdk.orig/jdk/make/sun/awt/FILES_export_unix.gmk openjdk/jdk/make/sun/awt/FILES_export_unix.gmk
--- openjdk.orig/jdk/make/sun/awt/FILES_export_unix.gmk	2014-04-08 06:21:07.378317552 +0100
+++ openjdk/jdk/make/sun/awt/FILES_export_unix.gmk	2014-04-10 02:56:51.238477367 +0100
@@ -60,48 +60,15 @@
 	sun/awt/image/DataBufferNative.java \
 	\
 	sun/awt/motif/X11FontMetrics.java \
-	sun/awt/motif/X11Clipboard.java \
-	sun/awt/motif/X11Selection.java \
-	sun/awt/motif/X11SelectionHolder.java \
 	sun/awt/X11InputMethod.java \
-	sun/awt/motif/MInputMethod.java \
-	sun/awt/motif/MInputMethodControl.java \
-	sun/awt/motif/MCustomCursor.java \
 	sun/awt/motif/MFontConfiguration.java \
 	sun/awt/motif/MFontPeer.java \
 	sun/awt/motif/MToolkit.java \
-	sun/awt/motif/MComponentPeer.java \
-	sun/awt/motif/MButtonPeer.java \
-	sun/awt/motif/MCanvasPeer.java \
-	sun/awt/motif/MCheckboxPeer.java \
-	sun/awt/motif/MFileDialogPeer.java \
-	sun/awt/motif/MGlobalCursorManager.java \
-	sun/awt/motif/MTextFieldPeer.java \
-	sun/awt/motif/MLabelPeer.java \
-	sun/awt/motif/MListPeer.java \
-	sun/awt/motif/MWindowPeer.java \
-	sun/awt/motif/MMenuBarPeer.java \
-	sun/awt/motif/MMenuPeer.java \
-        sun/awt/motif/MPopupMenuPeer.java \
-	sun/awt/motif/MDialogPeer.java \
-	sun/awt/motif/MMenuItemPeer.java \
-	sun/awt/motif/MCheckboxMenuItemPeer.java \
-	sun/awt/motif/MChoicePeer.java \
-	sun/awt/motif/MTextAreaPeer.java \
-	sun/awt/motif/MScrollbarPeer.java \
-	sun/awt/motif/MScrollPanePeer.java \
-	sun/awt/motif/MFramePeer.java \
         sun/awt/DebugSettings.java \
 	sun/awt/EmbeddedFrame.java \
-	sun/awt/motif/MEmbeddedFramePeer.java \
 	sun/awt/PlatformFont.java \
 	sun/awt/FontDescriptor.java \
 	sun/awt/NativeLibLoader.java \
-	sun/awt/motif/MDropTargetContextPeer.java \
-	sun/awt/motif/MDragSourceContextPeer.java \
-	sun/awt/motif/MRobotPeer.java \
-	sun/awt/motif/X11DragSourceContextPeer.java \
-	sun/awt/motif/X11DropTargetContextPeer.java \
 	sun/awt/X11GraphicsEnvironment.java \
 	sun/awt/X11GraphicsDevice.java \
 	sun/awt/X11GraphicsConfig.java \
@@ -124,7 +91,6 @@
         sun/java2d/cmm/ColorTransform.java \
         sun/awt/datatransfer/DataTransferer.java \
 	sun/awt/dnd/SunDragSourceContextPeer.java \
-	sun/awt/motif/MDataTransferer.java \
 	sun/awt/motif/MToolkitThreadBlockedHandler.java \
 	sun/java2d/opengl/OGLBlitLoops.java \
 	sun/java2d/opengl/OGLContext.java \
@@ -220,6 +186,5 @@
 	java/awt/event/NativeLibLoader.java \
 	java/awt/peer/ComponentPeer.java \
 	java/awt/dnd/DnDConstants.java \
-	sun/awt/CausedFocusEvent.java \
-	sun/awt/motif/MEmbedCanvasPeer.java
+	sun/awt/CausedFocusEvent.java
 
diff -Nru openjdk.orig/jdk/make/sun/awt/mapfile-mawt-vers openjdk/jdk/make/sun/awt/mapfile-mawt-vers
--- openjdk.orig/jdk/make/sun/awt/mapfile-mawt-vers	2014-04-08 13:33:31.866665689 +0100
+++ openjdk/jdk/make/sun/awt/mapfile-mawt-vers	2014-04-10 02:56:51.242477427 +0100
@@ -31,7 +31,7 @@
 	global:
 		JNI_OnLoad;
 
-                Java_sun_awt_motif_MComponentPeer_restoreFocus;
+                #Java_sun_awt_motif_MComponentPeer_restoreFocus;
 		Java_sun_awt_DefaultMouseInfoPeer_fillPointWithCoords;
 		Java_sun_awt_DefaultMouseInfoPeer_isWindowUnderMouse;
 		Java_java_awt_AWTEvent_nativeSetSource;
@@ -56,163 +56,163 @@
                 Java_sun_awt_UNIXToolkit_load_1stock_1icon;
                 Java_sun_awt_UNIXToolkit_load_1gtk_1icon;
 		Java_sun_awt_UNIXToolkit_nativeSync;
-		Java_sun_awt_motif_MButtonPeer_create;
-		Java_sun_awt_motif_MButtonPeer_setLabel;
-                Java_sun_awt_motif_MPanelPeer_pEnsureIndex;
-                Java_sun_awt_motif_MPanelPeer_pRestack;
-		Java_sun_awt_motif_MCanvasPeer_create;
-		Java_sun_awt_motif_MCanvasPeer_initIDs;
-		Java_sun_awt_motif_MCanvasPeer_resetTargetGC;
-		Java_sun_awt_motif_MCheckboxMenuItemPeer_pSetState;
-		Java_sun_awt_motif_MCheckboxPeer_create;
-		Java_sun_awt_motif_MCheckboxPeer_setCheckboxGroup;
-		Java_sun_awt_motif_MCheckboxPeer_setLabel;
-		Java_sun_awt_motif_MCheckboxPeer_pSetState;
-		Java_sun_awt_motif_MCheckboxPeer_pGetState;
-		Java_sun_awt_motif_MChoicePeer_addItem;
-		Java_sun_awt_motif_MChoicePeer_appendItems;
-		Java_sun_awt_motif_MChoicePeer_create;
-		Java_sun_awt_motif_MChoicePeer_pReshape;
-		Java_sun_awt_motif_MChoicePeer_remove;
-		Java_sun_awt_motif_MChoicePeer_removeAll;
-		Java_sun_awt_motif_MChoicePeer_setBackground;
-		Java_sun_awt_motif_MChoicePeer_pSelect;
-		Java_sun_awt_motif_MChoicePeer_setFont;
-		Java_sun_awt_motif_MChoicePeer_setForeground;
-		Java_sun_awt_motif_MComponentPeer_addNativeDropTarget;
-		Java_sun_awt_motif_MComponentPeer_getNativeColor;
-		Java_sun_awt_motif_MComponentPeer_getWindow;
-		Java_sun_awt_motif_MComponentPeer_pDisable;
-		Java_sun_awt_motif_MComponentPeer_pDispose;
-		Java_sun_awt_motif_MComponentPeer_pEnable;
-		Java_sun_awt_motif_MComponentPeer_pGetLocationOnScreen;
-		Java_sun_awt_motif_MComponentPeer_pGetLocationOnScreen2;
-		Java_sun_awt_motif_MComponentPeer_pHide;
-		Java_sun_awt_motif_MComponentPeer_pInitialize;
-		Java_sun_awt_motif_MComponentPeer_pMakeCursorVisible;
-		Java_sun_awt_motif_MComponentPeer_pReshape;
-		Java_sun_awt_motif_MComponentPeer_pShow;
-		Java_sun_awt_motif_MComponentPeer_removeNativeDropTarget;
-		Java_sun_awt_motif_MComponentPeer_pSetBackground;
-		Java_sun_awt_motif_MComponentPeer_pSetFont;
-                Java_sun_awt_motif_MComponentPeer_processSynchronousLightweightTransfer;
-                Java_sun_awt_motif_MComponentPeer__1requestFocus;
-                Java_sun_awt_motif_MComponentPeer_getNativeFocusedWindow;
-		Java_sun_awt_motif_MCheckboxMenuItemPeer_getState;
-		Java_sun_awt_motif_MComponentPeer_pSetForeground;
-		Java_sun_awt_motif_MDragSourceContextPeer_startDrag;
-		Java_sun_awt_motif_MDragSourceContextPeer_setNativeCursor;
-		Java_sun_awt_motif_MDropTargetContextPeer_addTransfer;
-		Java_sun_awt_motif_MDropTargetContextPeer_dropDone;
-		Java_sun_awt_motif_MDropTargetContextPeer_startTransfer;
-		Java_sun_awt_motif_X11DragSourceContextPeer_startDrag;
-		Java_sun_awt_motif_X11DragSourceContextPeer_setNativeCursor;
-		Java_sun_awt_motif_X11DropTargetContextPeer_sendResponse;
-		Java_sun_awt_motif_X11DropTargetContextPeer_dropDone;
-		Java_sun_awt_motif_X11DropTargetContextPeer_getData;
-		Java_sun_awt_motif_MEmbeddedFramePeer_NEFcreate;
-		Java_sun_awt_motif_MEmbeddedFramePeer_pShowImpl;
-		Java_sun_awt_motif_MEmbeddedFramePeer_requestXEmbedFocus;
-		Java_sun_awt_motif_MEmbeddedFramePeer_isXEmbedApplicationActive;
-		Java_sun_awt_motif_MEmbeddedFramePeer_isXEmbedActive;
-                Java_sun_awt_motif_MEmbeddedFramePeer_synthesizeFocusInOut;
-		Java_sun_awt_motif_MEmbeddedFramePeer_pReshapePrivate;
-		Java_sun_awt_motif_MEmbeddedFramePeer_getBoundsPrivate;
-		Java_sun_awt_motif_MEmbeddedFrame_getWidget;
-		Java_sun_awt_motif_MEmbeddedFrame_mapWidget;
-                Java_sun_awt_motif_MEmbedCanvasPeer_forwardEventToEmbedded;       
-		Java_sun_awt_motif_MFramePeer_pSetIconImage___3B_3I_3SII;
-		Java_sun_awt_motif_MFileDialogPeer_create;
-		Java_sun_awt_motif_MFileDialogPeer_pDispose;
-		Java_sun_awt_motif_MFileDialogPeer_pHide;
-		Java_sun_awt_motif_MFileDialogPeer_pReshape;
-		Java_sun_awt_motif_MFileDialogPeer_pShow;
-		Java_sun_awt_motif_MFileDialogPeer_setFileEntry;
-		Java_sun_awt_motif_MFileDialogPeer_setFont;
-		Java_sun_awt_motif_MFramePeer_pGetIconSize;
-		Java_sun_awt_motif_MGlobalCursorManager_cacheInit;
-		Java_sun_awt_motif_MGlobalCursorManager_findComponentAt;
-		Java_sun_awt_motif_MGlobalCursorManager_findHeavyweightUnderCursor;
-		Java_sun_awt_motif_MGlobalCursorManager_getCursorPos;
-		Java_sun_awt_motif_MGlobalCursorManager_getLocationOnScreen;
-		Java_sun_awt_motif_MLabelPeer_create;
-		Java_sun_awt_motif_MLabelPeer_setAlignment;
-		Java_sun_awt_motif_MLabelPeer_setText;
-		Java_sun_awt_motif_MListPeer_addItem;
-		Java_sun_awt_motif_MListPeer_create;
-		Java_sun_awt_motif_MListPeer_delItems;
-		Java_sun_awt_motif_MListPeer_deselect;
-		Java_sun_awt_motif_MListPeer_isSelected;
-		Java_sun_awt_motif_MListPeer_makeVisible;
-		Java_sun_awt_motif_MListPeer_nativeHandleMouseWheel;
-		Java_sun_awt_motif_MListPeer_select;
-		Java_sun_awt_motif_MListPeer_setMultipleSelections;
-		Java_sun_awt_motif_MMenuBarPeer_create;
-		Java_sun_awt_motif_MMenuItemPeer_createMenuItem;
-		Java_sun_awt_motif_MMenuItemPeer_pDisable;
-		Java_sun_awt_motif_MMenuItemPeer_pDispose;
-		Java_sun_awt_motif_MMenuItemPeer_pEnable;
-		Java_sun_awt_motif_MMenuItemPeer_pSetLabel;
-		Java_sun_awt_motif_MMenuPeer_createMenu;
-		Java_sun_awt_motif_MMenuPeer_createSubMenu;
-		Java_sun_awt_motif_MMenuPeer_pDispose;
-		Java_sun_awt_motif_MPopupMenuPeer_createMenu;
-		Java_sun_awt_motif_MPopupMenuPeer_pDispose;
-		Java_sun_awt_motif_MPopupMenuPeer_pShow;
-		Java_sun_awt_motif_MRobotPeer_getRGBPixelsImpl;
-		Java_sun_awt_motif_MRobotPeer_keyPressImpl;
-		Java_sun_awt_motif_MRobotPeer_keyReleaseImpl;
-		Java_sun_awt_motif_MRobotPeer_mouseMoveImpl;
-		Java_sun_awt_motif_MRobotPeer_mousePressImpl;
-		Java_sun_awt_motif_MRobotPeer_mouseReleaseImpl;
-		Java_sun_awt_motif_MRobotPeer_mouseWheelImpl;
-		Java_sun_awt_motif_MRobotPeer_setup;
-		Java_sun_awt_motif_MScrollbarPeer_create;
-		Java_sun_awt_motif_MScrollbarPeer_setLineIncrement;
-		Java_sun_awt_motif_MScrollbarPeer_setPageIncrement;
-		Java_sun_awt_motif_MScrollbarPeer_pSetValues;
-		Java_sun_awt_motif_MScrollPanePeer_create;
-		Java_sun_awt_motif_MScrollPanePeer_pGetBlockIncrement;
-		Java_sun_awt_motif_MScrollPanePeer_pGetScrollbarSpace;
-		Java_sun_awt_motif_MScrollPanePeer_pGetShadow;
-		Java_sun_awt_motif_MScrollPanePeer_pInsets;
-		Java_sun_awt_motif_MScrollPanePeer_pSetIncrement;
-		Java_sun_awt_motif_MScrollPanePeer_pSetScrollChild;
-		Java_sun_awt_motif_MScrollPanePeer_setScrollPosition;
-		Java_sun_awt_motif_MScrollPanePeer_setTypedValue;
-		Java_sun_awt_motif_MTextAreaPeer_initIDs;
-		Java_sun_awt_motif_MTextAreaPeer_pCreate;
-		Java_sun_awt_motif_MTextAreaPeer_getCaretPosition;
-		Java_sun_awt_motif_MTextAreaPeer_getExtraHeight;
-		Java_sun_awt_motif_MTextAreaPeer_getExtraWidth;
-		Java_sun_awt_motif_MTextAreaPeer_getSelectionEnd;
-		Java_sun_awt_motif_MTextAreaPeer_getSelectionStart;
-		Java_sun_awt_motif_MTextAreaPeer_getText;
-		Java_sun_awt_motif_MTextAreaPeer_insert;
-		Java_sun_awt_motif_MTextAreaPeer_nativeHandleMouseWheel;
-		Java_sun_awt_motif_MTextAreaPeer_pMakeCursorVisible;
-		Java_sun_awt_motif_MTextAreaPeer_pSetEditable;
-		Java_sun_awt_motif_MTextAreaPeer_pShow2;
-		Java_sun_awt_motif_MTextAreaPeer_replaceRange;
-		Java_sun_awt_motif_MTextAreaPeer_select;
-		Java_sun_awt_motif_MTextAreaPeer_setCaretPosition;
-		Java_sun_awt_motif_MTextAreaPeer_setFont;
-		Java_sun_awt_motif_MTextAreaPeer_setText;
-		Java_sun_awt_motif_MTextAreaPeer_setTextBackground;
-		Java_sun_awt_motif_MTextFieldPeer_initIDs;
-		Java_sun_awt_motif_MTextFieldPeer_pCreate;
-		Java_sun_awt_motif_MTextFieldPeer_getCaretPosition;
-		Java_sun_awt_motif_MTextFieldPeer_getSelectionEnd;
-		Java_sun_awt_motif_MTextFieldPeer_getSelectionStart;
-		Java_sun_awt_motif_MTextFieldPeer_getText;
-		Java_sun_awt_motif_MTextFieldPeer_insertReplaceText;
-		Java_sun_awt_motif_MTextFieldPeer_preDispose;
-		Java_sun_awt_motif_MTextFieldPeer_pSetEditable;
-		Java_sun_awt_motif_MTextFieldPeer_select;
-		Java_sun_awt_motif_MTextFieldPeer_setCaretPosition;
-		Java_sun_awt_motif_MTextFieldPeer_setEchoChar;
-		Java_sun_awt_motif_MTextFieldPeer_setFont;
-		Java_sun_awt_motif_MTextFieldPeer_setText;
+		#Java_sun_awt_motif_MButtonPeer_create;
+		#Java_sun_awt_motif_MButtonPeer_setLabel;
+                #Java_sun_awt_motif_MPanelPeer_pEnsureIndex;
+                #Java_sun_awt_motif_MPanelPeer_pRestack;
+		#Java_sun_awt_motif_MCanvasPeer_create;
+		#Java_sun_awt_motif_MCanvasPeer_initIDs;
+		#Java_sun_awt_motif_MCanvasPeer_resetTargetGC;
+		#Java_sun_awt_motif_MCheckboxMenuItemPeer_pSetState;
+		#Java_sun_awt_motif_MCheckboxPeer_create;
+		#Java_sun_awt_motif_MCheckboxPeer_setCheckboxGroup;
+		#Java_sun_awt_motif_MCheckboxPeer_setLabel;
+		#Java_sun_awt_motif_MCheckboxPeer_pSetState;
+		#Java_sun_awt_motif_MCheckboxPeer_pGetState;
+		#Java_sun_awt_motif_MChoicePeer_addItem;
+		#Java_sun_awt_motif_MChoicePeer_appendItems;
+		#Java_sun_awt_motif_MChoicePeer_create;
+		#Java_sun_awt_motif_MChoicePeer_pReshape;
+		#Java_sun_awt_motif_MChoicePeer_remove;
+		#Java_sun_awt_motif_MChoicePeer_removeAll;
+		#Java_sun_awt_motif_MChoicePeer_setBackground;
+		#Java_sun_awt_motif_MChoicePeer_pSelect;
+		#Java_sun_awt_motif_MChoicePeer_setFont;
+		#Java_sun_awt_motif_MChoicePeer_setForeground;
+		#Java_sun_awt_motif_MComponentPeer_addNativeDropTarget;
+		#Java_sun_awt_motif_MComponentPeer_getNativeColor;
+		#Java_sun_awt_motif_MComponentPeer_getWindow;
+		#Java_sun_awt_motif_MComponentPeer_pDisable;
+		#Java_sun_awt_motif_MComponentPeer_pDispose;
+		#Java_sun_awt_motif_MComponentPeer_pEnable;
+		#Java_sun_awt_motif_MComponentPeer_pGetLocationOnScreen;
+		#Java_sun_awt_motif_MComponentPeer_pGetLocationOnScreen2;
+		#Java_sun_awt_motif_MComponentPeer_pHide;
+		#Java_sun_awt_motif_MComponentPeer_pInitialize;
+		#Java_sun_awt_motif_MComponentPeer_pMakeCursorVisible;
+		#Java_sun_awt_motif_MComponentPeer_pReshape;
+		#Java_sun_awt_motif_MComponentPeer_pShow;
+		#Java_sun_awt_motif_MComponentPeer_removeNativeDropTarget;
+		#Java_sun_awt_motif_MComponentPeer_pSetBackground;
+		#Java_sun_awt_motif_MComponentPeer_pSetFont;
+                #Java_sun_awt_motif_MComponentPeer_processSynchronousLightweightTransfer;
+                #Java_sun_awt_motif_MComponentPeer__1requestFocus;
+                #Java_sun_awt_motif_MComponentPeer_getNativeFocusedWindow;
+		#Java_sun_awt_motif_MCheckboxMenuItemPeer_getState;
+		#Java_sun_awt_motif_MComponentPeer_pSetForeground;
+		#Java_sun_awt_motif_MDragSourceContextPeer_startDrag;
+		#Java_sun_awt_motif_MDragSourceContextPeer_setNativeCursor;
+		#Java_sun_awt_motif_MDropTargetContextPeer_addTransfer;
+		#Java_sun_awt_motif_MDropTargetContextPeer_dropDone;
+		#Java_sun_awt_motif_MDropTargetContextPeer_startTransfer;
+		#Java_sun_awt_motif_X11DragSourceContextPeer_startDrag;
+		#Java_sun_awt_motif_X11DragSourceContextPeer_setNativeCursor;
+		#Java_sun_awt_motif_X11DropTargetContextPeer_sendResponse;
+		#Java_sun_awt_motif_X11DropTargetContextPeer_dropDone;
+		#Java_sun_awt_motif_X11DropTargetContextPeer_getData;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_NEFcreate;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_pShowImpl;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_requestXEmbedFocus;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_isXEmbedApplicationActive;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_isXEmbedActive;
+                #Java_sun_awt_motif_MEmbeddedFramePeer_synthesizeFocusInOut;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_pReshapePrivate;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_getBoundsPrivate;
+		#Java_sun_awt_motif_MEmbeddedFrame_getWidget;
+		#Java_sun_awt_motif_MEmbeddedFrame_mapWidget;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_forwardEventToEmbedded;       
+		#Java_sun_awt_motif_MFramePeer_pSetIconImage___3B_3I_3SII;
+		#Java_sun_awt_motif_MFileDialogPeer_create;
+		#Java_sun_awt_motif_MFileDialogPeer_pDispose;
+		#Java_sun_awt_motif_MFileDialogPeer_pHide;
+		#Java_sun_awt_motif_MFileDialogPeer_pReshape;
+		#Java_sun_awt_motif_MFileDialogPeer_pShow;
+		#Java_sun_awt_motif_MFileDialogPeer_setFileEntry;
+		#Java_sun_awt_motif_MFileDialogPeer_setFont;
+		#Java_sun_awt_motif_MFramePeer_pGetIconSize;
+		#Java_sun_awt_motif_MGlobalCursorManager_cacheInit;
+		#Java_sun_awt_motif_MGlobalCursorManager_findComponentAt;
+		#Java_sun_awt_motif_MGlobalCursorManager_findHeavyweightUnderCursor;
+		#Java_sun_awt_motif_MGlobalCursorManager_getCursorPos;
+		#Java_sun_awt_motif_MGlobalCursorManager_getLocationOnScreen;
+		#Java_sun_awt_motif_MLabelPeer_create;
+		#Java_sun_awt_motif_MLabelPeer_setAlignment;
+		#Java_sun_awt_motif_MLabelPeer_setText;
+		#Java_sun_awt_motif_MListPeer_addItem;
+		#Java_sun_awt_motif_MListPeer_create;
+		#Java_sun_awt_motif_MListPeer_delItems;
+		#Java_sun_awt_motif_MListPeer_deselect;
+		#Java_sun_awt_motif_MListPeer_isSelected;
+		#Java_sun_awt_motif_MListPeer_makeVisible;
+		#Java_sun_awt_motif_MListPeer_nativeHandleMouseWheel;
+		#Java_sun_awt_motif_MListPeer_select;
+		#Java_sun_awt_motif_MListPeer_setMultipleSelections;
+		#Java_sun_awt_motif_MMenuBarPeer_create;
+		#Java_sun_awt_motif_MMenuItemPeer_createMenuItem;
+		#Java_sun_awt_motif_MMenuItemPeer_pDisable;
+		#Java_sun_awt_motif_MMenuItemPeer_pDispose;
+		#Java_sun_awt_motif_MMenuItemPeer_pEnable;
+		#Java_sun_awt_motif_MMenuItemPeer_pSetLabel;
+		#Java_sun_awt_motif_MMenuPeer_createMenu;
+		#Java_sun_awt_motif_MMenuPeer_createSubMenu;
+		#Java_sun_awt_motif_MMenuPeer_pDispose;
+		#Java_sun_awt_motif_MPopupMenuPeer_createMenu;
+		#Java_sun_awt_motif_MPopupMenuPeer_pDispose;
+		#Java_sun_awt_motif_MPopupMenuPeer_pShow;
+		#Java_sun_awt_motif_MRobotPeer_getRGBPixelsImpl;
+		#Java_sun_awt_motif_MRobotPeer_keyPressImpl;
+		#Java_sun_awt_motif_MRobotPeer_keyReleaseImpl;
+		#Java_sun_awt_motif_MRobotPeer_mouseMoveImpl;
+		#Java_sun_awt_motif_MRobotPeer_mousePressImpl;
+		#Java_sun_awt_motif_MRobotPeer_mouseReleaseImpl;
+		#Java_sun_awt_motif_MRobotPeer_mouseWheelImpl;
+		#Java_sun_awt_motif_MRobotPeer_setup;
+		#Java_sun_awt_motif_MScrollbarPeer_create;
+		#Java_sun_awt_motif_MScrollbarPeer_setLineIncrement;
+		#Java_sun_awt_motif_MScrollbarPeer_setPageIncrement;
+		#Java_sun_awt_motif_MScrollbarPeer_pSetValues;
+		#Java_sun_awt_motif_MScrollPanePeer_create;
+		#Java_sun_awt_motif_MScrollPanePeer_pGetBlockIncrement;
+		#Java_sun_awt_motif_MScrollPanePeer_pGetScrollbarSpace;
+		#Java_sun_awt_motif_MScrollPanePeer_pGetShadow;
+		#Java_sun_awt_motif_MScrollPanePeer_pInsets;
+		#Java_sun_awt_motif_MScrollPanePeer_pSetIncrement;
+		#Java_sun_awt_motif_MScrollPanePeer_pSetScrollChild;
+		#Java_sun_awt_motif_MScrollPanePeer_setScrollPosition;
+		#Java_sun_awt_motif_MScrollPanePeer_setTypedValue;
+		#Java_sun_awt_motif_MTextAreaPeer_initIDs;
+		#Java_sun_awt_motif_MTextAreaPeer_pCreate;
+		#Java_sun_awt_motif_MTextAreaPeer_getCaretPosition;
+		#Java_sun_awt_motif_MTextAreaPeer_getExtraHeight;
+		#Java_sun_awt_motif_MTextAreaPeer_getExtraWidth;
+		#Java_sun_awt_motif_MTextAreaPeer_getSelectionEnd;
+		#Java_sun_awt_motif_MTextAreaPeer_getSelectionStart;
+		#Java_sun_awt_motif_MTextAreaPeer_getText;
+		#Java_sun_awt_motif_MTextAreaPeer_insert;
+		#Java_sun_awt_motif_MTextAreaPeer_nativeHandleMouseWheel;
+		#Java_sun_awt_motif_MTextAreaPeer_pMakeCursorVisible;
+		#Java_sun_awt_motif_MTextAreaPeer_pSetEditable;
+		#Java_sun_awt_motif_MTextAreaPeer_pShow2;
+		#Java_sun_awt_motif_MTextAreaPeer_replaceRange;
+		#Java_sun_awt_motif_MTextAreaPeer_select;
+                #Java_sun_awt_motif_MTextAreaPeer_setCaretPosition;
+		#Java_sun_awt_motif_MTextAreaPeer_setFont;
+		#Java_sun_awt_motif_MTextAreaPeer_setText;
+		#Java_sun_awt_motif_MTextAreaPeer_setTextBackground;
+		#Java_sun_awt_motif_MTextFieldPeer_initIDs;
+		#Java_sun_awt_motif_MTextFieldPeer_pCreate;
+		#Java_sun_awt_motif_MTextFieldPeer_getCaretPosition;
+		#Java_sun_awt_motif_MTextFieldPeer_getSelectionEnd;
+		#Java_sun_awt_motif_MTextFieldPeer_getSelectionStart;
+		#Java_sun_awt_motif_MTextFieldPeer_getText;
+		#Java_sun_awt_motif_MTextFieldPeer_insertReplaceText;
+		#Java_sun_awt_motif_MTextFieldPeer_preDispose;
+		#Java_sun_awt_motif_MTextFieldPeer_pSetEditable;
+		#Java_sun_awt_motif_MTextFieldPeer_select;
+		#Java_sun_awt_motif_MTextFieldPeer_setCaretPosition;
+		#Java_sun_awt_motif_MTextFieldPeer_setEchoChar;
+		#Java_sun_awt_motif_MTextFieldPeer_setFont;
+		#Java_sun_awt_motif_MTextFieldPeer_setText;
 		Java_sun_awt_motif_MToolkit_beep;
 		Java_sun_awt_motif_MToolkit_getLockingKeyStateNative;
 		Java_sun_awt_motif_MToolkit_getMulticlickTime;
@@ -236,30 +236,30 @@
                 Java_sun_awt_motif_MToolkit_nativeGrab;
                 Java_sun_awt_motif_MToolkit_getWMName;
 		Java_sun_awt_motif_MWindowAttributes_initIDs;
-		Java_sun_awt_motif_MWindowPeer_pDispose;
-		Java_sun_awt_motif_MWindowPeer_pHide;
-		Java_sun_awt_motif_MWindowPeer_pReshape;
-		Java_sun_awt_motif_MWindowPeer_pSetTitle;
-		Java_sun_awt_motif_MWindowPeer_pShow;
-		Java_sun_awt_motif_MWindowPeer_setResizable;
-		Java_sun_awt_motif_MWindowPeer_toBack;
-		Java_sun_awt_motif_MWindowPeer_addTextComponentNative;
-		Java_sun_awt_motif_MWindowPeer_getState;
-		Java_sun_awt_motif_MWindowPeer_pSetIMMOption;
-		Java_sun_awt_motif_MWindowPeer_pSetMenuBar;
-		Java_sun_awt_motif_MWindowPeer_pShowModal;
-		Java_sun_awt_motif_MWindowPeer_removeTextComponentNative;
-		Java_sun_awt_motif_MWindowPeer_setSaveUnder;
-		Java_sun_awt_motif_MWindowPeer_setState;
-		Java_sun_awt_motif_MWindowPeer_resetTargetGC;
-		Java_sun_awt_motif_MWindowPeer_registerX11DropTarget;
-		Java_sun_awt_motif_MWindowPeer_unregisterX11DropTarget;
-		Java_sun_awt_motif_MWindowPeer_updateAlwaysOnTop;
-                Java_sun_awt_motif_MWindowPeer_setFocusableWindow;
-                Java_sun_awt_motif_MWindowPeer_pToFront;
-		Java_sun_awt_motif_MCustomCursor_cacheInit;
-		Java_sun_awt_motif_MCustomCursor_createCursor;
-		Java_sun_awt_motif_MCustomCursor_queryBestCursor;
+		#Java_sun_awt_motif_MWindowPeer_pDispose;
+		#Java_sun_awt_motif_MWindowPeer_pHide;
+		#Java_sun_awt_motif_MWindowPeer_pReshape;
+		#Java_sun_awt_motif_MWindowPeer_pSetTitle;
+		#Java_sun_awt_motif_MWindowPeer_pShow;
+		#Java_sun_awt_motif_MWindowPeer_setResizable;
+		#Java_sun_awt_motif_MWindowPeer_toBack;
+		#Java_sun_awt_motif_MWindowPeer_addTextComponentNative;
+		#Java_sun_awt_motif_MWindowPeer_getState;
+		#Java_sun_awt_motif_MWindowPeer_pSetIMMOption;
+		#Java_sun_awt_motif_MWindowPeer_pSetMenuBar;
+		#Java_sun_awt_motif_MWindowPeer_pShowModal;
+		#Java_sun_awt_motif_MWindowPeer_removeTextComponentNative;
+		#Java_sun_awt_motif_MWindowPeer_setSaveUnder;
+		#Java_sun_awt_motif_MWindowPeer_setState;
+		#Java_sun_awt_motif_MWindowPeer_resetTargetGC;
+		#Java_sun_awt_motif_MWindowPeer_registerX11DropTarget;
+		#Java_sun_awt_motif_MWindowPeer_unregisterX11DropTarget;
+		#Java_sun_awt_motif_MWindowPeer_updateAlwaysOnTop;
+                #Java_sun_awt_motif_MWindowPeer_setFocusableWindow;
+                #Java_sun_awt_motif_MWindowPeer_pToFront;
+		#Java_sun_awt_motif_MCustomCursor_cacheInit;
+		#Java_sun_awt_motif_MCustomCursor_createCursor;
+		#Java_sun_awt_motif_MCustomCursor_queryBestCursor;
 		Java_sun_awt_motif_X11FontMetrics_bytesWidth;
 		Java_sun_awt_motif_X11FontMetrics_getMFCharsWidth;
 		Java_sun_awt_motif_X11FontMetrics_init;
@@ -268,18 +268,18 @@
 		Java_sun_awt_X11InputMethod_resetXIC;
 		Java_sun_awt_X11InputMethod_setCompositionEnabledNative;
 		Java_sun_awt_X11InputMethod_turnoffStatusWindow;
-		Java_sun_awt_motif_MInputMethod_openXIMNative;
-		Java_sun_awt_motif_MInputMethod_configureStatusAreaNative;
-		Java_sun_awt_motif_MInputMethod_createXICNative;
-		Java_sun_awt_motif_MInputMethod_reconfigureXICNative;
-		Java_sun_awt_motif_MInputMethod_setXICFocusNative;
-		Java_sun_awt_motif_X11Clipboard_getClipboardData;
-		Java_sun_awt_motif_X11Clipboard_getClipboardFormats;
-		Java_sun_awt_motif_X11Clipboard_registerClipboardViewer;
-		Java_sun_awt_motif_X11Clipboard_unregisterClipboardViewer;
-		Java_sun_awt_motif_X11Selection_init;
-		Java_sun_awt_motif_X11Selection_pGetSelectionOwnership;
-		Java_sun_awt_motif_X11Selection_clearNativeContext;
+		#Java_sun_awt_motif_MInputMethod_openXIMNative;
+		#Java_sun_awt_motif_MInputMethod_configureStatusAreaNative;
+		#Java_sun_awt_motif_MInputMethod_createXICNative;
+		#Java_sun_awt_motif_MInputMethod_reconfigureXICNative;
+		#Java_sun_awt_motif_MInputMethod_setXICFocusNative;
+		#Java_sun_awt_motif_X11Clipboard_getClipboardData;
+		#Java_sun_awt_motif_X11Clipboard_getClipboardFormats;
+		#Java_sun_awt_motif_X11Clipboard_registerClipboardViewer;
+		#Java_sun_awt_motif_X11Clipboard_unregisterClipboardViewer;
+		#Java_sun_awt_motif_X11Selection_init;
+		#Java_sun_awt_motif_X11Selection_pGetSelectionOwnership;
+		#Java_sun_awt_motif_X11Selection_clearNativeContext;
 		Java_sun_awt_SunToolkit_closeSplashScreen;
 		Java_sun_awt_PlatformFont_initIDs;
 		Java_sun_awt_X11GraphicsConfig_init;
@@ -312,25 +312,25 @@
                 Java_sun_awt_X11GraphicsEnvironment_initGLX;
 		Java_sun_awt_X11GraphicsEnvironment_pRunningXinerama;
 		Java_sun_awt_X11GraphicsEnvironment_getXineramaCenterPoint;
-                Java_sun_awt_motif_MEmbedCanvasPeer_initXEmbedServer;
-                Java_sun_awt_motif_MEmbedCanvasPeer_destroyXEmbedServer;
-                Java_sun_awt_motif_MEmbedCanvasPeer_isXEmbedActive;
-                Java_sun_awt_motif_MEmbedCanvasPeer_initDispatching;
-                Java_sun_awt_motif_MEmbedCanvasPeer_endDispatching;
-                Java_sun_awt_motif_MEmbedCanvasPeer_embedChild;
-                Java_sun_awt_motif_MEmbedCanvasPeer_childDestroyed;
-                Java_sun_awt_motif_MEmbedCanvasPeer_getEmbedPreferredSize;
-                Java_sun_awt_motif_MEmbedCanvasPeer_getEmbedMinimumSize;
-                Java_sun_awt_motif_MEmbedCanvasPeer_getClientBounds;
-                Java_sun_awt_motif_MEmbedCanvasPeer_notifyChildEmbedded;
-                Java_sun_awt_motif_MEmbedCanvasPeer_detachChild;
-                Java_sun_awt_motif_MEmbedCanvasPeer_forwardKeyEvent;
-                Java_sun_awt_motif_MEmbedCanvasPeer_getAWTKeyCodeForKeySym;
-                Java_sun_awt_motif_MEmbedCanvasPeer_sendMessage__I;
-                Java_sun_awt_motif_MEmbedCanvasPeer_sendMessage__IJJJ;
-                Java_sun_awt_motif_MEmbedCanvasPeer_getWindow;       
-                Java_sun_awt_motif_GrabbedKey_initKeySymAndModifiers;
-                Java_sun_awt_motif_MEmbeddedFramePeer_traverseOut;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_initXEmbedServer;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_destroyXEmbedServer;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_isXEmbedActive;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_initDispatching;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_endDispatching;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_embedChild;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_childDestroyed;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_getEmbedPreferredSize;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_getEmbedMinimumSize;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_getClientBounds;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_notifyChildEmbedded;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_detachChild;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_forwardKeyEvent;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_getAWTKeyCodeForKeySym;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_sendMessage__I;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_sendMessage__IJJJ;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_getWindow;       
+                #Java_sun_awt_motif_GrabbedKey_initKeySymAndModifiers;
+                #Java_sun_awt_motif_MEmbeddedFramePeer_traverseOut;
 		Java_java_awt_AWTEvent_initIDs;
 		Java_java_awt_Button_initIDs;
 		Java_java_awt_Container_initIDs;
@@ -344,39 +344,39 @@
 		Java_java_awt_Insets_initIDs;
 		Java_java_awt_TextField_initIDs;
 		Java_java_awt_Window_initIDs;
-		Java_sun_awt_motif_MCheckboxPeer_getIndicatorSize;
-		Java_sun_awt_motif_MCheckboxPeer_getSpacing;
-		Java_sun_awt_motif_MChoicePeer_freeNativeData;
-		Java_sun_awt_motif_MComponentPeer_getComponents_1NoClientCode;
-		Java_sun_awt_motif_MComponentPeer_getParent_1NoClientCode;
-		Java_sun_awt_motif_MComponentPeer_initIDs;
-		Java_sun_awt_motif_MComponentPeer_nativeHandleEvent;
-		Java_sun_awt_motif_MComponentPeer_pSetCursor;
-		Java_sun_awt_motif_MComponentPeer_pSetInnerForeground;
-		Java_sun_awt_motif_MComponentPeer_pSetScrollbarBackground;
-		Java_sun_awt_motif_MComponentPeer_setTargetBackground;
-		Java_sun_awt_motif_MDataTransferer_dragQueryFile;
-		Java_sun_awt_motif_MDataTransferer_getAtomForTarget;
-		Java_sun_awt_motif_MDataTransferer_getTargetNameForAtom;
-		Java_sun_awt_motif_MFileDialogPeer_insertReplaceFileDialogText;
+		#Java_sun_awt_motif_MCheckboxPeer_getIndicatorSize;
+		#Java_sun_awt_motif_MCheckboxPeer_getSpacing;
+		#Java_sun_awt_motif_MChoicePeer_freeNativeData;
+		#Java_sun_awt_motif_MComponentPeer_getComponents_1NoClientCode;
+		#Java_sun_awt_motif_MComponentPeer_getParent_1NoClientCode;
+		#Java_sun_awt_motif_MComponentPeer_initIDs;
+		#Java_sun_awt_motif_MComponentPeer_nativeHandleEvent;
+		#Java_sun_awt_motif_MComponentPeer_pSetCursor;
+		#Java_sun_awt_motif_MComponentPeer_pSetInnerForeground;
+		#Java_sun_awt_motif_MComponentPeer_pSetScrollbarBackground;
+		#Java_sun_awt_motif_MComponentPeer_setTargetBackground;
+		#Java_sun_awt_motif_MDataTransferer_dragQueryFile;
+		#Java_sun_awt_motif_MDataTransferer_getAtomForTarget;
+		#Java_sun_awt_motif_MDataTransferer_getTargetNameForAtom;
+		#Java_sun_awt_motif_MFileDialogPeer_insertReplaceFileDialogText;
 		Java_sun_awt_motif_MFontPeer_initIDs;
-		Java_sun_awt_motif_MListPeer_setBackground;
-		Java_sun_awt_motif_MMenuBarPeer_initIDs;
-		Java_sun_awt_motif_MMenuBarPeer_pDispose;
-		Java_sun_awt_motif_MMenuItemPeer_getParent_1NoClientCode;
-		Java_sun_awt_motif_MMenuItemPeer_initIDs;
-		Java_sun_awt_motif_MMenuItemPeer_pSetShortcut;
-		Java_sun_awt_motif_MPopupMenuPeer_initIDs;
-		Java_sun_awt_motif_MScrollbarPeer_initIDs;
-		Java_sun_awt_motif_MScrollPanePeer_initIDs;
-		Java_sun_awt_motif_MTextAreaPeer_pSetCursor;
+		#Java_sun_awt_motif_MListPeer_setBackground;
+		#Java_sun_awt_motif_MMenuBarPeer_initIDs;
+		#Java_sun_awt_motif_MMenuBarPeer_pDispose;
+		#Java_sun_awt_motif_MMenuItemPeer_getParent_1NoClientCode;
+		#Java_sun_awt_motif_MMenuItemPeer_initIDs;
+		#Java_sun_awt_motif_MMenuItemPeer_pSetShortcut;
+		#Java_sun_awt_motif_MPopupMenuPeer_initIDs;
+		#Java_sun_awt_motif_MScrollbarPeer_initIDs;
+		#Java_sun_awt_motif_MScrollPanePeer_initIDs;
+		#Java_sun_awt_motif_MTextAreaPeer_pSetCursor;
 		Java_sun_awt_motif_MToolkit_shutdown;
-		Java_sun_awt_motif_MWindowPeer_initIDs;
-		Java_sun_awt_motif_MWindowPeer_pCreate;
-		Java_sun_awt_motif_MWindowPeer_wrapInSequenced;
+		#Java_sun_awt_motif_MWindowPeer_initIDs;
+		#Java_sun_awt_motif_MWindowPeer_pCreate;
+		#Java_sun_awt_motif_MWindowPeer_wrapInSequenced;
 		Java_sun_awt_motif_X11FontMetrics_initIDs;
-		Java_sun_awt_X11InputMethod_initIDs;
-		Java_sun_awt_motif_X11Selection_initIDs;
+		#Java_sun_awt_X11InputMethod_initIDs;
+		#Java_sun_awt_motif_X11Selection_initIDs;
 		Java_sun_awt_motif_MToolkitThreadBlockedHandler_enter;
 		Java_sun_awt_motif_MToolkitThreadBlockedHandler_exit;
 		Java_sun_awt_X11GraphicsConfig_init;
diff -Nru openjdk.orig/jdk/make/sun/awt/mapfile-vers-linux openjdk/jdk/make/sun/awt/mapfile-vers-linux
--- openjdk.orig/jdk/make/sun/awt/mapfile-vers-linux	2014-04-08 13:33:31.870665747 +0100
+++ openjdk/jdk/make/sun/awt/mapfile-vers-linux	2014-04-10 02:56:51.246477485 +0100
@@ -169,7 +169,7 @@
 		GrPrim_Sg2dGetPixel;
 		GrPrim_Sg2dGetLCDTextContrast;
 
-		Java_sun_awt_motif_MComponentPeer_restoreFocus;
+		#Java_sun_awt_motif_MComponentPeer_restoreFocus;
 		Java_sun_awt_DefaultMouseInfoPeer_fillPointWithCoords;
 		Java_sun_awt_DefaultMouseInfoPeer_isWindowUnderMouse;
 		Java_java_awt_AWTEvent_nativeSetSource;
@@ -188,158 +188,158 @@
 		Java_java_awt_ScrollPane_initIDs;
 		Java_java_awt_TextArea_initIDs;
 		Java_sun_awt_FontDescriptor_initIDs;
-		Java_sun_awt_motif_MButtonPeer_create;
-		Java_sun_awt_motif_MButtonPeer_setLabel;
-		Java_sun_awt_motif_MCanvasPeer_create;
-		Java_sun_awt_motif_MCanvasPeer_initIDs;
-		Java_sun_awt_motif_MCanvasPeer_resetTargetGC;
-		Java_sun_awt_motif_MCheckboxMenuItemPeer_pSetState;
-		Java_sun_awt_motif_MCheckboxPeer_create;
-		Java_sun_awt_motif_MCheckboxPeer_setCheckboxGroup;
-		Java_sun_awt_motif_MCheckboxPeer_setLabel;
-		Java_sun_awt_motif_MCheckboxPeer_pSetState;
-		Java_sun_awt_motif_MCheckboxPeer_pGetState;
-		Java_sun_awt_motif_MChoicePeer_addItem;
-		Java_sun_awt_motif_MChoicePeer_appendItems;
-		Java_sun_awt_motif_MChoicePeer_create;
-		Java_sun_awt_motif_MChoicePeer_pReshape;
-		Java_sun_awt_motif_MChoicePeer_remove;
-		Java_sun_awt_motif_MChoicePeer_removeAll;
-		Java_sun_awt_motif_MChoicePeer_setBackground;
-		Java_sun_awt_motif_MChoicePeer_pSelect;
-		Java_sun_awt_motif_MChoicePeer_setFont;
-		Java_sun_awt_motif_MChoicePeer_setForeground;
-		Java_sun_awt_motif_MComponentPeer_addNativeDropTarget;
-		Java_sun_awt_motif_MComponentPeer_createBackBuffer;
-		Java_sun_awt_motif_MComponentPeer_destroyBackBuffer;
-		Java_sun_awt_motif_MComponentPeer_getNativeColor;
-		Java_sun_awt_motif_MComponentPeer_getWindow;
-		Java_sun_awt_motif_MComponentPeer_pDisable;
-		Java_sun_awt_motif_MComponentPeer_pDispose;
-		Java_sun_awt_motif_MComponentPeer_pEnable;
-		Java_sun_awt_motif_MComponentPeer_pGetLocationOnScreen;
-		Java_sun_awt_motif_MComponentPeer_pGetLocationOnScreen2;
-		Java_sun_awt_motif_MComponentPeer_pHide;
-		Java_sun_awt_motif_MComponentPeer_pInitialize;
-		Java_sun_awt_motif_MComponentPeer_pMakeCursorVisible;
-		Java_sun_awt_motif_MComponentPeer_pReshape;
-		Java_sun_awt_motif_MComponentPeer_pShow;
-		Java_sun_awt_motif_MComponentPeer_removeNativeDropTarget;
-		Java_sun_awt_motif_MComponentPeer_swapBuffers;
-		Java_sun_awt_motif_MComponentPeer_pSetBackground;
-		Java_sun_awt_motif_MComponentPeer_pSetFont;
-                Java_sun_awt_motif_MComponentPeer_processSynchronousLightweightTransfer;
-                Java_sun_awt_motif_MComponentPeer__1requestFocus;
-		Java_sun_awt_motif_MCheckboxMenuItemPeer_getState;
-		Java_sun_awt_motif_MComponentPeer_pSetForeground;
-		Java_sun_awt_motif_MDragSourceContextPeer_startDrag;
-		Java_sun_awt_motif_MDragSourceContextPeer_setNativeCursor;
-		Java_sun_awt_motif_MDropTargetContextPeer_addTransfer;
-		Java_sun_awt_motif_MDropTargetContextPeer_dropDone;
-		Java_sun_awt_motif_MDropTargetContextPeer_startTransfer;
-		Java_sun_awt_motif_X11DragSourceContextPeer_startDrag;
-		Java_sun_awt_motif_X11DragSourceContextPeer_setNativeCursor;
-		Java_sun_awt_motif_X11DropTargetContextPeer_sendResponse;
-		Java_sun_awt_motif_X11DropTargetContextPeer_dropDone;
-		Java_sun_awt_motif_X11DropTargetContextPeer_getData;
-		Java_sun_awt_motif_MEmbeddedFramePeer_NEFcreate;
-		Java_sun_awt_motif_MEmbeddedFramePeer_pShowImpl;
-		Java_sun_awt_motif_MEmbeddedFramePeer_pReshapePrivate;
-		Java_sun_awt_motif_MEmbeddedFramePeer_getBoundsPrivate;
-		Java_sun_awt_motif_MFramePeer_pSetIconImage___3B_3I_3SII;
-		Java_sun_awt_motif_MEmbeddedFramePeer_requestXEmbedFocus;
-		Java_sun_awt_motif_MEmbeddedFramePeer_isXEmbedApplicationActive;
-		Java_sun_awt_motif_MEmbeddedFramePeer_isXEmbedActive;
-		Java_sun_awt_motif_MEmbeddedFrame_getWidget;
-		Java_sun_awt_motif_MEmbeddedFrame_mapWidget;
-		Java_sun_awt_motif_MFileDialogPeer_create;
-		Java_sun_awt_motif_MFileDialogPeer_pDispose;
-		Java_sun_awt_motif_MFileDialogPeer_pHide;
-		Java_sun_awt_motif_MFileDialogPeer_pReshape;
-		Java_sun_awt_motif_MFileDialogPeer_pShow;
-		Java_sun_awt_motif_MFileDialogPeer_setFileEntry;
-		Java_sun_awt_motif_MFileDialogPeer_setFont;
-		Java_sun_awt_motif_MFramePeer_pGetIconSize;
-		Java_sun_awt_motif_MGlobalCursorManager_cacheInit;
-		Java_sun_awt_motif_MGlobalCursorManager_findComponentAt;
-		Java_sun_awt_motif_MGlobalCursorManager_findHeavyweightUnderCursor;
-		Java_sun_awt_motif_MGlobalCursorManager_getCursorPos;
-		Java_sun_awt_motif_MGlobalCursorManager_getLocationOnScreen;
-		Java_sun_awt_motif_MLabelPeer_create;
-		Java_sun_awt_motif_MLabelPeer_setAlignment;
-		Java_sun_awt_motif_MLabelPeer_setText;
-		Java_sun_awt_motif_MListPeer_addItem;
-		Java_sun_awt_motif_MListPeer_create;
-		Java_sun_awt_motif_MListPeer_delItems;
-		Java_sun_awt_motif_MListPeer_deselect;
-		Java_sun_awt_motif_MListPeer_isSelected;
-		Java_sun_awt_motif_MListPeer_makeVisible;
-		Java_sun_awt_motif_MListPeer_select;
-		Java_sun_awt_motif_MListPeer_setMultipleSelections;
-		Java_sun_awt_motif_MMenuBarPeer_create;
-		Java_sun_awt_motif_MMenuItemPeer_createMenuItem;
-		Java_sun_awt_motif_MMenuItemPeer_pDisable;
-		Java_sun_awt_motif_MMenuItemPeer_pDispose;
-		Java_sun_awt_motif_MMenuItemPeer_pEnable;
-		Java_sun_awt_motif_MMenuItemPeer_pSetLabel;
-		Java_sun_awt_motif_MMenuPeer_createMenu;
-		Java_sun_awt_motif_MMenuPeer_createSubMenu;
-		Java_sun_awt_motif_MMenuPeer_pDispose;
-		Java_sun_awt_motif_MPopupMenuPeer_createMenu;
-		Java_sun_awt_motif_MPopupMenuPeer_pDispose;
-		Java_sun_awt_motif_MPopupMenuPeer_pShow;
-		Java_sun_awt_motif_MRobotPeer_getRGBPixelsImpl;
-		Java_sun_awt_motif_MRobotPeer_keyPressImpl;
-		Java_sun_awt_motif_MRobotPeer_keyReleaseImpl;
-		Java_sun_awt_motif_MRobotPeer_mouseMoveImpl;
-		Java_sun_awt_motif_MRobotPeer_mousePressImpl;
-		Java_sun_awt_motif_MRobotPeer_mouseReleaseImpl;
-		Java_sun_awt_motif_MRobotPeer_mouseWheelImpl;
-		Java_sun_awt_motif_MRobotPeer_setup;
-		Java_sun_awt_motif_MScrollbarPeer_create;
-		Java_sun_awt_motif_MScrollbarPeer_setLineIncrement;
-		Java_sun_awt_motif_MScrollbarPeer_setPageIncrement;
-		Java_sun_awt_motif_MScrollbarPeer_pSetValues;
-		Java_sun_awt_motif_MScrollPanePeer_create;
-		Java_sun_awt_motif_MScrollPanePeer_pGetBlockIncrement;
-		Java_sun_awt_motif_MScrollPanePeer_pGetScrollbarSpace;
-		Java_sun_awt_motif_MScrollPanePeer_pGetShadow;
-		Java_sun_awt_motif_MScrollPanePeer_pInsets;
-		Java_sun_awt_motif_MScrollPanePeer_pSetIncrement;
-		Java_sun_awt_motif_MScrollPanePeer_pSetScrollChild;
-		Java_sun_awt_motif_MScrollPanePeer_setScrollPosition;
-		Java_sun_awt_motif_MTextAreaPeer_initIDs;
-		Java_sun_awt_motif_MTextAreaPeer_pCreate;
-		Java_sun_awt_motif_MTextAreaPeer_getCaretPosition;
-		Java_sun_awt_motif_MTextAreaPeer_getExtraHeight;
-		Java_sun_awt_motif_MTextAreaPeer_getExtraWidth;
-		Java_sun_awt_motif_MTextAreaPeer_getSelectionEnd;
-		Java_sun_awt_motif_MTextAreaPeer_getSelectionStart;
-		Java_sun_awt_motif_MTextAreaPeer_getText;
-		Java_sun_awt_motif_MTextAreaPeer_insert;
-		Java_sun_awt_motif_MTextAreaPeer_pMakeCursorVisible;
-		Java_sun_awt_motif_MTextAreaPeer_pSetEditable;
-		Java_sun_awt_motif_MTextAreaPeer_pShow2;
-		Java_sun_awt_motif_MTextAreaPeer_replaceRange;
-		Java_sun_awt_motif_MTextAreaPeer_select;
-		Java_sun_awt_motif_MTextAreaPeer_setCaretPosition;
-		Java_sun_awt_motif_MTextAreaPeer_setFont;
-		Java_sun_awt_motif_MTextAreaPeer_setText;
-		Java_sun_awt_motif_MTextAreaPeer_setTextBackground;
-		Java_sun_awt_motif_MTextFieldPeer_initIDs;
-		Java_sun_awt_motif_MTextFieldPeer_pCreate;
-		Java_sun_awt_motif_MTextFieldPeer_getCaretPosition;
-		Java_sun_awt_motif_MTextFieldPeer_getSelectionEnd;
-		Java_sun_awt_motif_MTextFieldPeer_getSelectionStart;
-		Java_sun_awt_motif_MTextFieldPeer_getText;
-		Java_sun_awt_motif_MTextFieldPeer_insertReplaceText;
-		Java_sun_awt_motif_MTextFieldPeer_preDispose;
-		Java_sun_awt_motif_MTextFieldPeer_pSetEditable;
-		Java_sun_awt_motif_MTextFieldPeer_select;
-		Java_sun_awt_motif_MTextFieldPeer_setCaretPosition;
-		Java_sun_awt_motif_MTextFieldPeer_setEchoChar;
-		Java_sun_awt_motif_MTextFieldPeer_setFont;
-		Java_sun_awt_motif_MTextFieldPeer_setText;
+		#Java_sun_awt_motif_MButtonPeer_create;
+		#Java_sun_awt_motif_MButtonPeer_setLabel;
+		#Java_sun_awt_motif_MCanvasPeer_create;
+		#Java_sun_awt_motif_MCanvasPeer_initIDs;
+		#Java_sun_awt_motif_MCanvasPeer_resetTargetGC;
+		#Java_sun_awt_motif_MCheckboxMenuItemPeer_pSetState;
+		#Java_sun_awt_motif_MCheckboxPeer_create;
+		#Java_sun_awt_motif_MCheckboxPeer_setCheckboxGroup;
+		#Java_sun_awt_motif_MCheckboxPeer_setLabel;
+		#Java_sun_awt_motif_MCheckboxPeer_pSetState;
+		#Java_sun_awt_motif_MCheckboxPeer_pGetState;
+		#Java_sun_awt_motif_MChoicePeer_addItem;
+		#Java_sun_awt_motif_MChoicePeer_appendItems;
+		#Java_sun_awt_motif_MChoicePeer_create;
+		#Java_sun_awt_motif_MChoicePeer_pReshape;
+		#Java_sun_awt_motif_MChoicePeer_remove;
+		#Java_sun_awt_motif_MChoicePeer_removeAll;
+		#Java_sun_awt_motif_MChoicePeer_setBackground;
+		#Java_sun_awt_motif_MChoicePeer_pSelect;
+		#Java_sun_awt_motif_MChoicePeer_setFont;
+		#Java_sun_awt_motif_MChoicePeer_setForeground;
+		#Java_sun_awt_motif_MComponentPeer_addNativeDropTarget;
+		#Java_sun_awt_motif_MComponentPeer_createBackBuffer;
+		#Java_sun_awt_motif_MComponentPeer_destroyBackBuffer;
+		#Java_sun_awt_motif_MComponentPeer_getNativeColor;
+		#Java_sun_awt_motif_MComponentPeer_getWindow;
+		#Java_sun_awt_motif_MComponentPeer_pDisable;
+		#Java_sun_awt_motif_MComponentPeer_pDispose;
+		#Java_sun_awt_motif_MComponentPeer_pEnable;
+		#Java_sun_awt_motif_MComponentPeer_pGetLocationOnScreen;
+		#Java_sun_awt_motif_MComponentPeer_pGetLocationOnScreen2;
+		#Java_sun_awt_motif_MComponentPeer_pHide;
+		#Java_sun_awt_motif_MComponentPeer_pInitialize;
+		#Java_sun_awt_motif_MComponentPeer_pMakeCursorVisible;
+		#Java_sun_awt_motif_MComponentPeer_pReshape;
+		#Java_sun_awt_motif_MComponentPeer_pShow;
+		#Java_sun_awt_motif_MComponentPeer_removeNativeDropTarget;
+		#Java_sun_awt_motif_MComponentPeer_swapBuffers;
+		#Java_sun_awt_motif_MComponentPeer_pSetBackground;
+		#Java_sun_awt_motif_MComponentPeer_pSetFont;
+                #Java_sun_awt_motif_MComponentPeer_processSynchronousLightweightTransfer;
+                #Java_sun_awt_motif_MComponentPeer__1requestFocus;
+		#Java_sun_awt_motif_MCheckboxMenuItemPeer_getState;
+		#Java_sun_awt_motif_MComponentPeer_pSetForeground;
+		#Java_sun_awt_motif_MDragSourceContextPeer_startDrag;
+		#Java_sun_awt_motif_MDragSourceContextPeer_setNativeCursor;
+		#Java_sun_awt_motif_MDropTargetContextPeer_addTransfer;
+		#Java_sun_awt_motif_MDropTargetContextPeer_dropDone;
+		#Java_sun_awt_motif_MDropTargetContextPeer_startTransfer;
+		#Java_sun_awt_motif_X11DragSourceContextPeer_startDrag;
+		#Java_sun_awt_motif_X11DragSourceContextPeer_setNativeCursor;
+		#Java_sun_awt_motif_X11DropTargetContextPeer_sendResponse;
+		#Java_sun_awt_motif_X11DropTargetContextPeer_dropDone;
+		#Java_sun_awt_motif_X11DropTargetContextPeer_getData;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_NEFcreate;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_pShowImpl;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_pReshapePrivate;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_getBoundsPrivate;
+		#Java_sun_awt_motif_MFramePeer_pSetIconImage___3B_3I_3SII;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_requestXEmbedFocus;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_isXEmbedApplicationActive;
+		#Java_sun_awt_motif_MEmbeddedFramePeer_isXEmbedActive;
+		#Java_sun_awt_motif_MEmbeddedFrame_getWidget;
+		#Java_sun_awt_motif_MEmbeddedFrame_mapWidget;
+		#Java_sun_awt_motif_MFileDialogPeer_create;
+		#Java_sun_awt_motif_MFileDialogPeer_pDispose;
+		#Java_sun_awt_motif_MFileDialogPeer_pHide;
+		#Java_sun_awt_motif_MFileDialogPeer_pReshape;
+		#Java_sun_awt_motif_MFileDialogPeer_pShow;
+		#Java_sun_awt_motif_MFileDialogPeer_setFileEntry;
+		#Java_sun_awt_motif_MFileDialogPeer_setFont;
+		#Java_sun_awt_motif_MFramePeer_pGetIconSize;
+		#Java_sun_awt_motif_MGlobalCursorManager_cacheInit;
+		#Java_sun_awt_motif_MGlobalCursorManager_findComponentAt;
+		#Java_sun_awt_motif_MGlobalCursorManager_findHeavyweightUnderCursor;
+		#Java_sun_awt_motif_MGlobalCursorManager_getCursorPos;
+		#Java_sun_awt_motif_MGlobalCursorManager_getLocationOnScreen;
+		#Java_sun_awt_motif_MLabelPeer_create;
+		#Java_sun_awt_motif_MLabelPeer_setAlignment;
+		#Java_sun_awt_motif_MLabelPeer_setText;
+		#Java_sun_awt_motif_MListPeer_addItem;
+		#Java_sun_awt_motif_MListPeer_create;
+		#Java_sun_awt_motif_MListPeer_delItems;
+		#Java_sun_awt_motif_MListPeer_deselect;
+		#Java_sun_awt_motif_MListPeer_isSelected;
+		#Java_sun_awt_motif_MListPeer_makeVisible;
+		#Java_sun_awt_motif_MListPeer_select;
+		#Java_sun_awt_motif_MListPeer_setMultipleSelections;
+		#Java_sun_awt_motif_MMenuBarPeer_create;
+		#Java_sun_awt_motif_MMenuItemPeer_createMenuItem;
+		#Java_sun_awt_motif_MMenuItemPeer_pDisable;
+		#Java_sun_awt_motif_MMenuItemPeer_pDispose;
+		#Java_sun_awt_motif_MMenuItemPeer_pEnable;
+		#Java_sun_awt_motif_MMenuItemPeer_pSetLabel;
+		#Java_sun_awt_motif_MMenuPeer_createMenu;
+		#Java_sun_awt_motif_MMenuPeer_createSubMenu;
+		#Java_sun_awt_motif_MMenuPeer_pDispose;
+		#Java_sun_awt_motif_MPopupMenuPeer_createMenu;
+		#Java_sun_awt_motif_MPopupMenuPeer_pDispose;
+		#Java_sun_awt_motif_MPopupMenuPeer_pShow;
+		#Java_sun_awt_motif_MRobotPeer_getRGBPixelsImpl;
+		#Java_sun_awt_motif_MRobotPeer_keyPressImpl;
+		#Java_sun_awt_motif_MRobotPeer_keyReleaseImpl;
+		#Java_sun_awt_motif_MRobotPeer_mouseMoveImpl;
+		#Java_sun_awt_motif_MRobotPeer_mousePressImpl;
+		#Java_sun_awt_motif_MRobotPeer_mouseReleaseImpl;
+		#Java_sun_awt_motif_MRobotPeer_mouseWheelImpl;
+		#Java_sun_awt_motif_MRobotPeer_setup;
+		#Java_sun_awt_motif_MScrollbarPeer_create;
+		#Java_sun_awt_motif_MScrollbarPeer_setLineIncrement;
+		#Java_sun_awt_motif_MScrollbarPeer_setPageIncrement;
+		#Java_sun_awt_motif_MScrollbarPeer_pSetValues;
+		#Java_sun_awt_motif_MScrollPanePeer_create;
+		#Java_sun_awt_motif_MScrollPanePeer_pGetBlockIncrement;
+		#Java_sun_awt_motif_MScrollPanePeer_pGetScrollbarSpace;
+		#Java_sun_awt_motif_MScrollPanePeer_pGetShadow;
+		#Java_sun_awt_motif_MScrollPanePeer_pInsets;
+		#Java_sun_awt_motif_MScrollPanePeer_pSetIncrement;
+		#Java_sun_awt_motif_MScrollPanePeer_pSetScrollChild;
+		#Java_sun_awt_motif_MScrollPanePeer_setScrollPosition;
+		#Java_sun_awt_motif_MTextAreaPeer_initIDs;
+		#Java_sun_awt_motif_MTextAreaPeer_pCreate;
+		#Java_sun_awt_motif_MTextAreaPeer_getCaretPosition;
+		#Java_sun_awt_motif_MTextAreaPeer_getExtraHeight;
+		#Java_sun_awt_motif_MTextAreaPeer_getExtraWidth;
+		#Java_sun_awt_motif_MTextAreaPeer_getSelectionEnd;
+		#Java_sun_awt_motif_MTextAreaPeer_getSelectionStart;
+		#Java_sun_awt_motif_MTextAreaPeer_getText;
+		#Java_sun_awt_motif_MTextAreaPeer_insert;
+		#Java_sun_awt_motif_MTextAreaPeer_pMakeCursorVisible;
+		#Java_sun_awt_motif_MTextAreaPeer_pSetEditable;
+		#Java_sun_awt_motif_MTextAreaPeer_pShow2;
+		#Java_sun_awt_motif_MTextAreaPeer_replaceRange;
+		#Java_sun_awt_motif_MTextAreaPeer_select;
+		#Java_sun_awt_motif_MTextAreaPeer_setCaretPosition;
+		#Java_sun_awt_motif_MTextAreaPeer_setFont;
+		#Java_sun_awt_motif_MTextAreaPeer_setText;
+		#Java_sun_awt_motif_MTextAreaPeer_setTextBackground;
+		#Java_sun_awt_motif_MTextFieldPeer_initIDs;
+		#Java_sun_awt_motif_MTextFieldPeer_pCreate;
+		#Java_sun_awt_motif_MTextFieldPeer_getCaretPosition;
+		#Java_sun_awt_motif_MTextFieldPeer_getSelectionEnd;
+		#Java_sun_awt_motif_MTextFieldPeer_getSelectionStart;
+		#Java_sun_awt_motif_MTextFieldPeer_getText;
+		#Java_sun_awt_motif_MTextFieldPeer_insertReplaceText;
+		#Java_sun_awt_motif_MTextFieldPeer_preDispose;
+		#Java_sun_awt_motif_MTextFieldPeer_pSetEditable;
+		#Java_sun_awt_motif_MTextFieldPeer_select;
+		#Java_sun_awt_motif_MTextFieldPeer_setCaretPosition;
+		#Java_sun_awt_motif_MTextFieldPeer_setEchoChar;
+		#Java_sun_awt_motif_MTextFieldPeer_setFont;
+		#Java_sun_awt_motif_MTextFieldPeer_setText;
 		Java_sun_awt_motif_MToolkit_beep;
 		Java_sun_awt_motif_MToolkit_getLockingKeyStateNative;
 		Java_sun_awt_motif_MToolkit_getMulticlickTime;
@@ -356,28 +356,28 @@
 		Java_sun_awt_motif_MToolkit_sync;
                 Java_sun_awt_motif_MToolkit_isAlwaysOnTopSupported;
 		Java_sun_awt_motif_MWindowAttributes_initIDs;
-		Java_sun_awt_motif_MWindowPeer_pDispose;
-		Java_sun_awt_motif_MWindowPeer_pHide;
-		Java_sun_awt_motif_MWindowPeer_pReshape;
-		Java_sun_awt_motif_MWindowPeer_pSetTitle;
-		Java_sun_awt_motif_MWindowPeer_pShow;
-		Java_sun_awt_motif_MWindowPeer_setResizable;
-		Java_sun_awt_motif_MWindowPeer_toBack;
-		Java_sun_awt_motif_MWindowPeer_addTextComponentNative;
-		Java_sun_awt_motif_MWindowPeer_getState;
-		Java_sun_awt_motif_MWindowPeer_pSetIMMOption;
-		Java_sun_awt_motif_MWindowPeer_pSetMenuBar;
-		Java_sun_awt_motif_MWindowPeer_pShowModal;
-		Java_sun_awt_motif_MWindowPeer_removeTextComponentNative;
-		Java_sun_awt_motif_MWindowPeer_setSaveUnder;
-		Java_sun_awt_motif_MWindowPeer_setState;
-		Java_sun_awt_motif_MWindowPeer_resetTargetGC;
-		Java_sun_awt_motif_MWindowPeer_registerX11DropTarget;
-		Java_sun_awt_motif_MWindowPeer_unregisterX11DropTarget;
-                Java_sun_awt_motif_MWindowPeer_updateAlwaysOnTop;
-		Java_sun_awt_motif_X11CustomCursor_cacheInit;
-		Java_sun_awt_motif_X11CustomCursor_createCursor;
-		Java_sun_awt_motif_X11CustomCursor_queryBestCursor;
+		#Java_sun_awt_motif_MWindowPeer_pDispose;
+		#Java_sun_awt_motif_MWindowPeer_pHide;
+		#Java_sun_awt_motif_MWindowPeer_pReshape;
+		#Java_sun_awt_motif_MWindowPeer_pSetTitle;
+		#Java_sun_awt_motif_MWindowPeer_pShow;
+		#Java_sun_awt_motif_MWindowPeer_setResizable;
+		#Java_sun_awt_motif_MWindowPeer_toBack;
+		#Java_sun_awt_motif_MWindowPeer_addTextComponentNative;
+		#Java_sun_awt_motif_MWindowPeer_getState;
+		#Java_sun_awt_motif_MWindowPeer_pSetIMMOption;
+		#Java_sun_awt_motif_MWindowPeer_pSetMenuBar;
+		#Java_sun_awt_motif_MWindowPeer_pShowModal;
+		#Java_sun_awt_motif_MWindowPeer_removeTextComponentNative;
+		#Java_sun_awt_motif_MWindowPeer_setSaveUnder;
+		#Java_sun_awt_motif_MWindowPeer_setState;
+		#Java_sun_awt_motif_MWindowPeer_resetTargetGC;
+		#Java_sun_awt_motif_MWindowPeer_registerX11DropTarget;
+		#Java_sun_awt_motif_MWindowPeer_unregisterX11DropTarget;
+                #Java_sun_awt_motif_MWindowPeer_updateAlwaysOnTop;
+		#Java_sun_awt_motif_X11CustomCursor_cacheInit;
+		#Java_sun_awt_motif_X11CustomCursor_createCursor;
+		#Java_sun_awt_motif_X11CustomCursor_queryBestCursor;
 		Java_sun_awt_motif_X11FontMetrics_bytesWidth;
 		Java_sun_awt_motif_X11FontMetrics_getMFCharsWidth;
 		Java_sun_awt_motif_X11FontMetrics_init;
@@ -386,18 +386,18 @@
 		Java_sun_awt_X11InputMethod_resetXIC;
 		Java_sun_awt_X11InputMethod_setCompositionEnabledNative;
 		Java_sun_awt_X11InputMethod_turnoffStatusWindow;
-		Java_sun_awt_motif_MInputMethod_openXIMNative;
-		Java_sun_awt_motif_MInputMethod_configureStatusAreaNative;
-		Java_sun_awt_motif_MInputMethod_createXICNative;
-		Java_sun_awt_motif_MInputMethod_reconfigureXICNative;
-		Java_sun_awt_motif_MInputMethod_setXICFocusNative;
-		Java_sun_awt_motif_X11Clipboard_getClipboardData;
-		Java_sun_awt_motif_X11Clipboard_getClipboardFormats;
-		Java_sun_awt_motif_X11Clipboard_registerClipboardViewer;
-		Java_sun_awt_motif_X11Clipboard_unregisterClipboardViewer;
-		Java_sun_awt_motif_X11Selection_init;
-		Java_sun_awt_motif_X11Selection_pGetSelectionOwnership;
-		Java_sun_awt_motif_X11Selection_clearNativeContext;
+		#Java_sun_awt_motif_MInputMethod_openXIMNative;
+		#Java_sun_awt_motif_MInputMethod_configureStatusAreaNative;
+		#Java_sun_awt_motif_MInputMethod_createXICNative;
+		#Java_sun_awt_motif_MInputMethod_reconfigureXICNative;
+		#Java_sun_awt_motif_MInputMethod_setXICFocusNative;
+		#Java_sun_awt_motif_X11Clipboard_getClipboardData;
+		#Java_sun_awt_motif_X11Clipboard_getClipboardFormats;
+		#Java_sun_awt_motif_X11Clipboard_registerClipboardViewer;
+		#Java_sun_awt_motif_X11Clipboard_unregisterClipboardViewer;
+		#Java_sun_awt_motif_X11Selection_init;
+		#Java_sun_awt_motif_X11Selection_pGetSelectionOwnership;
+		#Java_sun_awt_motif_X11Selection_clearNativeContext;
 		Java_sun_awt_SunToolkit_closeSplashScreen;
 		Java_sun_awt_PlatformFont_initIDs;
 		Java_sun_awt_X11GraphicsConfig_init;
@@ -442,40 +442,40 @@
 		Java_java_awt_Insets_initIDs;
 		Java_java_awt_TextField_initIDs;
 		Java_java_awt_Window_initIDs;
-		Java_sun_awt_motif_MCheckboxPeer_getIndicatorSize;
-		Java_sun_awt_motif_MCheckboxPeer_getSpacing;
-		Java_sun_awt_motif_MChoicePeer_freeNativeData;
-		Java_sun_awt_motif_MComponentPeer_getComponents_1NoClientCode;
-		Java_sun_awt_motif_MComponentPeer_getParent_1NoClientCode;
-		Java_sun_awt_motif_MComponentPeer_initIDs;
-		Java_sun_awt_motif_MComponentPeer_nativeHandleEvent;
-		Java_sun_awt_motif_MComponentPeer_pSetCursor;
-		Java_sun_awt_motif_MComponentPeer_pSetInnerForeground;
-		Java_sun_awt_motif_MComponentPeer_pSetScrollbarBackground;
-		Java_sun_awt_motif_MComponentPeer_setTargetBackground;
-		Java_sun_awt_motif_MDataTransferer_dragQueryFile;
-		Java_sun_awt_motif_MDataTransferer_getAtomForTarget;
-		Java_sun_awt_motif_MDataTransferer_getTargetNameForAtom;
-		Java_sun_awt_motif_MFileDialogPeer_insertReplaceFileDialogText;
+		#Java_sun_awt_motif_MCheckboxPeer_getIndicatorSize;
+		#Java_sun_awt_motif_MCheckboxPeer_getSpacing;
+		#Java_sun_awt_motif_MChoicePeer_freeNativeData;
+		#Java_sun_awt_motif_MComponentPeer_getComponents_1NoClientCode;
+		#Java_sun_awt_motif_MComponentPeer_getParent_1NoClientCode;
+		#Java_sun_awt_motif_MComponentPeer_initIDs;
+		#Java_sun_awt_motif_MComponentPeer_nativeHandleEvent;
+		#Java_sun_awt_motif_MComponentPeer_pSetCursor;
+		#Java_sun_awt_motif_MComponentPeer_pSetInnerForeground;
+		#Java_sun_awt_motif_MComponentPeer_pSetScrollbarBackground;
+		#Java_sun_awt_motif_MComponentPeer_setTargetBackground;
+		#Java_sun_awt_motif_MDataTransferer_dragQueryFile;
+		#Java_sun_awt_motif_MDataTransferer_getAtomForTarget;
+		#Java_sun_awt_motif_MDataTransferer_getTargetNameForAtom;
+		#Java_sun_awt_motif_MFileDialogPeer_insertReplaceFileDialogText;
 		Java_sun_awt_motif_MFontPeer_initIDs;
-		Java_sun_awt_motif_MListPeer_setBackground;
-		Java_sun_awt_motif_MMenuBarPeer_initIDs;
-		Java_sun_awt_motif_MMenuBarPeer_pDispose;
-		Java_sun_awt_motif_MMenuItemPeer_getParent_1NoClientCode;
-		Java_sun_awt_motif_MMenuItemPeer_initIDs;
-		Java_sun_awt_motif_MMenuItemPeer_pSetShortcut;
-		Java_sun_awt_motif_MPopupMenuPeer_initIDs;
-		Java_sun_awt_motif_MScrollbarPeer_initIDs;
-		Java_sun_awt_motif_MScrollPanePeer_initIDs;
-		Java_sun_awt_motif_MTextAreaPeer_pSetCursor;
+		#Java_sun_awt_motif_MListPeer_setBackground;
+		#Java_sun_awt_motif_MMenuBarPeer_initIDs;
+		#Java_sun_awt_motif_MMenuBarPeer_pDispose;
+		#Java_sun_awt_motif_MMenuItemPeer_getParent_1NoClientCode;
+		#Java_sun_awt_motif_MMenuItemPeer_initIDs;
+		#Java_sun_awt_motif_MMenuItemPeer_pSetShortcut;
+		#Java_sun_awt_motif_MPopupMenuPeer_initIDs;
+		#Java_sun_awt_motif_MScrollbarPeer_initIDs;
+		#Java_sun_awt_motif_MScrollPanePeer_initIDs;
+		#Java_sun_awt_motif_MTextAreaPeer_pSetCursor;
 		Java_sun_awt_motif_MToolkit_shutdown;
-		Java_sun_awt_motif_MWindowPeer_initIDs;
-		Java_sun_awt_motif_MWindowPeer_pCreate;
-		Java_sun_awt_motif_MWindowPeer_wrapInSequenced;
+		#Java_sun_awt_motif_MWindowPeer_initIDs;
+		#Java_sun_awt_motif_MWindowPeer_pCreate;
+		#Java_sun_awt_motif_MWindowPeer_wrapInSequenced;
 		Java_sun_awt_motif_X11FontMetrics_initIDs;
-		Java_sun_awt_X11InputMethod_initIDs;
+		#Java_sun_awt_X11InputMethod_initIDs;
 		Java_sun_awt_motif_X11OffScreenImage_updateBitmask;
-		Java_sun_awt_motif_X11Selection_initIDs;
+		#Java_sun_awt_motif_X11Selection_initIDs;
 		Java_sun_awt_motif_MToolkitThreadBlockedHandler_enter;
 		Java_sun_awt_motif_MToolkitThreadBlockedHandler_exit;
 		Java_sun_awt_X11GraphicsConfig_init;
@@ -503,26 +503,26 @@
 		Java_sun_awt_X11SurfaceData_isDgaAvailable;
 		Java_sun_awt_X11SurfaceData_setInvalid;
 		Java_sun_awt_X11SurfaceData_flushNativeSurface;
-                Java_sun_awt_motif_MEmbedCanvasPeer_initXEmbedServer;
-                Java_sun_awt_motif_MEmbedCanvasPeer_destroyXEmbedServer;
-                Java_sun_awt_motif_MEmbedCanvasPeer_isXEmbedActive;
-                Java_sun_awt_motif_MEmbedCanvasPeer_initDispatching;
-                Java_sun_awt_motif_MEmbedCanvasPeer_endDispatching;
-                Java_sun_awt_motif_MEmbedCanvasPeer_embedChild;
-                Java_sun_awt_motif_MEmbedCanvasPeer_childDestroyed;
-                Java_sun_awt_motif_MEmbedCanvasPeer_getEmbedPreferredSize;
-                Java_sun_awt_motif_MEmbedCanvasPeer_getEmbedMinimumSize;
-                Java_sun_awt_motif_MEmbedCanvasPeer_getClientBounds;
-                Java_sun_awt_motif_MEmbedCanvasPeer_notifyChildEmbedded;
-                Java_sun_awt_motif_MEmbedCanvasPeer_detachChild;
-                Java_sun_awt_motif_MEmbedCanvasPeer_forwardKeyEvent;
-                Java_sun_awt_motif_MEmbedCanvasPeer_getAWTKeyCodeForKeySym;
-                Java_sun_awt_motif_MEmbedCanvasPeer_sendMessage__I;
-                Java_sun_awt_motif_MEmbedCanvasPeer_sendMessage__IJJJ;
-                Java_sun_awt_motif_MEmbedCanvasPeer_getWindow;       
-                Java_sun_awt_motif_MEmbedCanvasPeer_forwardEventToEmbedded;       
-                Java_sun_awt_motif_GrabbedKey_initKeySymAndModifiers;
-                Java_sun_awt_motif_MEmbeddedFramePeer_traverseOut;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_initXEmbedServer;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_destroyXEmbedServer;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_isXEmbedActive;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_initDispatching;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_endDispatching;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_embedChild;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_childDestroyed;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_getEmbedPreferredSize;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_getEmbedMinimumSize;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_getClientBounds;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_notifyChildEmbedded;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_detachChild;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_forwardKeyEvent;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_getAWTKeyCodeForKeySym;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_sendMessage__I;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_sendMessage__IJJJ;
+                #Java_sun_awt_motif_MEmbedCanvasPeer_getWindow;       
+                #Java_sun_awt_motif_MEmbedCanvasPeer_forwardEventToEmbedded;       
+                #Java_sun_awt_motif_GrabbedKey_initKeySymAndModifiers;
+                #Java_sun_awt_motif_MEmbeddedFramePeer_traverseOut;
 		awt_display;
 		awt_lock;
 		awt_Lock;
diff -Nru openjdk.orig/jdk/make/sun/awt/mawt.gmk openjdk/jdk/make/sun/awt/mawt.gmk
--- openjdk.orig/jdk/make/sun/awt/mawt.gmk	2014-04-08 05:27:03.574876919 +0100
+++ openjdk/jdk/make/sun/awt/mawt.gmk	2014-04-10 02:56:51.246477485 +0100
@@ -28,14 +28,6 @@
 #
 INIT += $(LIB_LOCATION) 
 
-ifndef HEADLESS
-ifeq ($(PLATFORM), linux)
-ifeq ($(STATIC_MOTIF),false)
-INIT += $(LIB_LOCATION)/libXm.so
-endif
-endif
-endif
-
 #
 # Files
 #
@@ -52,13 +44,9 @@
 ifdef HEADLESS
   FILES_c = $(FILES_NO_MOTIF_c)
 else
-  FILES_c = $(FILES_MOTIF_c) $(FILES_NO_MOTIF_c)
-
-  ifeq ($(MOTIF_VERSION), 2)
-    FILES_c += awt_motif21.c
-    FILES_c += awt_Choice21.c
-  endif
-
+#  FILES_c = $(FILES_MOTIF_c) $(FILES_NO_MOTIF_c)
+#  XXX if in FILES_MOTIF_c there are unrelated to motif stuff, create a separate list!
+  FILES_c = $(FILES_NO_MOTIF_c)
 endif
 
 ifeq ($(PLATFORM), solaris)
@@ -93,15 +81,6 @@
 $(LIB_LOCATION):
 	$(MKDIR) -p $@
 
-ifeq ($(PLATFORM), linux)
-ifeq ($(STATIC_MOTIF),false)
-$(LIB_LOCATION)/libXm.so:
-	$(CP) $(MOTIF_LIB)/libXm.so $(LIB_LOCATION)/libXm.so
-# Automounter problem makes the link fail on Redhat 6.1.
-#	$(LN) -s $(MOTIF_LIB)/libXm.so $(LIB_LOCATION)/libXm.so
-endif
-endif
-
 clean:: 
 
 #
@@ -137,33 +116,49 @@
 CPPFLAGS += -DHEADLESS=$(HEADLESS)
 OTHER_LDLIBS =
 else
-CFLAGS += -DMOTIF_VERSION=$(MOTIF_VERSION)
+#CFLAGS += -DMOTIF_VERSION=$(MOTIF_VERSION)
 
-ifeq ($(STATIC_MOTIF),true)
-    LIBXM = $(MOTIF_LIB)/libXm.a -lXp -lXmu
-    ifeq ($(PLATFORM), linux)
-	ifeq ($(ARCH_DATA_MODEL), 64)
-            LIBXT = -lXt
-        else
-        # Allows for builds on Debian GNU Linux, X11 is in a different place 
-	    LIBXT = $(firstword $(wildcard /usr/X11R6/lib/libXt.a) \
-                            $(wildcard /usr/lib/libXt.a))
-	    LIBSM = $(firstword $(wildcard /usr/X11R6/lib/libSM.a) \
-                            $(wildcard /usr/lib/libSM.a))
-	    LIBICE = $(firstword $(wildcard /usr/X11R6/lib/libICE.a) \
-                             $(wildcard /usr/lib/libICE.a))
-	endif
-    endif
-else
-    LIBXM = -L$(MOTIF_LIB) -lXm -lXp
-    ifeq ($(PLATFORM), linux)
-	LIBXT = -lXt
-	LIBSM = 
-	LIBICE = 
-    endif
-endif
+#ifeq ($(STATIC_MOTIF),true)
+#    LIBXM = $(MOTIF_LIB)/libXm.a -lXp -lXmu
+#    ifeq ($(PLATFORM), linux)
+#	ifeq ($(ARCH_DATA_MODEL), 64)
+#            LIBXT = -lXt
+#        else
+#        # Allows for builds on Debian GNU Linux, X11 is in a different place 
+#	    LIBXT = $(firstword $(wildcard /usr/X11R6/lib/libXt.a) \
+#                            $(wildcard /usr/lib/libXt.a))
+#	    LIBSM = $(firstword $(wildcard /usr/X11R6/lib/libSM.a) \
+#                            $(wildcard /usr/lib/libSM.a))
+#	    LIBICE = $(firstword $(wildcard /usr/X11R6/lib/libICE.a) \
+#                             $(wildcard /usr/lib/libICE.a))
+#	endif
+#    endif
+#else
+#    LIBXM = -L$(MOTIF_LIB) -lXm -lXp
+#    ifeq ($(PLATFORM), linux)
+#	LIBXT = -lXt
+#	LIBSM = 
+#	LIBICE = 
+#    endif
+#endif
 
 LIBXTST = -lXtst
+ifeq ($(PLATFORM), linux)
+   ifeq ($(ARCH_DATA_MODEL), 64)
+   # XXX what about the rest of them?
+        LIBXT = -lXt
+    else
+    # Allows for builds on Debian GNU Linux, X11 is in a different place 
+       LIBXT = $(firstword $(wildcard /usr/X11R6/lib/libXt.a) \
+                        $(wildcard /usr/lib/libXt.a))
+       LIBSM = $(firstword $(wildcard /usr/X11R6/lib/libSM.a) \
+                        $(wildcard /usr/lib/libSM.a))
+       LIBICE = $(firstword $(wildcard /usr/X11R6/lib/libICE.a) \
+                         $(wildcard /usr/lib/libICE.a))
+       LIBXTST = $(firstword $(wildcard /usr/X11R6/lib/libXtst.a) \
+                         $(wildcard /usr/lib/libXtst.a))
+   endif
+endif
 
 # Use -lXmu for EditRes support
 LIBXMU_DBG	= -lXmu
@@ -171,14 +166,14 @@
 LIBXMU		= $(LIBXMU_$(VARIANT))
 
 ifeq ($(PLATFORM), solaris)
-OTHER_LDLIBS = $(LIBXM) -lXt -lXext $(LIBXTST) $(LIBXMU) -lX11 -lXi
+OTHER_LDLIBS = -lXt -lXext $(LIBXTST) $(LIBXMU) -lX11 -lXi
 endif
 
 ifeq ($(PLATFORM), linux)
 OTHER_CFLAGS += -DMLIB_NO_LIBSUNMATH
-OTHER_CFLAGS += -DMOTIF_VERSION=2
+# XXX what is this define below? Isn't it motif-related?
 OTHER_CFLAGS += -DXMSTRINGDEFINES=1
-OTHER_LDLIBS = $(LIBXM) $(LIBXMU) $(LIBXTST) -lXext $(LIBXT) $(LIBSM) $(LIBICE) -lX11 -lXi
+OTHER_LDLIBS =  $(LIBXMU) $(LIBXTST) -lXext $(LIBXT) $(LIBSM) $(LIBICE) -lX11 -lXi
 endif
 
 endif
@@ -201,9 +196,8 @@
 CPPFLAGS += -I$(CUPS_HEADERS_PATH)
 
 ifndef HEADLESS
-CPPFLAGS += -I$(MOTIF_DIR)/include \
-            -I$(OPENWIN_HOME)/include 
-LDFLAGS  += -L$(MOTIF_LIB) -L$(OPENWIN_LIB)
+CPPFLAGS += -I$(OPENWIN_HOME)/include 
+LDFLAGS  += -L$(OPENWIN_LIB)
 
 endif # !HEADLESS
 
diff -Nru openjdk.orig/jdk/make/sun/jawt/Makefile openjdk/jdk/make/sun/jawt/Makefile
--- openjdk.orig/jdk/make/sun/jawt/Makefile	2014-04-08 05:27:03.630877745 +0100
+++ openjdk/jdk/make/sun/jawt/Makefile	2014-04-10 02:56:51.258477661 +0100
@@ -99,7 +99,6 @@
 # Other extra flags needed for compiling.
 #
 CPPFLAGS += -I$(OPENWIN_HOME)/include \
-	    -I$(MOTIF_DIR)/include \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
             -I$(SHARE_SRC)/native/$(PKGDIR)/image \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/image/cvutils \
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MButtonPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MButtonPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MButtonPeer.java	2014-04-08 05:27:04.974897587 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MButtonPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 1995, 2001, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import java.awt.event.ActionEvent;
-
-class MButtonPeer extends MComponentPeer implements ButtonPeer {
-    native void create(MComponentPeer peer);
-    public native void setLabel(String label);
-
-    MButtonPeer(Button target) {
-        super(target);
-    }
-
-    public Dimension getMinimumSize() {
-        FontMetrics fm = getFontMetrics(target.getFont());
-        String label = ((Button)target).getLabel();
-        if ( label == null ) {
-            label = "";
-        }
-        return new Dimension(fm.stringWidth(label) + 14,
-                             fm.getHeight() + 8);
-    }
-
-    public boolean isFocusable() {
-        return true;
-    }
-
-    // NOTE: This method is called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void action(final long when, final int modifiers) {
-        MToolkit.executeOnEventHandlerThread(target, new Runnable() {
-            public void run() {
-                postEvent(new ActionEvent(target, ActionEvent.ACTION_PERFORMED,
-                                          ((Button)target).getActionCommand(),
-                                          when, modifiers));
-            }
-        });
-    }
-
-    /*
-     * Print the native component by rendering the Motif look ourselves.
-     * ToDo(aim): needs to query native motif for more accurate size and
-     * color information.
-     */
-    public void print(Graphics g) {
-        Button b = (Button)target;
-        Dimension d = b.size();
-        Color bg = b.getBackground();
-        Color fg = b.getForeground();
-
-        g.setColor(bg);
-        g.fillRect(2, 2, d.width - 3, d.height - 3);
-        draw3DRect(g, bg, 1, 1, d.width - 2, d.height - 2, true);
-
-        g.setColor(fg);
-        g.setFont(b.getFont());
-        FontMetrics fm = g.getFontMetrics();
-        String lbl = b.getLabel();
-        g.drawString(lbl, (d.width - fm.stringWidth(lbl)) / 2,
-                          (d.height + fm.getMaxAscent() - fm.getMaxDescent()) / 2);
-
-        target.print(g);
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public Dimension minimumSize() {
-        return getMinimumSize();
-    }
-
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MCanvasPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MCanvasPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MCanvasPeer.java	2014-04-08 05:27:04.974897587 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MCanvasPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,113 +0,0 @@
-/*
- * Copyright (c) 1995, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import sun.awt.DisplayChangedListener;
-import sun.awt.X11GraphicsConfig;
-import sun.awt.X11GraphicsDevice;
-import sun.awt.X11GraphicsEnvironment;
-
-class MCanvasPeer extends MComponentPeer implements CanvasPeer,
- DisplayChangedListener {
-
-    native void create(MComponentPeer parent);
-    private static native void initIDs();
-    static {
-        initIDs();
-    }
-
-    MCanvasPeer() {}
-
-    MCanvasPeer(Component target) {
-        super(target);
-    }
-
-    MCanvasPeer(Component target, Object arg) {
-        super(target, arg);
-    }
-
-/* --- DisplayChangedListener Stuff --- */
-    public void displayChanged() {}
-    public void paletteChanged() {}
-    native void resetTargetGC(Component target);
-
-    /*
-     * Called when the Window this
-     * Canvas is on is moved onto another Xinerama screen.
-     *
-     * Canvases can be created with a non-defulat GraphicsConfiguration.  The
-     * GraphicsConfiguration needs to be changed to one on the new screen,
-     * preferably with the same visual ID.
-     *
-     * Up-called for other windows peer instances (WPanelPeer, WWindowPeer).
-     *
-     * Should only be called from the event thread.
-     */
-     public void displayChanged(int screenNum) {
-        resetLocalGC(screenNum);
-        resetTargetGC(target);  /* call Canvas.setGCFromPeer() via native */
-    }
-
-    /* Set graphicsConfig to a GraphicsConfig with the same visual on the new
-     * screen, which should be easy in Xinerama mode.
-     *
-     * Should only be called from displayChanged(), and therefore only from
-     * the event thread.
-     */
-    void resetLocalGC(int screenNum) {
-        // Opt: Only need to do if we're not using the default GC
-        if (graphicsConfig != null) {
-            X11GraphicsConfig parentgc;
-            // save vis id of current gc
-            int visual = graphicsConfig.getVisual();
-
-            X11GraphicsDevice newDev = (X11GraphicsDevice) GraphicsEnvironment.
-                                                 getLocalGraphicsEnvironment().
-                                                 getScreenDevices()[screenNum];
-
-            for (int i = 0; i < newDev.getNumConfigs(screenNum); i++) {
-                if (visual == newDev.getConfigVisualId(i, screenNum)) {
-                    // use that
-                    graphicsConfig = (X11GraphicsConfig)newDev.getConfigurations()[i];
-                    break;
-                }
-            }
-            // just in case...
-            if (graphicsConfig == null) {
-                graphicsConfig = (X11GraphicsConfig) GraphicsEnvironment.
-                                           getLocalGraphicsEnvironment().
-                                           getScreenDevices()[screenNum].
-                                           getDefaultConfiguration();
-            }
-        }
-    }
-
-    protected boolean shouldFocusOnClick() {
-        // Canvas should always be able to be focused by mouse clicks.
-        return true;
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MCheckboxMenuItemPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MCheckboxMenuItemPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MCheckboxMenuItemPeer.java	2014-04-08 05:27:04.974897587 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MCheckboxMenuItemPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,93 +0,0 @@
-/*
- * Copyright (c) 1995, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-
-import java.awt.*;
-import java.awt.event.*;
-import java.awt.peer.*;
-
-class MCheckboxMenuItemPeer extends MMenuItemPeer
-                            implements CheckboxMenuItemPeer {
-    private boolean inUpCall=false;
-    private boolean inInit=false;
-
-    native void pSetState(boolean t);
-    native boolean getState();
-
-    void create(MMenuPeer parent) {
-        super.create(parent);
-        inInit=true;
-        setState(((CheckboxMenuItem)target).getState());
-        inInit=false;
-    }
-
-    MCheckboxMenuItemPeer(CheckboxMenuItem target) {
-        this.target = target;
-        isCheckbox = true;
-        MMenuPeer parent = (MMenuPeer) MToolkit.targetToPeer(getParent_NoClientCode(target));
-        create(parent);
-    }
-
-    public void setState(boolean t) {
-        if (!nativeCreated) {
-            return;
-        }
-        if (!inUpCall && (t != getState())) {
-            pSetState(t);
-            if (!inInit) {
-                // 4135725 : do not notify on programatic changes
-                // notifyStateChanged(t);
-            }
-        }
-    }
-
-    void notifyStateChanged(boolean state) {
-        CheckboxMenuItem cb = (CheckboxMenuItem)target;
-        ItemEvent e = new ItemEvent(cb,
-                          ItemEvent.ITEM_STATE_CHANGED,
-                          cb.getLabel(),
-                          state ? ItemEvent.SELECTED : ItemEvent.DESELECTED);
-        postEvent(e);
-    }
-
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void action(long when, int modifiers, boolean state) {
-        final CheckboxMenuItem cb = (CheckboxMenuItem)target;
-        final boolean newState = state;
-
-        MToolkit.executeOnEventHandlerThread(cb, new Runnable() {
-            public void run() {
-                cb.setState(newState);
-                notifyStateChanged(newState);
-            }
-        });
-        //Fix for 5005195: MAWT: CheckboxMenuItem fires action events
-        //super.action() is not invoked
-    } // action()
-} // class MCheckboxMenuItemPeer
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MCheckboxPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MCheckboxPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MCheckboxPeer.java	2014-04-08 05:27:04.974897587 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MCheckboxPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,187 +0,0 @@
-/*
- * Copyright (c) 1995, 2000, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import java.awt.event.*;
-
-public class MCheckboxPeer extends MComponentPeer implements CheckboxPeer {
-    private boolean inUpCall = false;
-    private boolean inInit=false;
-
-    native void create(MComponentPeer parent);
-    native void pSetState(boolean state);
-    native boolean pGetState();
-
-    public native void setLabel(String label);
-    public native void setCheckboxGroup(CheckboxGroup g);
-
-
-    void initialize() {
-        Checkbox t = (Checkbox)target;
-        inInit=true;
-
-        setState(t.getState());
-        setCheckboxGroup(t.getCheckboxGroup());
-        super.initialize();
-        inInit=false;
-    }
-
-    public MCheckboxPeer(Checkbox target) {
-        super(target);
-    }
-
-    public boolean isFocusable() {
-        return true;
-    }
-
-    public void setState(boolean state) {
-        if (inInit) {
-                pSetState(state);
-        } else if (!inUpCall && (state != pGetState())) {
-                pSetState(state);
-                // 4135725 : do not notify on programatic changes
-                // notifyStateChanged(state);
-        }
-    }
-    private native int getIndicatorSize();
-    private native int getSpacing();
-
-    public Dimension getMinimumSize() {
-        String lbl = ((Checkbox)target).getLabel();
-        if (lbl == null) {
-            lbl = "";
-        }
-        FontMetrics fm = getFontMetrics(target.getFont());
-        /*
-         * Spacing (number of pixels between check mark and label text) is
-         * currently set to 0, but in case it ever changes we have to add
-         * it. 8 is a heuristic number. Indicator size depends on font
-         * height, so we don't need to include it in checkbox's height
-         * calculation.
-         */
-        int wdth = fm.stringWidth(lbl) + getIndicatorSize() + getSpacing() + 8;
-        int hght = Math.max(fm.getHeight() + 8, 15);
-        return new Dimension(wdth, hght);
-    }
-
-
-    void notifyStateChanged(boolean state) {
-        Checkbox cb = (Checkbox) target;
-        ItemEvent e = new ItemEvent(cb,
-                          ItemEvent.ITEM_STATE_CHANGED,
-                          cb.getLabel(),
-                          state ? ItemEvent.SELECTED : ItemEvent.DESELECTED);
-        postEvent(e);
-    }
-
-
-    // NOTE: This method is called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    void action(boolean state) {
-        final Checkbox cb = (Checkbox)target;
-        final boolean newState = state;
-        MToolkit.executeOnEventHandlerThread(cb, new Runnable() {
-            public void run() {
-                CheckboxGroup cbg = cb.getCheckboxGroup();
-                /* Bugid 4039594. If this is the current Checkbox in
-                 * a CheckboxGroup, then return to prevent deselection.
-                 * Otherwise, it's logical state will be turned off,
-                 * but it will appear on.
-                 */
-                if ((cbg != null) && (cbg.getSelectedCheckbox() == cb) &&
-                    cb.getState()) {
-                  inUpCall = false;
-                  cb.setState(true);
-                  return;
-                }
-                // All clear - set the new state
-                cb.setState(newState);
-                notifyStateChanged(newState);
-            } // run()
-        });
-    } // action()
-
-
-
-    static final int SIZE = 19;
-    static final int BORDER = 4;
-    static final int SIZ = SIZE - BORDER*2 - 1;
-
-    /*
-     * Print the native component by rendering the Motif look ourselves.
-     * ToDo(aim): needs to query native motif for more accurate size and
-     * color information; need to render check mark.
-     */
-    public void print(Graphics g) {
-        Checkbox cb = (Checkbox)target;
-        Dimension d = cb.size();
-        Color bg = cb.getBackground();
-        Color fg = cb.getForeground();
-        Color shadow = bg.darker();
-        int x = BORDER;
-        int y = ((d.height - SIZE) / 2) + BORDER;
-
-        g.setColor(cb.getState()? shadow : bg);
-
-        if (cb.getCheckboxGroup() != null) {
-            g.fillOval(x, y, SIZ, SIZ);
-            draw3DOval(g, bg, x, y, SIZ, SIZ, !(cb.getState()));
-            if (cb.getState()) {
-                g.setColor(fg);
-                g.fillOval(x + 3, y + 3, SIZ - 6, SIZ - 6);
-            }
-        } else {
-            g.fillRect(x, y, SIZ, SIZ);
-            draw3DRect(g, bg, x, y, SIZ, SIZ, !(cb.getState()));
-            if (cb.getState()) {
-                g.setColor(fg);
-                g.drawLine(x+1, y+1, x+SIZ-1, y+SIZ-1);
-                g.drawLine(x+1, y+SIZ-1, x+SIZ-1, y+1);
-            }
-        }
-        g.setColor(fg);
-        String lbl = cb.getLabel();
-        if (lbl != null) {
-            // REMIND: align
-            g.setFont(cb.getFont());
-            FontMetrics fm = g.getFontMetrics();
-            g.drawString(lbl, SIZE,
-                         (d.height + fm.getMaxAscent() - fm.getMaxDescent()) / 2);
-        }
-
-        target.print(g);
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public Dimension minimumSize() {
-            return getMinimumSize();
-    }
-
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MChoicePeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MChoicePeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MChoicePeer.java	2014-04-08 05:27:04.974897587 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MChoicePeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,177 +0,0 @@
-/*
- * Copyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import java.awt.event.ItemEvent;
-
-class MChoicePeer extends MComponentPeer implements ChoicePeer {
-    boolean inUpCall=false;
-
-    native void create(MComponentPeer parent);
-    native void pReshape(int x, int y, int width, int height);
-    native void pSelect(int index, boolean init);
-    native void appendItems(String[] items);
-
-    void initialize() {
-        Choice opt = (Choice)target;
-        int itemCount = opt.countItems();
-        String[] items = new String[itemCount];
-        for (int i=0; i < itemCount; i++) {
-            items[i] = opt.getItem(i);
-        }
-        if (itemCount > 0) {
-            appendItems(items);
-            pSelect(opt.getSelectedIndex(), true);
-        }
-        super.initialize();
-    }
-
-    public MChoicePeer(Choice target) {
-        super(target);
-    }
-
-    public boolean isFocusable() {
-        return true;
-    }
-
-    public Dimension getMinimumSize() {
-        FontMetrics fm = getFontMetrics(target.getFont());
-        Choice c = (Choice)target;
-        int w = 0;
-        for (int i = c.countItems() ; i-- > 0 ;) {
-            w = Math.max(fm.stringWidth(c.getItem(i)), w);
-        }
-        return new Dimension(32 + w, Math.max(fm.getHeight() + 8, 15) + 5);
-    }
-
-    public native void setFont(Font f);
-
-    public void add(String item, int index) {
-        addItem(item, index);
-        // Adding an item can change the size of the Choice, so do
-        // a reshape, based on the font size.
-        Rectangle r = target.getBounds();
-        reshape(r.x, r.y, 0, 0);
-    }
-
-    public native void remove(int index);
-
-    public native void removeAll();
-
-    /**
-     * DEPRECATED, but for now, called by add(String, int).
-     */
-    public native void addItem(String item, int index);
-
-    // public native void remove(int index);
-
-    public native void setBackground(Color c);
-
-    public native void setForeground(Color c);
-
-    public void select(int index) {
-        if (!inUpCall) {
-            pSelect(index, false);
-        }
-    }
-
-    void notifySelection(String item) {
-        Choice c = (Choice)target;
-        ItemEvent e = new ItemEvent(c, ItemEvent.ITEM_STATE_CHANGED,
-                                item, ItemEvent.SELECTED);
-        postEvent(e);
-    }
-
-
-    // NOTE: This method is called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    void action(final int index) {
-        final Choice c = (Choice)target;
-        inUpCall = false;  /* Used to prevent native selection. */
-        MToolkit.executeOnEventHandlerThread(c, new Runnable() {
-            public void run() {
-                String item;
-                synchronized(c) {
-                    if (index >= c.getItemCount()) {
-                        /* Nothing to do when the list is too short */
-                        return;
-                    }
-                    inUpCall = true;       /* Prevent native selection. */
-                    c.select(index);       /* set value in target */
-                    item = c.getItem(index);
-                    inUpCall = false;
-                }
-                notifySelection(item);
-            }
-        });
-    }
-
-    /*
-     * Print the native component by rendering the Motif look ourselves.
-     * ToDo(aim): needs to query native motif for more accurate size and
-     * color information.
-     */
-    public void print(Graphics g) {
-        Choice ch = (Choice)target;
-        Dimension d = ch.size();
-        Color bg = ch.getBackground();
-        Color fg = ch.getForeground();
-
-        g.setColor(bg);
-        g.fillRect(2, 2, d.width-1, d.height-1);
-        draw3DRect(g, bg, 1, 1, d.width-2, d.height-2, true);
-        draw3DRect(g, bg, d.width - 18, (d.height / 2) - 3, 10, 6, true);
-
-        g.setColor(fg);
-        g.setFont(ch.getFont());
-        FontMetrics fm = g.getFontMetrics();
-        String lbl = ch.getSelectedItem();
-        if (lbl == null){
-            lbl = "";
-        }
-        if (lbl != ""){
-            g.drawString(lbl, 5, (d.height + fm.getMaxAscent()-fm.getMaxDescent())/2);
-        }
-
-        target.print(g);
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public Dimension minimumSize() {
-            return getMinimumSize();
-    }
-
-    protected void disposeImpl() {
-        freeNativeData();
-        super.disposeImpl();
-    }
-
-    private native void freeNativeData();
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MComponentPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MComponentPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MComponentPeer.java	2014-04-08 12:22:59.324041361 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MComponentPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,1184 +0,0 @@
-/*
- * Copyright (c) 1995, 2007, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import java.awt.event.PaintEvent;
-import java.awt.event.MouseEvent;
-import java.awt.event.InputEvent;
-
-import sun.awt.*;
-import sun.awt.image.ToolkitImage;
-import sun.awt.image.SunVolatileImage;
-import java.awt.image.ImageProducer;
-import java.awt.image.ImageObserver;
-import java.awt.image.ColorModel;
-import java.awt.image.VolatileImage;
-
-import java.awt.dnd.DropTarget;
-import java.awt.dnd.peer.DropTargetPeer;
-
-import sun.java2d.BackBufferCapsProvider;
-import sun.java2d.SunGraphics2D;
-import sun.java2d.SurfaceData;
-
-import java.lang.reflect.Method;
-
-import java.util.logging.*;
-
-import sun.java2d.pipe.Region;
-
-
-public /* REMIND: should not be public */
-abstract class MComponentPeer implements BackBufferCapsProvider, ComponentPeer, DropTargetPeer, X11ComponentPeer {
-
-    private static final Logger log = Logger.getLogger("sun.awt.motif.MComponentPeer");
-    private static final Logger focusLog = Logger.getLogger("sun.awt.motif.focus.MComponentPeer");
-
-    Component   target;
-    long        pData;
-    long        jniGlobalRef;
-    protected X11GraphicsConfig graphicsConfig;
-    SurfaceData surfaceData;
-    int         oldWidth = -1;
-    int         oldHeight = -1;
-
-    private RepaintArea paintArea;
-
-    boolean isLayouting = false;
-    boolean paintPending = false;
-
-    protected boolean disposed = false;
-    private static int JAWT_LOCK_ERROR=0x00000001;
-    private static int JAWT_LOCK_CLIP_CHANGED=0x00000002;
-    private static int JAWT_LOCK_BOUNDS_CHANGED=0x00000004;
-    private static int JAWT_LOCK_SURFACE_CHANGED=0x00000008;
-    private int drawState = JAWT_LOCK_CLIP_CHANGED |
-    JAWT_LOCK_BOUNDS_CHANGED |
-    JAWT_LOCK_SURFACE_CHANGED;
-
-    /* These are the enumerated types in awt_p.h*/
-    static final int MOTIF_NA = 0 ;
-    static final int MOTIF_V1 = 1 ;
-    static final int MOTIF_V2 = 2 ;
-
-    private Font font;
-    private long backBuffer = 0;
-    private VolatileImage xBackBuffer = null;
-    private BufferCapabilities backBufferCaps;
-
-    static {
-        initIDs();
-    }
-
-    /* initialize the fieldIDs of fields that may be accessed from C */
-    private native static void initIDs();
-
-
-    /* This will return the last state of a window. ie the specific
-     * "gotcha" is that if you iconify a window its obscurity remains
-     * unchanged. Current use of this is just in user-initiated scrolling.
-     * If that use expands to more cases you may need to "and" this with
-     * the value of the iconic state of a Frame.
-     * Note that de-iconifying an X11 window DOES generate a new event
-     * correctly notifying you of the new visibility of the window
-     */
-    public boolean isObscured() {
-
-        Container container  = (target instanceof Container) ?
-            (Container)target : target.getParent();
-
-        if (container == null) {
-            return true;
-        }
-
-        Container parent;
-        while ((parent = container.getParent()) != null) {
-            container = parent;
-        }
-
-        if (container instanceof Window) {
-            MWindowPeer wpeer = (MWindowPeer)(container.getPeer());
-            if (wpeer != null) {
-                return (wpeer.winAttr.visibilityState !=
-                        MWindowAttributes.AWT_UNOBSCURED);
-            }
-        }
-        return true;
-    }
-
-    public boolean canDetermineObscurity() {
-        return true;
-    }
-
-    abstract void create(MComponentPeer parent);
-    void create(MComponentPeer parent, Object arg) {
-        create(parent);
-    }
-
-    void EFcreate(MComponentPeer parent, int x){}
-
-    native void pInitialize();
-    native void pShow();
-    native void pHide();
-    native void pEnable();
-    native void pDisable();
-    native void pReshape(int x, int y, int width, int height);
-    native void pDispose();
-    native void pMakeCursorVisible();
-    native Point pGetLocationOnScreen();
-    native Point pGetLocationOnScreen2(Window win, MWindowPeer wpeer);
-    native void pSetForeground(Color c);
-    native void pSetBackground(Color c);
-    private native void pSetFont(Font f);
-
-    //Added for bug 4175560
-    //Returns the native representation for the Color argument,
-    //using the given GraphicsConfiguration.
-    native int getNativeColor(Color clr, GraphicsConfiguration gc);
-
-    // Returns the parent of the component, without invoking client
-    // code. This must go through native code, because it invokes
-    // private methods in the java.awt package, which we cannot
-    // do from this package.
-    static native Container getParent_NoClientCode(Component component);
-
-    // Returns the parent of the component, without invoking client
-    // code. This must go through native code, because it invokes
-    // private methods in the java.awt package, which we cannot
-    // do from this package.
-    static native Component[] getComponents_NoClientCode(Container container);
-
-    void initialize() {
-        if (!target.isVisible()) {
-            hide();
-        }
-        Color c;
-        Font  f;
-        Cursor cursor;
-
-        pInitialize();
-
-        if ((c = target.getForeground()) != null) {
-            setForeground(c);
-        }
-        if ((c = target.getBackground()) != null) {
-            setBackground(c);
-        }
-        if ((f = target.getFont()) != null) {
-            setFont(f);
-        }
-        pSetCursor(target.getCursor());
-        if (!target.isEnabled()) {
-            disable();
-        }
-        Rectangle r = target.getBounds();
-        reshape(r.x, r.y, r.width, r.height);
-        if (target.isVisible()) {
-            show();
-        }
-
-        surfaceData = graphicsConfig.createSurfaceData(this);
-    }
-
-    public void init(Component target, Object arg) {
-        this.target = target;
-        this.paintArea = new RepaintArea();
-
-        Container parent = MToolkit.getNativeContainer(target);
-        MComponentPeer parentPeer = (MComponentPeer) MToolkit.targetToPeer(parent);
-        create(parentPeer, arg);
-
-        initialize();
-    }
-
-    MComponentPeer(Component target, Object arg) {
-        init(target, arg);
-    }
-
-    MComponentPeer() {}
-
-    public void init(Component target) {
-        this.target = target;
-        this.paintArea = new RepaintArea();
-
-        Container parent = MToolkit.getNativeContainer(target);
-        MComponentPeer parentPeer = (MComponentPeer) MToolkit.targetToPeer(parent);
-        create(parentPeer);
-
-        if (parent != null && parent instanceof ScrollPane) {
-            MScrollPanePeer speer = (MScrollPanePeer) parentPeer;
-            speer.setScrollChild(this);
-        }
-        initialize();
-    }
-
-    MComponentPeer(Component target) {
-        init(target);
-    }
-
-    protected void finalize() throws Throwable {
-        dispose();
-        super.finalize();
-    }
-
-    public void setForeground(Color c) {
-        pSetForeground(c);
-    }
-
-    public void setBackground(Color c) {
-        pSetBackground(c);
-    }
-
-    public void updateCursorImmediately() {
-        MGlobalCursorManager.getCursorManager().updateCursorImmediately();
-    }
-
-    public void setFont(Font f) {
-        ComponentPeer peer;
-        if (f == null) {
-            f = defaultFont;
-        }
-        pSetFont(f);
-        if ( target instanceof Container ) {
-            Container container = (Container) target;
-            int count = container.getComponentCount();
-            Component[] children = container.getComponents();
-            for (int i=0; i<count; i++) {
-                if ( children[i] != null ) {
-/*
-** note: recursion in the widget in pSetFont() has by now broken any
-**       children with different Fonts - so fix now:
-*/
-                    peer = children[i].getPeer();
-                    if (peer != null) {
-                        Font rightFont = children[i].getFont();
-                        if (!f.equals(rightFont)) {
-                            peer.setFont(rightFont);
-                        } else
-                            if (children[i] instanceof Container) {
-                                peer.setFont(f);
-                            }
-                    }
-                }
-            }
-        }
-
-        /*
-         * Keep a reference to the java.awt.Font object in order to
-         * preserve the XFontStructs which underlying widgets are using.
-         * Save this AFTER changing the widgets in order to keep the
-         * previous reference (if any) alive.
-         */
-        font = f;
-    }
-
-
-    public native void setTargetBackground(Color c);
-    public native void pSetCursor(Cursor c);
-    public native void pSetScrollbarBackground(Color c);
-    public native void pSetInnerForeground(Color c);
-
-    public boolean isFocusable() {
-        return false;
-    }
-
-    public SurfaceData getSurfaceData() {
-        return surfaceData;
-    }
-
-    public ColorModel getColorModel() {
-        return graphicsConfig.getColorModel();
-    }
-
-    public ColorModel getColorModel(int transparency) {
-        return graphicsConfig.getColorModel(transparency);
-    }
-
-    public int updatePriority() {
-        return Thread.NORM_PRIORITY;
-    }
-
-    public void repaint(long tm, int x, int y, int width, int height) {
-    }
-
-    public void paint(Graphics g) {
-        Dimension d = target.getSize();
-        if (g instanceof Graphics2D ||
-            g instanceof sun.awt.Graphics2Delegate) {
-            // background color is setup correctly, so just use clearRect
-            g.clearRect(0, 0, d.width, d.height);
-        } else {
-            // emulate clearRect
-            g.setColor(target.getBackground());
-            g.fillRect(0, 0, d.width, d.height);
-            g.setColor(target.getForeground());
-        }
-
-        target.paint(g);
-    }
-    public void print(Graphics g) {
-        Dimension d = target.getSize();
-        if (g instanceof Graphics2D ||
-            g instanceof sun.awt.Graphics2Delegate) {
-            // background color is setup correctly, so just use clearRect
-            g.clearRect(0, 0, d.width, d.height);
-        } else {
-            // emulate clearRect
-            g.setColor(target.getBackground());
-            g.fillRect(0, 0, d.width, d.height);
-            g.setColor(target.getForeground());
-        }
-
-        target.print(g);
-    }
-
-    public void coalescePaintEvent(PaintEvent e) {
-        Rectangle r = e.getUpdateRect();
-        paintArea.add(r, e.getID());
-
-        if (log.isLoggable(Level.FINEST)) {
-            switch(e.getID()) {
-              case PaintEvent.UPDATE:
-                  log.log(Level.FINEST, "coalescePaintEvent: UPDATE: add: x = " +
-                          r.x + ", y = " + r.y + ", width = " + r.width + ", height = " + r.height);
-                  return;
-              case PaintEvent.PAINT:
-                  log.log(Level.FINEST, "coalescePaintEvent: PAINT: add: x = " +
-                          r.x + ", y = " + r.y + ", width = " + r.width + ", height = " + r.height);
-                  return;
-            }
-        }
-    }
-
-    native void nativeHandleEvent(AWTEvent e);
-
-    /**
-     * Returns whether or not this component should be given focus on mouse click.
-     * Default implementation return whether or not this peer is "focusable"
-     * Descendants might want to override it to extend/restrict conditions at which this
-     * component should be focused by click (see MCanvasPeer and MPanelPeer)
-     */
-    protected boolean shouldFocusOnClick() {
-        return isFocusable();
-    }
-
-    /**
-     * Checks whether or not this component would be focused by native system if it would be allowed to do so.
-     * Currently it checks that it displayable, visible, enabled and focusable.
-     */
-    static boolean canBeFocusedByClick(Component component) {
-        if (component == null) {
-            return false;
-        } else {
-            return component.isDisplayable() && component.isVisible() && component.isEnabled() && component.isFocusable();
-        }
-    }
-
-    static Method requestFocusWithCause;
-
-    static void callRequestFocusInWindow(Component target, CausedFocusEvent.Cause cause) {
-        AWTAccessor.getComponentAccessor().requestFocusInWindow(target, cause);
-    }
-
-    public void handleEvent(AWTEvent e) {
-        int id = e.getID();
-
-        switch(id) {
-          case PaintEvent.PAINT:
-              // Got native painting
-              paintPending = false;
-              // Fallthrough to next statement
-          case PaintEvent.UPDATE:
-              // Skip all painting while layouting and all UPDATEs
-              // while waiting for native paint
-              if (!isLayouting && !paintPending) {
-                  paintArea.paint(target,false);
-              }
-              return;
-          case MouseEvent.MOUSE_PRESSED:
-              if (target == e.getSource() && !((InputEvent)e).isConsumed() && shouldFocusOnClick()
-                  && !target.isFocusOwner() && canBeFocusedByClick(target))
-              {
-                  callRequestFocusInWindow(target, CausedFocusEvent.Cause.MOUSE_EVENT);
-              }
-              break;
-          default:
-              break;
-        }
-
-        // Call the native code
-        nativeHandleEvent(e);
-    }
-
-    /* New API for 1.1 */
-    public Dimension getMinimumSize() {
-        return target.getSize();
-    }
-
-    /* New API for 1.1 */
-    public Dimension getPreferredSize() {
-        return getMinimumSize();
-    }
-
-    // Do nothing for heavyweight implementation
-    public void layout() {}
-
-    public Rectangle getBounds() {
-        return ((Component)target).getBounds();
-    }
-
-    public Object getTarget() {
-        return target;
-    }
-
-    public java.awt.Toolkit getToolkit() {
-        // XXX: bogus
-        return Toolkit.getDefaultToolkit();
-    }
-
-    // fallback default font object
-    final static Font defaultFont = new Font(Font.DIALOG, Font.PLAIN, 12);
-
-    public synchronized Graphics getGraphics() {
-        if (!disposed) {
-            Component target = (Component) this.target;
-
-            /* Fix for bug 4746122. Color and Font shouldn't be null */
-            Color bgColor = target.getBackground();
-            if (bgColor == null) {
-                bgColor = SystemColor.window;
-            }
-            Color fgColor = target.getForeground();
-            if (fgColor == null) {
-                fgColor = SystemColor.windowText;
-            }
-            Font font = target.getFont();
-            if (font == null) {
-                font = defaultFont;
-            }
-            return new SunGraphics2D(surfaceData, fgColor, bgColor, font);
-        }
-
-        return null;
-    }
-
-    public Image createImage(ImageProducer producer) {
-        return new ToolkitImage(producer);
-    }
-
-    public Image createImage(int width, int height) {
-        return graphicsConfig.createAcceleratedImage(target, width, height);
-    }
-
-    public VolatileImage createVolatileImage(int width, int height) {
-        return new SunVolatileImage(target, width, height);
-    }
-
-    public boolean prepareImage(Image img, int w, int h, ImageObserver o) {
-        return getToolkit().prepareImage(img, w, h, o);
-    }
-
-    public int checkImage(Image img, int w, int h, ImageObserver o) {
-        return getToolkit().checkImage(img, w, h, o);
-    }
-
-    public FontMetrics getFontMetrics(Font font) {
-        return X11FontMetrics.getFontMetrics(font);
-    }
-
-    /*
-     * Subclasses should override disposeImpl() instead of dispose(). Client
-     * code should always invoke dispose(), never disposeImpl().
-     */
-    protected void disposeImpl() {
-        SurfaceData oldData = surfaceData;
-        surfaceData = null;
-        oldData.invalidate();
-        MToolkit.targetDisposedPeer(target, this);
-        pDispose();
-    }
-    public final void dispose() {
-        boolean call_disposeImpl = false;
-
-        if (!disposed) {
-            synchronized (this) {
-                SunToolkit.awtLock();
-                try {
-                    if (!disposed) {
-                        disposed = call_disposeImpl = true;
-                    }
-                } finally {
-                    SunToolkit.awtUnlock();
-                }
-            }
-        }
-
-        if (call_disposeImpl) {
-            disposeImpl();
-        }
-    }
-
-    native static boolean processSynchronousLightweightTransfer(Component heavyweight, Component descendant,
-                                                                boolean temporary, boolean focusedWindowChangeAllowed,
-                                                                long time);
-    public boolean requestFocus
-    (Component lightweightChild, boolean temporary,
-         boolean focusedWindowChangeAllowed, long time, CausedFocusEvent.Cause cause) {
-        if (processSynchronousLightweightTransfer((Component)target, lightweightChild, temporary,
-                                                  focusedWindowChangeAllowed, time)) {
-            return true;
-        } else {
-            if (focusLog.isLoggable(Level.FINER)) {
-                focusLog.log(Level.FINER, "Current native focused window " + getNativeFocusedWindow());
-            }
-            /**
-             * The problems with requests in non-focused window arise because shouldNativelyFocusHeavyweight
-             * checks that native window is focused while appropriate WINDOW_GAINED_FOCUS has not yet
-             * been processed - it is in EventQueue. Thus, SNFH allows native request and stores request record
-             * in requests list - and it breaks our requests sequence as first record on WGF should be the last focus
-             * owner which had focus before WLF. So, we should not add request record for such requests
-             * but store this component in mostRecent - and return true as before for compatibility.
-             */
-            Container parent = (target instanceof Container) ? ((Container)target) : (target.getParent());
-            // Search for parent window
-            while (parent != null && !(parent instanceof Window)) {
-                parent = getParent_NoClientCode(parent);
-            }
-            if (parent != null) {
-                Window parentWindow = (Window)parent;
-                // and check that it is focused
-                if (focusLog.isLoggable(Level.FINER)) {
-                    focusLog.log(Level.FINER, "Parent window " + parentWindow);
-                }
-                if (!parentWindow.isFocused() && getNativeFocusedWindow() == parentWindow) {
-                    // if it is not - skip requesting focus on Solaris
-                    // but return true for compatibility.
-                    return true;
-                } else if (getNativeFocusedWindow() != parentWindow) {
-                    WindowPeer wpeer = (WindowPeer)parentWindow.getPeer();
-                    boolean res = wpeer.requestWindowFocus();
-                    if (focusLog.isLoggable(Level.FINER)) {
-                        focusLog.log(Level.FINER, "Requested window focus: " + res);
-                    }
-                    // If parent window can be made focused and has been made focused(synchronously)
-                    // then we can proceed with children, otherwise we retreat.
-                    if (!(res && parentWindow.isFocused())) {
-                        focusLog.finer("Waiting for asynchronous processing of window focus request");
-                        KeyboardFocusManagerPeerImpl.removeLastFocusRequest(target);
-                        return false;
-                    }
-                }
-            }
-            return _requestFocus(lightweightChild, temporary, focusedWindowChangeAllowed, time, cause);
-        }
-    }
-
-    native boolean _requestFocus
-        (Component lightweightChild, boolean temporary,
-         boolean focusedWindowChangeAllowed, long time, CausedFocusEvent.Cause cause);
-
-    static native Window getNativeFocusedWindow();
-
-    /*
-     * Post an event to the event queue.
-     */
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    void postEvent(AWTEvent event) {
-        MToolkit.postEvent(MToolkit.targetToAppContext(target), event);
-    }
-
-    /* Callbacks for window-system events to the frame
-     *
-     * NOTE: This method may be called by privileged threads.
-     *       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-     */
-    void handleExpose(int x, int y, int w, int h) {
-        if ( !ComponentAccessor.getIgnoreRepaint(target) ) {
-            postEvent(new PaintEvent(target, PaintEvent.PAINT,
-                                     new Rectangle(x, y, w, h)));
-        }
-    }
-
-    /* Callbacks for window-system events to the frame
-     *
-     * NOTE: This method may be called by privileged threads.
-     *       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-     */
-    void handleRepaint(int x, int y, int w, int h) {
-        if ( !ComponentAccessor.getIgnoreRepaint(target) ) {
-            postEvent(new PaintEvent(target, PaintEvent.UPDATE,
-                                     new Rectangle(x, y, w, h)));
-        }
-    }
-
-    /* Return the component's z-order position relative to
-     * other peer'd siblings (don't count lightweight siblings
-     * or siblings who don't yet have valid peers).
-     *
-     * NOTE: This method may be called by privileged threads.
-     *       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-     */
-    public int getZOrderPosition_NoClientCode() {
-        // SECURITY: use _NoClientCode() methods, because we may
-        //           be running on a privileged thread
-        Container p = getParent_NoClientCode(target);
-        if (p != null) {
-            // SECURITY: use _NoClientCode() methods, because we may
-            //           be running on a privileged thread
-            Component children[] = getComponents_NoClientCode(p);
-            int i;
-            int index = 0;
-            for (i = 0; i < children.length; i++) {
-                if (children[i] == target) {
-                    return index;
-                } else {
-                    Object cpeer = MToolkit.targetToPeer(children[i]);
-                    if (cpeer != null &&
-                        !(cpeer instanceof java.awt.peer.LightweightPeer)) {
-                        index++;
-                    }
-                }
-            }
-        }
-        return -1;
-    }
-
-    /*
-     * drawXXX() methods are used to print the native components by
-     * rendering the Motif look ourselves.
-     * ToDo(aim): needs to query native motif for more accurate color
-     * information.
-     */
-    void draw3DOval(Graphics g, Color bg,
-                    int x, int y, int w, int h, boolean raised) {
-        Color c = g.getColor();
-        Color shadow = bg.darker();
-        Color highlight = bg.brighter();
-
-        g.setColor(raised ? highlight : shadow);
-        g.drawArc(x, y, w, h, 45, 180);
-        g.setColor(raised ? shadow : highlight);
-        g.drawArc(x, y, w, h, 225, 180);
-        g.setColor(c);
-    }
-    void draw3DRect(Graphics g, Color bg,
-                    int x, int y, int width, int height,
-                    boolean raised) {
-        Color c = g.getColor();
-        Color shadow = bg.darker();
-        Color highlight = bg.brighter();
-
-        g.setColor(raised ? highlight : shadow);
-        g.drawLine(x, y, x, y + height);
-        g.drawLine(x + 1, y, x + width - 1, y);
-        g.setColor(raised ? shadow : highlight);
-        g.drawLine(x + 1, y + height, x + width, y + height);
-        g.drawLine(x + width, y, x + width, y + height - 1);
-        g.setColor(c);
-    }
-    void drawScrollbar(Graphics g, Color bg, int thickness, int length,
-                       int min, int max, int val, int vis, boolean horizontal) {
-        Color c = g.getColor();
-        double f = (double)(length - 2*(thickness-1)) / Math.max(1, ((max - min) + vis));
-        int v1 = thickness + (int)(f * (val - min));
-        int v2 = (int)(f * vis);
-        int w2 = thickness-4;
-        int tpts_x[] = new int[3];
-        int tpts_y[] = new int[3];
-
-        if (length < 3*w2 ) {
-            v1 = v2 = 0;
-            if (length < 2*w2 + 2) {
-                w2 = (length-2)/2;
-            }
-        } else  if (v2 < 7) {
-            // enforce a minimum handle size
-            v1 = Math.max(0, v1 - ((7 - v2)>>1));
-            v2 = 7;
-        }
-
-        int ctr   = thickness/2;
-        int sbmin = ctr - w2/2;
-        int sbmax = ctr + w2/2;
-
-        // paint the background slightly darker
-        {
-            Color d = new Color((int) (bg.getRed()   * 0.85),
-                                (int) (bg.getGreen() * 0.85),
-                                (int) (bg.getBlue()  * 0.85));
-
-            g.setColor(d);
-            if (horizontal) {
-                g.fillRect(0, 0, length, thickness);
-            } else {
-                g.fillRect(0, 0, thickness, length);
-            }
-        }
-
-        // paint the thumb and arrows in the normal background color
-        g.setColor(bg);
-        if (v1 > 0) {
-            if (horizontal) {
-                g.fillRect(v1, 3, v2, thickness-3);
-            } else {
-                g.fillRect(3, v1, thickness-3, v2);
-            }
-        }
-
-        tpts_x[0] = ctr;        tpts_y[0] = 2;
-        tpts_x[1] = sbmin;      tpts_y[1] = w2;
-        tpts_x[2] = sbmax;      tpts_y[2] = w2;
-        if (horizontal) {
-            g.fillPolygon(tpts_y, tpts_x, 3);
-        } else {
-            g.fillPolygon(tpts_x, tpts_y, 3);
-        }
-
-        tpts_y[0] = length-2;
-        tpts_y[1] = length-w2;
-        tpts_y[2] = length-w2;
-        if (horizontal) {
-            g.fillPolygon(tpts_y, tpts_x, 3);
-        } else {
-            g.fillPolygon(tpts_x, tpts_y, 3);
-        }
-
-        Color highlight = bg.brighter();
-
-        // // // // draw the "highlighted" edges
-        g.setColor(highlight);
-
-        // outline & arrows
-        if (horizontal) {
-            g.drawLine(1, thickness, length - 1, thickness);
-            g.drawLine(length - 1, 1, length - 1, thickness);
-
-            // arrows
-            g.drawLine(1, ctr, w2, sbmin);
-            g.drawLine(length - w2, sbmin, length - w2, sbmax);
-            g.drawLine(length - w2, sbmin, length - 2, ctr);
-
-        } else {
-            g.drawLine(thickness, 1, thickness, length - 1);
-            g.drawLine(1, length - 1, thickness, length - 1);
-
-            // arrows
-            g.drawLine(ctr, 1, sbmin, w2);
-            g.drawLine(sbmin, length - w2, sbmax, length - w2);
-            g.drawLine(sbmin, length - w2, ctr, length - 2);
-        }
-
-        // thumb
-        if (v1 > 0) {
-            if (horizontal) {
-                g.drawLine(v1, 2, v1 + v2, 2);
-                g.drawLine(v1, 2, v1, thickness-3);
-            } else {
-                g.drawLine(2, v1, 2, v1 + v2);
-                g.drawLine(2, v1, thickness-3, v1);
-            }
-        }
-
-        Color shadow = bg.darker();
-
-        // // // // draw the "shadowed" edges
-        g.setColor(shadow);
-
-        // outline && arrows
-        if (horizontal) {
-            g.drawLine(0, 0, 0, thickness);
-            g.drawLine(0, 0, length - 1, 0);
-
-            // arrows
-            g.drawLine(w2, sbmin, w2, sbmax);
-            g.drawLine(w2, sbmax, 1, ctr);
-            g.drawLine(length-2, ctr, length-w2, sbmax);
-
-        } else {
-            g.drawLine(0, 0, thickness, 0);
-            g.drawLine(0, 0, 0, length - 1);
-
-            // arrows
-            g.drawLine(sbmin, w2, sbmax, w2);
-            g.drawLine(sbmax, w2, ctr, 1);
-            g.drawLine(ctr, length-2, sbmax, length-w2);
-        }
-
-        // thumb
-        if (v1 > 0) {
-            if (horizontal) {
-                g.drawLine(v1 + v2, 2, v1 + v2, thickness-2);
-                g.drawLine(v1, thickness-2, v1 + v2, thickness-2);
-            } else {
-                g.drawLine(2, v1 + v2, thickness-2, v1 + v2);
-                g.drawLine(thickness-2, v1, thickness-2, v1 + v2);
-            }
-        }
-        g.setColor(c);
-    }
-
-    public String toString() {
-        return getClass().getName() + "[" + target + "]";
-    }
-
-    /* New 1.1 API */
-    public void setVisible(boolean b) {
-        if (b) {
-            Dimension s = target.getSize();
-            oldWidth = s.width;
-            oldHeight = s.height;
-            pShow();
-        } else {
-            pHide();
-        }
-    }
-
-    /* New 1.1 API */
-    public void setEnabled(boolean b) {
-        if (b) {
-            pEnable();
-        } else {
-            pDisable();
-        }
-    }
-
-    /* New 1.1 API */
-    public Point getLocationOnScreen() {
-        synchronized (target.getTreeLock()) {
-            Component comp = target;
-            while (comp != null && !(comp instanceof Window)) {
-                comp = getParent_NoClientCode(comp);
-            }
-
-            // applets, embedded, etc - translate directly
-            if (comp == null || comp instanceof sun.awt.EmbeddedFrame) {
-                return pGetLocationOnScreen();
-            }
-
-            MWindowPeer wpeer = (MWindowPeer)(MToolkit.targetToPeer(comp));
-            if (wpeer == null) {
-                return pGetLocationOnScreen();
-            }
-            return pGetLocationOnScreen2((Window)comp, wpeer);
-        }
-    }
-
-    public int serialNum = 0;
-
-    /* Returns the native paint should be posted after setting new size
-     */
-    public boolean checkNativePaintOnSetBounds(int width, int height) {
-        return (width != oldWidth) || (height != oldHeight);
-    }
-
-    void setBounds(int x, int y, int width, int height) {
-        setBounds(x, y, width, height, SET_BOUNDS);
-    }
-
-    /* New 1.1 API */
-    public void setBounds(int x, int y, int width, int height, int op) {
-        if (disposed) return;
-
-        Container parent = getParent_NoClientCode(target);
-
-        // Should set paintPending before reshape to prevent
-        // thread race between PaintEvent and setBounds
-        // This part of the 4267393 fix proved to be unstable under solaris,
-        // dissabled due to regressions 4418155, 4486762, 4490079
-        paintPending = false; //checkNativePaintOnSetBounds(width, height);
-
-        // Note: it would be ideal to NOT execute this if it's
-        // merely a Move which is occurring.
-        if (parent != null && parent instanceof ScrollPane) {
-            MScrollPanePeer speer = (MScrollPanePeer)parent.getPeer();
-            if (!speer.ignore) {
-                pReshape(x, y, width, height);
-                speer.childResized(width, height);
-            }
-        } else {
-            pReshape(x, y, width, height);
-        }
-
-        if ((width != oldWidth) || (height != oldHeight)) {
-            SurfaceData oldData = surfaceData;
-            if (oldData != null) {
-                surfaceData = graphicsConfig.createSurfaceData(this);
-                oldData.invalidate();
-            }
-            oldWidth = width;
-            oldHeight = height;
-        }
-        validateSurface(width, height);
-        serialNum++;
-    }
-
-    void validateSurface(int width, int height) {
-        SunToolkit.awtLock();
-        try {
-            if (!disposed && (width != oldWidth || height != oldHeight)) {
-                SurfaceData oldData = surfaceData;
-                if (oldData != null) {
-                    surfaceData = graphicsConfig.createSurfaceData(this);
-                    oldData.invalidate();
-                }
-                oldWidth = width;
-                oldHeight = height;
-            }
-        } finally {
-            SunToolkit.awtUnlock();
-        }
-    }
-
-    public void beginValidate() {
-    }
-
-    native void restoreFocus();
-
-    public void endValidate() {
-        restoreFocus();
-    }
-
-    public void beginLayout() {
-        // Skip all painting till endLayout
-        isLayouting = true;
-    }
-
-    public void endLayout() {
-        if (!paintPending && !paintArea.isEmpty() &&
-            !((Component)target).getIgnoreRepaint()) {
-            // if not waiting for native painting repaint damaged area
-            postEvent(new PaintEvent((Component)target, PaintEvent.PAINT,
-                                     new Rectangle()));
-        }
-        isLayouting = false;
-    }
-
-    /**
-     * DEPRECATED:  Replaced by setVisible(boolean).
-     */
-    public void show() {
-        setVisible(true);
-    }
-
-    /**
-     * DEPRECATED:  Replaced by setVisible(boolean).
-     */
-    public void hide() {
-        setVisible(false);
-    }
-
-    /**
-     * DEPRECATED:  Replaced by setEnabled(boolean).
-     */
-    public void enable() {
-        setEnabled(true);
-    }
-
-    /**
-     * DEPRECATED:  Replaced by setEnabled(boolean).
-     */
-    public void disable() {
-        setEnabled(false);
-    }
-
-    /**
-     * DEPRECATED:  Replaced by setBounds(int, int, int, int).
-     */
-    public void reshape(int x, int y, int width, int height) {
-        setBounds(x, y, width, height);
-    }
-
-    /**
-     * DEPRECATED:  Replaced by getMinimumSize().
-     */
-    public Dimension minimumSize() {
-        return getMinimumSize();
-    }
-
-    /**
-     * DEPRECATED:  Replaced by getPreferredSize().
-     */
-    public Dimension preferredSize() {
-        return getPreferredSize();
-    }
-
-    /**
-     *
-     */
-
-    public void addDropTarget(DropTarget dt) {
-        if (MToolkit.useMotifDnD()) {
-            addNativeDropTarget(dt);
-        } else {
-            Component comp = target;
-            while(!(comp == null || comp instanceof java.awt.Window)) {
-                comp = getParent_NoClientCode(comp);
-            }
-
-            if (comp instanceof Window) {
-                MWindowPeer wpeer = (MWindowPeer)(comp.getPeer());
-                if (wpeer != null) {
-                    wpeer.addDropTarget();
-                }
-            }
-        }
-    }
-
-    /**
-     *
-     */
-
-    public void removeDropTarget(DropTarget dt) {
-        if (MToolkit.useMotifDnD()) {
-            removeNativeDropTarget(dt);
-        } else {
-            Component comp = target;
-            while(!(comp == null || comp instanceof java.awt.Window)) {
-                comp = getParent_NoClientCode(comp);
-            }
-
-            if (comp instanceof Window) {
-                MWindowPeer wpeer = (MWindowPeer)(comp.getPeer());
-                if (wpeer != null) {
-                    wpeer.removeDropTarget();
-                }
-            }
-        }
-    }
-
-    public void notifyTextComponentChange(boolean add){
-        Container parent = getParent_NoClientCode(target);
-        while(!(parent == null ||
-                parent instanceof java.awt.Frame ||
-                parent instanceof java.awt.Dialog)) {
-            parent = getParent_NoClientCode(parent);
-        }
-
-        if (parent instanceof java.awt.Frame ||
-            parent instanceof java.awt.Dialog) {
-            if (add)
-                ((MInputMethodControl)parent.getPeer()).addTextComponent((MComponentPeer)this);
-            else
-                ((MInputMethodControl)parent.getPeer()).removeTextComponent((MComponentPeer)this);
-        }
-    }
-
-    native void addNativeDropTarget(DropTarget dt);
-
-    native void removeNativeDropTarget(DropTarget dt);
-
-    public GraphicsConfiguration getGraphicsConfiguration() {
-        GraphicsConfiguration ret = graphicsConfig;
-        if (ret == null) {
-            ret = target.getGraphicsConfiguration();
-        }
-        return ret;
-    }
-
-    // Returns true if we are inside begin/endLayout and
-    // are waiting for native painting
-    public boolean isPaintPending() {
-        return paintPending && isLayouting;
-    }
-
-    public boolean handlesWheelScrolling() {
-        return false;
-    }
-
-    /**
-     * The following multibuffering-related methods delegate to our
-     * associated GraphicsConfig (X11 or GLX) to handle the appropriate
-     * native windowing system specific actions.
-     */
-
-    private native long getWindow(long pData);
-
-    public long getContentWindow() {
-        return getWindow(pData);
-    }
-
-    public void createBuffers(int numBuffers, BufferCapabilities caps)
-      throws AWTException
-    {
-        // set the caps first, they're used when creating the bb
-        backBufferCaps = caps;
-        backBuffer = graphicsConfig.createBackBuffer(this, numBuffers, caps);
-        xBackBuffer = graphicsConfig.createBackBufferImage(target,
-                                                           backBuffer);
-    }
-
-    public BufferCapabilities getBackBufferCaps() {
-        return backBufferCaps;
-    }
-
-    public void flip(int x1, int y1, int x2, int y2,
-                     BufferCapabilities.FlipContents flipAction)
-    {
-        if (backBuffer == 0) {
-            throw new IllegalStateException("Buffers have not been created");
-        }
-        graphicsConfig.flip(this, target, xBackBuffer,
-                            x1, y1, x2, y2, flipAction);
-    }
-
-    public Image getBackBuffer() {
-        if (backBuffer == 0) {
-            throw new IllegalStateException("Buffers have not been created");
-        }
-        return xBackBuffer;
-    }
-
-    public void destroyBuffers() {
-        graphicsConfig.destroyBackBuffer(backBuffer);
-        backBuffer = 0;
-        xBackBuffer = null;
-    }
-
-    /**
-     * @see java.awt.peer.ComponentPeer#isReparentSupported
-     */
-    public boolean isReparentSupported() {
-        return false;
-    }
-
-    /**
-     * @see java.awt.peer.ComponentPeer#reparent
-     */
-    public void reparent(ContainerPeer newNativeParent) {
-        throw new UnsupportedOperationException();
-    }
-
-    /**
-     * Applies the shape to the native component window.
-     * @since 1.7
-     */
-    public void applyShape(Region shape) {
-    }
-
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MCustomCursor.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MCustomCursor.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MCustomCursor.java	2014-04-08 05:27:04.974897587 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MCustomCursor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-/*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import sun.awt.X11CustomCursor;
-import sun.awt.CustomCursor;
-import java.awt.*;
-import java.awt.image.*;
-import sun.awt.image.ImageRepresentation;
-
-public class MCustomCursor extends X11CustomCursor {
-
-    public MCustomCursor(Image cursor, Point hotSpot, String name)
-            throws IndexOutOfBoundsException {
-        super(cursor, hotSpot, name);
-    }
-    /**
-     * Returns the supported cursor size
-     */
-    public static Dimension getBestCursorSize(
-        int preferredWidth, int preferredHeight) {
-
-        // Fix for bug 4212593 The Toolkit.createCustomCursor does not
-        //                     check absence of the image of cursor
-        // We use XQueryBestCursor which accepts unsigned ints to obtain
-        // the largest cursor size that could be dislpayed
-        Dimension d = new Dimension(Math.abs(preferredWidth), Math.abs(preferredHeight));
-
-        queryBestCursor(d);
-        return d;
-    }
-
-    private static native void queryBestCursor(Dimension d);
-
-    protected native void createCursor(byte[] xorMask, byte[] andMask,
-                                     int width, int height,
-                                     int fcolor, int bcolor,
-                                     int xHotSpot, int yHotSpot);
-
-    static {
-        cacheInit();
-    }
-
-    private native static void cacheInit();
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MDataTransferer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MDataTransferer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MDataTransferer.java	2014-04-08 05:27:04.974897587 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MDataTransferer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,386 +0,0 @@
-/*
- * Copyright (c) 2000, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.Image;
-
-import java.awt.datatransfer.DataFlavor;
-
-import java.awt.image.BufferedImage;
-import java.awt.image.ColorModel;
-import java.awt.image.WritableRaster;
-
-import java.io.InputStream;
-import java.io.IOException;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-import javax.imageio.ImageIO;
-import javax.imageio.ImageTypeSpecifier;
-import javax.imageio.ImageWriter;
-import javax.imageio.spi.ImageWriterSpi;
-
-import sun.awt.datatransfer.DataTransferer;
-import sun.awt.datatransfer.ToolkitThreadBlockedHandler;
-
-/**
- * Platform-specific support for the data transfer subsystem.
- *
- * @author Roger Brinkley
- * @author Danila Sinopalnikov
- *
- * @since 1.3.1
- */
-public class MDataTransferer extends DataTransferer {
-    private static final long FILE_NAME_ATOM;
-    private static final long DT_NET_FILE_ATOM;
-    private static final long PNG_ATOM;
-    private static final long JFIF_ATOM;
-
-    static {
-        FILE_NAME_ATOM = getAtomForTarget("FILE_NAME");
-        DT_NET_FILE_ATOM = getAtomForTarget("_DT_NETFILE");
-        PNG_ATOM = getAtomForTarget("PNG");
-        JFIF_ATOM = getAtomForTarget("JFIF");
-    }
-
-    /**
-     * Singleton constructor
-     */
-    private MDataTransferer() {
-    }
-
-    private static MDataTransferer transferer;
-
-    static MDataTransferer getInstanceImpl() {
-        if (transferer == null) {
-            synchronized (MDataTransferer.class) {
-                if (transferer == null) {
-                    transferer = new MDataTransferer();
-                }
-            }
-        }
-        return transferer;
-    }
-
-    public String getDefaultUnicodeEncoding() {
-        return "iso-10646-ucs-2";
-    }
-
-    public boolean isLocaleDependentTextFormat(long format) {
-        return false;
-    }
-
-    public boolean isTextFormat(long format) {
-        return super.isTextFormat(format)
-            || isMimeFormat(format, "text");
-    }
-
-    protected String getCharsetForTextFormat(Long lFormat) {
-        long format = lFormat.longValue();
-        if (isMimeFormat(format, "text")) {
-            String nat = getNativeForFormat(format);
-            DataFlavor df = new DataFlavor(nat, null);
-            // Ignore the charset parameter of the MIME type if the subtype
-            // doesn't support charset.
-            if (!DataTransferer.doesSubtypeSupportCharset(df)) {
-                return null;
-            }
-            String charset = df.getParameter("charset");
-            if (charset != null) {
-                return charset;
-            }
-        }
-        return super.getCharsetForTextFormat(lFormat);
-    }
-
-    public boolean isFileFormat(long format) {
-        return format == FILE_NAME_ATOM || format == DT_NET_FILE_ATOM;
-    }
-
-    public boolean isImageFormat(long format) {
-        return format == PNG_ATOM || format == JFIF_ATOM
-            || isMimeFormat(format, "image");
-    }
-
-    protected Long getFormatForNativeAsLong(String str) {
-        // Just get the atom. If it has already been retrived
-        // once, we'll get a copy so this should be very fast.
-        long atom = getAtomForTarget(str);
-        if (atom <= 0) {
-            throw new InternalError("Cannot register a target");
-        }
-        return Long.valueOf(atom);
-    }
-
-    protected String getNativeForFormat(long format) {
-        return getTargetNameForAtom(format);
-    }
-
-    public ToolkitThreadBlockedHandler getToolkitThreadBlockedHandler() {
-        return MToolkitThreadBlockedHandler.getToolkitThreadBlockedHandler();
-    }
-
-    /**
-     * Gets an atom for a format name.
-     */
-    static native long getAtomForTarget(String name);
-
-    /**
-     * Gets an format name for a given format (atom)
-     */
-    private static native String getTargetNameForAtom(long atom);
-
-    protected byte[] imageToPlatformBytes(Image image, long format)
-      throws IOException {
-        String mimeType = null;
-        if (format == PNG_ATOM) {
-            mimeType = "image/png";
-        } else if (format == JFIF_ATOM) {
-            mimeType = "image/jpeg";
-        } else {
-            // Check if an image MIME format.
-            try {
-                String nat = getNativeForFormat(format);
-                DataFlavor df = new DataFlavor(nat);
-                String primaryType = df.getPrimaryType();
-                if ("image".equals(primaryType)) {
-                    mimeType = df.getPrimaryType() + "/" + df.getSubType();
-                }
-            } catch (Exception e) {
-                // Not an image MIME format.
-            }
-        }
-        if (mimeType != null) {
-            return imageToStandardBytes(image, mimeType);
-        } else {
-            String nativeFormat = getNativeForFormat(format);
-            throw new IOException("Translation to " + nativeFormat +
-                                  " is not supported.");
-        }
-    }
-
-    /**
-     * Translates either a byte array or an input stream which contain
-     * platform-specific image data in the given format into an Image.
-     */
-    protected Image platformImageBytesOrStreamToImage(InputStream inputStream,
-                                                      byte[] bytes,
-                                                      long format)
-      throws IOException {
-        String mimeType = null;
-        if (format == PNG_ATOM) {
-            mimeType = "image/png";
-        } else if (format == JFIF_ATOM) {
-            mimeType = "image/jpeg";
-        } else {
-            // Check if an image MIME format.
-            try {
-                String nat = getNativeForFormat(format);
-                DataFlavor df = new DataFlavor(nat);
-                String primaryType = df.getPrimaryType();
-                if ("image".equals(primaryType)) {
-                    mimeType = df.getPrimaryType() + "/" + df.getSubType();
-                }
-            } catch (Exception e) {
-                // Not an image MIME format.
-            }
-        }
-        if (mimeType != null) {
-            return standardImageBytesOrStreamToImage(inputStream, bytes, mimeType);
-        } else {
-            String nativeFormat = getNativeForFormat(format);
-            throw new IOException("Translation from " + nativeFormat +
-                                  " is not supported.");
-        }
-    }
-
-    /**
-     * Returns true if and only if the name of the specified format Atom
-     * constitutes a valid MIME type with the specified primary type.
-     */
-    private boolean isMimeFormat(long format, String primaryType) {
-        String nat = getNativeForFormat(format);
-
-        if (nat == null) {
-            return false;
-        }
-
-        try {
-            DataFlavor df = new DataFlavor(nat);
-            if (primaryType.equals(df.getPrimaryType())) {
-                return true;
-            }
-        } catch (Exception e) {
-            // Not a MIME format.
-        }
-
-        return false;
-    }
-
-    /*
-     * The XDnD protocol prescribes that the Atoms used as targets for data
-     * transfer should have string names that represent the corresponding MIME
-     * types.
-     * To meet this requirement we check if the passed native format constitutes
-     * a valid MIME and return a list of flavors to which the data in this MIME
-     * type can be translated by the Data Transfer subsystem.
-     */
-    public List getPlatformMappingsForNative(String nat) {
-        List flavors = new ArrayList();
-
-        if (nat == null) {
-            return flavors;
-        }
-
-        DataFlavor df = null;
-
-        try {
-            df = new DataFlavor(nat);
-        } catch (Exception e) {
-            // The string doesn't constitute a valid MIME type.
-            return flavors;
-        }
-
-        Object value = df;
-        final String primaryType = df.getPrimaryType();
-        final String baseType = primaryType + "/" + df.getSubType();
-
-        // For text formats we map natives to MIME strings instead of data
-        // flavors to enable dynamic text native-to-flavor mapping generation.
-        // See SystemFlavorMap.getFlavorsForNative() for details.
-        if ("text".equals(primaryType)) {
-            value = primaryType + "/" + df.getSubType();
-        } else if ("image".equals(primaryType)) {
-            Iterator readers = ImageIO.getImageReadersByMIMEType(baseType);
-            if (readers.hasNext()) {
-                flavors.add(DataFlavor.imageFlavor);
-            }
-        }
-
-        flavors.add(value);
-
-        return flavors;
-    }
-
-    private static ImageTypeSpecifier defaultSpecifier = null;
-
-    private ImageTypeSpecifier getDefaultImageTypeSpecifier() {
-        if (defaultSpecifier == null) {
-            ColorModel model = ColorModel.getRGBdefault();
-            WritableRaster raster =
-                model.createCompatibleWritableRaster(10, 10);
-
-            BufferedImage bufferedImage =
-                new BufferedImage(model, raster, model.isAlphaPremultiplied(),
-                                  null);
-
-            defaultSpecifier = new ImageTypeSpecifier(bufferedImage);
-        }
-
-        return defaultSpecifier;
-    }
-
-    /*
-     * The XDnD protocol prescribes that the Atoms used as targets for data
-     * transfer should have string names that represent the corresponding MIME
-     * types.
-     * To meet this requirement we return a list of formats that represent
-     * MIME types to which the data in this flavor can be translated by the Data
-     * Transfer subsystem.
-     */
-    public List getPlatformMappingsForFlavor(DataFlavor df) {
-        List natives = new ArrayList(1);
-
-        if (df == null) {
-            return natives;
-        }
-
-        String charset = df.getParameter("charset");
-        String baseType = df.getPrimaryType() + "/" + df.getSubType();
-        String mimeType = baseType;
-
-        if (charset != null && DataTransferer.isFlavorCharsetTextType(df)) {
-            mimeType += ";charset=" + charset;
-        }
-
-        // Add a mapping to the MIME native whenever the representation class
-        // doesn't require translation.
-        if (df.getRepresentationClass() != null &&
-            (df.isRepresentationClassInputStream() ||
-             df.isRepresentationClassByteBuffer() ||
-             byteArrayClass.equals(df.getRepresentationClass()))) {
-            natives.add(mimeType);
-        }
-
-        if (DataFlavor.imageFlavor.equals(df)) {
-            String[] mimeTypes = ImageIO.getWriterMIMETypes();
-            if (mimeTypes != null) {
-                for (int i = 0; i < mimeTypes.length; i++) {
-                    Iterator writers =
-                        ImageIO.getImageWritersByMIMEType(mimeTypes[i]);
-
-                    while (writers.hasNext()) {
-                        ImageWriter imageWriter = (ImageWriter)writers.next();
-                        ImageWriterSpi writerSpi =
-                            imageWriter.getOriginatingProvider();
-
-                        if (writerSpi != null &&
-                            writerSpi.canEncodeImage(getDefaultImageTypeSpecifier())) {
-                            natives.add(mimeTypes[i]);
-                            break;
-                        }
-                    }
-                }
-            }
-        } else if (DataTransferer.isFlavorCharsetTextType(df)) {
-            final Iterator iter = DataTransferer.standardEncodings();
-
-            // stringFlavor is semantically equivalent to the standard
-            // "text/plain" MIME type.
-            if (DataFlavor.stringFlavor.equals(df)) {
-                baseType = "text/plain";
-            }
-
-            while (iter.hasNext()) {
-                String encoding = (String)iter.next();
-                if (!encoding.equals(charset)) {
-                    natives.add(baseType + ";charset=" + encoding);
-                }
-            }
-
-            // Add a MIME format without specified charset.
-            if (!natives.contains(baseType)) {
-                natives.add(baseType);
-            }
-        }
-
-        return natives;
-    }
-    protected native String[] dragQueryFile(byte[] bytes);
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MDialogPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MDialogPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MDialogPeer.java	2014-04-08 05:27:04.974897587 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MDialogPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,110 +0,0 @@
-/*
- * Copyright (c) 1995, 2007, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.util.Vector;
-import java.awt.*;
-import java.awt.peer.*;
-import java.awt.event.*;
-import sun.awt.motif.MInputMethodControl;
-import sun.awt.im.*;
-
-class MDialogPeer extends MWindowPeer implements DialogPeer, MInputMethodControl {
-
-    static Vector allDialogs = new Vector();
-
-    MDialogPeer(Dialog target) {
-
-        /* create MWindowPeer object */
-        super();
-
-        winAttr.nativeDecor = !target.isUndecorated();
-        winAttr.initialFocus = true;
-        winAttr.isResizable =  target.isResizable();
-        winAttr.initialState = MWindowAttributes.NORMAL;
-        winAttr.title = target.getTitle();
-        winAttr.icon = null;
-        if (winAttr.nativeDecor) {
-            winAttr.decorations = winAttr.AWT_DECOR_ALL |
-                                  winAttr.AWT_DECOR_MINIMIZE |
-                                  winAttr.AWT_DECOR_MAXIMIZE;
-        } else {
-            winAttr.decorations = winAttr.AWT_DECOR_NONE;
-        }
-        /* create and init native component */
-        init(target);
-        allDialogs.addElement(this);
-    }
-
-    public void setTitle(String title) {
-        pSetTitle(title);
-    }
-
-    protected void disposeImpl() {
-        allDialogs.removeElement(this);
-        super.disposeImpl();
-    }
-
-    // NOTE: This method is called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleMoved(int x, int y) {
-        postEvent(new ComponentEvent(target, ComponentEvent.COMPONENT_MOVED));
-    }
-
-    public void show() {
-        pShowModal( ((Dialog)target).isModal() );
-        updateAlwaysOnTop(alwaysOnTop);
-    }
-
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleIconify() {
-// Note: These routines are necessary for Coaleseing of native implementations
-//       As Dialogs do not currently send Iconify/DeIconify messages but
-//       Windows/Frames do.  If this should be made consistent...to do so
-//       uncomment the postEvent.
-//       postEvent(new WindowEvent((Window)target, WindowEvent.WINDOW_ICONIFIED));
-    }
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleDeiconify() {
-// Note: These routines are necessary for Coaleseing of native implementations
-//       As Dialogs do not currently send Iconify/DeIconify messages but
-//       Windows/Frames do. If this should be made consistent...to do so
-//       uncomment the postEvent.
-//       postEvent(new WindowEvent((Window)target, WindowEvent.WINDOW_DEICONIFIED));
-    }
-
-    public void blockWindows(java.util.List<Window> toBlock) {
-        // do nothing
-    }
-
-    @Override
-    final boolean isTargetUndecorated() {
-        return ((Dialog)target).isUndecorated();
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MDragSourceContextPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MDragSourceContextPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MDragSourceContextPeer.java	2014-04-08 05:27:04.974897587 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MDragSourceContextPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,120 +0,0 @@
-/*
- * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.Component;
-import java.awt.Cursor;
-import java.awt.Image;
-import java.awt.Point;
-
-import java.awt.datatransfer.Transferable;
-
-import java.awt.dnd.DragSourceContext;
-import java.awt.dnd.DragGestureEvent;
-import java.awt.dnd.InvalidDnDOperationException;
-
-import java.awt.event.InputEvent;
-
-import java.awt.peer.ComponentPeer;
-import java.awt.peer.LightweightPeer;
-
-import java.util.Map;
-import sun.awt.SunToolkit;
-import sun.awt.dnd.SunDragSourceContextPeer;
-
-/**
- * <p>
- * TBC
- * </p>
- *
- * @since JDK1.2
- *
- */
-
-final class MDragSourceContextPeer extends SunDragSourceContextPeer {
-
-    private static final MDragSourceContextPeer theInstance =
-        new MDragSourceContextPeer(null);
-
-    /**
-     * construct a new MDragSourceContextPeer
-     */
-
-    private MDragSourceContextPeer(DragGestureEvent dge) {
-        super(dge);
-    }
-
-    static MDragSourceContextPeer createDragSourceContextPeer(DragGestureEvent dge) throws InvalidDnDOperationException {
-        theInstance.setTrigger(dge);
-        return theInstance;
-    }
-
-    protected void startDrag(Transferable transferable,
-                             long[] formats, Map formatMap) {
-        try {
-            long nativeCtxtLocal = startDrag(getTrigger().getComponent(),
-                                             transferable,
-                                             getTrigger().getTriggerEvent(),
-                                             getCursor(),
-                                             getCursor() == null ? 0 : getCursor().getType(),
-                                             getDragSourceContext().getSourceActions(),
-                                             formats,
-                                             formatMap);
-            setNativeContext(nativeCtxtLocal);
-        } catch (Exception e) {
-            throw new InvalidDnDOperationException("failed to create native peer: " + e);
-        }
-
-        if (getNativeContext() == 0) {
-            throw new InvalidDnDOperationException("failed to create native peer");
-        }
-
-        MDropTargetContextPeer.setCurrentJVMLocalSourceTransferable(transferable);
-    }
-
-    /**
-     * downcall into native code
-     */
-
-    private native long startDrag(Component component,
-                                  Transferable transferable,
-                                  InputEvent nativeTrigger,
-                                  Cursor c, int ctype, int actions,
-                                  long[] formats, Map formatMap);
-
-    /**
-     * set cursor
-     */
-
-    public void setCursor(Cursor c) throws InvalidDnDOperationException {
-        SunToolkit.awtLock();
-        super.setCursor(c);
-        SunToolkit.awtUnlock();
-    }
-
-    protected native void setNativeCursor(long nativeCtxt, Cursor c, int cType);
-
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MDropTargetContextPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MDropTargetContextPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MDropTargetContextPeer.java	2014-04-08 05:27:04.978897645 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MDropTargetContextPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,147 +0,0 @@
-/*
- * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.datatransfer.DataFlavor;
-import java.awt.datatransfer.UnsupportedFlavorException;
-
-import java.awt.dnd.DnDConstants;
-import java.awt.dnd.InvalidDnDOperationException;
-
-import java.io.InputStream;
-
-import java.util.Map;
-
-import java.io.IOException;
-import sun.awt.dnd.SunDropTargetContextPeer;
-import sun.awt.SunToolkit;
-
-/**
- * <p>
- * The MDropTargetContextPeer class is the class responsible for handling
- * the interaction between the Motif DnD system and Java.
- * </p>
- *
- * @since JDK1.2
- *
- */
-
-final class MDropTargetContextPeer extends SunDropTargetContextPeer {
-
-    private long              nativeDropTransfer;
-
-    long                      nativeDataAvailable = 0;
-    Object                    nativeData          = null;
-
-    /**
-     * create the peer
-     */
-
-    static MDropTargetContextPeer createMDropTargetContextPeer() {
-        return new MDropTargetContextPeer();
-    }
-
-    /**
-     * create the peer
-     */
-
-    private MDropTargetContextPeer() {
-        super();
-    }
-
-    protected Object getNativeData(long format) {
-        SunToolkit.awtLock();
-        if (nativeDropTransfer == 0) {
-            nativeDropTransfer = startTransfer(getNativeDragContext(),
-                                               format);
-        } else {
-            addTransfer (nativeDropTransfer, format);
-        }
-
-        for (nativeDataAvailable = 0;
-             format != nativeDataAvailable;) {
-            try {
-                SunToolkit.awtLockWait();
-            } catch (Throwable e) {
-                e.printStackTrace();
-            }
-        }
-        SunToolkit.awtUnlock();
-
-        return nativeData;
-    }
-
-    /**
-     * signal drop complete
-     */
-
-    protected void doDropDone(boolean success, int dropAction,
-                              boolean isLocal) {
-        dropDone(getNativeDragContext(), nativeDropTransfer, isLocal,
-                 success, dropAction);
-    }
-
-    /**
-     * notify transfer complete
-     */
-
-    private void newData(long format, String type, byte[] data) {
-        nativeDataAvailable = format;
-        nativeData          = data;
-
-        SunToolkit.awtLockNotifyAll();
-    }
-
-    /**
-     * notify transfer failed
-     */
-
-    private void transferFailed(long format) {
-        nativeDataAvailable = format;
-        nativeData          = null;
-
-        SunToolkit.awtLockNotifyAll();
-    }
-
-    /**
-     * schedule a native DnD transfer
-     */
-
-    private native long startTransfer(long nativeDragContext, long format);
-
-    /**
-     * schedule a native DnD data transfer
-     */
-
-    private native void addTransfer(long nativeDropTransfer, long format);
-
-    /**
-     * signal that drop is completed
-     */
-
-    private native void dropDone(long nativeDragContext, long nativeDropTransfer,
-                                 boolean localTx, boolean success, int dropAction);
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MEmbedCanvasPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MEmbedCanvasPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MEmbedCanvasPeer.java	2014-04-08 05:27:04.978897645 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MEmbedCanvasPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,584 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.dnd.DropTarget;
-import java.awt.dnd.DropTargetListener;
-import java.awt.event.*;
-import java.awt.image.ColorModel;
-import java.awt.image.ImageObserver;
-import java.awt.image.ImageProducer;
-import java.awt.image.VolatileImage;
-import java.awt.peer.*;
-import sun.awt.*;
-import sun.awt.motif.X11FontMetrics;
-import java.lang.reflect.*;
-import java.util.logging.*;
-import java.util.*;
-
-// FIXME: Add X errors handling
-// FIXME: Add chaining of parameters to XEmbed-client if we are both(accelerators; XDND; focus already automatically)
-public class MEmbedCanvasPeer extends MCanvasPeer implements WindowFocusListener, KeyEventPostProcessor, ModalityListener, WindowIDProvider {
-    private static final Logger xembedLog = Logger.getLogger("sun.awt.motif.xembed.MEmbedCanvasPeer");
-
-    final static int XEMBED_VERSION = 0,
-        XEMBED_MAPPED = (1 << 0);
-/* XEMBED messages */
-    final static int XEMBED_EMBEDDED_NOTIFY     =       0;
-    final static int XEMBED_WINDOW_ACTIVATE  =  1;
-    final static int XEMBED_WINDOW_DEACTIVATE =         2;
-    final static int XEMBED_REQUEST_FOCUS               =3;
-    final static int XEMBED_FOCUS_IN    =       4;
-    final static int XEMBED_FOCUS_OUT   =       5;
-    final static int XEMBED_FOCUS_NEXT  =       6;
-    final static int XEMBED_FOCUS_PREV  =       7;
-/* 8-9 were used for XEMBED_GRAB_KEY/XEMBED_UNGRAB_KEY */
-    final static int XEMBED_GRAB_KEY = 8;
-    final static int XEMBED_UNGRAB_KEY = 9;
-    final static int XEMBED_MODALITY_ON         =       10;
-    final static int XEMBED_MODALITY_OFF        =       11;
-    final static int XEMBED_REGISTER_ACCELERATOR =    12;
-    final static int XEMBED_UNREGISTER_ACCELERATOR=   13;
-    final static int XEMBED_ACTIVATE_ACCELERATOR  =   14;
-
-    final static int NON_STANDARD_XEMBED_GTK_GRAB_KEY = 108;
-    final static int NON_STANDARD_XEMBED_GTK_UNGRAB_KEY = 109;
-
-//     A detail code is required for XEMBED_FOCUS_IN. The following values are valid:
-/* Details for  XEMBED_FOCUS_IN: */
-    final static int XEMBED_FOCUS_CURRENT       =       0;
-    final static int XEMBED_FOCUS_FIRST         =       1;
-    final static int XEMBED_FOCUS_LAST  =       2;
-
-// Modifiers bits
-    final static int XEMBED_MODIFIER_SHIFT   = (1 << 0);
-    final static int XEMBED_MODIFIER_CONTROL = (1 << 1);
-    final static int XEMBED_MODIFIER_ALT     = (1 << 2);
-    final static int XEMBED_MODIFIER_SUPER   = (1 << 3);
-    final static int XEMBED_MODIFIER_HYPER   = (1 << 4);
-
-    boolean applicationActive; // Whether the application is active(has focus)
-    Map<Long, AWTKeyStroke> accelerators = new HashMap<Long, AWTKeyStroke>(); // Maps accelerator ID into AWTKeyStroke
-    Map<AWTKeyStroke, Long> accel_lookup = new HashMap<AWTKeyStroke, Long>(); // Maps AWTKeyStroke into accelerator ID
-    Set<GrabbedKey> grabbed_keys = new HashSet<GrabbedKey>(); // A set of keys grabbed by client
-    Object ACCEL_LOCK = accelerators; // Lock object for working with accelerators;
-    Object GRAB_LOCK = grabbed_keys; // Lock object for working with keys grabbed by client
-
-    MEmbedCanvasPeer() {}
-
-    MEmbedCanvasPeer(Component target) {
-        super(target);
-    }
-
-    void initialize() {
-        super.initialize();
-
-        installActivateListener();
-        installAcceleratorListener();
-        installModalityListener();
-
-        // XEmbed canvas should be non-traversable.
-        // FIXME: Probably should be removed and enforced setting of it by the users
-        target.setFocusTraversalKeysEnabled(false);
-
-        initXEmbedServer();
-    }
-
-    void installModalityListener() {
-        ((SunToolkit)Toolkit.getDefaultToolkit()).addModalityListener(this);
-    }
-
-    void deinstallModalityListener() {
-        ((SunToolkit)Toolkit.getDefaultToolkit()).removeModalityListener(this);
-    }
-
-    void installAcceleratorListener() {
-        KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventPostProcessor(this);
-    }
-
-    void deinstallAcceleratorListener() {
-        KeyboardFocusManager.getCurrentKeyboardFocusManager().removeKeyEventPostProcessor(this);
-    }
-
-    void installActivateListener() {
-        // FIXME: should watch for hierarchy changes
-        Window toplevel = getTopLevel(target);
-        if (toplevel != null) {
-            toplevel.addWindowFocusListener(this);
-            applicationActive = toplevel.isFocused();
-        }
-    }
-
-    void deinstallActivateListener() {
-        Window toplevel = getTopLevel(target);
-        if (toplevel != null) {
-            toplevel.removeWindowFocusListener(this);
-        }
-    }
-
-    native boolean isXEmbedActive();
-
-    boolean isApplicationActive() {
-        return applicationActive;
-    }
-
-    native void initDispatching();
-
-    native void endDispatching();
-
-    native void embedChild(long child);
-
-    native void childDestroyed();
-
-    public void handleEvent(AWTEvent e) {
-        super.handleEvent(e);
-        if (isXEmbedActive()) {
-            switch (e.getID()) {
-              case FocusEvent.FOCUS_GAINED:
-                  canvasFocusGained((FocusEvent)e);
-                  break;
-              case FocusEvent.FOCUS_LOST:
-                  canvasFocusLost((FocusEvent)e);
-                  break;
-              case KeyEvent.KEY_PRESSED:
-              case KeyEvent.KEY_RELEASED:
-                  if (!((InputEvent)e).isConsumed()) {
-                      forwardKeyEvent((KeyEvent)e);
-                  }
-                  break;
-            }
-        }
-    }
-
-    public Dimension getPreferredSize() {
-        if (isXEmbedActive()) {
-            Dimension dim = getEmbedPreferredSize();
-            if (dim == null) {
-                return super.getPreferredSize();
-            } else {
-                return dim;
-            }
-        } else {
-            return super.getPreferredSize();
-        }
-    }
-    native Dimension getEmbedPreferredSize();
-    public Dimension getMinimumSize() {
-        if (isXEmbedActive()) {
-            Dimension dim = getEmbedMinimumSize();
-            if (dim == null) {
-                return super.getMinimumSize();
-            } else {
-                return dim;
-            }
-        } else {
-            return super.getMinimumSize();
-        }
-    }
-    native Dimension getEmbedMinimumSize();
-    protected void disposeImpl() {
-        if (isXEmbedActive()) {
-            detachChild();
-        }
-        deinstallActivateListener();
-        deinstallModalityListener();
-        deinstallAcceleratorListener();
-
-        destroyXEmbedServer();
-        super.disposeImpl();
-    }
-
-    public boolean isFocusable() {
-        return true;
-    }
-
-    Window getTopLevel(Component comp) {
-        while (comp != null && !(comp instanceof Window)) {
-            comp = comp.getParent();
-        }
-        return (Window)comp;
-    }
-
-    native Rectangle getClientBounds();
-
-    void childResized() {
-        if (xembedLog.isLoggable(Level.FINER)) {
-            Rectangle bounds = getClientBounds();
-            xembedLog.finer("Child resized: " + bounds);
-            // It is not required to update embedder's size when client size changes
-            // However, since there is no any means to get client size it seems to be the
-            // only way to provide it. However, it contradicts with Java layout concept -
-            // so it is disabled for now.
-//             Rectangle my_bounds = getBounds();
-//             setBounds(my_bounds.x, my_bounds.y, bounds.width, bounds.height, SET_BOUNDS);
-        }
-        postEvent(new ComponentEvent(target, ComponentEvent.COMPONENT_RESIZED));
-    }
-
-    void focusNext() {
-        if (isXEmbedActive()) {
-            xembedLog.fine("Requesting focus for the next component after embedder");
-            postEvent(new InvocationEvent(target, new Runnable() {
-                    public void run() {
-                        KeyboardFocusManager.getCurrentKeyboardFocusManager().focusNextComponent(target);
-                    }
-                }));
-        } else {
-            xembedLog.fine("Application is not active - denying focus next");
-        }
-    }
-
-    void focusPrev() {
-        if (isXEmbedActive()) {
-            xembedLog.fine("Requesting focus for the next component after embedder");
-            postEvent(new InvocationEvent(target, new Runnable() {
-                    public void run() {
-                        KeyboardFocusManager.getCurrentKeyboardFocusManager().focusPreviousComponent(target);
-                    }
-                }));
-        } else {
-            xembedLog.fine("Application is not active - denying focus prev");
-        }
-    }
-
-    void requestXEmbedFocus() {
-        if (isXEmbedActive()) {
-            xembedLog.fine("Requesting focus for client");
-            postEvent(new InvocationEvent(target, new Runnable() {
-                    public void run() {
-                        target.requestFocusInWindow();
-                    }
-                }));
-        } else {
-            xembedLog.fine("Application is not active - denying request focus");
-        }
-    }
-
-    native void notifyChildEmbedded();
-
-    native void detachChild();
-
-    public void windowGainedFocus(WindowEvent e) {
-        applicationActive = true;
-        if (isXEmbedActive()) {
-            xembedLog.fine("Sending WINDOW_ACTIVATE");
-            sendMessage(XEMBED_WINDOW_ACTIVATE);
-        }
-    }
-
-    public void windowLostFocus(WindowEvent e) {
-        applicationActive = false;
-        if (isXEmbedActive()) {
-            xembedLog.fine("Sending WINDOW_DEACTIVATE");
-            sendMessage(XEMBED_WINDOW_DEACTIVATE);
-        }
-    }
-
-    void canvasFocusGained(FocusEvent e) {
-        if (isXEmbedActive()) {
-            xembedLog.fine("Forwarding FOCUS_GAINED");
-            int flavor = XEMBED_FOCUS_CURRENT;
-            if (e instanceof CausedFocusEvent) {
-                CausedFocusEvent ce = (CausedFocusEvent)e;
-                if (ce.getCause() == CausedFocusEvent.Cause.TRAVERSAL_FORWARD) {
-                    flavor = XEMBED_FOCUS_FIRST;
-                } else if (ce.getCause() == CausedFocusEvent.Cause.TRAVERSAL_BACKWARD) {
-                    flavor = XEMBED_FOCUS_LAST;
-                }
-            }
-            sendMessage(XEMBED_FOCUS_IN, flavor, 0, 0);
-        }
-    }
-
-    void canvasFocusLost(FocusEvent e) {
-        if (isXEmbedActive() && !e.isTemporary()) {
-            xembedLog.fine("Forwarding FOCUS_LOST");
-            Component opp = e.getOppositeComponent();
-            int num = 0;
-            try {
-                num = Integer.parseInt(opp.getName());
-            } catch (NumberFormatException nfe) {
-            }
-            sendMessage(XEMBED_FOCUS_OUT, num, 0, 0);
-        }
-    }
-
-    native void forwardKeyEvent(KeyEvent e);
-
-    void grabKey(final long keysym, final long modifiers) {
-        postEvent(new InvocationEvent(target, new Runnable() {
-                public void run() {
-                    GrabbedKey grab = new GrabbedKey(keysym, modifiers);
-                    if (xembedLog.isLoggable(Level.FINE)) xembedLog.fine("Grabbing key: " + grab);
-                    synchronized(GRAB_LOCK) {
-                        grabbed_keys.add(grab);
-                    }
-                }
-            }));
-    }
-
-    void ungrabKey(final long keysym, final long modifiers) {
-        postEvent(new InvocationEvent(target, new Runnable() {
-                public void run() {
-                    GrabbedKey grab = new GrabbedKey(keysym, modifiers);
-                    if (xembedLog.isLoggable(Level.FINE)) xembedLog.fine("UnGrabbing key: " + grab);
-                    synchronized(GRAB_LOCK) {
-                        grabbed_keys.remove(grab);
-                    }
-                }
-            }));
-    }
-
-    void registerAccelerator(final long accel_id, final long keysym, final long modifiers) {
-        postEvent(new InvocationEvent(target, new Runnable() {
-                public void run() {
-                    AWTKeyStroke stroke = getKeyStrokeForKeySym(keysym, modifiers);
-                    if (stroke != null) {
-                        if (xembedLog.isLoggable(Level.FINE)) xembedLog.fine("Registering accelerator " + accel_id + " for " + stroke);
-                        synchronized(ACCEL_LOCK) {
-                            accelerators.put(accel_id, stroke);
-                            accel_lookup.put(stroke, accel_id);
-                        }
-                    }
-                    // Propogate accelerators to the another embedder
-                    propogateRegisterAccelerator(stroke);
-                }
-            }));
-    }
-
-    void unregisterAccelerator(final long accel_id) {
-        postEvent(new InvocationEvent(target, new Runnable() {
-                public void run() {
-                    AWTKeyStroke stroke = null;
-                    synchronized(ACCEL_LOCK) {
-                        stroke = accelerators.get(accel_id);
-                        if (stroke != null) {
-                            if (xembedLog.isLoggable(Level.FINE)) xembedLog.fine("Unregistering accelerator: " + accel_id);
-                            accelerators.remove(accel_id);
-                            accel_lookup.remove(stroke); // FIXME: How about several accelerators with the same stroke?
-                        }
-                    }
-                    // Propogate accelerators to the another embedder
-                    propogateUnRegisterAccelerator(stroke);
-                }
-            }));
-    }
-
-    void propogateRegisterAccelerator(AWTKeyStroke stroke) {
-        // Find the top-level and see if it is XEmbed client. If so, ask him to
-        // register the accelerator
-        MWindowPeer parent = getParentWindow();
-        if (parent != null && parent instanceof MEmbeddedFramePeer) {
-            MEmbeddedFramePeer embedded = (MEmbeddedFramePeer)parent;
-            embedded.registerAccelerator(stroke);
-        }
-    }
-
-    void propogateUnRegisterAccelerator(AWTKeyStroke stroke) {
-        // Find the top-level and see if it is XEmbed client. If so, ask him to
-        // register the accelerator
-        MWindowPeer parent = getParentWindow();
-        if (parent != null && parent instanceof MEmbeddedFramePeer) {
-            MEmbeddedFramePeer embedded = (MEmbeddedFramePeer)parent;
-            embedded.unregisterAccelerator(stroke);
-        }
-    }
-
-    public boolean postProcessKeyEvent(KeyEvent e) {
-        // Processing events only if we are in the focused window.
-        MWindowPeer parent = getParentWindow();
-        if (parent == null || !((Window)parent.target).isFocused() || target.isFocusOwner()) {
-            return false;
-        }
-
-        boolean result = false;
-
-        if (xembedLog.isLoggable(Level.FINER)) xembedLog.finer("Post-processing event " + e);
-
-        // Process ACCELERATORS
-        AWTKeyStroke stroke = AWTKeyStroke.getAWTKeyStrokeForEvent(e);
-        long accel_id = 0;
-        boolean exists = false;
-        synchronized(ACCEL_LOCK) {
-            exists = accel_lookup.containsKey(stroke);
-            if (exists) {
-                accel_id = accel_lookup.get(stroke).longValue();
-            }
-        }
-        if (exists) {
-            if (xembedLog.isLoggable(Level.FINE)) xembedLog.fine("Activating accelerator " + accel_id);
-            sendMessage(XEMBED_ACTIVATE_ACCELERATOR, accel_id, 0, 0); // FIXME: How about overloaded?
-            result = true;
-        }
-
-        // Process Grabs, unofficial GTK feature
-        exists = false;
-        GrabbedKey key = new GrabbedKey(e);
-        synchronized(GRAB_LOCK) {
-            exists = grabbed_keys.contains(key);
-        }
-        if (exists) {
-            if (xembedLog.isLoggable(Level.FINE)) xembedLog.fine("Forwarding grabbed key " + e);
-            forwardKeyEvent(e);
-            result = true;
-        }
-
-        return result;
-    }
-
-    public void modalityPushed(ModalityEvent ev) {
-        sendMessage(XEMBED_MODALITY_ON);
-    }
-
-    public void modalityPopped(ModalityEvent ev) {
-        sendMessage(XEMBED_MODALITY_OFF);
-    }
-
-    int getModifiers(int state) {
-        int mods = 0;
-        if ((state & XEMBED_MODIFIER_SHIFT) != 0) {
-            mods |= InputEvent.SHIFT_DOWN_MASK;
-        }
-        if ((state & XEMBED_MODIFIER_CONTROL) != 0) {
-            mods |= InputEvent.CTRL_DOWN_MASK;
-        }
-        if ((state & XEMBED_MODIFIER_ALT) != 0) {
-            mods |= InputEvent.ALT_DOWN_MASK;
-        }
-        // FIXME: What is super/hyper?
-        // FIXME: Experiments show that SUPER is ALT. So what is Alt then?
-        if ((state & XEMBED_MODIFIER_SUPER) != 0) {
-            mods |= InputEvent.ALT_DOWN_MASK;
-        }
-//         if ((state & XEMBED_MODIFIER_HYPER) != 0) {
-//             mods |= InputEvent.DOWN_MASK;
-//         }
-        return mods;
-    }
-
-    // Shouldn't be called on Toolkit thread.
-    AWTKeyStroke getKeyStrokeForKeySym(long keysym, long state) {
-
-        int keycode = getAWTKeyCodeForKeySym((int)keysym);
-        int modifiers = getModifiers((int)state);
-        return AWTKeyStroke.getAWTKeyStroke(keycode, modifiers);
-    }
-    native int getAWTKeyCodeForKeySym(int keysym);
-    native void sendMessage(int msg);
-    native void sendMessage(int msg, long detail, long data1, long data2);
-    MWindowPeer getParentWindow() {
-        Component parent = target.getParent();
-        synchronized(target.getTreeLock()) {
-            while (parent != null && !(parent.getPeer() instanceof MWindowPeer)) {
-                parent = parent.getParent();
-            }
-            return (parent != null)?(MWindowPeer)parent.getPeer():null;
-        }
-    }
-
-    private static class XEmbedDropTarget extends DropTarget {
-        public void addDropTargetListener(DropTargetListener dtl)
-          throws TooManyListenersException {
-            // Drop target listeners registered with this target will never be
-            // notified, since all drag notifications are routed to the XEmbed
-            // client. To avoid confusion we prohibit listeners registration
-            // by throwing TooManyListenersException as if there is a listener
-            // registered with this target already.
-            throw new TooManyListenersException();
-        }
-    }
-
-    public void setXEmbedDropTarget() {
-        // Register a drop site on the top level.
-        Runnable r = new Runnable() {
-                public void run() {
-                    target.setDropTarget(new XEmbedDropTarget());
-                }
-            };
-        SunToolkit.executeOnEventHandlerThread(target, r);
-    }
-
-    public void removeXEmbedDropTarget() {
-        // Unregister a drop site on the top level.
-        Runnable r = new Runnable() {
-                public void run() {
-                    if (target.getDropTarget() instanceof XEmbedDropTarget) {
-                        target.setDropTarget(null);
-                    }
-                }
-            };
-        SunToolkit.executeOnEventHandlerThread(target, r);
-    }
-
-    public boolean processXEmbedDnDEvent(long ctxt, int eventID) {
-        if (target.getDropTarget() instanceof XEmbedDropTarget) {
-            forwardEventToEmbedded(ctxt, eventID);
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    native void forwardEventToEmbedded(long ctxt, int eventID);
-    native void initXEmbedServer();
-    native void destroyXEmbedServer();
-    public native long getWindow();
-}
-class GrabbedKey {
-    long keysym;
-    long modifiers;
-    GrabbedKey(long keysym, long modifiers) {
-        this.keysym = keysym;
-        this.modifiers = modifiers;
-    }
-
-    GrabbedKey(KeyEvent ev) {
-        init(ev);
-    }
-
-    native void initKeySymAndModifiers(KeyEvent e);
-
-    private void init(KeyEvent e) {
-        initKeySymAndModifiers(e);
-    }
-
-    public int hashCode() {
-        return (int)keysym & 0xFFFFFFFF;
-    }
-
-    public boolean equals(Object o) {
-        if (!(o instanceof GrabbedKey)) {
-            return false;
-        }
-        GrabbedKey key = (GrabbedKey)o;
-        return (keysym == key.keysym && modifiers == key.modifiers);
-    }
-
-    public String toString() {
-        return "Key combination[keysym=" + keysym + ", mods=" + modifiers + "]";
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MEmbeddedFrame.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MEmbeddedFrame.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MEmbeddedFrame.java	2014-04-08 05:27:04.978897645 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MEmbeddedFrame.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-/*
- * Copyright (c) 1996, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.Component;
-import java.awt.peer.FramePeer;
-import sun.awt.EmbeddedFrame;
-import java.awt.peer.ComponentPeer;
-import sun.awt.*;
-import java.awt.*;
-
-public class MEmbeddedFrame extends EmbeddedFrame {
-
-    /**
-     * Widget id of the shell widget
-     */
-    long handle;
-
-    public enum IDKind {
-        WIDGET,
-        WINDOW
-    };
-
-    public MEmbeddedFrame() {
-    }
-
-    /**
-     * Backward-compatible implementation. This constructor takes widget which represents Frame's
-     * shell and uses it as top-level to build hierarchy of top-level widgets upon. It assumes that
-     * no XEmbed support is provided.
-     * @param widget a valid Xt widget pointer.
-     */
-    public MEmbeddedFrame(long widget) {
-        this(widget, IDKind.WIDGET, false);
-    }
-
-    /**
-     * New constructor, gets X Window id and allows to specify whether XEmbed is supported by parent
-     * X window. Creates hierarchy of top-level widgets under supplied window ID.
-     * @param winid a valid X window
-     * @param supportsXEmbed whether the host application supports XEMBED protocol
-     */
-    public MEmbeddedFrame(long winid, boolean supportsXEmbed) {
-        this(winid, IDKind.WINDOW, supportsXEmbed);
-    }
-
-    /**
-     * Creates embedded frame using ID as parent.
-     * @param ID parent ID
-     * @param supportsXEmbed whether the host application supports XEMBED protocol
-     * @param kind if WIDGET, ID represents a valid Xt widget pointer; if WINDOW, ID is a valid X Window
-     * ID
-     */
-    public MEmbeddedFrame(long ID, IDKind kind, boolean supportsXEmbed) {
-        super(supportsXEmbed);
-        if (kind == IDKind.WIDGET) {
-            this.handle = ID;
-        } else {
-            this.handle = getWidget(ID);
-        }
-        MToolkit toolkit = (MToolkit)Toolkit.getDefaultToolkit();
-        setPeer(toolkit.createEmbeddedFrame(this));
-        /*
-         * addNotify() creates a LightweightDispatcher that propagates
-         * SunDropTargetEvents to subcomponents.
-         * NOTE: show() doesn't call addNotify() for embedded frames.
-         */
-        addNotify();
-        show();
-    }
-
-    public void synthesizeWindowActivation(boolean b) {
-        MEmbeddedFramePeer peer = (MEmbeddedFramePeer)getPeer();
-        if (peer != null) {
-            if (peer.supportsXEmbed()) {
-                if (peer.isXEmbedActive()) {
-                    // If XEmbed is active no synthetic focus events are allowed - everything
-                    // should go through XEmbed
-                    if (b) {
-                        peer.requestXEmbedFocus();
-                    }
-                }
-            } else {
-                peer.synthesizeFocusInOut(b);
-            }
-        }
-    }
-
-    public void show() {
-        if (handle != 0) {
-            mapWidget(handle);
-        }
-        super.show();
-    }
-
-    protected boolean traverseOut(boolean direction) {
-        MEmbeddedFramePeer xefp = (MEmbeddedFramePeer) getPeer();
-        xefp.traverseOut(direction);
-        return true;
-    }
-
-    // Native methods to handle widget <-> X Windows mapping
-    //
-    static native long getWidget(long winid);
-    static native int mapWidget(long widget);
-    public void registerAccelerator(AWTKeyStroke stroke) {
-        MEmbeddedFramePeer xefp = (MEmbeddedFramePeer) getPeer();
-        if (xefp != null) {
-            xefp.registerAccelerator(stroke);
-        }
-    }
-    public void unregisterAccelerator(AWTKeyStroke stroke) {
-        MEmbeddedFramePeer xefp = (MEmbeddedFramePeer) getPeer();
-        if (xefp != null) {
-            xefp.unregisterAccelerator(stroke);
-        }
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MEmbeddedFramePeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MEmbeddedFramePeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MEmbeddedFramePeer.java	2014-04-08 05:27:04.978897645 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MEmbeddedFramePeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,213 +0,0 @@
-/*
- * Copyright (c) 1996, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import sun.awt.EmbeddedFrame;
-import java.util.logging.*;
-import java.awt.Component;
-import java.awt.Point;
-import java.awt.Rectangle;
-import java.awt.Window;
-import java.awt.AWTKeyStroke;
-import java.awt.Component;
-import java.awt.Container;
-import sun.awt.SunToolkit;
-import java.util.LinkedList;
-import java.util.Iterator;
-
-import sun.java2d.SurfaceData;
-
-public class MEmbeddedFramePeer extends MFramePeer {
-    private static final Logger xembedLog = Logger.getLogger("sun.awt.motif.xembed.MEmbeddedFramePeer");
-
-//     A detail code is required for XEMBED_FOCUS_IN. The following values are valid:
-/* Details for  XEMBED_FOCUS_IN: */
-    final static int XEMBED_FOCUS_CURRENT       =       0;
-    final static int XEMBED_FOCUS_FIRST         =       1;
-    final static int XEMBED_FOCUS_LAST  =       2;
-
-    LinkedList<AWTKeyStroke> strokes = new LinkedList<AWTKeyStroke>();
-
-    public MEmbeddedFramePeer(EmbeddedFrame target) {
-        super(target);
-        xembedLog.fine("Creating XEmbed-enabled motif embedded frame, frame supports XEmbed:" + supportsXEmbed());
-    }
-
-    void create(MComponentPeer parent) {
-        NEFcreate(parent, ((MEmbeddedFrame)target).handle);
-    }
-    native void NEFcreate(MComponentPeer parent, long handle);
-    native void pShowImpl();
-    void pShow() {
-        pShowImpl();
-    }
-
-    boolean supportsXEmbed() {
-        EmbeddedFrame frame = (EmbeddedFrame)target;
-        if (frame != null) {
-            return frame.supportsXEmbed();
-        } else {
-            return false;
-        }
-    }
-
-    public void setVisible(boolean vis) {
-        super.setVisible(vis);
-        xembedLog.fine("Peer made visible");
-        if (vis && !supportsXEmbed()) {
-            xembedLog.fine("Synthesizing FocusIn");
-            // Fix for 4878303 - generate WINDOW_GAINED_FOCUS and update if we were focused
-            // since noone will do it for us(WM does it for regular top-levels)
-            synthesizeFocusInOut(true);
-        }
-    }
-    public native void synthesizeFocusInOut(boolean b);
-
-    native boolean isXEmbedActive();
-    native boolean isXEmbedApplicationActive();
-    native void requestXEmbedFocus();
-
-    public boolean requestWindowFocus() {
-        xembedLog.fine("In requestWindowFocus");
-        // Should check for active state of host application
-        if (isXEmbedActive()) {
-            if (isXEmbedApplicationActive()) {
-                xembedLog.fine("Requesting focus from embedding host");
-                requestXEmbedFocus();
-                return true;
-            } else {
-                xembedLog.fine("Host application is not active");
-                return false;
-            }
-        } else {
-            xembedLog.fine("Requesting focus from X");
-            return super.requestWindowFocus();
-        }
-    }
-
-    void registerAccelerator(AWTKeyStroke stroke) {
-//         if (stroke == null) return;
-//         strokes.add(stroke);
-//         if (isXEmbedActive()) {
-//             nativeRegisterAccelerator(stroke, strokes.size()-1);
-//         }
-    }
-
-    void unregisterAccelerator(AWTKeyStroke stroke) {
-//         if (stroke == null) return;
-//         if (isXEmbedActive()) {
-//             int index = strokes.indexOf(stroke);
-//             nativeUnregisterAccelerator(index);
-//         }
-    }
-
-    void notifyStarted() {
-        // Register accelerators
-//         int i = 0;
-//         Iterator<AWTKeyStroke> iter = strokes.iterator();
-//         while (iter.hasNext()) {
-//             nativeRegisterAccelerator(iter.next(), i++);
-//         }
-
-        updateDropTarget();
-    }
-
-    native void traverseOut(boolean direction);
-
-    void handleFocusIn(int detail) {
-        xembedLog.log(Level.FINE, "handleFocusIn {0}", new Object[]{Integer.valueOf(detail)});
-        switch(detail) {
-          case XEMBED_FOCUS_CURRENT:
-              // Do nothing - just restore to the current value
-              break;
-          case XEMBED_FOCUS_FIRST:
-              SunToolkit.executeOnEventHandlerThread(target, new Runnable() {
-                      public void run() {
-                          Component comp = ((Container)target).getFocusTraversalPolicy().getFirstComponent((Container)target);
-                          if (comp != null) {
-                              comp.requestFocusInWindow();
-                          }
-                      }});
-              break;
-          case XEMBED_FOCUS_LAST:
-              SunToolkit.executeOnEventHandlerThread(target, new Runnable() {
-                      public void run() {
-                          Component comp = ((Container)target).getFocusTraversalPolicy().getLastComponent((Container)target);
-                          if (comp != null) {
-                              comp.requestFocusInWindow();
-                          }
-                      }});
-              break;
-        }
-    }
-    public void handleWindowFocusIn() {
-        super.handleWindowFocusIn();
-        xembedLog.fine("windowFocusIn");
-    }
-    public void handleWindowFocusOut(Window oppositeWindow) {
-        super.handleWindowFocusOut(oppositeWindow);
-        xembedLog.fine("windowFocusOut, opposite is null?:" + (oppositeWindow==null));
-    }
-
-    native void pReshapePrivate(int x, int y, int w, int h);
-
-    public void setBoundsPrivate(int x, int y, int width, int height)
-    {
-        if (disposed)
-        {
-            return;
-        }
-
-        // Should set paintPending before reshape to prevent
-        // thread race between PaintEvent and setBounds
-        // This part of the 4267393 fix proved to be unstable under solaris,
-        // dissabled due to regressions 4418155, 4486762, 4490079
-        paintPending = false; //checkNativePaintOnSetBounds(width, height);
-
-        pReshapePrivate(x, y, width, height);
-
-        if ((width != oldWidth) || (height != oldHeight))
-        {
-            SurfaceData oldData = surfaceData;
-            if (oldData != null) {
-                surfaceData = graphicsConfig.createSurfaceData(this);
-                oldData.invalidate();
-            }
-            oldWidth = width;
-            oldHeight = height;
-        }
-        validateSurface(width, height);
-        serialNum++;
-    }
-
-    public native Rectangle getBoundsPrivate();
-
-    @Override
-    Rectangle constrainBounds(int x, int y, int width, int height) {
-        // We don't constrain the bounds of the EmbeddedFrames
-        return new Rectangle(x, y, width, height);
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MFileDialogPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MFileDialogPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MFileDialogPeer.java	2014-04-08 05:27:04.978897645 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MFileDialogPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,300 +0,0 @@
-/*
- * Copyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import java.io.*;
-import java.awt.datatransfer.*;
-import java.util.ArrayList;
-import sun.awt.datatransfer.ToolkitThreadBlockedHandler;
-
-public class MFileDialogPeer extends MDialogPeer implements FileDialogPeer {
-    private FilenameFilter filter;
-    private String[] NativeFilteredFiles;
-    native void create(MComponentPeer parent);
-    void create(MComponentPeer parent, Object arg) {
-        create(parent);
-    }
-    public MFileDialogPeer(FileDialog target) {
-        super(target);
-        FileDialog      fdialog = (FileDialog)target;
-        String          dir = fdialog.getDirectory();
-        String          file = fdialog.getFile();
-        FilenameFilter  filter = fdialog.getFilenameFilter();
-
-        insets = new Insets(0, 0, 0, 0);
-        setDirectory(dir);
-        if (file != null) {
-            setFile(file);
-        }
-            setFilenameFilter(filter);
-    }
-    native void         pReshape(int x, int y, int width, int height);
-    native void         pDispose();
-    native void         pShow();
-    native void         pHide();
-    native void         setFileEntry(String dir, String file, String[] ffiles);
-    native void insertReplaceFileDialogText(String l);
-    public native void  setFont(Font f);
-
-    String getFilteredFile(String file) {
-        if (file == null) {
-            file = ((FileDialog)target).getFile();
-        }
-        String dir = ((FileDialog)target).getDirectory();
-        if (dir == null) {
-            dir = "./";
-        }
-        if (file == null) {
-            file = "";
-        }
-        if (filter != null && !filter.accept(new File(dir), file)) {
-            file = "";
-        }
-        return file;
-    }
-    // NOTE: This method is called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void         handleSelected(final String file) {
-        final FileDialog fileDialog = (FileDialog)target;
-        MToolkit.executeOnEventHandlerThread(fileDialog, new Runnable() {
-            public void run() {
-                int index = file.lastIndexOf(java.io.File.separatorChar);/*2509*//*ibm*/
-                String dir;
-
-                if (index == -1) {
-                    dir = "."+java.io.File.separator;
-                    fileDialog.setFile(file);
-                } else {
-                    dir = file.substring(0, index + 1);
-                    fileDialog.setFile(file.substring(index + 1));
-                }
-                fileDialog.setDirectory(dir);
-                fileDialog.hide();
-            }
-        });
-    } // handleSelected()
-
-    // NOTE: This method is called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void         handleCancel() {
-        final FileDialog fileDialog = (FileDialog)target;
-        MToolkit.executeOnEventHandlerThread(fileDialog, new Runnable() {
-            public void run() {
-                fileDialog.setFile(null);
-                fileDialog.hide();
-            }
-        });
-    } // handleCancel()
-
-    // NOTE: This method is called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void         handleQuit() {
-        final FileDialog fileDialog = (FileDialog)target;
-        MToolkit.executeOnEventHandlerThread(fileDialog, new Runnable() {
-            public void run() {
-                fileDialog.hide();
-            }
-        });
-    } // handleQuit()
-
-    public  void setDirectory(String dir) {
-        String file = ((FileDialog)target).getFile();
-        setFileEntry((dir != null) ? dir : "./", (file != null) ? file
-                     : "", null);
-    }
-
-
-    public  void setFile(String file) {
-        String dir = ((FileDialog)target).getDirectory();
-        if (dir == null) {
-            dir = "./";
-        }
-        setFileEntry((dir != null) ? dir : "./", getFilteredFile(null), null);
-    }
-    class DirectoryFilter implements FilenameFilter {
-        FilenameFilter userFilter;
-        DirectoryFilter(FilenameFilter userFilter) {
-            this.userFilter = userFilter;
-        }
-        public boolean accept(File parent, String name) {
-            File toTest = new File(parent, name);
-            if (toTest.isDirectory()) {
-                return false;
-            } else if (userFilter != null) {
-                return userFilter.accept(parent, name);
-            } else {
-                return true;
-            }
-        }
-    }
-    public void doFilter(FilenameFilter filter, String dir) {
-        String d = (dir == null) ? (((FileDialog)target).getDirectory()):(dir);
-        String f = getFilteredFile(null);
-        File df = new File((d != null) ? d : ".");
-        String[] files = df.list(new DirectoryFilter(filter));
-        String[] nffiles = NativeFilteredFiles;
-
-        // At this point we have two file lists.
-        // The first one is a filtered list of files that we retrieve
-        // by using Java code and Java filter.
-        // The second one is a filtered list of files that we retrieve
-        // by using the native code and native pattern.
-        // We should find an intersection of these two lists. The result
-        // will be exactly what we expect to see in setFileEntry.
-        // For more details please see 4784704.
-        if ( files != null ) {
-            ArrayList filearr = new ArrayList();
-            if (nffiles != null) {
-                for (int j = 0; j < files.length; j++) {
-                    for (int n = 0; n < nffiles.length; n++) {
-                        if (files[j].equals(nffiles[n])) {
-                            filearr.add(files[j]);
-                            break;
-                        }
-                    }
-                }
-            }
-            files = new String[filearr.size()];
-            for (int i = 0; i < files.length; i++) {
-                files[i] = (String)filearr.get(i);
-            }
-        }
-        if (files == null || files.length == 0) {
-            files = new String[1];
-            files[0] = "";
-        }
-        setFileEntry((d != null) ? d : ".", (f != null) ? f : "", files);
-    }
-    private boolean proceedFiltering(final String dir, String[] nffiles,
-                                     boolean isPrivileged)
-    {
-        // Transfer the native filtered file list to the doFilter method.
-        NativeFilteredFiles = nffiles;
-        // If we are not on the Toolkit thread we can call doFilter() directly.
-        // If the filter is null no user code will be invoked
-        if (!isPrivileged || filter == null) {
-            try {
-                doFilter(filter, dir);
-                return true;
-            } catch(Exception e) {
-                e.printStackTrace();
-                return false;
-            }
-        }
-        // Otherwise we have to call user code on EvenDispatchThread
-        final ToolkitThreadBlockedHandler priveleged_lock =
-            MToolkitThreadBlockedHandler.getToolkitThreadBlockedHandler();
-        final boolean[] finished = new boolean[1];
-        final boolean[] result = new boolean[1];
-        finished[0] = false;
-        result[0] = false;
-
-
-        // Use the same Toolkit blocking mechanism as in DnD.
-        priveleged_lock.lock();
-
-        MToolkit.executeOnEventHandlerThread((FileDialog)target, new Runnable() {
-            public void run() {
-                priveleged_lock.lock();
-                try {
-                    doFilter(filter, dir);
-                    result[0] = true;
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    result[0] = false;
-                } finally {
-                    finished[0] = true;
-                    priveleged_lock.exit();
-                    priveleged_lock.unlock();
-                }
-            }
-        });
-
-        while (!finished[0]) {
-            priveleged_lock.enter();
-        }
-
-        priveleged_lock.unlock();
-
-        return result[0];
-    }
-
-    public void setFilenameFilter(FilenameFilter filter) {
-        this.filter = filter;
-        FileDialog      fdialog = (FileDialog)target;
-        String          dir = fdialog.getDirectory();
-        String          file = fdialog.getFile();
-        setFile(file);
-        doFilter(filter, null);
-    }
-
-    // Called from native widget when paste key is pressed and we
-    // already own the selection (prevents Motif from hanging while
-    // waiting for the selection)
-    //
-    public void pasteFromClipboard() {
-        Clipboard clipboard = target.getToolkit().getSystemClipboard();
-
-        Transferable content = clipboard.getContents(this);
-        if (content != null) {
-            try {
-                String data = (String)(content.getTransferData(DataFlavor.stringFlavor));
-                insertReplaceFileDialogText(data);
-            } catch (Exception e) {
-            }
-        }
-    }
-
-// CAVEAT:
-// Peer coalescing code turned over the fact that the following functions
-// were being inherited from Dialog and were not implemented in awt_FileDialog.c
-// Five methods decribed by the peer interface are at fault (setResizable, setTitle,
-// toFront, toBack and handleFocusTraversalEvent).  Additionally show has to be overridden
-// as it was necessary to add a show function in MDialogPeer for modality flag passing.
-// As a result we were winding up in  awt_Dialog.c (now coalesced into awt_TopLevel).
-// As Filedialogs are modal and its unclear to me that any of these functions
-// can be called while the FD is on-screen let it go.  RJM.
-    public void show() {
-        // must have our own show or we wind up in pShow for Window. Bad. Very bad.
-        setVisible(true);
-        setFilenameFilter(filter);
-    }
-
-    /**
-     * MFileDialogPeer doesn't have native pData so we don't do restack on it
-     * @see java.awt.peer.ContainerPeer#restack
-     */
-    public void restack() {
-    }
-
-    /**
-     * @see java.awt.peer.ContainerPeer#isRestackSupported
-     */
-    public boolean isRestackSupported() {
-        return false;
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MFramePeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MFramePeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MFramePeer.java	2014-04-08 05:27:04.978897645 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MFramePeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,511 +0,0 @@
-/*
- * Copyright (c) 1995, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.util.Vector;
-import java.awt.*;
-import java.awt.peer.*;
-import java.awt.event.*;
-import sun.awt.motif.MInputMethodControl;
-import sun.awt.im.*;
-import java.awt.image.ColorModel;
-import java.awt.image.BufferedImage;
-import java.awt.image.DataBuffer;
-import java.awt.image.DataBufferInt;
-import java.awt.image.DataBufferByte;
-import java.awt.image.DataBufferUShort;
-import java.awt.image.ImageObserver;
-import java.awt.image.WritableRaster;
-import sun.awt.image.ImageRepresentation;
-import sun.awt.image.ToolkitImage;
-
-class MFramePeer extends MWindowPeer implements FramePeer, MInputMethodControl {
-    static Vector allFrames = new Vector();
-
-    // XXX: Stub out for now.  Need to propagate to normal size hints.
-    public void setMaximizedBounds(Rectangle b) {}
-
-    public void create(MComponentPeer parent, Object arg) {
-        super.create( parent );
-    }
-
-    MFramePeer(Frame target) {
-        super();
-        // set the window attributes for this Frame
-        winAttr.nativeDecor = !target.isUndecorated();
-        winAttr.initialFocus = true;
-        winAttr.isResizable =  target.isResizable();
-        winAttr.initialState = target.getState();
-        winAttr.title = target.getTitle();
-        winAttr.icon = target.getIconImage();
-        if (winAttr.nativeDecor) {
-            winAttr.decorations = winAttr.AWT_DECOR_ALL;
-        } else {
-            winAttr.decorations = winAttr.AWT_DECOR_NONE;
-        }
-
-        // for input method windows, use minimal decorations
-        if (target instanceof InputMethodWindow) {
-            winAttr.initialFocus = false;
-            winAttr.decorations = (winAttr.AWT_DECOR_TITLE | winAttr.AWT_DECOR_BORDER);
-        }
-
-        // create and init native component
-        init( target);
-    if (winAttr.icon != null) {
-        setIconImage(winAttr.icon);
-    }
-        allFrames.addElement(this);
-    }
-
-    public void setTitle(String title) {
-        pSetTitle(title);
-    }
-
-    protected void disposeImpl() {
-        allFrames.removeElement(this);
-        super.disposeImpl();
-    }
-
-    public void setMenuBar(MenuBar mb) {
-        MMenuBarPeer mbpeer = (MMenuBarPeer) MToolkit.targetToPeer(mb);
-        pSetMenuBar(mbpeer);
-
-        Rectangle r = target.bounds();
-
-        pReshape(r.x, r.y, r.width, r.height);
-        if (target.isVisible()) {
-            target.validate();
-        }
-    }
-
-    public void setIconImage(Image im) {
-        int width;
-        int height;
-        GraphicsConfiguration defaultGC;
-        if (im != null) {  // 4633887  Avoid Null pointer exception.
-        if (im instanceof ToolkitImage) {
-            ImageRepresentation ir = ((ToolkitImage)im).getImageRep();
-            ir.reconstruct(ImageObserver.ALLBITS);
-            width = ir.getWidth();
-            height = ir.getHeight();
-        }
-        else {
-            width = im.getWidth(null);
-            height = im.getHeight(null);
-        }
-        if (pGetIconSize(width, height)) {
-            //Icons are displayed using the default visual, so create image
-            //using default GraphicsConfiguration
-            defaultGC = getGraphicsConfiguration().getDevice().
-                getDefaultConfiguration();
-            ColorModel model = defaultGC.getColorModel();
-            WritableRaster raster =
-                model.createCompatibleWritableRaster(iconWidth, iconHeight);
-            Image image = new BufferedImage(model, raster,
-                                            model.isAlphaPremultiplied(),
-                                            null);
-
-            // ARGB BufferedImage to hunt for transparent pixels
-            BufferedImage bimage =
-                new BufferedImage(iconWidth, iconHeight,
-                                  BufferedImage.TYPE_INT_ARGB);
-            ColorModel alphaCheck = bimage.getColorModel();
-            Graphics g = image.getGraphics();
-            Graphics big = bimage.getGraphics();
-            try {
-                g.drawImage(im, 0, 0, iconWidth, iconHeight, null);
-                big.drawImage(im, 0, 0, iconWidth, iconHeight, null);
-            } finally {
-                g.dispose();
-                big.dispose();
-            }
-
-            DataBuffer db = ((BufferedImage)image).getRaster().getDataBuffer();
-            DataBuffer bidb = bimage.getRaster().getDataBuffer();
-            byte[] bytedata = null;
-            int[] intdata = null;
-            int bidbLen = bidb.getSize();
-            int imgDataIdx;
-            //Get native RGB value for window background color
-            //Should work for byte as well as int
-            int bgRGB = getNativeColor(SystemColor.window, defaultGC);
-
-            /* My first attempt at a solution to bug 4175560 was to use
-             * the iconMask and iconPixmap attributes of Windows.
-             * This worked fine on CDE/dtwm, however olwm displayed only
-             * single color icons (white on background).  Instead, the
-             * fix gets the default background window color and replaces
-             * transparent pixels in the icon image with this color.  This
-             * solutions works well with dtwm as well as olwm.
-             */
-
-            for (imgDataIdx = 0; imgDataIdx < bidbLen; imgDataIdx++) {
-                if (alphaCheck.getAlpha(bidb.getElem(imgDataIdx)) == 0 ) {
-                    //Assuming single data bank
-                    db.setElem(imgDataIdx, bgRGB);
-                }
-            }
-            short[] ushortdata = null;
-            if (db instanceof DataBufferByte) {
-                // Pseudocolor data
-                bytedata = ((DataBufferByte)db).getData();
-            }
-            else if (db instanceof DataBufferInt) {
-                // Truecolor data
-                intdata = ((DataBufferInt) db).getData();
-            }
-            else if (db instanceof DataBufferUShort) {
-                // Truecolor data
-                ushortdata = ((DataBufferUShort) db).getData();
-            }
-               pSetIconImage(bytedata, intdata, ushortdata,
-                          iconWidth, iconHeight);
-        }
-        }
-    }
-
-    native boolean pGetIconSize(int widthHint, int heightHint);
-
-    // [jk] added ushortData for 16-bpp displays
-    native void pSetIconImage(byte[] byteData,
-                              int[] intData,
-                              short[] ushortData,
-                              int iconWidth, int iconHeight);
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleIconify() {
-        postEvent(new WindowEvent((Window)target, WindowEvent.WINDOW_ICONIFIED));
-    }
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleDeiconify() {
-        postEvent(new WindowEvent((Window)target, WindowEvent.WINDOW_DEICONIFIED));
-    }
-
-
-    /**
-     * Called to inform the Frame that it has moved.
-     */
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleMoved(int x, int y) {
-        postEvent(new ComponentEvent(target, ComponentEvent.COMPONENT_MOVED));
-    }
-
-    static final int CROSSHAIR_INSET = 5;
-
-    static final int BUTTON_Y = CROSSHAIR_INSET + 1;
-    static final int BUTTON_W = 17;
-    static final int BUTTON_H = 17;
-
-    static final int SYS_MENU_X = CROSSHAIR_INSET + 1;
-    static final int SYS_MENU_CONTAINED_X = SYS_MENU_X + 5;
-    static final int SYS_MENU_CONTAINED_Y = BUTTON_Y + 7;
-    static final int SYS_MENU_CONTAINED_W = 8;
-    static final int SYS_MENU_CONTAINED_H = 3;
-
-    static final int MAXIMIZE_X_DIFF = CROSSHAIR_INSET + BUTTON_W;
-    static final int MAXIMIZE_CONTAINED_X_DIFF = MAXIMIZE_X_DIFF - 5;
-    static final int MAXIMIZE_CONTAINED_Y = BUTTON_Y + 5;
-    static final int MAXIMIZE_CONTAINED_W = 8;
-    static final int MAXIMIZE_CONTAINED_H = 8;
-
-    static final int MINIMIZE_X_DIFF = MAXIMIZE_X_DIFF + BUTTON_W;
-    static final int MINIMIZE_CONTAINED_X_DIFF = MINIMIZE_X_DIFF - 7;
-    static final int MINIMIZE_CONTAINED_Y = BUTTON_Y + 7;
-    static final int MINIMIZE_CONTAINED_W = 3;
-    static final int MINIMIZE_CONTAINED_H = 3;
-
-    static final int TITLE_X = SYS_MENU_X + BUTTON_W;
-    static final int TITLE_W_DIFF = BUTTON_W * 3 + CROSSHAIR_INSET * 2 - 1;
-    static final int TITLE_MID_Y = BUTTON_Y + (BUTTON_H / 2);
-
-    static final int MENUBAR_X = CROSSHAIR_INSET + 1;
-    static final int MENUBAR_Y = BUTTON_Y + BUTTON_H;
-
-    static final int HORIZ_RESIZE_INSET = CROSSHAIR_INSET + BUTTON_H;
-    static final int VERT_RESIZE_INSET = CROSSHAIR_INSET + BUTTON_W;
-
-
-    /*
-     * Print the native component by rendering the Motif look ourselves.
-     * We also explicitly print the MenuBar since a MenuBar isn't a subclass
-     * of Component (and thus it has no "print" method which gets called by
-     * default).
-     */
-    public void print(Graphics g) {
-        super.print(g);
-
-        Frame f = (Frame)target;
-        Insets finsets = f.getInsets();
-        Dimension fsize = f.getSize();
-
-        Color bg = f.getBackground();
-        Color fg = f.getForeground();
-        Color highlight = bg.brighter();
-        Color shadow = bg.darker();
-
-        // Well, we could query for the currently running window manager
-        // and base the look on that, or we could just always do dtwm.
-        // aim, tball, and levenson all agree we'll just do dtwm.
-
-        if (hasDecorations(MWindowAttributes.AWT_DECOR_BORDER)) {
-
-            // top outer -- because we'll most likely be drawing on white paper,
-            // for aesthetic reasons, don't make any part of the outer border
-            // pure white
-            if (highlight.equals(Color.white)) {
-                g.setColor(new Color(230, 230, 230));
-            }
-            else {
-                g.setColor(highlight);
-            }
-            g.drawLine(0, 0, fsize.width, 0);
-            g.drawLine(0, 1, fsize.width - 1, 1);
-
-            // left outer
-            // if (highlight.equals(Color.white)) {
-            //     g.setColor(new Color(230, 230, 230));
-            // }
-            // else {
-            //     g.setColor(highlight);
-            // }
-            g.drawLine(0, 0, 0, fsize.height);
-            g.drawLine(1, 0, 1, fsize.height - 1);
-
-            // bottom cross-hair
-            g.setColor(highlight);
-            g.drawLine(CROSSHAIR_INSET + 1, fsize.height - CROSSHAIR_INSET,
-                       fsize.width - CROSSHAIR_INSET,
-                       fsize.height - CROSSHAIR_INSET);
-
-            // right cross-hair
-            // g.setColor(highlight);
-            g.drawLine(fsize.width - CROSSHAIR_INSET, CROSSHAIR_INSET + 1,
-                       fsize.width - CROSSHAIR_INSET,
-                       fsize.height - CROSSHAIR_INSET);
-
-            // bottom outer
-            g.setColor(shadow);
-            g.drawLine(1, fsize.height, fsize.width, fsize.height);
-            g.drawLine(2, fsize.height - 1, fsize.width, fsize.height - 1);
-
-            // right outer
-            // g.setColor(shadow);
-            g.drawLine(fsize.width, 1, fsize.width, fsize.height);
-            g.drawLine(fsize.width - 1, 2, fsize.width - 1, fsize.height);
-
-            // top cross-hair
-            // g.setColor(shadow);
-            g.drawLine(CROSSHAIR_INSET, CROSSHAIR_INSET,
-                       fsize.width - CROSSHAIR_INSET, CROSSHAIR_INSET);
-
-            // left cross-hair
-            // g.setColor(shadow);
-            g.drawLine(CROSSHAIR_INSET, CROSSHAIR_INSET, CROSSHAIR_INSET,
-                   fsize.height - CROSSHAIR_INSET);
-        }
-
-        if (hasDecorations(MWindowAttributes.AWT_DECOR_TITLE)) {
-
-            if (hasDecorations(MWindowAttributes.AWT_DECOR_MENU)) {
-
-                // system menu
-                g.setColor(bg);
-                g.fill3DRect(SYS_MENU_X, BUTTON_Y, BUTTON_W, BUTTON_H, true);
-                g.fill3DRect(SYS_MENU_CONTAINED_X, SYS_MENU_CONTAINED_Y,
-                             SYS_MENU_CONTAINED_W, SYS_MENU_CONTAINED_H, true);
-            }
-
-            // title bar
-            // g.setColor(bg);
-            g.fill3DRect(TITLE_X, BUTTON_Y, fsize.width - TITLE_W_DIFF, BUTTON_H,
-                         true);
-
-            if (hasDecorations(MWindowAttributes.AWT_DECOR_MINIMIZE)) {
-
-                // minimize button
-                // g.setColor(bg);
-                g.fill3DRect(fsize.width - MINIMIZE_X_DIFF, BUTTON_Y, BUTTON_W,
-                             BUTTON_H, true);
-                g.fill3DRect(fsize.width - MINIMIZE_CONTAINED_X_DIFF,
-                             MINIMIZE_CONTAINED_Y, MINIMIZE_CONTAINED_W,
-                             MINIMIZE_CONTAINED_H, true);
-            }
-
-            if (hasDecorations(MWindowAttributes.AWT_DECOR_MAXIMIZE)) {
-
-                // maximize button
-                // g.setColor(bg);
-                g.fill3DRect(fsize.width - MAXIMIZE_X_DIFF, BUTTON_Y, BUTTON_W,
-                             BUTTON_H, true);
-                g.fill3DRect(fsize.width - MAXIMIZE_CONTAINED_X_DIFF,
-                             MAXIMIZE_CONTAINED_Y, MAXIMIZE_CONTAINED_W,
-                             MAXIMIZE_CONTAINED_H, true);
-            }
-
-            // title bar text
-            g.setColor(fg);
-            Font sysfont = new Font(Font.SANS_SERIF, Font.PLAIN, 10);
-            g.setFont(sysfont);
-            FontMetrics sysfm = g.getFontMetrics();
-            String ftitle = f.getTitle();
-            g.drawString(ftitle,
-                         ((TITLE_X + TITLE_X + fsize.width - TITLE_W_DIFF) / 2) -
-                         (sysfm.stringWidth(ftitle) / 2),
-                         TITLE_MID_Y + sysfm.getMaxDescent());
-        }
-
-        if (f.isResizable() &&
-            hasDecorations(MWindowAttributes.AWT_DECOR_RESIZEH)) {
-
-            // add resize cross hairs
-
-            // upper-left horiz (shadow)
-            g.setColor(shadow);
-            g.drawLine(1, HORIZ_RESIZE_INSET, CROSSHAIR_INSET,
-                       HORIZ_RESIZE_INSET);
-            // upper-left vert (shadow)
-            // g.setColor(shadow);
-            g.drawLine(VERT_RESIZE_INSET, 1, VERT_RESIZE_INSET, CROSSHAIR_INSET);
-            // upper-right horiz (shadow)
-            // g.setColor(shadow);
-            g.drawLine(fsize.width - CROSSHAIR_INSET + 1, HORIZ_RESIZE_INSET,
-                       fsize.width, HORIZ_RESIZE_INSET);
-            // upper-right vert (shadow)
-            // g.setColor(shadow);
-            g.drawLine(fsize.width - VERT_RESIZE_INSET - 1, 2,
-                       fsize.width - VERT_RESIZE_INSET - 1, CROSSHAIR_INSET + 1);
-            // lower-left horiz (shadow)
-            // g.setColor(shadow);
-            g.drawLine(1, fsize.height - HORIZ_RESIZE_INSET - 1,
-                       CROSSHAIR_INSET, fsize.height - HORIZ_RESIZE_INSET - 1);
-            // lower-left vert (shadow)
-            // g.setColor(shadow);
-            g.drawLine(VERT_RESIZE_INSET, fsize.height - CROSSHAIR_INSET + 1,
-                       VERT_RESIZE_INSET, fsize.height);
-            // lower-right horiz (shadow)
-            // g.setColor(shadow);
-            g.drawLine(fsize.width - CROSSHAIR_INSET + 1,
-                       fsize.height - HORIZ_RESIZE_INSET - 1, fsize.width,
-                       fsize.height - HORIZ_RESIZE_INSET - 1);
-            // lower-right vert (shadow)
-            // g.setColor(shadow);
-            g.drawLine(fsize.width - VERT_RESIZE_INSET - 1,
-                       fsize.height - CROSSHAIR_INSET + 1,
-                       fsize.width - VERT_RESIZE_INSET - 1, fsize.height);
-
-            // upper-left horiz (highlight)
-            g.setColor(highlight);
-            g.drawLine(2, HORIZ_RESIZE_INSET + 1, CROSSHAIR_INSET,
-                       HORIZ_RESIZE_INSET + 1);
-            // upper-left vert (highlight)
-            // g.setColor(highlight);
-            g.drawLine(VERT_RESIZE_INSET + 1, 2, VERT_RESIZE_INSET + 1,
-                       CROSSHAIR_INSET);
-            // upper-right horiz (highlight)
-            // g.setColor(highlight);
-            g.drawLine(fsize.width - CROSSHAIR_INSET + 1,
-                       HORIZ_RESIZE_INSET + 1, fsize.width - 1,
-                       HORIZ_RESIZE_INSET + 1);
-            // upper-right vert (highlight)
-            // g.setColor(highlight);
-            g.drawLine(fsize.width - VERT_RESIZE_INSET, 2,
-                       fsize.width - VERT_RESIZE_INSET, CROSSHAIR_INSET);
-            // lower-left horiz (highlight)
-            // g.setColor(highlight);
-            g.drawLine(2, fsize.height - HORIZ_RESIZE_INSET, CROSSHAIR_INSET,
-                       fsize.height - HORIZ_RESIZE_INSET);
-            // lower-left vert (highlight)
-            // g.setColor(highlight);
-            g.drawLine(VERT_RESIZE_INSET + 1,
-                       fsize.height - CROSSHAIR_INSET + 1,
-                       VERT_RESIZE_INSET + 1, fsize.height - 1);
-            // lower-right horiz (highlight)
-            // g.setColor(highlight);
-            g.drawLine(fsize.width - CROSSHAIR_INSET + 1,
-                       fsize.height - HORIZ_RESIZE_INSET, fsize.width - 1,
-                       fsize.height - HORIZ_RESIZE_INSET);
-            // lower-right vert (highlight)
-            // g.setColor(highlight);
-            g.drawLine(fsize.width - VERT_RESIZE_INSET,
-                       fsize.height - CROSSHAIR_INSET + 1,
-                       fsize.width - VERT_RESIZE_INSET, fsize.height - 1);
-        }
-
-        MenuBar mb = f.getMenuBar();
-        if (mb != null) {
-            MMenuBarPeer peer = (MMenuBarPeer) MToolkit.targetToPeer(mb);
-            if (peer != null) {
-                Insets insets = getInsets();
-                Graphics ng = g.create();
-                int menubarX = 0;
-                int menubarY = 0;
-                if (hasDecorations(MWindowAttributes.AWT_DECOR_BORDER)) {
-                    menubarX += CROSSHAIR_INSET + 1;
-                    menubarY += CROSSHAIR_INSET + 1;
-                }
-                if (hasDecorations(MWindowAttributes.AWT_DECOR_TITLE)) {
-                    menubarY += BUTTON_H;
-                }
-                try {
-                    ng.translate(menubarX, menubarY);
-                    peer.print(ng);
-                } finally {
-                    ng.dispose();
-                }
-            }
-        }
-    }
-
-    // Saveunders are not done by Frame.
-    void setSaveUnder(boolean state) {}
-
-    /* Returns the native paint should be posted after setting new size
-     */
-    public boolean checkNativePaintOnSetBounds(int width, int height) {
-        // Fix for 4418155. Undecorated Frame does not repaint
-        // automticaly if shrinking. Should not wait for Expose
-        return ((Frame)target).isUndecorated() ?
-            ((width > oldWidth) || (height > oldHeight)):
-            ((width != oldWidth) || (height != oldHeight));
-    }
-
-    public void setBoundsPrivate(int x, int y, int width, int height) {
-        setBounds(x, y, width, height);
-    }
-
-    public Rectangle getBoundsPrivate() {
-        return getBounds();
-    }
-
-    @Override
-    final boolean isTargetUndecorated() {
-        return ((Frame)target).isUndecorated();
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MGlobalCursorManager.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MGlobalCursorManager.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MGlobalCursorManager.java	2014-04-08 05:27:04.978897645 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MGlobalCursorManager.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,118 +0,0 @@
-/*
- * Copyright (c) 1999, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.*;
-import sun.awt.GlobalCursorManager;
-import sun.awt.GlobalCursorManager.*;
-
-public final class MGlobalCursorManager extends GlobalCursorManager {
-
-    static {
-        cacheInit();
-    }
-
-    private native static void cacheInit();
-
-    // cached nativeContainer
-    private Component nativeContainer;
-
-
-    /**
-     * The MGlobalCursorManager is a singleton.
-     */
-    private static MGlobalCursorManager manager;
-
-
-    static GlobalCursorManager getCursorManager() {
-        if (manager == null) {
-            manager = new MGlobalCursorManager();
-        }
-        return manager;
-    }
-
-    /**
-     * Should be called in response to a native mouse enter or native mouse
-     * button released message. Should not be called during a mouse drag.
-     */
-    static void nativeUpdateCursor(Component heavy) {
-        MGlobalCursorManager.getCursorManager().updateCursorLater(heavy);
-    }
-
-
-    protected void setCursor(Component comp, Cursor cursor, boolean useCache) {
-        if (comp == null) {
-            return;
-        }
-
-        Cursor cur = useCache ? cursor : getCapableCursor(comp);
-
-        Component nc = useCache ? nativeContainer : getNativeContainer(comp);
-
-        // System.out.println(" set cursor="+cursor+"  on "+comp+"  new curs="+cur);
-        if (nc != null && nc.isDisplayable()) {
-            nativeContainer = nc;
-            ((MComponentPeer)nc.getPeer()).pSetCursor(cur);
-        }
-    }
-
-    private Component getNativeContainer(Component comp) {
-        while (comp != null && comp.isLightweight()) {
-            comp = comp.getParent();
-        }
-        return comp;
-    }
-
-    protected native void getCursorPos(Point p);
-    protected native Component findHeavyweightUnderCursor();
-
-    /*
-     * two native methods to call corresponding methods in Container and
-     * Component
-     */
-    protected native Component findComponentAt(Container con, int x, int y);
-    protected native Point getLocationOnScreen(Component com);
-
-    protected Component findHeavyweightUnderCursor(boolean useCache) {
-        return findHeavyweightUnderCursor();
-    }
-
-    private Cursor getCapableCursor(Component comp) {
-        Component c = comp;
-        while ((c != null) && !(c instanceof Window) &&
-               c.isEnabled() && c.isVisible() && c.isDisplayable()) {
-            c = c.getParent();
-        }
-        if (c instanceof Window) {
-            return (c.isEnabled() && c.isVisible() && c.isDisplayable() && comp.isEnabled()) ?
-                    comp.getCursor() :
-                    Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
-        } else if (c == null) {
-            return null;
-        }
-        return getCapableCursor(c.getParent());
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MInputMethodControl.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MInputMethodControl.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MInputMethodControl.java	2014-04-08 05:27:04.978897645 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MInputMethodControl.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-/*
- * Copyright (c) 1997, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import sun.awt.motif.MComponentPeer;
-import sun.awt.motif.MInputMethod;
-
-/**
- * An interface for controlling containment hierarchy configuration to
- * keep track of existence of any TextArea or TextField and to manage
- * input method status area.
- *
- * @auther      JavaSoft International
- */
-interface MInputMethodControl {
-
-    /**
-     * Informs Frame or Dialog that a text component has been added to
-     * the hierarchy.
-     * @param   textComponentPeer       peer of the text component
-     */
-    void addTextComponent(MComponentPeer textComponentPeer);
-
-    /**
-     * Informs Frame or Dialog that a text component has been removed
-     * from the hierarchy.
-     * @param textComponentPeer peer of the text component
-     */
-    void removeTextComponent(MComponentPeer textComponentPeer);
-
-    /**
-     * Returns a text component peer in the containment hierarchy
-     * to obtain the Motif status area information
-     */
-    MComponentPeer getTextComponent();
-
-    /**
-     * Inform Frame or Dialog that an MInputMethod has been
-     * constructed so that Frame and Dialog can invoke the method in
-     * MInputMethod to reconfigure XICs.
-     * @param   inputMethod     an MInputMethod instance
-     */
-    void addInputMethod(MInputMethod inputMethod);
-
-    /**
-     * Inform Frame or Dialog that an X11InputMethod is being destroyed.
-     * @param   inputMethod     an X11InputMethod instance
-     */
-    void removeInputMethod(MInputMethod inputMethod);
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MInputMethodDescriptor.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MInputMethodDescriptor.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MInputMethodDescriptor.java	2014-04-08 05:27:04.982897704 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MInputMethodDescriptor.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-
-package sun.awt.motif;
-
-import java.awt.im.spi.InputMethod;
-import sun.awt.X11InputMethodDescriptor;
-
-/**
- * Provides sufficient information about an input method
- * to enable selection and loading of that input method.
- * The input method itself is only loaded when it is actually used.
- *
- * @since JDK1.3
- */
-
-class MInputMethodDescriptor extends X11InputMethodDescriptor {
-
-    /**
-     * @see java.awt.im.spi.InputMethodDescriptor#createInputMethod
-     */
-    public InputMethod createInputMethod() throws Exception {
-        return new MInputMethod();
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MInputMethod.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MInputMethod.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MInputMethod.java	2014-04-08 05:27:04.978897645 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MInputMethod.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,177 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.AWTException;
-import java.awt.Component;
-import java.awt.Container;
-import java.awt.Window;
-import java.awt.peer.ComponentPeer;
-import sun.awt.X11InputMethod;
-import sun.awt.SunToolkit;
-
-/**
- * Input Method Adapter for XIM (with Motif)
- *
- * @author JavaSoft International
- */
-public class MInputMethod extends X11InputMethod {
-
-    public MInputMethod() throws AWTException {
-        super();
-    }
-
-    protected boolean openXIM() {
-        return openXIMNative();
-    }
-
-    protected boolean createXIC() {
-        MComponentPeer peer = (MComponentPeer)getPeer(clientComponentWindow);
-        if (peer == null) {
-            return false;
-        }
-        MComponentPeer tc = null;
-        if (peer instanceof MInputMethodControl) {
-            tc = ((MInputMethodControl)peer).getTextComponent();
-        }
-        if (!createXICNative(peer, tc)) {
-            return false;
-        }
-        if (peer instanceof MInputMethodControl) {
-            ((MInputMethodControl)peer).addInputMethod(this);
-        }
-        return true;
-    }
-
-    protected void setXICFocus(ComponentPeer peer,
-                                    boolean value, boolean active) {
-        setXICFocusNative((MComponentPeer)peer, value, active);
-    }
-
-    protected Container getParent(Component client) {
-        // SECURITY: Use _NoClientCode(), because this thread may
-        //           be privileged
-        return MComponentPeer.getParent_NoClientCode(client);
-    }
-
-    /**
-     * Returns peer of the given client component. If the given client component
-     * doesn't have peer, peer of the native container of the client is returned.
-     */
-    protected ComponentPeer getPeer(Component client) {
-        MComponentPeer peer = (MComponentPeer)MToolkit.targetToPeer(client);
-        if (peer != null)
-            return peer;
-
-        Container nativeContainer = MToolkit.getNativeContainer(client);
-        peer = (MComponentPeer)MToolkit.targetToPeer(nativeContainer);
-        return peer;
-    }
-
-    /**
-     * Changes the status area configuration that is to be requested
-     * by Frame or Dialog.
-     */
-    void configureStatus() {
-        if (isDisposed()) {
-            return;
-        }
-
-        MComponentPeer peer = (MComponentPeer)getPeer((Window) clientComponentWindow);
-        MComponentPeer tc = ((MInputMethodControl)peer).getTextComponent();
-        if (tc != null) {
-            configureStatusAreaNative(tc);
-        }
-    }
-
-    /*
-     * Subclasses should override disposeImpl() instead of dispose(). Client
-     * code should always invoke dispose(), never disposeImpl().
-     */
-    protected synchronized void disposeImpl() {
-        if (clientComponentWindow != null) {
-            MComponentPeer peer = (MComponentPeer)getPeer(clientComponentWindow);
-            if (peer instanceof MInputMethodControl)
-                ((MInputMethodControl)peer).removeInputMethod(this);
-            clientComponentWindow = null;
-        }
-
-        super.disposeImpl();
-    }
-
-    /**
-     * @see java.awt.im.spi.InputMethod#removeNotify
-     */
-    public synchronized void removeNotify() {
-        if (MToolkit.targetToPeer(getClientComponent()) != null) {
-            dispose();
-        } else {
-            // We do not have to dispose XICs in case of lightweight component.
-            resetXIC();
-        }
-    }
-
-    /**
-     * Changes the internal XIC configurations. This is required the
-     * case that addition or elimination of text components has
-     * happened in the containment hierarchy. This method is invoked
-     * by Frame or Dialog.
-     */
-    synchronized void reconfigureXIC(MInputMethodControl control) {
-        if (!isDisposed()) {
-            // Some IM servers require to reset XIC before destroying
-            // the XIC. I.e., Destroying XIC doesn't reset the internal
-            // state of the IM server. endComposition() takes care of
-            // resetting XIC and preedit synchronization. However,
-            // there is no client at this point. It is assumed that
-            // the previous client is still available for dispatching
-            // committed text which maintains client's composition
-            // context.
-            endComposition();
-            resetXICifneeded();
-            reconfigureXICNative((MComponentPeer) control, control.getTextComponent());
-        }
-    }
-
-    protected void awtLock() {
-        SunToolkit.awtLock();
-    }
-
-    protected void awtUnlock() {
-        SunToolkit.awtUnlock();
-    }
-
-    /*
-     * Native methods
-     */
-    private native boolean openXIMNative();
-    private native boolean createXICNative(MComponentPeer peer, MComponentPeer tc);
-    private native void reconfigureXICNative(MComponentPeer peer,
-                                            MComponentPeer tc);
-    private native void configureStatusAreaNative(MComponentPeer tc);
-    private native void setXICFocusNative(MComponentPeer peer,
-                                    boolean value, boolean active);
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MLabelPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MLabelPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MLabelPeer.java	2014-04-08 05:27:04.982897704 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MLabelPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,104 +0,0 @@
-/*
- * Copyright (c) 1995, 1996, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-
-class MLabelPeer extends MComponentPeer implements LabelPeer {
-    native void create(MComponentPeer parent);
-
-    public void initialize() {
-        Label   l = (Label)target;
-        String  txt;
-        int     align;
-
-        if ((txt = l.getText()) != null) {
-            setText(l.getText());
-        }
-        if ((align = l.getAlignment()) != Label.LEFT) {
-            setAlignment(align);
-        }
-        super.initialize();
-    }
-
-    MLabelPeer(Label target) {
-        super(target);
-    }
-
-    public Dimension getMinimumSize() {
-        FontMetrics fm = getFontMetrics(target.getFont());
-        String label = ((Label)target).getText();
-        if (label == null) label = "";
-        return new Dimension(fm.stringWidth(label) + 14,
-                             fm.getHeight() + 8);
-    }
-
-    public native void setText(String label);
-    public native void setAlignment(int alignment);
-
-    /*
-     * Print the native component by rendering the Motif look ourselves.
-     */
-    public void print(Graphics g) {
-        Label l = (Label)target;
-        Dimension d = l.size();
-        Color bg = l.getBackground();
-        Color fg = l.getForeground();
-
-        g.setColor(bg);
-        g.fillRect(1, 1, d.width - 2, d.height - 2);
-
-        g.setColor(fg);
-        g.setFont(l.getFont());
-        FontMetrics fm = g.getFontMetrics();
-        String lbl = l.getText();
-
-        switch (l.getAlignment()) {
-          case Label.LEFT:
-            g.drawString(lbl, 2,
-                         (d.height + fm.getMaxAscent() - fm.getMaxDescent()) / 2);
-            break;
-          case Label.RIGHT:
-            g.drawString(lbl, d.width - (fm.stringWidth(lbl) + 2),
-                         (d.height + fm.getMaxAscent() - fm.getMaxDescent()) / 2);
-            break;
-          case Label.CENTER:
-            g.drawString(lbl, (d.width - fm.stringWidth(lbl)) / 2,
-                         (d.height + fm.getMaxAscent() - fm.getMaxDescent()) / 2);
-            break;
-        }
-
-        target.print(g);
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public Dimension minimumSize() {
-            return getMinimumSize();
-    }
-
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MListPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MListPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MListPeer.java	2014-04-08 05:27:04.982897704 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MListPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,390 +0,0 @@
-/*
- * Copyright (c) 1995, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import java.awt.event.ActionEvent;
-import java.awt.event.ItemEvent;
-import java.awt.event.MouseEvent;
-import java.awt.event.MouseWheelEvent;
-
-class MListPeer extends MComponentPeer implements ListPeer {
-    native void create(MComponentPeer parent);
-
-    void initialize() {
-        List li = (List)target;
-
-        /* add any items that were already inserted in the target. */
-        int  nitems = li.countItems();
-        for (int i = 0; i < nitems; i++) {
-            addItem(li.getItem(i), -1);
-        }
-
-        /* set whether this list should allow multiple selections. */
-        setMultipleSelections(li.allowsMultipleSelections());
-
-        /* make the visible position visible. */
-        int index = li.getVisibleIndex();
-        if (index >= 0) {
-            makeVisible(index);
-        }
-
-        /* select the item if necessary. */
-        int sel[] = li.getSelectedIndexes();
-        for (int i = 0 ; i < sel.length ; i++) {
-            select(sel[i]);
-        }
-
-        /* BugID 4060345 to avoid showing scrollbar in empty List */
-        if (nitems == 0) {
-            addItem(" ", 0);
-            delItems(0, 0);
-        }
-        super.pSetScrollbarBackground(getParent_NoClientCode(li).getBackground());
-
-        if (!target.isBackgroundSet()) {
-            target.setBackground(SystemColor.text);
-        }
-        if (!target.isForegroundSet()) {
-            target.setForeground(SystemColor.textText);
-        }
-
-        super.initialize();
-    }
-
-    MListPeer(List target) {
-        super(target);
-    }
-
-    /* New method name for 1.1 */
-    public void add(String item, int index) {
-        addItem(item, index);
-    }
-
-    /* New method name for 1.1 */
-    public void removeAll() {
-        clear();
-    }
-
-    /* New method name for 1.1 */
-    public void setMultipleMode (boolean b) {
-        setMultipleSelections(b);
-    }
-
-    /* New method name for 1.1 */
-    public Dimension getPreferredSize(int rows) {
-        return preferredSize(rows);
-    }
-
-    /* New method name for 1.1 */
-    public Dimension getMinimumSize(int rows) {
-        return minimumSize(rows);
-    }
-
-    public void setForeground(Color c) {
-        pSetInnerForeground(c);
-    }
-
-    public native void setBackground(Color c);
-    public native void setMultipleSelections(boolean v);
-    public native boolean isSelected(int index);
-    public native void addItem(String item, int index);
-    public native void delItems(int start, int end);
-    public native void select(int index);
-    public native void deselect(int index);
-    public native void makeVisible(int index);
-
-    public void clear() {
-        List l = (List)target;
-        int count = l.countItems();
-        if (count > 0) {
-            delItems(0, count-1);
-        }
-    }
-
-    public int[] getSelectedIndexes() {
-        List l = (List)target;
-        int len = l.countItems();
-        int sel[] = new int[len];
-        int nsel = 0;
-        for (int i = 0 ; i < len ; i++) {
-            if (isSelected(i)) {
-                sel[nsel++] = i;
-            }
-        }
-        int selected[] = new int[nsel];
-        System.arraycopy(sel, 0, selected, 0, nsel);
-        return selected;
-    }
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void action(int index, final long when, final int modifiers) {
-        final List list = (List)target;
-        final int selectIndex = index;
-
-        MToolkit.executeOnEventHandlerThread(list, new Runnable() {
-            public void run() {
-                list.select(selectIndex);
-                postEvent(new ActionEvent(target, ActionEvent.ACTION_PERFORMED,
-                                          list.getItem(selectIndex), when,
-                                          modifiers));
-            }
-        });
-    } // action()
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleListChanged(int index) {
-        final MListPeer listPeer = this;
-        final List list = (List)target;
-        final int listIndex = index;
-
-        MToolkit.executeOnEventHandlerThread(list, new Runnable() {
-            public void run() {
-                int selected[] = listPeer.getSelectedIndexes();
-                boolean isSelected = false;
-
-                for (int i=0; i < selected.length; i++) {
-                    if (listIndex == selected[i]) {
-                        isSelected = true;
-                        break;
-                    }
-                }
-                postEvent(new ItemEvent(list, ItemEvent.ITEM_STATE_CHANGED,
-                                Integer.valueOf(listIndex),
-                                isSelected? ItemEvent.SELECTED : ItemEvent.DESELECTED));
-
-            }
-        });
-    } // handleListChanged()
-
-    public Dimension minimumSize() {
-        return minimumSize(4);
-    }
-
-    public Dimension preferredSize(int v) {
-        return minimumSize(v);
-    }
-
-    public Dimension minimumSize(int v) {
-        FontMetrics fm = getFontMetrics(((List)target).getFont());
-        return new Dimension(SCROLLBAR + 2*MARGIN +
-                             fm.stringWidth("0123456789abcde"),
-                             ((fm.getHeight()+2*SPACE) * v) +
-                             2*MARGIN);
-    }
-
-    public boolean isFocusable() {
-        return true;
-    }
-
-    /*
-     * Print the native component by rendering the Motif look ourselves.
-     * ToDo(aim): needs to query native motif for more accurate size and
-     * color information, selected items, and item offset.
-     */
-    final static int    MARGIN = 2;
-    final static int    SPACE = 1;
-    final static int    SCROLLBAR = 16;
-    int fontHeight;
-    int fontAscent;
-    int fontLeading;
-    int vval;
-    int hval;
-    int vmax;
-    int hmax;
-
-    public void print(Graphics g) {
-        List l = (List)target;
-        Dimension d = l.size();
-        Color bg = l.getBackground();
-        Color fg = l.getForeground();
-        int numItems = l.getItemCount();
-        FontMetrics fm = getFontMetrics(l.getFont());
-        int w, h;
-        int vvis, hvis, vmin, hmin;
-        int max = 0;
-
-        for (int i = 0; i < numItems; i++) {
-            int len = fm.stringWidth(l.getItem(i));
-            max = Math.max(max, len);
-        }
-
-        fontHeight = fm.getHeight();
-        fontAscent = fm.getAscent();
-        fontLeading = fm.getLeading();
-
-        hmin = vmin = 0;
-
-        vvis = itemsInWindow(true);
-        vmax = Math.max(numItems - vvis, 0);
-        h = d.height - SCROLLBAR;
-
-        if (vmax != 0) {
-            w = d.width - SCROLLBAR;
-            hvis = w - ((2 * SPACE) + (2 * MARGIN));
-            hmax = Math.max(max - hvis, 0);
-        } else {
-            w = d.width;
-            hvis = w - ((2 * SPACE) + (2 * MARGIN));
-            hmax = Math.max(max - hvis, 0);
-        }
-        if (hmax == 0) {
-            h = d.height;
-            vvis = itemsInWindow(false);
-            vmax = Math.max(numItems - vvis, 0);
-        }
-        if (vmax == 0) {
-            w = d.width;
-            hvis = w - ((2 * SPACE) + (2 * MARGIN));
-            hmax = Math.max(max - hvis, 0);
-        }
-
-        hval = 0;
-        vval = 0;
-        /*
-System.out.println("print List: "+d.width+"x"+d.height+" numItems="+numItems+
-"max="+max+" vsb=("+vmin+".."+vmax+","+vval+","+vvis+
-") hsb=("+hmin+".."+hmax+","+hval+","+hvis+")");
-*/
-
-        g.setColor(bg);
-        g.fillRect(0, 0, w, h);
-
-        if (hmax != 0) {
-            int sbw = d.width - ((vmax == 0) ? 0 : SCROLLBAR);
-            g.fillRect(1, d.height - SCROLLBAR - 3, sbw - 1, SCROLLBAR - 3);
-            Graphics ng = g.create();
-            try {
-                ng.translate(0, d.height - (SCROLLBAR - 2));
-                drawScrollbar(ng, bg, SCROLLBAR - 2, sbw,
-                               hmin, hmax, hval, hvis, true);
-            } finally {
-                ng.dispose();
-            }
-        }
-        if (vmax != 0) {
-            int sbh = d.height - ((hmax == 0) ? 0 : SCROLLBAR);
-            g.fillRect(d.width - SCROLLBAR - 3, 1, SCROLLBAR - 3, sbh - 1);
-            Graphics ng = g.create();
-            try {
-                ng.translate(d.width - (SCROLLBAR - 2), 0);
-                drawScrollbar(ng, bg, SCROLLBAR - 2, sbh,
-                               vmin, vmax, vval, vvis, false);
-            } finally {
-                ng.dispose();
-            }
-        }
-
-        draw3DRect(g, bg, 0, 0, w - 1, h - 1, false);
-
-        if (numItems > 0) {
-            int n = itemsInWindow(hmax != 0);
-            int e = Math.min(numItems - 1, (vval + n) - 1);
-            paintItems(g, bg, fg, vval, e);
-        }
-
-        target.print(g);
-    }
-
-    int itemsInWindow(boolean scrollbarVisible) {
-        Dimension d = target.size();
-        int h;
-        if (scrollbarVisible) {
-            h = d.height - ((2 * MARGIN) + SCROLLBAR);
-        } else {
-            h = d.height - 2*MARGIN;
-        }
-        int i = fontHeight - fontLeading;
-        return h / (i + (2 * SPACE));
-    }
-
-    void paintItem(Graphics g, Color bg, Color fg, int index, boolean isSelected) {
-        List l = (List)target;
-        Dimension d = l.size();
-        int numItems = l.getItemCount();
-        Color shadow = bg.darker();
-
-        if ((index < vval) || (index >= (vval + itemsInWindow(hmax != 0)))) {
-            return;
-        }
-        int w = d.width - ((2 * MARGIN) + ((vmax != 0)? SCROLLBAR : 0));
-        int h = (fontHeight - fontLeading);
-        int htotal = h + (2 * SPACE);
-        int index2y = MARGIN + (index * htotal) + SPACE;
-        int y = index2y - (vval * htotal);
-        int x = MARGIN + SPACE;
-        Graphics ng = g.create();
-        try {
-            if (index > numItems - 1) {
-                ng.setColor(bg);
-                ng.fillRect(x - 2, y - 2, w, h + 4);
-                return;
-            }
-            if (isSelected) {
-                ng.setColor(shadow);
-                ng.fillRect(x - 1, y - 1, w - 2, h + 2);
-            } else {
-                ng.setColor(bg);
-                ng.fillRect(x - 1, y - 1, w - 2, h + 2);
-            }
-            ng.setColor(bg);
-
-            ng.drawRect(x - 2, y - 2, w - 1, h + 3);
-            ng.setColor(fg);
-            String str = (String)l.getItem(index);
-            ng.clipRect(x, y, w - (2 * SPACE), h);
-            ng.drawString(str, x - hval, y + fontAscent);
-        } finally {
-            ng.dispose();
-        }
-    }
-
-    void paintItems(Graphics g, Color bg, Color fg, int s, int e) {
-        for (int i = s ; i <= e ; i++) {
-          paintItem(g, bg, fg, i, false);
-        }
-    }
-
-    public boolean handlesWheelScrolling() {return true;}
-
-    public void handleEvent(AWTEvent e) {
-        if (e.getID() == MouseEvent.MOUSE_WHEEL) {
-            MouseWheelEvent mwe = (MouseWheelEvent)e;
-            nativeHandleMouseWheel(mwe.getScrollType(),
-                                   mwe.getScrollAmount(),
-                                   mwe.getWheelRotation());
-        }
-        else {
-            super.handleEvent(e);
-        }
-    }
-
-    native void nativeHandleMouseWheel(int scrollType,
-                                       int scrollAmount,
-                                       int wheelRotation);
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MMenuBarPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MMenuBarPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MMenuBarPeer.java	2014-04-08 05:27:04.982897704 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MMenuBarPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,192 +0,0 @@
-/*
- * Copyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import sun.awt.*;
-
-public class MMenuBarPeer implements MenuBarPeer {
-    long        pData;
-    MenuBar     target;
-    private X11GraphicsConfig   graphicsConfig=null;
-
-    private boolean disposed = false;
-
-    static {
-        initIDs();
-    }
-
-     /**
-     * Initialize JNI field and method IDs for fields that may be accessed
-       from C.
-     */
-    private static native void initIDs();
-
-    native void create(MFramePeer f);
-
-    public MMenuBarPeer(MenuBar target) {
-        this.target = target;
-        MFramePeer parent = (MFramePeer) MToolkit.targetToPeer(MMenuItemPeer.getParent_NoClientCode(target));
-        create(parent);
-    }
-
-    protected void finalize() throws Throwable {
-        dispose();
-        super.finalize();
-    }
-
-    /*
-     * Subclasses should override disposeImpl() instead of dispose(). Client
-     * code should always invoke dispose(), never disposeImpl().
-     */
-    private native void pDispose();
-    protected void disposeImpl() {
-        MToolkit.targetDisposedPeer(target, this);
-        pDispose();
-    }
-    public final void dispose() {
-        boolean call_disposeImpl = false;
-
-        if (!disposed) {
-            synchronized (this) {
-                if (!disposed) {
-                    disposed = call_disposeImpl = true;
-                }
-            }
-        }
-
-        if (call_disposeImpl) {
-            disposeImpl();
-        }
-    }
-    public void addMenu(Menu m) {
-    }
-    public void delMenu(int index) {
-    }
-    public void addHelpMenu(Menu m) {
-    }
-
-    static final int GAP = 10;
-    static final int W_DIFF = (MFramePeer.CROSSHAIR_INSET + 1) * 2;
-    static final int H_DIFF = MFramePeer.BUTTON_Y + MFramePeer.BUTTON_H;
-
-    /*
-     * Print the native component by rendering the Motif look ourselves.
-     * ToDo(aim): needs to query native motif for more appropriate size and
-     * color information.
-     */
-    void print(Graphics g) {
-        MenuBar mb = (MenuBar)target;
-        Frame f = (Frame)MMenuItemPeer.getParent_NoClientCode(target);
-        Dimension fd = f.size();
-        Insets insets = f.insets();
-
-        /* Calculate menubar dimension. */
-        int width = fd.width;
-        int height = insets.top;
-        if (f.getPeer() instanceof MFramePeer) {
-            MFramePeer fpeer = (MFramePeer)f.getPeer();
-            if (fpeer.hasDecorations(MWindowAttributes.AWT_DECOR_BORDER)) {
-                width -= W_DIFF;
-                height -= MFramePeer.BUTTON_Y;
-            }
-            if (fpeer.hasDecorations(MWindowAttributes.AWT_DECOR_MENU)) {
-                height -= MFramePeer.BUTTON_H;
-            }
-        }
-        Dimension d = new Dimension(width, height);
-
-        Shape oldClipArea = g.getClip();
-        g.clipRect(0, 0, d.width, d.height);
-
-        Color bg = f.getBackground();
-        Color fg = f.getForeground();
-        Color highlight = bg.brighter();
-        Color shadow = bg.darker();
-
-        // because we'll most likely be drawing on white paper,
-        // for aesthetic reasons, don't make any part of the outer border
-        // pure white
-        if (highlight.equals(Color.white)) {
-            g.setColor(new Color(230, 230, 230));
-        }
-        else {
-            g.setColor(highlight);
-        }
-        g.drawLine(0, 0, d.width, 0);
-        g.drawLine(1, 1, d.width - 1, 1);
-        g.drawLine(0, 0, 0, d.height);
-        g.drawLine(1, 1, 1, d.height - 1);
-        g.setColor(shadow);
-        g.drawLine(d.width, 1, d.width, d.height);
-        g.drawLine(d.width - 1, 2, d.width - 1, d.height);
-        g.drawLine(1, d.height, d.width, d.height);
-        g.drawLine(2, d.height - 1, d.width, d.height - 1);
-
-        int x = GAP;
-        int nitems = mb.countMenus();
-
-        Menu helpMenu = target.getHelpMenu();
-
-        for (int i = 0 ; i < nitems ; i++) {
-            Menu mn = target.getMenu(i);
-            String item = mn.getLabel();
-            if (item == null) {
-                item = "";
-            }
-            Font menuFont = mn.getFont();
-            g.setFont(menuFont);
-            FontMetrics menuMetrics = g.getFontMetrics();
-            int y = (d.height / 2) + menuMetrics.getMaxDescent();
-            int w = menuMetrics.stringWidth(item) + GAP * 2;
-
-            if (x >= d.width) {
-                break;
-            }
-            if (mn.isEnabled()) {
-                g.setColor(fg);
-            }
-            else {
-                  // draw text as grayed out
-                g.setColor(shadow);
-            }
-
-            if (helpMenu == mn) {
-                g.drawString(item, d.width - w + GAP, y);
-            }
-            else {
-                g.drawString(item, x, y);
-                x += w;
-            }
-        }
-
-        g.setClip(oldClipArea);
-    }
-
-    // Needed for MenuComponentPeer.
-    public void setFont(Font f) {
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MMenuItemPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MMenuItemPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MMenuItemPeer.java	2014-04-08 05:27:04.982897704 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MMenuItemPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,190 +0,0 @@
-/*
- * Copyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import java.awt.event.ActionEvent;
-import sun.awt.AppContext;
-
-class MMenuItemPeer implements MenuItemPeer {
-    long        pData;
-    long        jniGlobalRef;
-    boolean     isCheckbox = false;
-    MenuItem    target;
-    boolean     nativeCreated = false;
-
-    private boolean disposed = false;
-
-    static {
-        initIDs();
-    }
-
-    /**
-     * Initialize JNI field and method IDs
-     */
-    private static native void initIDs();
-
-    native void createMenuItem(MMenuPeer parent);
-
-    void create(MMenuPeer parent) {
-        if (parent.nativeCreated) {
-            createMenuItem(parent);
-            nativeCreated = true;
-            setEnabled(target.isEnabled());
-        }
-    }
-
-    protected MMenuItemPeer() {
-    }
-
-    MMenuItemPeer(MenuItem target) {
-        this.target = target;
-        MMenuPeer parent = (MMenuPeer) MToolkit.targetToPeer(getParent_NoClientCode(target));
-        create(parent);
-    }
-
-    static native MenuContainer getParent_NoClientCode(MenuComponent menuComponent);
-
-    protected void finalize() throws Throwable {
-        dispose();
-        super.finalize();
-    }
-
-    public void setEnabled(boolean b) {
-        if (b) {
-            enable();
-        } else {
-            disable();
-        }
-    }
-
-    public void setLabel(String label) {
-        if (!nativeCreated) {
-            return;
-        }
-        pSetLabel(label);
-        // Fix for bug 4234266 AWT component : MenuItem  throw NullPointer exception.
-        MenuShortcut sc = target.getShortcut();
-        setShortcut(sc != null ? sc.toString() : null );
-    }
-
-    public void setShortcut(String shortCut) {
-        if (!nativeCreated) {
-            return;
-        }
-        pSetShortcut(shortCut);
-    }
-
-    native void pSetLabel(String label);
-    native void pSetShortcut(String shortCut);
-
-    /**
-     * DEPRECATED but, for now, called by setEnabled(boolean).
-     */
-    public void enable() {
-        if (!nativeCreated) {
-            return;
-        }
-        pEnable();
-    }
-    native void pEnable();
-
-    /**
-     * DEPRECATED but, for now, called by setEnabled(boolean).
-     */
-    public void disable() {
-        if (!nativeCreated) {
-            return;
-        }
-        pDisable();
-    }
-    native void pDisable();
-
-    private void destroyNativeWidgetImpl() {
-        if (nativeCreated) {
-            pDispose();
-            nativeCreated = false;
-        }
-    }
-
-    void destroyNativeWidget() {
-        // We do not need to synchronize this method because the caller
-        // always holds the tree lock
-
-        destroyNativeWidgetImpl();
-    }
-
-    /*
-     * Subclasses should override disposeImpl() instead of dispose(). Client
-     * code should always invoke dispose(), never disposeImpl().
-     */
-    protected void disposeImpl() {
-        // Don't call destroyNativeWidget() because on a Menu, this will
-        // cause a traversal of all the menu's MenuItems. This traversal was
-        // already done once by java.awt.Menu.removeNotify().
-
-        destroyNativeWidgetImpl();
-        MToolkit.targetDisposedPeer(target, this);
-    }
-    public final void dispose() {
-        boolean call_disposeImpl = false;
-
-        if (!disposed) {
-            synchronized (this) {
-                if (!disposed) {
-                    disposed = call_disposeImpl = true;
-                }
-            }
-        }
-
-        if (call_disposeImpl) {
-            disposeImpl();
-        }
-    }
-
-    native void pDispose();
-
-    void postEvent(AWTEvent event) {
-        MToolkit.postEvent(MToolkit.targetToAppContext(target), event);
-    }
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void action(final long when, final int modifiers) {
-
-        MToolkit.executeOnEventHandlerThread(target, new Runnable() {
-            public void run() {
-                postEvent(new ActionEvent(target, ActionEvent.ACTION_PERFORMED,
-                                          target.getActionCommand(), when,
-                                          modifiers));
-            }
-        });
-    }
-
-    // Needed for MenuComponentPeer.
-    public void setFont(Font f) {
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MMenuPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MMenuPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MMenuPeer.java	2014-04-08 05:27:04.982897704 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MMenuPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,83 +0,0 @@
-/*
- * Copyright (c) 1995, 1999, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-
-public class MMenuPeer extends MMenuItemPeer implements MenuPeer {
-    native void createMenu(MMenuBarPeer parent);
-    native void createSubMenu(MMenuPeer parent);
-
-    void create(MMenuPeer parent) {
-        if (parent.nativeCreated) {
-            createSubMenu(parent);
-            nativeCreated = true;
-        }
-    }
-
-    protected MMenuPeer() {
-    }
-
-    public MMenuPeer(Menu target) {
-        this.target = target;
-        MenuContainer parent = getParent_NoClientCode(target);
-
-        if (parent instanceof MenuBar) {
-            MMenuBarPeer mb = (MMenuBarPeer) MToolkit.targetToPeer(parent);
-            createMenu(mb);
-            nativeCreated = true;
-        } else if (parent instanceof Menu) {
-            MMenuPeer m = (MMenuPeer) MToolkit.targetToPeer(parent);
-            create(m);
-        } else {
-            throw new IllegalArgumentException("unknown menu container class");
-        }
-    }
-
-    public void addSeparator() {
-    }
-    public void addItem(MenuItem item) {
-    }
-    public void delItem(int index) {
-    }
-
-    void destroyNativeWidget() {
-        // We do not need to synchronize this method because the caller
-        // always holds the tree lock
-
-        if (nativeCreated) {
-            Menu menu = (Menu) target;
-            int nitems = menu.getItemCount();
-            for (int i = 0 ; i < nitems ; i++) {
-                MMenuItemPeer mipeer =
-                    (MMenuItemPeer) MToolkit.targetToPeer(menu.getItem(i));
-                mipeer.destroyNativeWidget();
-            }
-            super.destroyNativeWidget();
-        }
-    }
-    native void pDispose();
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MMouseDragGestureRecognizer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MMouseDragGestureRecognizer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MMouseDragGestureRecognizer.java	2014-04-08 05:27:04.982897704 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MMouseDragGestureRecognizer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,233 +0,0 @@
-/*
- * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.Toolkit;
-import java.awt.Component;
-
-import java.awt.Point;
-import java.awt.dnd.DnDConstants;
-import java.awt.dnd.DragSource;
-import java.awt.dnd.MouseDragGestureRecognizer;
-import java.awt.dnd.DragGestureListener;
-
-import java.awt.event.InputEvent;
-import java.awt.event.MouseEvent;
-import java.awt.event.MouseListener;
-import java.awt.event.MouseMotionListener;
-
-import java.lang.reflect.*;
-
-import sun.awt.dnd.SunDragSourceContextPeer;
-
-/**
- * <p>
- * This subclass of MouseDragGestureRecognizer defines a DragGestureRecognizer
- * for Mouse based gestures on OSF/Motif.
- * </p>
- *
- * @author Laurence P. G. Cable
- *
- * @see java.awt.dnd.DragGestureListener
- * @see java.awt.dnd.DragGestureEvent
- * @see java.awt.dnd.DragSource
- */
-
-class MMouseDragGestureRecognizer extends MouseDragGestureRecognizer {
-
-    private static final long serialVersionUID = -841711780352520383L;
-
-    /*
-     * constant for number of pixels hysterisis before drag is determined
-     * to have started
-     */
-
-    protected static int motionThreshold;
-
-
-    protected static final int ButtonMask = InputEvent.BUTTON1_DOWN_MASK |
-                                            InputEvent.BUTTON2_DOWN_MASK |
-                                            InputEvent.BUTTON3_DOWN_MASK;
-
-    /**
-     * construct a new MMouseDragGestureRecognizer
-     *
-     * @param ds  The DragSource for the Component c
-     * @param c   The Component to observe
-     * @param act The actions permitted for this Drag
-     * @param dgl The DragGestureRecognizer to notify when a gesture is detected
-     *
-     */
-
-    protected MMouseDragGestureRecognizer(DragSource ds, Component c, int act, DragGestureListener dgl) {
-        super(ds, c, act, dgl);
-    }
-
-    /**
-     * construct a new MMouseDragGestureRecognizer
-     *
-     * @param ds  The DragSource for the Component c
-     * @param c   The Component to observe
-     * @param act The actions permitted for this Drag
-     */
-
-    protected MMouseDragGestureRecognizer(DragSource ds, Component c, int act) {
-        this(ds, c, act, null);
-    }
-
-    /**
-     * construct a new MMouseDragGestureRecognizer
-     *
-     * @param ds  The DragSource for the Component c
-     * @param c   The Component to observe
-     */
-
-    protected MMouseDragGestureRecognizer(DragSource ds, Component c) {
-        this(ds, c, DnDConstants.ACTION_NONE);
-    }
-
-    /**
-     * construct a new MMouseDragGestureRecognizer
-     *
-     * @param ds  The DragSource for the Component c
-     */
-
-    protected MMouseDragGestureRecognizer(DragSource ds) {
-        this(ds, null);
-    }
-
-    /**
-     * determine the drop action from the event
-     */
-
-    protected int mapDragOperationFromModifiers(MouseEvent e) {
-        int mods = e.getModifiersEx();
-        int btns = mods & ButtonMask;
-
-        // Do not allow right mouse button drag since Motif DnD does not
-        // terminate drag operation on right mouse button release.
-        if (!(btns == InputEvent.BUTTON1_DOWN_MASK ||
-              btns == InputEvent.BUTTON2_DOWN_MASK)) {
-            return DnDConstants.ACTION_NONE;
-        }
-
-        return
-            SunDragSourceContextPeer.convertModifiersToDropAction(mods,
-                                                                  getSourceActions());
-    }
-
-    /**
-     * Invoked when the mouse has been clicked on a component.
-     */
-
-    public void mouseClicked(MouseEvent e) {
-        // do nothing
-    }
-
-    /**
-     * Invoked when a mouse button has been pressed on a component.
-     */
-
-    public void mousePressed(MouseEvent e) {
-        events.clear();
-
-        if (mapDragOperationFromModifiers(e) != DnDConstants.ACTION_NONE) {
-            try {
-                motionThreshold = DragSource.getDragThreshold();
-            } catch (Exception exc) {
-                motionThreshold = 5;
-            }
-            appendEvent(e);
-        }
-    }
-
-    /**
-     * Invoked when a mouse button has been released on a component.
-     */
-
-    public void mouseReleased(MouseEvent e) {
-        events.clear();
-    }
-
-    /**
-     * Invoked when the mouse enters a component.
-     */
-
-    public void mouseEntered(MouseEvent e) {
-        events.clear();
-    }
-
-    /**
-     * Invoked when the mouse exits a component.
-     */
-
-    public void mouseExited(MouseEvent e) {
-        if (!events.isEmpty()) { // gesture pending
-            int dragAction = mapDragOperationFromModifiers(e);
-
-            if (dragAction == DnDConstants.ACTION_NONE) {
-                events.clear();
-            }
-        }
-    }
-
-    /**
-     * Invoked when a mouse button is pressed on a component.
-     */
-
-    public void mouseDragged(MouseEvent e) {
-        if (!events.isEmpty()) { // gesture pending
-            int dop = mapDragOperationFromModifiers(e);
-
-
-            if (dop == DnDConstants.ACTION_NONE) {
-                return;
-            }
-
-            MouseEvent trigger = (MouseEvent)events.get(0);
-
-            Point      origin  = trigger.getPoint();
-            Point      current = e.getPoint();
-
-            int        dx      = Math.abs(origin.x - current.x);
-            int        dy      = Math.abs(origin.y - current.y);
-
-            if (dx > motionThreshold || dy > motionThreshold) {
-                fireDragGestureRecognized(dop, ((MouseEvent)getTriggerEvent()).getPoint());
-            } else
-                appendEvent(e);
-        }
-    }
-
-    /**
-     * Invoked when the mouse button has been moved on a component
-     * (with no buttons no down).
-     */
-
-    public void mouseMoved(MouseEvent e) {
-        // do nothing
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MPanelPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MPanelPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MPanelPeer.java	2014-04-08 05:27:04.982897704 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MPanelPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,201 +0,0 @@
-/*
- * Copyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-
-import sun.awt.SunGraphicsCallback;
-
-class MPanelPeer extends MCanvasPeer implements PanelPeer {
-
-    MPanelPeer() {}
-
-    MPanelPeer(Component target) {
-        super(target);
-    }
-
-    MPanelPeer(Component target, Object arg) {
-        super(target, arg);
-    }
-
-    public Insets getInsets() {
-        return new Insets(0, 0, 0, 0);
-    }
-
-    public void paint(Graphics g) {
-        super.paint(g);
-        SunGraphicsCallback.PaintHeavyweightComponentsCallback.getInstance().
-            runComponents(((Container)target).getComponents(), g,
-                          SunGraphicsCallback.LIGHTWEIGHTS |
-                          SunGraphicsCallback.HEAVYWEIGHTS);
-    }
-    public void print(Graphics g) {
-        super.print(g);
-        SunGraphicsCallback.PrintHeavyweightComponentsCallback.getInstance().
-            runComponents(((Container)target).getComponents(), g,
-                          SunGraphicsCallback.LIGHTWEIGHTS |
-                          SunGraphicsCallback.HEAVYWEIGHTS);
-    }
-
-    public void setBackground(Color c) {
-        Component comp;
-        int i;
-
-        Container cont = (Container) target;
-        synchronized(target.getTreeLock()) {
-            int n = cont.getComponentCount();
-            for(i=0; i < n; i++) {
-                comp = cont.getComponent(i);
-                MComponentPeer peer = (MComponentPeer) MToolkit.targetToPeer(comp);
-                if (peer != null) {
-                    Color color = comp.getBackground();
-                    if (color == null || color.equals(c)) {
-                        peer.setBackground(c);
-                        peer.pSetBackground(c);
-                    }
-                    if ((comp instanceof java.awt.List) ||
-                           (comp instanceof java.awt.TextArea) ||
-                           (comp instanceof java.awt.ScrollPane)) {
-                        peer.pSetScrollbarBackground(c);
-                    }
-                }
-            }
-        }
-        pSetBackground(c);
-    }
-
-    public void setForeground(Color c) {
-        Component comp;
-        int i;
-
-        Container cont = (Container) target;
-        synchronized(target.getTreeLock()) {
-            int n = cont.getComponentCount();
-            for(i=0; i < n; i++) {
-                comp = cont.getComponent(i);
-                MComponentPeer peer = (MComponentPeer) MToolkit.targetToPeer(comp);
-                if (peer != null) {
-                    Color color = comp.getForeground();
-                    if (color == null || color.equals(c)) {
-                        peer.setForeground(c);
-                        peer.pSetForeground(c);
-                    }
-                    if ((comp instanceof java.awt.List) ||
-                           (comp instanceof java.awt.TextArea) ||
-                           (comp instanceof java.awt.ScrollPane)) {
-                        peer.pSetInnerForeground(c);
-                    }
-                }
-            }
-        }
-        pSetForeground(c);
-    }
-
-    /**
-     * DEPRECATED:  Replaced by getInsets().
-     */
-    public Insets insets() {
-        return getInsets();
-    }
-
-    /**
-     * Recursive method that handles the propagation of the displayChanged
-     * event into the entire hierarchy of peers.
-     * Unlike on win32, on X we don't worry about handling on-the-fly
-     * display settings changes, only windows being dragged across Xinerama
-     * screens.  Thus, we only need to tell MCanvasPeers, not all
-     * MComponentPeers.
-     */
-     private void recursiveDisplayChanged(Component c, int screenNum) {
-        if (c instanceof Container) {
-            Component children[] = ((Container)c).getComponents();
-            for (int i = 0; i < children.length; ++i) {
-                recursiveDisplayChanged(children[i], screenNum);
-            }
-        }
-        ComponentPeer peer = c.getPeer();
-        if (peer != null && peer instanceof MCanvasPeer) {
-            MCanvasPeer mPeer = (MCanvasPeer)peer;
-            mPeer.displayChanged(screenNum);
-        }
-    }
-
-    /*
-     * Often up-called from a MWindowPeer instance.
-     * Calls displayChanged() on all child canvas' peers.
-     * Recurses into Container children to ensure all canvases
-     * get the message.
-     */
-    public void displayChanged(int screenNum) {
-       // Don't do super call because MWindowPeer has already updated its GC
-
-       Component children[] = ((Container)target).getComponents();
-
-       for (int i = 0; i < children.length; i++) {
-           recursiveDisplayChanged(children[i], screenNum);
-       }
-   }
-
-    protected boolean shouldFocusOnClick() {
-        // Return false if this container has children so in that case it won't
-        // be focused. Return true otherwise.
-        return ((Container)target).getComponentCount() == 0;
-    }
-
-    private native void pEnsureIndex(ComponentPeer child, int index);
-    private native void pRestack();
-
-    private int restack(Container cont, int ind) {
-        for (int i = 0; i < cont.getComponentCount(); i++) {
-            Component comp = cont.getComponent(i);
-            if (!comp.isLightweight()) {
-                if (comp.getPeer() != null) {
-                    pEnsureIndex(comp.getPeer(), ind++);
-                }
-            }
-            if (comp.isLightweight() && comp instanceof Container) {
-                ind = restack((Container)comp, ind);
-            }
-        }
-        return ind;
-    }
-
-    /**
-     * @see java.awt.peer.ContainerPeer#restack
-     */
-    public void restack() {
-        Container cont = (Container)target;
-        restack(cont, 0);
-        pRestack();
-    }
-
-    /**
-     * @see java.awt.peer.ContainerPeer#isRestackSupported
-     */
-    public boolean isRestackSupported() {
-        return true;
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MPopupMenuPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MPopupMenuPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MPopupMenuPeer.java	2014-04-08 05:27:04.982897704 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MPopupMenuPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,132 +0,0 @@
-/*
- * Copyright (c) 1996, 1998, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-
-public class MPopupMenuPeer extends MMenuPeer implements PopupMenuPeer {
-
-    static {
-        initIDs();
-    }
-
-    /* initialize the methodIDs of methods that may be accessed from C */
-    private native static void initIDs();
-
-    native void createMenu(MComponentPeer parent);
-
-    void createPopupMenu() {
-        if (MMenuItemPeer.getParent_NoClientCode(target) instanceof Component) {
-            Component parent = (Component)getParent_NoClientCode(target);
-            MComponentPeer parentPeer = (MComponentPeer) MToolkit.targetToPeer(parent);
-            if (parentPeer == null) {
-                // because the menu isn't a component (sigh) we first have to wait
-                // for a failure to map the peer which should only happen for a
-                // lightweight container, then find the actual native parent from
-                // that component.
-                parent = MToolkit.getNativeContainer(parent);
-                parentPeer = (MComponentPeer) MToolkit.targetToPeer(parent);
-            }
-            createMenu(parentPeer);
-            nativeCreated = true;
-            createItems((Menu)target);
-
-        } else {
-            throw new IllegalArgumentException("illegal popup menu container class");
-        }
-    }
-
-    void createItems(Menu target) {
-        int nitems = target.getItemCount();
-        MMenuPeer parent = (MMenuPeer)MToolkit.targetToPeer(target);
-        for (int i = 0 ; i < nitems ; i++) {
-            MenuItem mitem = target.getItem(i);
-            MMenuItemPeer mipeer = (MMenuItemPeer)MToolkit.targetToPeer(mitem);
-            mipeer.create(parent);
-            if (mitem instanceof Menu) {
-                createItems((Menu)mitem);
-            }
-        }
-    }
-
-    public MPopupMenuPeer(PopupMenu target) {
-        // Do NOT instantiate native widget until just before showing the
-        // menu, else right mouse click will cause display to lock up
-        // (because of passive grab in Motif)
-        //
-        this.target = target;
-    }
-
-    native void pShow(Event evt, int x, int y, MComponentPeer origin);
-
-    public void show(Event evt) {
-
-        if (!nativeCreated)
-            createPopupMenu();
-
-        Component origin = (Component)evt.target;
-        MComponentPeer peer = (MComponentPeer) MToolkit.targetToPeer(origin);
-        int x = evt.x;
-        int y = evt.y;
-        if (peer == null) {
-            // A failure to map the peer should only happen for a
-            // lightweight component, then find the actual native parent from
-            // that component.  The event coorinates are going to have to be
-            Component nativeOrigin = MToolkit.getNativeContainer(origin);
-            peer = (MComponentPeer) MToolkit.targetToPeer(nativeOrigin);
-
-            // remove the event coordinates
-            for (Component c = origin; c != nativeOrigin;
-                              c = MComponentPeer.getParent_NoClientCode(c)) {
-                Point p = c.getLocation();
-                x += p.x;
-                y += p.y;
-            }
-        }
-        pShow(evt, x, y, peer);
-    }
-
-    /**
-     * This is the callback function called on the Motif thread by
-     * Popup_popdownCB(Widget, XtPointer, XtPointer) in awt_PopupMenu.c.
-     */
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    private void destroyNativeWidgetAfterGettingTreeLock() {
-
-        MToolkit.executeOnEventHandlerThread(target, new Runnable() {
-            public void run() {
-
-                Object treeLock = new Button().getTreeLock();
-                synchronized (treeLock) {
-                    destroyNativeWidget();
-                }
-            }
-        });
-    }
-
-    native void pDispose();
-} // class MPopupMenuPeer
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MRobotPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MRobotPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MRobotPeer.java	2014-04-08 05:27:04.982897704 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MRobotPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,96 +0,0 @@
-/*
- * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import java.security.*;
-import sun.awt.X11GraphicsConfig;
-
-class MRobotPeer implements RobotPeer {
-    private X11GraphicsConfig   xgc = null;
-    /*
-     * native implementation uses some static shared data (pipes, processes)
-     * so use a class lock to synchronize native method calls
-     */
-    static Object robotLock = new Object();
-
-    MRobotPeer(GraphicsConfiguration gc) {
-        this.xgc = (X11GraphicsConfig)gc;
-        setup();
-    }
-
-    public void dispose() {
-        // does nothing
-    }
-
-    public void mouseMove(int x, int y) {
-        mouseMoveImpl(xgc, x, y);
-    }
-
-    public void mousePress(int buttons) {
-        mousePressImpl(buttons);
-    }
-
-    public void mouseRelease(int buttons) {
-        mouseReleaseImpl(buttons);
-    }
-
-    public void mouseWheel(int wheelAmt) {
-    mouseWheelImpl(wheelAmt);
-    }
-
-    public void keyPress(int keycode) {
-        keyPressImpl(keycode);
-    }
-
-    public void keyRelease(int keycode) {
-        keyReleaseImpl(keycode);
-    }
-
-    public int getRGBPixel(int x, int y) {
-        int pixelArray[] = new int[1];
-        getRGBPixelsImpl(xgc, x, y, 1, 1, pixelArray);
-        return pixelArray[0];
-    }
-
-    public int [] getRGBPixels(Rectangle bounds) {
-        int pixelArray[] = new int[bounds.width*bounds.height];
-        getRGBPixelsImpl(xgc, bounds.x, bounds.y, bounds.width, bounds.height, pixelArray);
-        return pixelArray;
-    }
-
-    private static native synchronized void setup();
-
-    private static native synchronized void mouseMoveImpl(X11GraphicsConfig xgc, int x, int y);
-    private static native synchronized void mousePressImpl(int buttons);
-    private static native synchronized void mouseReleaseImpl(int buttons);
-    private static native synchronized void mouseWheelImpl(int wheelAmt);
-
-    private static native synchronized void keyPressImpl(int keycode);
-    private static native synchronized void keyReleaseImpl(int keycode);
-
-    private static native synchronized void getRGBPixelsImpl(X11GraphicsConfig xgc, int x, int y, int width, int height, int pixelArray[]);
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MScrollbarPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MScrollbarPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MScrollbarPeer.java	2014-04-08 05:27:04.986897763 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MScrollbarPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,187 +0,0 @@
-/*
- * Copyright (c) 1995, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import java.awt.event.AdjustmentEvent;
-
-class MScrollbarPeer extends MComponentPeer implements ScrollbarPeer {
-    static {
-        initIDs();
-    }
-
-    private boolean inUpCall = false;
-
-    native void create(MComponentPeer parent);
-
-    MScrollbarPeer(Scrollbar target) {
-        super(target);
-    }
-
-    // Initialize JNI field and method IDs
-    private static native void initIDs();
-
-    public native void pSetValues(int value, int visible, int minimum, int maximum);
-    public native void setLineIncrement(int l);
-    public native void setPageIncrement(int l);
-
-    /**
-     * Returns default size of Motif scrollbar on the platform
-     * Currently uses hardcoded values
-     */
-    int getDefaultDimension() {
-        if (System.getProperty("os.name").equals("Linux")) {
-            return 15;
-        } else {
-            return 19;
-        }
-    }
-
-    public Dimension getMinimumSize() {
-        if (((Scrollbar)target).getOrientation() == Scrollbar.VERTICAL) {
-            return new Dimension(getDefaultDimension(), 50);
-        } else {
-            return new Dimension(50, getDefaultDimension());
-        }
-    }
-
-    // NOTE: Callback methods are called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-
-    private void postAdjustmentEvent(final int type, final int value,
-                                     final boolean isAdjusting)
-    {
-        final Scrollbar sb = (Scrollbar)target;
-        MToolkit.executeOnEventHandlerThread(sb, new Runnable() {
-            public void run() {
-                inUpCall = true;
-                sb.setValueIsAdjusting(isAdjusting);
-                sb.setValue(value);
-                postEvent(new AdjustmentEvent(sb,
-                                AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED,
-                                type, value, isAdjusting));
-                inUpCall = false;
-            }
-        });
-    }
-
-    void lineUp(int value) {
-        postAdjustmentEvent(AdjustmentEvent.UNIT_DECREMENT, value, false);
-    }
-
-    void lineDown(int value) {
-        postAdjustmentEvent(AdjustmentEvent.UNIT_INCREMENT, value, false);
-    }
-
-    void pageUp(int value) {
-        postAdjustmentEvent(AdjustmentEvent.BLOCK_DECREMENT, value, false);
-    }
-
-    void pageDown(int value) {
-        postAdjustmentEvent(AdjustmentEvent.BLOCK_INCREMENT, value, false);
-    }
-
-    // SB_TOP/BOTTOM are mapped to tracking
-    void warp(int value) {
-        postAdjustmentEvent(AdjustmentEvent.TRACK, value, false);
-    }
-
-    private boolean dragInProgress = false;
-
-    void drag(final int value) {
-        if (!dragInProgress) {
-            dragInProgress = true;
-        }
-        postAdjustmentEvent(AdjustmentEvent.TRACK, value, true);
-    }
-
-    void dragEnd(final int value) {
-        final Scrollbar sb = (Scrollbar)target;
-
-        if (!dragInProgress) {
-            return;
-        }
-
-        dragInProgress = false;
-        MToolkit.executeOnEventHandlerThread(sb, new Runnable() {
-            public void run() {
-                // NB: notification only, no sb.setValue()
-                // last TRACK event will have done it already
-                inUpCall = true;
-                sb.setValueIsAdjusting(false);
-                postEvent(new AdjustmentEvent(sb,
-                                AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED,
-                                AdjustmentEvent.TRACK, value, false));
-                inUpCall = false;
-            }
-        });
-    }
-
-    /**
-     * Set the value of the slider in the ScrollBar.
-     */
-    public void setValues(int value, int visible, int minimum, int maximum) {
-        // Fix for BugTraq ID 4048060.  Prevent unnecessary redrawing
-        // of the slider, when the slider is already in the correct
-        // position.  Since the ScrollBar widget now receives the
-        // ButtonRelease X event before the Java Adjustor event is
-        // handled, the slider is already in the correct position and
-        // does not need to be set again and redrawn, when processing
-        // the Adjustor event.
-        if (!inUpCall) {
-            pSetValues(value, visible, minimum, maximum);
-        }
-    }
-
-    public void print(Graphics g) {
-        Scrollbar sb = (Scrollbar)target;
-        Dimension d = sb.size();
-        Color bg = sb.getBackground();
-
-        boolean horiz = (sb.getOrientation() == Scrollbar.HORIZONTAL);
-
-        drawScrollbar(g, bg, horiz? d.height : d.width,
-                          horiz? d.width : d.height,
-                          sb.getMinimum(), sb.getMaximum(),
-                          sb.getValue(), sb.getVisible(),
-                          horiz);
-
-        target.print(g);
-    }
-
-
-    /**
-     * DEPRECATED
-     */
-    public Dimension minimumSize() {
-            return getMinimumSize();
-    }
-
-    protected boolean shouldFocusOnClick() {
-        // Changed in 1.4 - scroll bars are made focusable by mouse clicks.
-        return true;
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MScrollPanePeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MScrollPanePeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MScrollPanePeer.java	2014-04-08 05:27:04.982897704 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MScrollPanePeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,411 +0,0 @@
-/*
- * Copyright (c) 1996, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.event.AdjustmentEvent;
-import java.awt.peer.ScrollPanePeer;
-
-import java.util.logging.*;
-
-import sun.awt.PeerEvent;
-
-class MScrollPanePeer extends MPanelPeer implements ScrollPanePeer {
-
-    private static final Logger log = Logger.getLogger("sun.awt.motif.MScrollPanePeer");
-
-    final static int UNIT_INCREMENT = 0;
-    final static int BLOCK_INCREMENT = 1;
-
-    boolean ignore;
-
-    native void create(MComponentPeer parent);
-
-    static {
-        initIDs();
-    }
-
-    /**
-     * Initialize JNI field and method IDs
-     */
-    private static native void initIDs();
-
-    MScrollPanePeer(Component target) {
-        init(target);
-        scrollPaneInit();
-    }
-
-    MScrollPanePeer(Component target, Object arg) {
-        init(target, arg);
-        scrollPaneInit();
-    }
-
-    void scrollPaneInit() {
-        ignore = false;
-        ScrollPane sp = (ScrollPane)target;
-        Adjustable vadj, hadj;
-        if ((vadj = sp.getVAdjustable()) != null) {
-            pSetIncrement(Adjustable.VERTICAL, UNIT_INCREMENT, vadj.getUnitIncrement());
-        }
-        if ((hadj = sp.getHAdjustable()) != null) {
-            pSetIncrement(Adjustable.HORIZONTAL, UNIT_INCREMENT, hadj.getUnitIncrement());
-        }
-        super.pSetScrollbarBackground(sp.getBackground());
-    }
-
-    public void setScrollChild(MComponentPeer child) {
-        pSetScrollChild(child);
-    }
-
-    public void setBackground(Color c) {
-        super.setBackground(c);
-        pSetScrollbarBackground(c);
-    }
-
-    public void setForeground(Color c) {
-        super.setForeground(c);
-        pSetInnerForeground(c);
-    }
-
-    native void pSetScrollChild(MComponentPeer child);
-    native void pSetIncrement(int orient, int type, int incr);
-    native int pGetScrollbarSpace(int orient);
-    native int pGetBlockIncrement(int orient);
-    native Insets pInsets(int w, int h, int childw, int childh);
-    native int pGetShadow();
-
-    public int getHScrollbarHeight() {
-        ScrollPane sp = (ScrollPane)target;
-        if (sp.getScrollbarDisplayPolicy() == ScrollPane.SCROLLBARS_NEVER) {
-            return 0;
-        } else {
-            return pGetScrollbarSpace(Adjustable.HORIZONTAL);
-        }
-    }
-
-    public int getVScrollbarWidth() {
-        ScrollPane sp = (ScrollPane)target;
-        if (sp.getScrollbarDisplayPolicy() == ScrollPane.SCROLLBARS_NEVER) {
-            return 0;
-        } else {
-            return pGetScrollbarSpace(Adjustable.VERTICAL);
-        }
-    }
-
-    public Insets insets() {
-        ScrollPane sp = (ScrollPane)target;
-        Dimension d = sp.size();
-        Dimension cd;
-        Component c = getScrollChild();
-        if (c != null) {
-            cd = c.size();
-        } else {
-            cd = new Dimension(0, 0);
-        }
-        return pInsets(d.width, d.height, cd.width, cd.height);
-    }
-
-    public void setUnitIncrement(Adjustable adj, int u) {
-        ScrollPane sp = (ScrollPane)target;
-        if (sp.getScrollbarDisplayPolicy() != ScrollPane.SCROLLBARS_NEVER) {
-            pSetIncrement(adj.getOrientation(), UNIT_INCREMENT, u);
-        }
-    }
-
-    public void setValue(Adjustable adj, int v) {
-        if (! ignore) {
-            Point p;
-            Component c = getScrollChild();
-            if (c == null) {
-                return;
-            }
-            p = c.getLocation();
-            switch(adj.getOrientation()) {
-            case Adjustable.VERTICAL:
-                setScrollPosition(-(p.x), v);
-                break;
-            case Adjustable.HORIZONTAL:
-                setScrollPosition(v, -(p.y));
-                break;
-            }
-        }
-    }
-
-    public native void setScrollPosition(int x, int y);
-
-    public void childResized(int w, int h) {
-        // REMIND AIM:  May need to revisit this...
-        if (((ScrollPane)target).getScrollbarDisplayPolicy() != ScrollPane.SCROLLBARS_NEVER) {
-            ScrollPane sp = (ScrollPane)target;
-            Adjustable vAdj = sp.getVAdjustable();
-            Adjustable hAdj = sp.getHAdjustable();
-            pSetIncrement(Scrollbar.VERTICAL, UNIT_INCREMENT, vAdj.getUnitIncrement());
-            pSetIncrement(Scrollbar.HORIZONTAL, UNIT_INCREMENT, hAdj.getUnitIncrement());
-            pSetIncrement(Scrollbar.VERTICAL, BLOCK_INCREMENT, vAdj.getBlockIncrement());
-            pSetIncrement(Scrollbar.HORIZONTAL, BLOCK_INCREMENT, hAdj.getBlockIncrement());
-        }
-
-    }
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    private void postScrollEvent(int orient, int type,
-                                 int pos, boolean isAdjusting)
-    {
-        Runnable adjustor = new Adjustor(orient, type, pos, isAdjusting);
-        MToolkit.executeOnEventHandlerThread(new ScrollEvent(target, adjustor));
-    }
-
-    /**
-     * This is used to change the adjustable on dispatch thread to
-     * represent a change made in the native scrollbar.  Since the
-     * change was reflected immediately at the native level,
-     * notification from the adjustable is temporarily ignored.
-     */
-    class ScrollEvent extends PeerEvent {
-        ScrollEvent(Object source, Runnable runnable) {
-            super(source, runnable, 0L);
-        }
-
-        public PeerEvent coalesceEvents(PeerEvent newEvent) {
-            if (log.isLoggable(Level.FINEST)) {
-                log.log(Level.FINEST, "ScrollEvent coalesced " + newEvent);
-            }
-            if (newEvent instanceof ScrollEvent) {
-                return newEvent;
-            }
-            return null;
-        }
-    }
-
-    native void setTypedValue(ScrollPaneAdjustable adjustable, int value, int type);
-
-    /**
-     * Runnable for the ScrollEvent that performs the adjustment.
-     */
-    class Adjustor implements Runnable {
-        int orient;             // selects scrollbar
-        int type;               // adjustment type
-        int pos;                // new position (only used for absolute)
-        boolean isAdjusting;    // isAdjusting status
-
-        Adjustor(int orient, int type, int pos, boolean isAdjusting) {
-            this.orient = orient;
-            this.type = type;
-            this.pos = pos;
-            this.isAdjusting = isAdjusting;
-        }
-
-        public void run() {
-            ScrollPane sp = (ScrollPane)MScrollPanePeer.this.target;
-            ScrollPaneAdjustable adj = null;
-
-            // ScrollPaneAdjustable made public in 1.4, but
-            // get[HV]Adjustable can't be declared to return
-            // ScrollPaneAdjustable because it would break backward
-            // compatibility -- hence the cast
-
-            if (orient == Adjustable.VERTICAL) {
-                adj = (ScrollPaneAdjustable)sp.getVAdjustable();
-            } else if (orient == Adjustable.HORIZONTAL) {
-                adj = (ScrollPaneAdjustable)sp.getHAdjustable();
-            } else {
-                if (log.isLoggable(Level.FINE)) {
-                    log.log(Level.FINE, "Assertion failed: unknown orient");
-                }
-            }
-
-            if (adj == null) {
-                return;
-            }
-
-            int newpos = adj.getValue();
-            switch (type) {
-              case AdjustmentEvent.UNIT_DECREMENT:
-                  newpos -= adj.getUnitIncrement();
-                  break;
-              case AdjustmentEvent.UNIT_INCREMENT:
-                  newpos += adj.getUnitIncrement();
-                  break;
-              case AdjustmentEvent.BLOCK_DECREMENT:
-                  newpos -= adj.getBlockIncrement();
-                  break;
-              case AdjustmentEvent.BLOCK_INCREMENT:
-                  newpos += adj.getBlockIncrement();
-                  break;
-              case AdjustmentEvent.TRACK:
-                  newpos = this.pos;
-                  break;
-              default:
-                  if (log.isLoggable(Level.FINE)) {
-                      log.log(Level.FINE, "Assertion failed: unknown type");
-                  }
-                  return;
-            }
-
-            // keep scroll position in acceptable range
-            newpos = Math.max(adj.getMinimum(), newpos);
-            newpos = Math.min(adj.getMaximum(), newpos);
-
-            // set value; this will synchronously fire an AdjustmentEvent
-            try {
-                MScrollPanePeer.this.ignore = true;
-                adj.setValueIsAdjusting(isAdjusting);
-
-                // Fix for 4075484 - consider type information when creating AdjustmentEvent
-                // We can't just call adj.setValue() because it creates AdjustmentEvent with type=TRACK
-                // Instead, we call private method setTypedValue of ScrollPaneAdjustable.
-                // Because ScrollPaneAdjustable is in another package we should call it through native code.
-                setTypedValue(adj, newpos, type);
-            } finally {
-                MScrollPanePeer.this.ignore = false;
-            }
-        }
-    } // class Adjustor
-
-
-    private Component getScrollChild() {
-        ScrollPane sp = (ScrollPane)target;
-        Component child = null;
-        try {
-            child = sp.getComponent(0);
-        } catch (ArrayIndexOutOfBoundsException e) {
-            // do nothing.  in this case we return null
-        }
-        return child;
-    }
-
-    final static int    MARGIN = 1;
-    final static int    SCROLLBAR = 16;
-    int hsbSpace;
-    int vsbSpace;
-    int vval;
-    int hval;
-    int vmax;
-    int hmax;
-    /*
-     * Print the native component by rendering the Motif look ourselves.
-     * ToDo(aim): needs to query native motif for more accurate size and
-     * color information.
-     */
-    public void print(Graphics g) {
-        ScrollPane sp = (ScrollPane)target;
-        Dimension d = sp.size();
-        Color bg = sp.getBackground();
-        Color fg = sp.getForeground();
-        Point p = sp.getScrollPosition();
-        Component c = getScrollChild();
-        Dimension cd;
-        if (c != null) {
-            cd = c.size();
-        } else {
-            cd = new Dimension(0, 0);
-        }
-        int sbDisplay = sp.getScrollbarDisplayPolicy();
-        int vvis, hvis, vmin, hmin, vmax, hmax, vval, hval;
-
-        switch (sbDisplay) {
-          case ScrollPane.SCROLLBARS_NEVER:
-            hsbSpace = vsbSpace = 0;
-            break;
-          case ScrollPane.SCROLLBARS_ALWAYS:
-            hsbSpace = vsbSpace = SCROLLBAR;
-            break;
-          case ScrollPane.SCROLLBARS_AS_NEEDED:
-            hsbSpace = (cd.width <= (d.width - 2*MARGIN)? 0 : SCROLLBAR);
-            vsbSpace = (cd.height <= (d.height - 2*MARGIN)? 0 : SCROLLBAR);
-
-            if (hsbSpace == 0 && vsbSpace != 0) {
-                hsbSpace = (cd.width <= (d.width - SCROLLBAR - 2*MARGIN)? 0 : SCROLLBAR);
-            }
-            if (vsbSpace == 0 && hsbSpace != 0) {
-                vsbSpace = (cd.height <= (d.height - SCROLLBAR - 2*MARGIN)? 0 : SCROLLBAR);
-            }
-        }
-
-        vvis = hvis = vmin = hmin = vmax = hmax = vval = hval = 0;
-
-        if (vsbSpace > 0) {
-            vmin = 0;
-            vvis = d.height - (2*MARGIN) - hsbSpace;
-            vmax = Math.max(cd.height - vvis, 0);
-            vval = p.y;
-        }
-        if (hsbSpace > 0) {
-            hmin = 0;
-            hvis = d.width - (2*MARGIN) - vsbSpace;
-            hmax = Math.max(cd.width - hvis, 0);
-            hval = p.x;
-        }
-
-        // need to be careful to add the margins back in here because
-        // we're drawing the margin border, after all!
-        int w = d.width - vsbSpace;
-        int h = d.height - hsbSpace;
-
-        g.setColor(bg);
-        g.fillRect(0, 0, d.width, d.height);
-
-        if (hsbSpace > 0) {
-            int sbw = d.width - vsbSpace;
-            g.fillRect(1, d.height - SCROLLBAR - 3, sbw - 1, SCROLLBAR - 3);
-            Graphics ng = g.create();
-            try {
-                ng.translate(0, d.height - (SCROLLBAR - 2));
-                drawScrollbar(ng, bg, SCROLLBAR - 2, sbw,
-                               hmin, hmax, hval, hvis, true);
-            } finally {
-                ng.dispose();
-            }
-        }
-        if (vsbSpace > 0) {
-            int sbh = d.height - hsbSpace;
-            g.fillRect(d.width - SCROLLBAR - 3, 1, SCROLLBAR - 3, sbh - 1);
-            Graphics ng = g.create();
-            try {
-                ng.translate(d.width - (SCROLLBAR - 2), 0);
-                drawScrollbar(ng, bg, SCROLLBAR - 2, sbh,
-                               vmin, vmax, vval, vvis, false);
-            } finally {
-                ng.dispose();
-            }
-        }
-
-        draw3DRect(g, bg, 0, 0, w - 1, h - 1, false);
-
-        target.print(g);
-        sp.printComponents(g);
-    }
-
-    /**
-     * @see ContainerPeer#restack
-     */
-    public void restack() {
-        // Since ScrollPane can only have one child its restacking does nothing.
-        // Also, it is dangerous, since SP child is actually not a child of SP widget
-        // but the child of SP content widget.
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MTextAreaPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MTextAreaPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MTextAreaPeer.java	2014-04-08 05:27:04.986897763 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MTextAreaPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,555 +0,0 @@
-/*
- * Copyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import java.awt.event.TextEvent;
-import java.awt.event.MouseEvent;
-import java.awt.event.MouseWheelEvent;
-import java.awt.datatransfer.*;
-import java.io.BufferedReader;
-import java.io.StringReader;
-import java.io.IOException;
-import java.util.Vector;
-import java.awt.im.InputMethodRequests;
-
-
-public class MTextAreaPeer extends MComponentPeer implements TextAreaPeer {
-    native void pCreate(MComponentPeer parent);
-
-    private boolean firstChangeSkipped;
-
-    /**
-     * Initialize JNI field and method IDs
-     */
-    private static native void initIDs();
-
-    static {
-        initIDs();
-    }
-
-    void create(MComponentPeer parent) {
-        firstChangeSkipped = false;
-        pCreate(parent);
-    }
-
-    void initialize() {
-        int start, end;
-
-        TextArea txt = (TextArea)target;
-        String  text;
-
-        if ((text = txt.getText()) != null) {
-            setText(text);
-        }
-
-        start = txt.getSelectionStart();
-        end = txt.getSelectionEnd();
-
-        if (end > start) {
-            select(start, end);
-        } else {
-            setCaretPosition(start);
-        }
-
-        super.pSetScrollbarBackground(getParent_NoClientCode(target).getBackground());
-
-        if (!target.isBackgroundSet()) {
-            // This is a way to set the background color of the TextArea
-            // without calling setBackground - go through native C code
-            setTargetBackground(SystemColor.text);
-        }
-        if (!target.isForegroundSet()) {
-            target.setForeground(SystemColor.textText);
-        }
-
-        setEditable(txt.isEditable());
-
-//      oldSelectionStart = -1; // accessibility support
-//      oldSelectionEnd = -1;   // accessibility support
-
-        super.initialize();
-    }
-
-    public MTextAreaPeer(TextArea target) {
-        super(target);
-    }
-
-    public void setEditable(boolean editable) {
-        pSetEditable(editable);
-
-        /* 4136955 - Calling setBackground() here works around an Xt
-         * bug by forcing Xt to flush an internal widget cache
-         */
-        setBackground(target.getBackground());
-    }
-    public void setBackground(Color c) {
-        setTextBackground(c);
-    }
-    public void setForeground(Color c) {
-        pSetInnerForeground(c);
-    }
-
-    native int getExtraWidth();
-    native int getExtraHeight();
-    public native void setTextBackground(Color c);
-    public native void pSetEditable(boolean e);
-    public native void select(int selStart, int selEnd);
-    public native int getSelectionStart();
-    public native int getSelectionEnd();
-    public native void setText(String txt);
-    public native String getText();
-    public native void insert(String txt, int pos);
-    public native void replaceRange(String txt, int start, int end);
-    public native void setFont(Font f);
-    public native void setCaretPosition(int pos);
-    public native int getCaretPosition();
-    public native void pSetCursor(Cursor c);
-    native void pShow2();
-    native void pMakeCursorVisible();
-
-
-    public Dimension getMinimumSize() {
-        return getMinimumSize(10, 60);
-    }
-    public Dimension getPreferredSize(int rows, int cols) {
-        return getMinimumSize(rows, cols);
-    }
-    public Dimension getMinimumSize(int rows, int cols) {
-        FontMetrics fm = getFontMetrics(target.getFont());
-
-        /* Calculate proper size for text area plus scrollbars.
-         *   - Motif allows NO leading in its text areas ...
-         *   - extra width and height counts everything outside the
-         *     usable text space.
-         * (bug 4103248, 4120310):
-         *   - Motif uses maxAscent + maxDescent, not ascent + descent.
-         */
-        int colWidth = fm.charWidth('0');
-        int rowHeight = fm.getMaxAscent() + fm.getMaxDescent();
-        return new Dimension(cols * colWidth + getExtraWidth(),
-                             rows * rowHeight + getExtraHeight());
-    }
-    public boolean isFocusable() {
-        return true;
-    }
-
-    // Called from native widget when paste key is pressed and we
-    // already own the selection (prevents Motif from hanging while
-    // waiting for the selection)
-    //
-    public void pasteFromClipboard() {
-        Clipboard clipboard = target.getToolkit().getSystemClipboard();
-
-        Transferable content = clipboard.getContents(this);
-        if (content != null) {
-            try {
-                String data = (String)(content.getTransferData(DataFlavor.stringFlavor));
-                // fix for 4401853: to clear TextArea selection if null is pasted
-                data = (data == null ? "" : data);
-                replaceRange(data, getSelectionStart(), getSelectionEnd());
-
-            } catch (Exception e) {
-            }
-        }
-    }
-
-    /*
-     * Print the native component by rendering the Motif look ourselves.
-     * ToDo(aim): needs to query native motif for more accurate size and
-     * color information, the top/left text offsets, and selected text.
-     */
-    static final int MARGIN = 2;
-    static final int BORDER = 1;
-    static final int SCROLLBAR = 16;
-    int fontHeight;
-    int fontAscent;
-    int fontLeading;
-    int topLine = 0;
-    int numLines = 0;
-    int textLength = 0;
-    Vector lines;
-    int selStart = 0;
-    int selEnd = 0;
-    int movedRight = 0;
-
-    // the following vars are assigned in print() method
-    transient boolean hscrollbar;
-    transient boolean vscrollbar;
-
-    public void print(Graphics g) {
-        TextArea area = (TextArea)target;
-        Dimension d = area.size();
-        Color bg = area.getBackground();
-        Color fg = area.getForeground();
-        FontMetrics fm = getFontMetrics(area.getFont());
-        int vmin, vmax, vval, vvis;
-        int hmin, hmax, hval, hvis;
-        int max = 0;
-
-        /*
-          Doesn't work right yet.
-        selStart = area.getSelectionStart();
-        selEnd = area.getSelectionEnd();
-        */
-
-        // Figure out number of lines and max line length
-        String text = area.getText();
-        textLength = text.length();
-        BufferedReader is = new BufferedReader(new StringReader(text));
-        String line;
-        int pos = 0;
-        lines = new Vector();
-        int sv = ((TextArea)target).getScrollbarVisibility();
-        vscrollbar = (sv == TextArea.SCROLLBARS_BOTH ||
-                sv == TextArea.SCROLLBARS_VERTICAL_ONLY);
-        hscrollbar = (sv == TextArea.SCROLLBARS_BOTH ||
-                sv == TextArea.SCROLLBARS_HORIZONTAL_ONLY);
-        boolean wrap = !hscrollbar;
-        int w = d.width - (vscrollbar ? SCROLLBAR : 0);
-        int h = d.height - (hscrollbar ? SCROLLBAR : 0);
-
-        try {
-            numLines = 0;
-            while((line = is.readLine()) != null) {
-                int len = fm.stringWidth(line);
-                if (len > w && wrap) {
-                   // need to do line wrapping
-                   int start = 0;
-                   int end = 0;
-                   int string_length = line.length();
-                   while (true) {
-                       int line_width = 0;
-                       end = start + 1; // at least one character per line
-                       while (end < string_length) {
-                               char c = line.charAt(end);
-                               int cw = fm.charWidth(c);
-                               if (line_width + cw + 10 > w) // +10?
-                                       break;
-                               line_width += cw;
-                               end++;
-                       }
-                       // form a line from start to end (not including end)
-                       String substr = line.substring(start, end);
-                       // System.out.println("wrap line: " + substr);
-                       TextLine tline = new TextLine();
-                       tline.text = substr;
-                       tline.pos = pos + start;
-                       lines.addElement(tline);
-                       start = end;
-                       max = Math.max(max, len);
-                       numLines ++;
-                       if (end == string_length) {
-                           // we have processed the whole string
-                           pos += line.length() + 1; // +1 for the ending \n ?
-                           break;
-                       }
-                   }
-                } else {
-                TextLine tline = new TextLine();
-                tline.text = line;
-                tline.pos = pos;
-                lines.addElement(tline);
-                pos += line.length() + 1;
-
-                max = Math.max(max, len);
-                numLines++;
-                }
-            }
-            is.close();
-
-        } catch (IOException e) {
-        }
-
-
-        fontHeight = fm.getHeight();
-        fontAscent = fm.getAscent();
-        fontLeading = fm.getLeading();
-
-        hmin = vmin = 0;
-
-        vvis = linesInWindow(true);
-        vmax = Math.max(numLines - vvis, 0);
-        vval = 0;
-
-        hvis = w - (2 * MARGIN);
-        hmax = Math.max(max - hvis, 0);
-        hval = 0;
-
-        g.setColor(bg);
-        g.fillRect(BORDER, BORDER, w, h);
-        if (vscrollbar)
-        {
-            int sbh = d.height - (hscrollbar ? SCROLLBAR : 0);
-            g.fillRect(d.width - SCROLLBAR - 3, 1, SCROLLBAR - 3, sbh - 1);
-            Graphics ng = g.create();
-            try {
-                ng.translate(d.width - (SCROLLBAR - 2), 0);
-                drawScrollbar(ng, bg, SCROLLBAR - 2, sbh,
-                              vmin, vmax, vval, vvis, false);
-            } finally {
-                ng.dispose();
-            }
-        }
-        if (hscrollbar)
-        {
-            int sbw = d.width - (vscrollbar ? SCROLLBAR : 0);
-            g.fillRect(1, d.height - SCROLLBAR - 3, sbw - 1, SCROLLBAR - 3);
-            Graphics ng = g.create();
-            try {
-                ng.translate(0, d.height - (SCROLLBAR - 2));
-                drawScrollbar(ng, bg, SCROLLBAR - 2, sbw,
-                              hmin, hmax, hval, hvis, true);
-            } finally {
-                ng.dispose();
-            }
-        }
-
-        draw3DRect(g, bg, 0, 0, w - 1, h - 1, false);
-
-        if (text != null) {
-            int l = linesInWindow(true);
-            h = d.height - ((2 * MARGIN) + SCROLLBAR);
-            int e = Math.min(numLines - 1, (topLine + l) - 1);
-            paintLines(g, bg, fg, topLine, e);
-        }
-
-
-        target.print(g);
-    }
-
-    int linesInWindow(boolean horizScrollbar) {
-        Dimension d = target.size();
-        int htotal = d.height - ((2 * MARGIN) + (horizScrollbar? SCROLLBAR : 0));
-        return htotal / fontHeight;
-    }
-
-    void paintLines(Graphics g, Color bg, Color fg, int s, int e) {
-        Dimension d = target.size();
-        int w = d.width - ((2 * BORDER) + (vscrollbar ? SCROLLBAR : 0));
-        int h = d.height - ((2 * BORDER) + (hscrollbar ? SCROLLBAR : 0));
-        int lm = linesInWindow(true) + topLine;
-        s = Math.max(topLine, s);
-        e = Math.min(e, lm - 1);
-        Graphics ng = g.create();
-        try {
-            ng.clipRect(BORDER + MARGIN, MARGIN + BORDER, w - (2*MARGIN),
-                        h - (2*MARGIN));
-            ng.setFont(target.getFont());
-            for (int i = s ; i <= e; i++) {
-                paintLine(ng, bg, fg, i);
-            }
-        } finally {
-            ng.dispose();
-        }
-    }
-
-    void paintLine(Graphics g, Color bg, Color fg, int lnr) {
-        Dimension d = target.size();
-        int l = linesInWindow(true);
-
-        if((lnr < topLine) || (lnr >= l + topLine)) {
-            return;
-        }
-        int w = d.width - ((2 * BORDER) + (hscrollbar ? SCROLLBAR : 0));
-        int y = MARGIN + fontLeading + ((lnr - topLine) * fontHeight);
-        String text = ((TextLine)lines.elementAt(lnr)).text;
-        int len = text.length();
-
-        if (lnr > numLines - 1) {
-            g.setColor(bg);
-            g.fillRect(BORDER, y - fontLeading, w, fontHeight);
-            return;
-        }
-        int s = 0;
-        int e = (lnr < numLines - 1) ? len : textLength;
-        int xs = pos2x(selStart) - movedRight;
-        int xe = pos2x(selEnd) - movedRight;
-
-        Color highlight = bg.brighter();
-        if ((selStart < s) && (selEnd > e)) {
-            g.setColor(highlight);
-            g.fillRect(BORDER, y - fontLeading, w, fontHeight);
-        } else {
-            g.setColor(bg);
-            g.fillRect(BORDER, y - fontLeading, w, fontHeight);
-
-            if ((selStart >= s) && (selStart <= e)) {
-                g.setColor(highlight);
-
-                if (selEnd > e) {
-                    g.fillRect(xs, y - fontLeading, (w + BORDER) - xs, fontHeight);
-                } else if (selStart == selEnd) {
-                  //g.fillRect(xs, y - fontLeading, 1, fontHeight);
-                } else {
-                    g.fillRect(xs, y - fontLeading, xe - xs, fontHeight);
-                }
-            } else if ((selEnd >= s) && (selEnd <= e)) {
-                g.setColor(highlight);
-                g.fillRect(BORDER, y - fontLeading, xe - BORDER, fontHeight);
-            }
-        }
-        g.setColor(fg);
-        g.drawString(text, MARGIN - movedRight, y + fontAscent);
-    }
-
-    int pos2x(int pos) {
-        FontMetrics fm = getFontMetrics(target.getFont());
-        int widths[] = fm.getWidths();
-        TextLine tl1 = (TextLine)lines.elementAt(0);
-        TextLine tl2;
-        int l = 0;
-        for (int i = 0; i < lines.size() - 1; i++) {
-            tl2 = (TextLine)lines.elementAt(i+1);
-            if (pos >= tl1.pos && pos < tl2.pos) {
-                l = i;
-                break;
-            }
-            tl1 = tl2;
-        }
-        int x = MARGIN;
-        for (int i = 0 ; i < (pos - tl1.pos - 1) ; i++) {
-            x += widths[tl1.text.charAt(i)];
-        }
-        return x;
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public void insertText(String txt, int pos) {
-        insert(txt, pos);
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public void replaceText(String txt, int start, int end) {
-        replaceRange(txt, start, end);
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public Dimension minimumSize() {
-        return getMinimumSize();
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public Dimension preferredSize(int rows, int cols) {
-        return getPreferredSize(rows, cols);
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public Dimension minimumSize(int rows, int cols) {
-        return getMinimumSize(rows, cols);
-    }
-
-    /*
-     * Post a new TextEvent when the value of a text component changes.
-     */
-    public void valueChanged() {
-        postEvent(new TextEvent(target, TextEvent.TEXT_VALUE_CHANGED));
-    }
-
-    void pShow(){
-      pShow2();
-      notifyTextComponentChange(true);
-    }
-
-    void pHide(){
-      notifyTextComponentChange(false);
-      super.pHide();
-    }
-
-    void pDispose(){
-      notifyTextComponentChange(false);
-      super.pDispose();
-    }
-
-    public boolean handlesWheelScrolling() {return true;}
-
-    public void handleEvent(AWTEvent e) {
-        if (e.getID() == MouseEvent.MOUSE_WHEEL) {
-            MouseWheelEvent mwe = (MouseWheelEvent)e;
-            nativeHandleMouseWheel(mwe.getScrollType(),
-                                   mwe.getScrollAmount(),
-                                   mwe.getWheelRotation());
-        }
-        else {
-            super.handleEvent(e);
-        }
-    }
-
-     public InputMethodRequests getInputMethodRequests() {
-            return null;
-      }
-
-
-
-    native void nativeHandleMouseWheel(int scrollType,
-                                       int scrollAmount,
-                                       int wheelRotation);
-
-    //
-    // Accessibility support
-    //
-
-
-    // stub functions: to be fully implemented in a future release
-    public int getIndexAtPoint(int x, int y) { return -1; }
-    public Rectangle getCharacterBounds(int i) { return null; }
-    public long filterEvents(long mask) { return 0; }
-
-/*  To be fully implemented in a future release
-
-    int oldSelectionStart;
-    int oldSelectionEnd;
-
-    public native int getIndexAtPoint(int x, int y);
-    public native Rectangle getCharacterBounds(int i);
-    public native long filterEvents(long mask);
-
-    /**
-     * Handle a change in the text selection endpoints
-     * (Note: could be simply a change in the caret location)
-     *
-    public void selectionValuesChanged(int start, int end) {
-        return;  // Need to write implementation of this.
-    }
-*/
-}
-
-
-class TextLine {
-    String text;
-    int pos;
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MTextFieldPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MTextFieldPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MTextFieldPeer.java	2014-04-08 05:27:04.986897763 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MTextFieldPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,356 +0,0 @@
-/*
- * Copyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.*;
-import java.awt.peer.*;
-import java.awt.datatransfer.*;
-import java.awt.event.ActionEvent;
-import java.awt.event.TextEvent;
-import java.awt.im.InputMethodRequests;
-
-
-public class MTextFieldPeer extends MComponentPeer implements TextFieldPeer {
-    native void pCreate(MComponentPeer parent);
-
-    private boolean firstChangeSkipped;
-
-    /**
-     * Initialize JNI field and method IDs
-     */
-    private static native void initIDs();
-
-    static {
-        initIDs();
-    }
-
-    void create(MComponentPeer parent) {
-        firstChangeSkipped = false;
-        pCreate(parent);
-    }
-
-    void initialize() {
-        int start, end;
-
-        TextField txt = (TextField)target;
-
-        setText(txt.getText());
-        if (txt.echoCharIsSet()) {
-            setEchoChar(txt.getEchoChar());
-        }
-
-        start = txt.getSelectionStart();
-        end = txt.getSelectionEnd();
-
-        if (end > start) {
-            select(start, end);
-        } else {
-            setCaretPosition(start);
-        }
-
-        if (!target.isBackgroundSet()) {
-            // This is a way to set the background color of the TextArea
-            // without calling setBackground - go through native C code
-            setTargetBackground(SystemColor.text);
-        }
-        if (!target.isForegroundSet()) {
-            target.setForeground(SystemColor.textText);
-        }
-
-        setEditable(txt.isEditable());
-
-//      oldSelectionStart = -1; // accessibility support
-//      oldSelectionEnd = -1;   // accessibility support
-
-        super.initialize();
-    }
-
-    public MTextFieldPeer(TextField target) {
-        super(target);
-    }
-
-    public void setEditable(boolean editable) {
-        pSetEditable(editable);
-
-        /* 4136955 - Calling setBackground() here works around an Xt
-         * bug by forcing Xt to flush an internal widget cache
-         */
-        setBackground(target.getBackground());
-    }
-
-    public native void pSetEditable(boolean editable);
-    public native void select(int selStart, int selEnd);
-    public native int getSelectionStart();
-    public native int getSelectionEnd();
-    public native void setText(String l);
-    public native void insertReplaceText(String l);
-    public native void preDispose();
-    public native String getText();
-    public native void setEchoChar(char c);
-    public native void setFont(Font f);
-    public native void setCaretPosition(int pos);
-    public native int getCaretPosition();
-
-    // CDE/Motif defaults: margin=5, shadow=2, highlight=1 -- times 2.
-    // Should have asked the widgets for correct values (see MTextAreaPeer).
-    private static final int padding = 16;
-
-    public Dimension getMinimumSize() {
-        FontMetrics fm = getFontMetrics(target.getFont());
-        return new Dimension(fm.stringWidth(((TextField)target).getText())+20,
-                             fm.getMaxDescent() + fm.getMaxAscent() + padding);
-    }
-
-    public Dimension getPreferredSize(int cols) {
-        return getMinimumSize(cols);
-    }
-
-    public Dimension getMinimumSize(int cols) {
-        FontMetrics fm = getFontMetrics(target.getFont());
-        return new Dimension(fm.charWidth('0') * cols + 20,
-                             fm.getMaxDescent() + fm.getMaxAscent() + padding);
-    }
-
-    public boolean isFocusable() {
-        return true;
-    }
-
-    // NOTE: This method is called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void action(final long when, final int modifiers) {
-        MToolkit.executeOnEventHandlerThread(target, new Runnable() {
-            public void run() {
-                postEvent(new ActionEvent(target, ActionEvent.ACTION_PERFORMED,
-                                          ((TextField)target).getText(), when,
-                                          modifiers));
-            }
-        });
-    }
-
-    protected void disposeImpl() {
-        preDispose();
-        super.disposeImpl();
-    }
-
-    /*
-     * Post a new TextEvent when the value of a text component changes.
-     */
-    public void valueChanged() {
-        postEvent(new TextEvent(target, TextEvent.TEXT_VALUE_CHANGED));
-    }
-
-    // Called from native widget when paste key is pressed and we
-    // already own the selection (prevents Motif from hanging while
-    // waiting for the selection)
-    //
-    // NOTE: This method is called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void pasteFromClipboard() {
-        Clipboard clipboard = target.getToolkit().getSystemClipboard();
-
-        Transferable content = clipboard.getContents(this);
-        if (content != null) {
-            try {
-                String data = (String)(content.getTransferData(DataFlavor.stringFlavor));
-                insertReplaceText(data);
-
-            } catch (Exception e) {
-            }
-        }
-    }
-
-    /*
-     * Print the native component by rendering the Motif look ourselves.
-     * ToDo(aim): needs to query native motif for more accurate size and
-     * color information, left text offset, and selected text.
-     */
-    public final static int BORDER = 2;
-    public final static int MARGIN = 4;
-
-    public void print(Graphics g) {
-        TextField txt = (TextField)target;
-        Dimension d = txt.size();
-        int w = d.width - (2 * BORDER);
-        int h = d.height - (2 * BORDER);
-        Color bg = txt.getBackground();
-        Color fg = txt.getForeground();
-        Color highlight = bg.brighter();
-        String text = txt.getText();
-        int moved = 0;
-        int selStart = 0;
-        int selEnd = 0;
-
-        g.setFont(txt.getFont());
-        g.setColor(txt.isEditable() ? highlight : bg);
-        g.fillRect(BORDER, BORDER, w, h);
-
-        g.setColor(bg);
-        //g.drawRect(0, 0, d.width-1, d.height-1);
-        draw3DRect(g, bg, 1, 1, d.width-3, d.height-3, false);
-
-        if (text != null) {
-            g.clipRect(BORDER, MARGIN, w, d.height - (2 * MARGIN));
-            FontMetrics fm = g.getFontMetrics();
-
-            w = d.width - BORDER;
-            h = d.height - (2 * MARGIN);
-            int xs = pos2x(selStart) - moved;
-            int xe = pos2x(selEnd) - moved;
-
-            if ((xs < MARGIN) && (xe > w)) {
-                g.setColor(highlight);
-                g.fillRect(BORDER, MARGIN, w - BORDER, h);
-            } else {
-                g.setColor(bg);
-                //g.fillRect(BORDER, MARGIN, w - BORDER, h);
-
-                if ((xs >= MARGIN) && (xs <= w)) {
-                    g.setColor(highlight); // selected text
-
-                    if (xe > w) {
-                        g.fillRect(xs, MARGIN, w - xs, h);
-                    } else if (xs == xe) {
-                      //g.fillRect(xs, MARGIN, 1, h);
-                    } else {
-                        g.fillRect(xs, MARGIN, xe - xs, h);
-                    }
-                } else if ((xe >= MARGIN) && (xe <= w)) {
-                    g.setColor(highlight);
-                    g.fillRect(BORDER, MARGIN, xe - BORDER, h);
-                }
-            }
-           g.setColor(fg);
-           int x = MARGIN - moved;
-           char echoChar = txt.getEchoChar();
-           if (echoChar == 0) {
-               g.drawString(text, x, BORDER + MARGIN + fm.getMaxAscent());
-           } else {
-               char data[] = new char[text.length()];
-               for (int i = 0 ; i < data.length ; i++) {
-                   data[i] = echoChar;
-               }
-               g.drawChars(data, 0, data.length, x,
-                           BORDER + MARGIN + fm.getMaxAscent());
-
-           }
-        }
-
-        target.print(g);
-    }
-
-    int pos2x(int pos) {
-        TextField txt = (TextField)target;
-        FontMetrics fm = getFontMetrics(txt.getFont());
-        int x = MARGIN, widths[] = fm.getWidths();
-        String text = txt.getText();
-        char echoChar = txt.getEchoChar();
-        if (echoChar == 0) {
-            for (int i = 0 ; i < pos ; i++) {
-                x += widths[text.charAt(i)];
-            }
-        } else {
-            x += widths[echoChar] * pos;
-        }
-        return x;
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public void setEchoCharacter(char c) {
-        setEchoChar(c);
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public Dimension minimumSize() {
-        return getMinimumSize();
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public Dimension minimumSize(int cols) {
-        return getMinimumSize(cols);
-    }
-
-    /**
-     * DEPRECATED
-     */
-    public Dimension preferredSize(int cols) {
-        return getPreferredSize(cols);
-    }
-    void pShow(){
-      super.pShow();
-      notifyTextComponentChange(true);
-    }
-
-    void pHide(){
-      notifyTextComponentChange(false);
-      super.pHide();
-    }
-
-    void pDispose(){
-      notifyTextComponentChange(false);
-      super.pDispose();
-    }
-
-     public InputMethodRequests getInputMethodRequests() {
-            return null;
-      }
-
-
-
-    //
-    // Accessibility support
-    //
-
-    // stub functions: to be fully implemented in a future release
-    public int getIndexAtPoint(int x, int y) { return -1; }
-    public Rectangle getCharacterBounds(int i) { return null; }
-    public long filterEvents(long mask) { return 0; }
-
-
-/*  To be fully implemented in a future release
-
-    int oldSelectionStart;
-    int oldSelectionEnd;
-
-    public native int getIndexAtPoint(int x, int y);
-    public native Rectangle getCharacterBounds(int i);
-    public native long filterEvents(long mask);
-
-    /**
-     * Handle a change in the text selection endpoints
-     * (Note: could be simply a change in the caret location)
-     *
-    public void selectionValuesChanged(int start, int end) {
-        return;  // Need to write implemetation of this.
-    }
-*/
-
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MToolkit.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MToolkit.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MToolkit.java	2014-04-08 15:06:36.094162392 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MToolkit.java	2014-04-10 02:56:51.330478719 +0100
@@ -60,12 +60,12 @@
 import java.awt.dnd.InvalidDnDOperationException;
 import java.awt.dnd.peer.DragSourceContextPeer;
 
-import sun.awt.motif.MInputMethod;
+//import sun.awt.motif.MInputMethod;
 import sun.awt.X11GraphicsConfig;
 import sun.awt.X11GraphicsEnvironment;
 import sun.awt.XSettings;
 
-import sun.awt.motif.MDragSourceContextPeer;
+//import sun.awt.motif.MDragSourceContextPeer;
 
 import sun.print.PrintJob2D;
 
@@ -79,9 +79,9 @@
     private static final Logger log = Logger.getLogger("sun.awt.motif.MToolkit");
 
     // the system clipboard - CLIPBOARD selection
-    X11Clipboard clipboard;
+    //X11Clipboard clipboard;
     // the system selection - PRIMARY selection
-    X11Clipboard selection;
+    //X11Clipboard selection;
 
     // Dynamic Layout Resize client code setting
     protected static boolean dynamicLayoutSetting = false;
@@ -130,7 +130,7 @@
             new GetBooleanAction("awt.dnd.motifdnd"))).booleanValue();
     }
 
-    public static final String DATA_TRANSFERER_CLASS_NAME = "sun.awt.motif.MDataTransferer";
+    //public static final String DATA_TRANSFERER_CLASS_NAME = "sun.awt.motif.MDataTransferer";
 
     public MToolkit() {
         super();
@@ -150,7 +150,7 @@
             }
 
             init(mainClassName);
-            SunToolkit.setDataTransfererClassName(DATA_TRANSFERER_CLASS_NAME);
+            //SunToolkit.setDataTransfererClassName(DATA_TRANSFERER_CLASS_NAME);
 
             Thread toolkitThread = new Thread(this, "AWT-Motif");
             toolkitThread.setPriority(Thread.NORM_PRIORITY + 1);
@@ -197,131 +197,152 @@
      */
 
     public ButtonPeer createButton(Button target) {
-        ButtonPeer peer = new MButtonPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //ButtonPeer peer = new MButtonPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public TextFieldPeer createTextField(TextField target) {
-        TextFieldPeer peer = new MTextFieldPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //TextFieldPeer peer = new MTextFieldPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public LabelPeer createLabel(Label target) {
-        LabelPeer peer = new MLabelPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //LabelPeer peer = new MLabelPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public ListPeer createList(List target) {
-        ListPeer peer = new MListPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //ListPeer peer = new MListPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public CheckboxPeer createCheckbox(Checkbox target) {
-        CheckboxPeer peer = new MCheckboxPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //CheckboxPeer peer = new MCheckboxPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public ScrollbarPeer createScrollbar(Scrollbar target) {
-        ScrollbarPeer peer = new MScrollbarPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //ScrollbarPeer peer = new MScrollbarPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public ScrollPanePeer createScrollPane(ScrollPane target) {
-        ScrollPanePeer peer = new MScrollPanePeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //ScrollPanePeer peer = new MScrollPanePeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public TextAreaPeer createTextArea(TextArea target) {
-        TextAreaPeer peer = new MTextAreaPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //TextAreaPeer peer = new MTextAreaPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public ChoicePeer createChoice(Choice target) {
-        ChoicePeer peer = new MChoicePeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //ChoicePeer peer = new MChoicePeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public FramePeer  createFrame(Frame target) {
-        FramePeer peer = new MFramePeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //FramePeer peer = new MFramePeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public CanvasPeer createCanvas(Canvas target) {
-        CanvasPeer peer = (isXEmbedServerRequested() ? new MEmbedCanvasPeer(target) : new MCanvasPeer(target));
-        targetCreatedPeer(target, peer);
-        return peer;
+        //CanvasPeer peer = (isXEmbedServerRequested() ? new MEmbedCanvasPeer(target) : new MCanvasPeer(target));
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public PanelPeer createPanel(Panel target) {
-        PanelPeer peer = new MPanelPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //PanelPeer peer = new MPanelPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public WindowPeer createWindow(Window target) {
-        WindowPeer peer = new MWindowPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //WindowPeer peer = new MWindowPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public DialogPeer createDialog(Dialog target) {
-        DialogPeer peer = new MDialogPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //DialogPeer peer = new MDialogPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public FileDialogPeer createFileDialog(FileDialog target) {
-        FileDialogPeer peer = new MFileDialogPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //FileDialogPeer peer = new MFileDialogPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public MenuBarPeer createMenuBar(MenuBar target) {
-        MenuBarPeer peer = new MMenuBarPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //MenuBarPeer peer = new MMenuBarPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public MenuPeer createMenu(Menu target) {
-        MenuPeer peer = new MMenuPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //MenuPeer peer = new MMenuPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public PopupMenuPeer createPopupMenu(PopupMenu target) {
-        PopupMenuPeer peer = new MPopupMenuPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //PopupMenuPeer peer = new MPopupMenuPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public MenuItemPeer createMenuItem(MenuItem target) {
-        MenuItemPeer peer = new MMenuItemPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //MenuItemPeer peer = new MMenuItemPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
     public CheckboxMenuItemPeer createCheckboxMenuItem(CheckboxMenuItem target) {
-        CheckboxMenuItemPeer peer = new MCheckboxMenuItemPeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
+        //CheckboxMenuItemPeer peer = new MCheckboxMenuItemPeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+        return null;
     }
 
-    public MEmbeddedFramePeer createEmbeddedFrame(MEmbeddedFrame target)
-    {
-        MEmbeddedFramePeer peer = new MEmbeddedFramePeer(target);
-        targetCreatedPeer(target, peer);
-        return peer;
-    }
+    //public MEmbeddedFramePeer createEmbeddedFrame(MEmbeddedFrame target)
+    //{
+        //MEmbeddedFramePeer peer = new MEmbeddedFramePeer(target);
+        //targetCreatedPeer(target, peer);
+        //return peer;
+    //    return null;
+    //}
 
 
     public FontPeer getFontPeer(String name, int style){
@@ -438,29 +459,31 @@
     public native void beep();
 
     public  Clipboard getSystemClipboard() {
-        SecurityManager security = System.getSecurityManager();
-        if (security != null) {
-          security.checkSystemClipboardAccess();
-        }
-        synchronized (this) {
-            if (clipboard == null) {
-                clipboard = new X11Clipboard("System", "CLIPBOARD");
-            }
-        }
-        return clipboard;
+        //SecurityManager security = System.getSecurityManager();
+        //if (security != null) {
+        //  security.checkSystemClipboardAccess();
+        //}
+        //synchronized (this) {
+        //    if (clipboard == null) {
+        //        clipboard = new X11Clipboard("System", "CLIPBOARD");
+        //    }
+        //}
+        //return clipboard;
+        return null;
     }
 
     public Clipboard getSystemSelection() {
-        SecurityManager security = System.getSecurityManager();
-        if (security != null) {
-            security.checkSystemClipboardAccess();
-        }
-        synchronized (this) {
-            if (selection == null) {
-                selection = new X11Clipboard("Selection", "PRIMARY");
-            }
-        }
-        return selection;
+        //SecurityManager security = System.getSecurityManager();
+        //if (security != null) {
+        //    security.checkSystemClipboardAccess();
+        //}
+        //synchronized (this) {
+        //    if (selection == null) {
+        //        selection = new X11Clipboard("Selection", "PRIMARY");
+        //    }
+        //}
+        //return selection;
+        return null;
     }
 
     public boolean getLockingKeyState(int key) {
@@ -492,11 +515,12 @@
     }
 
     public DragSourceContextPeer createDragSourceContextPeer(DragGestureEvent dge) throws InvalidDnDOperationException {
-        if (MToolkit.useMotifDnD()) {
-            return MDragSourceContextPeer.createDragSourceContextPeer(dge);
-        } else {
-            return X11DragSourceContextPeer.createDragSourceContextPeer(dge);
-        }
+        //if (MToolkit.useMotifDnD()) {
+        //    return MDragSourceContextPeer.createDragSourceContextPeer(dge);
+        //} else {
+        //    return X11DragSourceContextPeer.createDragSourceContextPeer(dge);
+        //}
+        return null;
     }
 
     public <T extends DragGestureRecognizer> T
@@ -504,9 +528,9 @@
                                     DragSource ds, Component c, int srcActions,
                                     DragGestureListener dgl)
     {
-        if (MouseDragGestureRecognizer.class.equals(abstractRecognizerClass))
-            return (T)new MMouseDragGestureRecognizer(ds, c, srcActions, dgl);
-        else
+        //if (MouseDragGestureRecognizer.class.equals(abstractRecognizerClass))
+        //    return (T)new MMouseDragGestureRecognizer(ds, c, srcActions, dgl);
+        //else
             return null;
     }
 
@@ -514,14 +538,14 @@
      * Returns a new input method adapter descriptor for native input methods.
      */
     public InputMethodDescriptor getInputMethodAdapterDescriptor() throws AWTException {
-        return new MInputMethodDescriptor();
+        return null; // return new MInputMethodDescriptor();
     }
 
     /**
      * Returns a style map for the input method highlight.
      */
     public Map mapInputMethodHighlight(InputMethodHighlight highlight) {
-        return MInputMethod.mapInputMethodHighlight(highlight);
+        return null; //return MInputMethod.mapInputMethodHighlight(highlight);
     }
 
     /**
@@ -529,15 +553,15 @@
      */
     public Cursor createCustomCursor(Image cursor, Point hotSpot, String name)
         throws IndexOutOfBoundsException {
-        return new MCustomCursor(cursor, hotSpot, name);
+        return null; //return new MCustomCursor(cursor, hotSpot, name);
     }
 
     /**
      * Returns the supported cursor size
      */
     public Dimension getBestCursorSize(int preferredWidth, int preferredHeight) {
-        return MCustomCursor.getBestCursorSize(
-            java.lang.Math.max(1,preferredWidth), java.lang.Math.max(1,preferredHeight));
+        return null; //MCustomCursor.getBestCursorSize(
+            //java.lang.Math.max(1,preferredWidth), java.lang.Math.max(1,preferredHeight));
     }
 
     public int getMaximumCursorColors() {
@@ -621,7 +645,8 @@
 
     public RobotPeer createRobot(Robot target, GraphicsDevice screen) {
         /* 'target' is unused for now... */
-        return new MRobotPeer(screen.getDefaultConfiguration());
+        //return new MRobotPeer(screen.getDefaultConfiguration());
+        return null;
     }
 
     static boolean useMotifDnD() {
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MWindowPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/MWindowPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/MWindowPeer.java	2014-04-08 16:38:59.712102235 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/MWindowPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,625 +0,0 @@
-/*
- * Copyright (c) 1995, 2007, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.awt.motif;
-
-import java.util.Vector;
-import java.awt.*;
-import java.awt.peer.*;
-import java.awt.event.*;
-import java.awt.image.BufferedImage;
-import java.awt.image.DataBuffer;
-import java.awt.image.DataBufferByte;
-import java.awt.image.DataBufferInt;
-import java.awt.image.ImageObserver;
-import sun.awt.image.ImageRepresentation;
-import sun.awt.motif.MInputMethod;
-import sun.awt.motif.MInputMethodControl;
-import sun.awt.im.*;
-import sun.awt.DisplayChangedListener;
-import sun.awt.SunToolkit;
-import sun.awt.X11GraphicsDevice;
-
-class MWindowPeer extends MPanelPeer implements WindowPeer,
-DisplayChangedListener {
-
-    Insets insets = new Insets( 0, 0, 0, 0 );
-    MWindowAttributes winAttr;
-    static Vector allWindows = new Vector();
-    int         iconWidth  = -1;
-    int         iconHeight = -1;
-
-    int dropTargetCount = 0;
-    boolean alwaysOnTop;
-
-    native void pCreate(MComponentPeer parent, String targetClassName, boolean isFocusableWindow);
-    native void pShow();
-    native void pToFront();
-    native void pShowModal(boolean isModal);
-    native void pHide();
-    native void pReshape(int x, int y, int width, int height);
-    native void pDispose();
-    native void pSetTitle(String title);
-    public native void setState(int state);
-    public native int getState();
-
-    public native void setResizable(boolean resizable);
-    native void addTextComponentNative(MComponentPeer tc);
-    native void removeTextComponentNative();
-    native void pSetIMMOption(String option);
-    native void pSetMenuBar(MMenuBarPeer mbpeer);
-    native void setSaveUnder(boolean state);
-
-    native void registerX11DropTarget(Component target);
-    native void unregisterX11DropTarget(Component target);
-    native void updateAlwaysOnTop(boolean isAlwaysOnTop);
-
-    private static native void initIDs();
-
-    static {
-        initIDs();
-    }
-
-    // this function is privileged! do not change it to public!
-    private static int getInset(final String name, final int def) {
-        Integer tmp = (Integer) java.security.AccessController.doPrivileged(
-            new sun.security.action.GetIntegerAction(name, def));
-        return tmp.intValue();
-    }
-
-    MWindowPeer() {
-        insets = new Insets(0,0,0,0);
-        winAttr = new MWindowAttributes();
-    }
-
-    MWindowPeer(Window target) {
-
-        this();
-        init(target);
-
-        allWindows.addElement(this);
-    }
-
-    void create(MComponentPeer parent) {
-        pCreate(parent, target.getClass().getName(), ((Window)target).isFocusableWindow());
-    }
-
-    void init( Window target ) {
-        if ( winAttr.nativeDecor == true ) {
-            insets.top = getInset("awt.frame.topInset", -1);
-            insets.left = getInset("awt.frame.leftInset", -1);
-            insets.bottom = getInset("awt.frame.bottomInset", -1);
-            insets.right = getInset("awt.frame.rightInset", -1);
-        }
-
-        Rectangle bounds = target.getBounds();
-        sysX = bounds.x;
-        sysY = bounds.y;
-        sysW = bounds.width;
-        sysH = bounds.height;
-
-        super.init(target);
-        InputMethodManager imm = InputMethodManager.getInstance();
-        String menuString = imm.getTriggerMenuString();
-        if (menuString != null)
-        {
-            pSetIMMOption(menuString);
-        }
-        pSetTitle(winAttr.title);
-
-        /*
-         * For Windows and undecorated Frames and Dialogs this just
-         * disables/enables resizing functions in the system menu.
-         */
-        setResizable(winAttr.isResizable);
-
-        setSaveUnder(true);
-
-        Font f = target.getFont();
-        if (f == null) {
-            f = defaultFont;
-            target.setFont(f);
-            setFont(f);
-        }
-        Color c = target.getBackground();
-        if (c == null) {
-            target.setBackground(SystemColor.window);
-            setBackground(SystemColor.window);
-        }
-        c = target.getForeground();
-        if (c == null) {
-            target.setForeground(SystemColor.windowText);
-            setForeground(SystemColor.windowText);
-        }
-        alwaysOnTop = ((Window)target).isAlwaysOnTop() && ((Window)target).isAlwaysOnTopSupported();
-
-        GraphicsConfiguration gc = getGraphicsConfiguration();
-        ((X11GraphicsDevice)gc.getDevice()).addDisplayChangedListener(this);
-
-    }
-
-    /* Support for multiple icons is not implemented in MAWT */
-    public void updateIconImages() {
-        if (this instanceof MFramePeer) {
-            ((MFramePeer)this).setIconImage(((Frame)target).getIconImage());
-        }
-    }
-
-
-    /* Not implemented in MAWT */
-    public void updateMinimumSize() {
-    }
-
-    protected void disposeImpl() {
-        allWindows.removeElement(this);
-        super.disposeImpl();
-    }
-
-    public native void toBack();
-
-    public void setAlwaysOnTop(boolean alwaysOnTop) {
-        this.alwaysOnTop = alwaysOnTop;
-        updateAlwaysOnTop(alwaysOnTop);
-    }
-
-    public void updateAlwaysOnTopState() {
-        setAlwaysOnTop(((Window)target).isAlwaysOnTop());
-    }
-
-    public void toFront() {
-        if (target.isVisible()) {
-            updateFocusableWindowState();
-            pToFront();
-        }
-    }
-
-    public void updateFocusableWindowState() {
-        setFocusableWindow(((Window)target).isFocusableWindow());
-    }
-    native void setFocusableWindow(boolean value);
-
-    public void setVisible( boolean b ) {
-        if (b) {
-            updateFocusableWindowState();
-        }
-        super.setVisible(b);
-        updateAlwaysOnTop(alwaysOnTop);
-    }
-
-    public Insets getInsets() {
-        return insets;
-    }
-
-    public void handleQuit() {
-        postEvent(new WindowEvent((Window)target, WindowEvent.WINDOW_CLOSING));
-    }
-
-    // XXX: nasty WM, foul play.  spank WM author.
-    public void handleDestroy() {
-        final Window target = (Window)this.target;
-        SunToolkit.executeOnEventHandlerThread(target,
-                                               new Runnable() {
-                                                   public void run() {
-                                                       // This seems like the only reasonable thing we
-                                                       // could do in this situation as the native window
-                                                       // is already dead.
-                                                       target.dispose();
-                                                   }
-                                               });
-    }
-
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleIconify() {
-        postEvent(new WindowEvent((Window)target, WindowEvent.WINDOW_ICONIFIED));
-    }
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleDeiconify() {
-        postEvent(new WindowEvent((Window)target, WindowEvent.WINDOW_DEICONIFIED));
-    }
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleStateChange(int oldState, int newState) {
-        postEvent(new WindowEvent((Window)target,
-                                  WindowEvent.WINDOW_STATE_CHANGED,
-                                  oldState, newState));
-    }
-
-    /**
-     * Called to inform the Window that its size has changed and it
-     * should layout its children.
-     */
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleResize(int width, int height) {
-        sysW = width;
-        sysH = height;
-
-        // REMIND: Is this secure? Can client code subclass input method?
-        if (!tcList.isEmpty() &&
-            !imList.isEmpty()){
-            int i;
-            for (i = 0; i < imList.size(); i++){
-                ((MInputMethod)imList.elementAt(i)).configureStatus();
-            }
-        }
-        validateSurface(width, height);
-        postEvent(new ComponentEvent(target, ComponentEvent.COMPONENT_RESIZED));
-    }
-
-
-    /**
-     * DEPRECATED:  Replaced by getInsets().
-     */
-    public Insets insets() {
-        return getInsets();
-    }
-
-    public void handleMoved(int x, int y) {
-        sysX = x;
-        sysY = y;
-        postEvent(new ComponentEvent(target, ComponentEvent.COMPONENT_MOVED));
-    }
-
-    private native AWTEvent wrapInSequenced(AWTEvent event);
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleWindowFocusIn() {
-        WindowEvent we = new WindowEvent((Window)target, WindowEvent.WINDOW_GAINED_FOCUS);
-        /* wrap in Sequenced, then post*/
-        postEvent(wrapInSequenced((AWTEvent) we));
-    }
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void handleWindowFocusOut(Window oppositeWindow) {
-        WindowEvent we = new WindowEvent((Window)target, WindowEvent.WINDOW_LOST_FOCUS,
-                                         oppositeWindow);
-        /* wrap in Sequenced, then post*/
-        postEvent(wrapInSequenced((AWTEvent) we));
-    }
-
-
-// relocation of Imm stuff
-    private Vector imList = new Vector();
-    private Vector tcList = new Vector();
-
-    // NOTE: This method is called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    void notifyIMMOptionChange(){
-
-        // REMIND: IS THIS SECURE??? CAN USER CODE SUBCLASS INPUTMETHODMGR???
-        InputMethodManager.getInstance().notifyChangeRequest(target);
-    }
-
-    public void addInputMethod(MInputMethod im) {
-        if (!imList.contains(im))
-            imList.addElement(im);
-    }
-
-    public void removeInputMethod(MInputMethod im) {
-        if (imList.contains(im))
-            imList.removeElement(im);
-    }
-
-    public void addTextComponent(MComponentPeer tc) {
-        if (tcList.contains(tc))
-            return;
-        if (tcList.isEmpty()){
-            addTextComponentNative(tc);
-            if (!imList.isEmpty()) {
-                for (int i = 0; i < imList.size(); i++) {
-                    ((MInputMethod)imList.elementAt(i)).reconfigureXIC((MInputMethodControl)this);
-                }
-            }
-            MToolkit.executeOnEventHandlerThread(target, new Runnable() {
-                    public void run() {
-                        synchronized(target.getTreeLock()) {
-                            target.doLayout();
-                        }
-                    }
-                });
-        }
-        tcList.addElement(tc);
-
-    }
-
-    public void removeTextComponent(MComponentPeer tc) {
-        if (!tcList.contains(tc))
-            return;
-        tcList.removeElement(tc);
-        if (tcList.isEmpty()){
-            removeTextComponentNative();
-            if (!imList.isEmpty()) {
-                for (int i = 0; i < imList.size(); i++) {
-                    ((MInputMethod)imList.elementAt(i)).reconfigureXIC((MInputMethodControl)this);
-                }
-            }
-            target.doLayout();
-        }
-    }
-
-    public MComponentPeer getTextComponent() {
-        if (!tcList.isEmpty()) {
-            return (MComponentPeer)tcList.firstElement();
-        } else {
-            return null;
-        }
-    }
-
-    boolean hasDecorations(int decor) {
-        if (!winAttr.nativeDecor) {
-            return false;
-        }
-        else {
-            int myDecor = winAttr.decorations;
-            boolean hasBits = ((myDecor & decor) == decor);
-            if ((myDecor & MWindowAttributes.AWT_DECOR_ALL) != 0)
-                return !hasBits;
-            else
-                return hasBits;
-        }
-    }
-
-    /* Returns the native paint should be posted after setting new size
-     */
-    public boolean checkNativePaintOnSetBounds(int width, int height) {
-        // Fix for 4418155. Window does not repaint
-        // automticaly if shrinking. Should not wait for Expose
-        return (width > oldWidth) || (height > oldHeight);
-    }
-
-/* --- DisplayChangedListener Stuff --- */
-
-    native void resetTargetGC(Component target);
-
-    /* Xinerama
-     * called to update our GC when dragged onto another screen
-     */
-    public void draggedToNewScreen(int screenNum) {
-        final int finalScreenNum = screenNum;
-
-        SunToolkit.executeOnEventHandlerThread((Component)target, new Runnable()
-            {
-                public void run() {
-                    displayChanged(finalScreenNum);
-                }
-            });
-    }
-
-    /* Xinerama
-     * called to update our GC when dragged onto another screen
-     */
-    public void displayChanged(int screenNum) {
-        // update our GC
-        resetLocalGC(screenNum);         /* upcall to MCanvasPeer */
-        resetTargetGC(target);           /* call Window.resetGC() via native */
-
-        //propagate to children
-        super.displayChanged(screenNum); /* upcall to MPanelPeer */
-    }
-
-    /**
-     * Helper method that executes the displayChanged(screen) method on
-     * the event dispatch thread.  This method is used in the Xinerama case
-     * and after display mode change events.
-     */
-    private void executeDisplayChangedOnEDT(int screenNum) {
-        final int finalScreenNum = screenNum;
-        Runnable dc = new Runnable() {
-            public void run() {
-                displayChanged(finalScreenNum);
-            }
-        };
-        SunToolkit.executeOnEventHandlerThread((Component)target, dc);
-    }
-
-    /**
-     * From the DisplayChangedListener interface; called from
-     * X11GraphicsDevice when the display mode has been changed.
-     */
-    public void displayChanged() {
-        GraphicsConfiguration gc = getGraphicsConfiguration();
-        int curScreenNum = ((X11GraphicsDevice)gc.getDevice()).getScreen();
-        executeDisplayChangedOnEDT(curScreenNum);
-    }
-
-    /**
-     * From the DisplayChangedListener interface; top-levels do not need
-     * to react to this event.
-     */
-    public void paletteChanged() {
-    }
-
-    public synchronized void addDropTarget() {
-        if (dropTargetCount == 0) {
-            registerX11DropTarget(target);
-        }
-        dropTargetCount++;
-    }
-
-    public synchronized void removeDropTarget() {
-        dropTargetCount--;
-        if (dropTargetCount == 0) {
-            unregisterX11DropTarget(target);
-        }
-    }
-
-    protected synchronized void updateDropTarget() {
-        if (dropTargetCount > 0) {
-            unregisterX11DropTarget(target);
-            registerX11DropTarget(target);
-        }
-    }
-
-    public boolean requestWindowFocus() {
-        return false;
-    }
-
-    public void setModalBlocked(Dialog blocker, boolean blocked) {
-        // do nothing
-    }
-
-    public void postUngrabEvent() {
-        postEvent(new sun.awt.UngrabEvent((Window)target));
-    }
-
-    boolean isOwnerOf(MComponentPeer child) {
-        if (child == null) return false;
-
-        Component comp = child.target;
-        while (comp != null && !(comp instanceof Window)) {
-            comp = getParent_NoClientCode(comp);
-        }
-        if (!(comp instanceof Window)) {
-            return false;
-        }
-
-        while (comp != null && !(comp == target) && !(comp instanceof Dialog)) {
-            comp = getParent_NoClientCode(comp);
-        }
-        return (comp == target);
-    }
-
-    boolean processUngrabMouseEvent(MComponentPeer compPeer, int x_root, int y_root, int type) {
-        switch (type) {
-          case 4: // ButtonPress
-              // Check that the target is the child of the grabbed
-              // window or the child of one of the owned windows of
-              // the grabbed window
-              if (!isOwnerOf(compPeer)) {
-                  postUngrabEvent();
-                  return true;
-              }
-        }
-        return false;
-    }
-
-    private final boolean hasWarningWindow() {
-        return ((Window)target).getWarningString() != null;
-    }
-
-    // This method is overriden at Dialog and Frame peers.
-    boolean isTargetUndecorated() {
-        return true;
-    }
-
-    private volatile int sysX = 0;
-    private volatile int sysY = 0;
-    private volatile int sysW = 0;
-    private volatile int sysH = 0;
-
-    Rectangle constrainBounds(int x, int y, int width, int height) {
-        // We don't restrict the setBounds() operation if the code is trusted.
-        if (!hasWarningWindow()) {
-            return new Rectangle(x, y, width, height);
-        }
-
-        int newX = x;
-        int newY = y;
-        int newW = width;
-        int newH = height;
-
-        GraphicsConfiguration gc = ((Window)target).getGraphicsConfiguration();
-        Rectangle sB = gc.getBounds();
-        Insets sIn = ((Window)target).getToolkit().getScreenInsets(gc);
-
-        int screenW = sB.width - sIn.left - sIn.right;
-        int screenH = sB.height - sIn.top - sIn.bottom;
-
-        // If it's undecorated or is not currently visible,
-        // then check each point is within the visible part of the screen
-        if (!target.isVisible() || isTargetUndecorated()) {
-            int screenX = sB.x + sIn.left;
-            int screenY = sB.y + sIn.top;
-
-            // First make sure the size is withing the visible part of the screen
-            if (newW > screenW) {
-                newW = screenW;
-            }
-
-            if (newH > screenH) {
-                newH = screenH;
-            }
-
-            // Tweak the location if needed
-            if (newX < screenX) {
-                newX = screenX;
-            } else if (newX + newW > screenX + screenW) {
-                newX = screenX + screenW - newW;
-            }
-
-            if (newY < screenY) {
-                newY = screenY;
-            } else if (newY + newH > screenY + screenH) {
-                newY = screenY + screenH - newH;
-            }
-        } else {
-            int maxW = Math.max(screenW, sysW);
-            int maxH = Math.max(screenH, sysH);
-
-            // Make sure the size is withing the visible part of the screen
-            // OR is less that the current size of the window.
-            if (newW > maxW) {
-                newW = maxW;
-            }
-
-            if (newH > maxH) {
-                newH = maxH;
-            }
-        }
-
-        return new Rectangle(newX, newY, newW, newH);
-    }
-
-    public void setBounds(int x, int y, int width, int height, int op) {
-        Rectangle newBounds = constrainBounds(x, y, width, height);
-        super.setBounds(newBounds.x, newBounds.y, newBounds.width, newBounds.height, op);
-    }
-
-    @Override
-    public void setOpacity(float opacity) {
-	// not implemented
-    }
-
-    @Override
-    public void setOpaque(boolean isOpaque) {
-        // no-op
-    }
-
-    @Override
-    public void updateWindow(BufferedImage backBuffer) {
-        // no-op
-    }
-
-    public void repositionSecurityWarning() {
-	// not implemented
-    }
-
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/X11Clipboard.java openjdk/jdk/src/solaris/classes/sun/awt/motif/X11Clipboard.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/X11Clipboard.java	2014-04-09 01:27:40.080656279 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/X11Clipboard.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,151 +0,0 @@
-/*
- * Copyright (c) 1996, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.datatransfer.ClipboardOwner;
-import java.awt.datatransfer.Transferable;
-
-import java.io.IOException;
-
-import java.security.AccessController;
-
-import sun.awt.datatransfer.SunClipboard;
-import sun.awt.datatransfer.TransferableProxy;
-import sun.awt.datatransfer.DataTransferer;
-
-import sun.security.action.GetIntegerAction;
-
-
-/**
- * A class which interfaces with the X11 selection service in order to support
- * data transfer via Clipboard operations. Most of the work is provided by
- * sun.awt.datatransfer.DataTransferer.
- *
- * @author Amy Fowler
- * @author Roger Brinkley
- * @author Danila Sinopalnikov
- * @author Alexander Gerasimov
- *
- * @since JDK1.1
- */
-public class X11Clipboard extends SunClipboard implements X11SelectionHolder {
-
-    private final X11Selection clipboardSelection;
-
-    private static final Object classLock = new Object();
-
-    private static final int defaultPollInterval = 200;
-
-    private static int pollInterval;
-
-    private static int listenedClipboardsCount;
-
-    /**
-     * Creates a system clipboard object.
-     */
-    public X11Clipboard(String name, String selectionName) {
-        super(name);
-        clipboardSelection = new X11Selection(selectionName, this);
-    }
-
-    protected void setContentsNative(Transferable contents) {
-        if (!clipboardSelection.getSelectionOwnership(contents, this)) {
-            // Need to figure out how to inform owner the request failed...
-            this.owner = null;
-            this.contents = null;
-        }
-    }
-
-    public long getID() {
-        return clipboardSelection.atom;
-    }
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void lostSelectionOwnership() {
-        lostOwnershipImpl();
-    }
-
-    protected void clearNativeContext() {
-        clipboardSelection.clearNativeContext();
-    }
-
-    protected long[] getClipboardFormats() {
-        return getClipboardFormats(getID());
-    }
-    private static native long[] getClipboardFormats(long clipboardID);
-
-    protected byte[] getClipboardData(long format)
-          throws IOException {
-        return getClipboardData(getID(), format);
-    }
-    private static native byte[] getClipboardData(long clipboardID, long format)
-            throws IOException;
-
-
-    // Called on the toolkit thread under awtLock.
-    public void checkChange(long[] formats) {
-        if (!clipboardSelection.isOwner()) {
-            super.checkChange(formats);
-        }
-    }
-
-    void checkChangeHere(Transferable contents) {
-        if (areFlavorListenersRegistered()) {
-            super.checkChange(DataTransferer.getInstance().
-                        getFormatsForTransferableAsArray(contents, getDefaultFlavorTable()));
-        }
-    }
-
-    protected void registerClipboardViewerChecked() {
-        if (pollInterval <= 0) {
-            pollInterval = ((Integer)AccessController.doPrivileged(
-                    new GetIntegerAction("awt.datatransfer.clipboard.poll.interval",
-                                         defaultPollInterval))).intValue();
-            if (pollInterval <= 0) {
-                pollInterval = defaultPollInterval;
-            }
-        }
-        synchronized (X11Clipboard.classLock) {
-            if (listenedClipboardsCount++ == 0) {
-                registerClipboardViewer(pollInterval);
-            }
-        }
-    }
-
-    private native void registerClipboardViewer(int pollInterval);
-
-    protected void unregisterClipboardViewerChecked() {
-        synchronized (X11Clipboard.classLock) {
-            if (--listenedClipboardsCount == 0) {
-                unregisterClipboardViewer();
-            }
-        }
-    }
-
-    private native void unregisterClipboardViewer();
-
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/X11DragSourceContextPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/X11DragSourceContextPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/X11DragSourceContextPeer.java	2014-04-08 05:27:04.990897822 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/X11DragSourceContextPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,131 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.Component;
-import java.awt.Cursor;
-import java.awt.Window;
-
-import java.awt.datatransfer.Transferable;
-
-import java.awt.dnd.DragSourceContext;
-import java.awt.dnd.DragSourceDragEvent;
-import java.awt.dnd.DragSourceDropEvent;
-import java.awt.dnd.DragSourceEvent;
-import java.awt.dnd.DragGestureEvent;
-import java.awt.dnd.InvalidDnDOperationException;
-
-import java.awt.event.InputEvent;
-
-import java.util.Map;
-
-import sun.awt.SunToolkit;
-
-import sun.awt.dnd.SunDragSourceContextPeer;
-import sun.awt.dnd.SunDropTargetContextPeer;
-
-/**
- * The X11DragSourceContextPeer class is the class responsible for handling
- * the interaction between the XDnD/Motif DnD subsystem and Java drag sources.
- *
- * @since 1.5
- */
-final class X11DragSourceContextPeer extends SunDragSourceContextPeer {
-
-    private static final X11DragSourceContextPeer theInstance =
-        new X11DragSourceContextPeer(null);
-
-    /**
-     * construct a new X11DragSourceContextPeer
-     */
-
-    private X11DragSourceContextPeer(DragGestureEvent dge) {
-        super(dge);
-    }
-
-    static X11DragSourceContextPeer createDragSourceContextPeer(DragGestureEvent dge) throws InvalidDnDOperationException {
-        theInstance.setTrigger(dge);
-        return theInstance;
-    }
-
-    protected void startDrag(Transferable transferable,
-                             long[] formats, Map formatMap) {
-        Component component = getTrigger().getComponent();
-        Component c = null;
-        MWindowPeer wpeer = null;
-
-        for (c = component; c != null && !(c instanceof java.awt.Window);
-             c = MComponentPeer.getParent_NoClientCode(c));
-
-        if (c instanceof Window) {
-            wpeer = (MWindowPeer)c.getPeer();
-        }
-
-        if (wpeer == null) {
-            throw new InvalidDnDOperationException(
-                "Cannot find top-level for the drag source component");
-        }
-
-        startDrag(component,
-                  wpeer,
-                  transferable,
-                  getTrigger().getTriggerEvent(),
-                  getCursor(),
-                  getCursor() == null ? 0 : getCursor().getType(),
-                  getDragSourceContext().getSourceActions(),
-                  formats,
-                  formatMap);
-
-        /* This implementation doesn't use native context */
-        setNativeContext(0);
-
-        SunDropTargetContextPeer.setCurrentJVMLocalSourceTransferable(transferable);
-    }
-
-    /**
-     * downcall into native code
-     */
-
-    private native long startDrag(Component component,
-                                  MWindowPeer wpeer,
-                                  Transferable transferable,
-                                  InputEvent nativeTrigger,
-                                  Cursor c, int ctype, int actions,
-                                  long[] formats, Map formatMap);
-
-    /**
-     * set cursor
-     */
-
-    public void setCursor(Cursor c) throws InvalidDnDOperationException {
-        SunToolkit.awtLock();
-        super.setCursor(c);
-        SunToolkit.awtUnlock();
-    }
-
-    protected native void setNativeCursor(long nativeCtxt, Cursor c, int cType);
-
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/X11DropTargetContextPeer.java openjdk/jdk/src/solaris/classes/sun/awt/motif/X11DropTargetContextPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/X11DropTargetContextPeer.java	2014-04-08 05:27:04.990897822 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/X11DropTargetContextPeer.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,167 +0,0 @@
-/*
- * Copyright (c) 2003, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.Component;
-import java.awt.peer.ComponentPeer;
-
-import sun.awt.AppContext;
-import sun.awt.SunToolkit;
-
-import sun.awt.dnd.SunDropTargetContextPeer;
-import sun.awt.dnd.SunDropTargetEvent;
-
-/**
- * The X11DropTargetContextPeer class is the class responsible for handling
- * the interaction between the XDnD/Motif DnD subsystem and Java drop targets.
- *
- * @since 1.5
- */
-final class X11DropTargetContextPeer extends SunDropTargetContextPeer {
-
-    /*
-     * A key to store a peer instance for an AppContext.
-     */
-    private static final Object DTCP_KEY = "DropTargetContextPeer";
-
-    private X11DropTargetContextPeer() {}
-
-    public static X11DropTargetContextPeer getPeer(AppContext appContext) {
-        synchronized (_globalLock) {
-            X11DropTargetContextPeer peer =
-                (X11DropTargetContextPeer)appContext.get(DTCP_KEY);
-            if (peer == null) {
-                peer = new X11DropTargetContextPeer();
-                appContext.put(DTCP_KEY, peer);
-            }
-
-            return peer;
-        }
-    }
-
-    /*
-     * Note:
-     * the method can be called on the toolkit thread while holding AWT_LOCK.
-     */
-    private static void postDropTargetEventToPeer(final Component component,
-                                                  final int x, final int y,
-                                                  final int dropAction,
-                                                  final int actions,
-                                                  final long[] formats,
-                                                  final long nativeCtxt,
-                                                  final int eventID) {
-
-        AppContext appContext = SunToolkit.targetToAppContext(component);
-        X11DropTargetContextPeer peer = getPeer(appContext);
-
-        peer.postDropTargetEvent(component, x, y, dropAction, actions, formats,
-                                 nativeCtxt, eventID,
-                                 !SunDropTargetContextPeer.DISPATCH_SYNC);
-    }
-
-    protected void eventProcessed(SunDropTargetEvent e, int returnValue,
-                                  boolean dispatcherDone) {
-        /* If the event was not consumed, send a response to the source. */
-        long ctxt = getNativeDragContext();
-        if (ctxt != 0) {
-            sendResponse(e.getID(), returnValue, ctxt, dispatcherDone,
-                         e.isConsumed());
-        }
-    }
-
-    protected void doDropDone(boolean success, int dropAction,
-                              boolean isLocal) {
-        dropDone(getNativeDragContext(), success, dropAction);
-    }
-
-    protected Object getNativeData(long format) {
-        return getData(getNativeDragContext(), format);
-    }
-
-    protected void processEnterMessage(SunDropTargetEvent event) {
-        if (!processSunDropTargetEvent(event)) {
-            super.processEnterMessage(event);
-        }
-    }
-
-    protected void processExitMessage(SunDropTargetEvent event) {
-        if (!processSunDropTargetEvent(event)) {
-            super.processExitMessage(event);
-        }
-    }
-
-    protected void processMotionMessage(SunDropTargetEvent event,
-                                        boolean operationChanged) {
-        if (!processSunDropTargetEvent(event)) {
-            super.processMotionMessage(event, operationChanged);
-        }
-    }
-
-    protected void processDropMessage(SunDropTargetEvent event) {
-        if (!processSunDropTargetEvent(event)) {
-            super.processDropMessage(event);
-        }
-    }
-
-    // If source is an XEmbedCanvasPeer, passes the event to it for processing and
-    // return true if the event is forwarded to the XEmbed child.
-    // Otherwise, does nothing and return false.
-    private boolean processSunDropTargetEvent(SunDropTargetEvent event) {
-        Object source = event.getSource();
-
-        if (source instanceof Component) {
-            ComponentPeer peer = ((Component)source).getPeer();
-            if (peer instanceof MEmbedCanvasPeer) {
-                MEmbedCanvasPeer mEmbedCanvasPeer = (MEmbedCanvasPeer)peer;
-                /* The native context is the pointer to the XClientMessageEvent
-                   structure. */
-                long ctxt = getNativeDragContext();
-
-                /* If the event is not consumed, pass it to the
-                   MEmbedCanvasPeer for processing. */
-                if (!event.isConsumed()) {
-                    // NOTE: ctxt can be zero at this point.
-                    if (mEmbedCanvasPeer.processXEmbedDnDEvent(ctxt,
-                                                               event.getID())) {
-                        event.consume();
-                        return true;
-                    }
-                }
-            }
-        }
-
-        return false;
-    }
-
-    private native void sendResponse(int eventID, int returnValue,
-                                     long nativeCtxt, boolean dispatcherDone,
-                                     boolean consumed);
-
-    private native void dropDone(long nativeCtxt, boolean success,
-                                 int dropAction);
-
-    private native Object getData(long nativeCtxt, long format);
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/X11SelectionHolder.java openjdk/jdk/src/solaris/classes/sun/awt/motif/X11SelectionHolder.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/X11SelectionHolder.java	2014-04-08 05:27:04.998897941 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/X11SelectionHolder.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 1996, 1998, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-interface X11SelectionHolder {
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    public void lostSelectionOwnership();
-}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/X11Selection.java openjdk/jdk/src/solaris/classes/sun/awt/motif/X11Selection.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/motif/X11Selection.java	2014-04-08 05:27:04.998897941 +0100
+++ openjdk/jdk/src/solaris/classes/sun/awt/motif/X11Selection.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,203 +0,0 @@
-/*
- * Copyright (c) 1996, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.motif;
-
-import java.awt.Toolkit;
-
-import java.awt.datatransfer.Transferable;
-import java.awt.datatransfer.FlavorMap;
-import java.awt.datatransfer.DataFlavor;
-import java.awt.datatransfer.SystemFlavorMap;
-
-import java.util.Map;
-import java.util.SortedMap;
-import java.util.Vector;
-
-import sun.awt.AppContext;
-import sun.awt.SunToolkit;
-
-import sun.awt.datatransfer.DataTransferer;
-
-/*
- * Implements a general interface to the X11 selection mechanism.
- *
- * @author Amy Fowler
- * @author Roger Brinkley
- * @author Danila Sinopalnikov
- * @author Alexander Gerasimov
- *
- * @since JDK1.1
- */
-public class X11Selection {
-
-    static FlavorMap flavorMap = SystemFlavorMap.getDefaultFlavorMap();
-
-    static Vector selections;
-
-    long atom;
-
-    private X11Clipboard clipboard;
-    private X11SelectionHolder holder;
-    private Transferable contents;
-
-    private boolean disposed = false;
-    private byte[] data = null;
-    private boolean dataAvailable = false;
-    private static final Object source = new Object();
-
-    static {
-        // 4154170:  Need to ensure the the toolkit is initialized prior
-        // to executing this initializer
-        Toolkit toolkit = Toolkit.getDefaultToolkit();
-
-        selections = new Vector();
-
-        initIDs();
-        init();
-
-    }
-
-    private static native void initIDs();
-    static native void init();
-
-    public X11Selection(String name, X11Clipboard clipboard) {
-        atom = ((MDataTransferer)DataTransferer.getInstance()).getAtomForTarget(name);
-        selections.addElement(this);
-        this.clipboard = clipboard;
-    }
-
-    private static Object[] getSelectionsArray() {
-        return selections.toArray();
-    }
-
-   /*
-    * methods for acting as selection provider
-    */
-    native boolean pGetSelectionOwnership(Object source,
-                                          Transferable transferable,
-                                          long[] formats,
-                                          Map formatMap,
-                                          X11SelectionHolder holder);
-
-    boolean getSelectionOwnership(Transferable contents,
-                                  X11SelectionHolder holder) {
-        SortedMap formatMap =
-            DataTransferer.getInstance().getFormatsForTransferable
-                (contents, DataTransferer.adaptFlavorMap(flavorMap));
-        long[] formats =
-            DataTransferer.getInstance().keysToLongArray(formatMap);
-        SunToolkit.insertTargetMapping(source, AppContext.getAppContext());
-
-        /*
-         * Update 'contents' and 'holder' fields in the native code under
-         * AWTLock protection to prevent race with lostSelectionOwnership().
-         */
-        SunToolkit.awtLock();
-        try {
-            boolean isOwnerSet = pGetSelectionOwnership(source, contents, formats, formatMap,
-                                                        holder);
-            if (isOwnerSet) {
-                clipboard.checkChangeHere(contents);
-            }
-            return isOwnerSet;
-        } finally {
-            SunToolkit.awtUnlock();
-        }
-    }
-
-    // To be MT-safe this method should be called under awtLock.
-    boolean isOwner() {
-        return holder != null;
-    }
-
-    // NOTE: This method may be called by privileged threads.
-    //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
-    private void lostSelectionOwnership() {
-        if (holder != null) {
-            holder.lostSelectionOwnership();
-            holder = null;
-        }
-        contents = null;
-    }
-
-    native void clearNativeContext();
-
-    /*
-     * Subclasses should override disposeImpl() instead of dispose(). Client
-     * code should always invoke dispose(), never disposeImpl().
-     */
-    protected void disposeImpl() {
-        selections.removeElement(this);
-    }
-
-    public final void dispose() {
-        boolean call_disposeImpl = false;
-
-        if (!disposed) {
-            synchronized (this) {
-                if (!disposed) {
-                    disposed = call_disposeImpl = true;
-                }
-            }
-        }
-
-        if (call_disposeImpl) {
-            disposeImpl();
-        }
-    }
-
-    /**
-     * Finds out all selections that have flavor listeners registered
-     * and returns their atoms.
-     * Upcall from native code.
-     *
-     * @return an array of selection atoms
-     */
-    private static long[] getSelectionAtomsToCheckChange() {
-        Object[] sels = getSelectionsArray();
-        long[] idArray = new long[sels.length];
-        int count = 0;
-
-        for (int i = 0; i < sels.length; i++) {
-            X11Clipboard clipboard = ((X11Selection)sels[i]).clipboard;
-            if (clipboard.areFlavorListenersRegistered()) {
-                idArray[count++] = clipboard.getID();
-            }
-        }
-
-        long[] atomArray = new long[count];
-        System.arraycopy(idArray, 0, atomArray, 0, atomArray.length);
-
-        return atomArray;
-    }
-
-    /**
-     * Upcall from native code.
-     */
-    private void checkChange(long[] formats) {
-        clipboard.checkChange(formats);
-    }
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Button.c openjdk/jdk/src/solaris/native/sun/awt/awt_Button.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Button.c	2014-04-08 05:27:03.426874734 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Button.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,276 +0,0 @@
-/*
- * Copyright (c) 1995, 2001, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-
-#include <jni.h>
-#include <jni_util.h>
-#include "multi_font.h"
-
-#include "awt_Component.h"
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern AwtGraphicsConfigDataPtr
-    copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-
-/*
- * When the -jni switch is thrown, these headers can be deleted.
- */
-#include "java_awt_Button.h"
-#include "sun_awt_motif_MButtonPeer.h"
-#include "sun_awt_motif_MComponentPeer.h"
-
-/* fieldIDs for Button fields that may be accessed from C */
-static struct ButtonIDs {
-    jfieldID label;
-} buttonIDs;
-
-static char emptyString[] = "";
-
-
-/*
- * Class:     java_awt_Button
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for Button.java
-   to initialize the fieldIDs for fields that may be accessed from C */
-
-JNIEXPORT void JNICALL
-Java_java_awt_Button_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    buttonIDs.label =
-      (*env)->GetFieldID(env, cls, "label", "Ljava/lang/String;");
-}
-
-/*
- * client_data is MButtonPeer instance
- */
-static void
-Button_callback (Widget w,
-                 XtPointer client_data,
-                 XmPushButtonCallbackStruct * call_data)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    ConvertEventTimeAndModifiers converted;
-
-    awt_util_convertEventTimeAndModifiers(call_data->event, &converted);
-
-    JNU_CallMethodByName(env, NULL, (jobject)client_data, "action", "(JI)V",
-                         converted.when, converted.modifiers);
-    if ((*env)->ExceptionOccurred (env)) {
-        (*env)->ExceptionDescribe (env);
-        (*env)->ExceptionClear (env);
-    }
-}
-
-/*
- * Class:     sun_awt_motif_MButtonPeer
- * Method:    create
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MButtonPeer_create
-  (JNIEnv * env, jobject this, jobject parent)
-{
-    jobject target;
-    jobject label;
-    struct ComponentData *cdata;
-    struct ComponentData *wdata;
-    char *clabel;
-    Pixel bg;
-    XmString mfstr = NULL;
-    jobject globalRef = awtJNI_CreateAndSetGlobalRef (env, this);
-    jobject font = awtJNI_GetFont (env, this);
-    jboolean IsMultiFont = awtJNI_IsMultiFont (env, font);
-    AwtGraphicsConfigDataPtr adata;
-
-    AWT_LOCK ();
-
-    if (JNU_IsNull (env, parent)) {
-        JNU_ThrowNullPointerException (env, "NullPointerException");
-        AWT_UNLOCK ();
-
-        return;
-    }
-    target = (*env)->GetObjectField (env, this, mComponentPeerIDs.target);
-    wdata = (struct ComponentData *)
-      JNU_GetLongFieldAsPtr(env, parent, mComponentPeerIDs.pData);
-
-    if (JNU_IsNull (env, target) || wdata == NULL) {
-        JNU_ThrowNullPointerException (env, "NullPointerException");
-        AWT_UNLOCK ();
-
-        return;
-    }
-    cdata = ZALLOC (ComponentData);
-    if (cdata == NULL) {
-        JNU_ThrowOutOfMemoryError (env, "OutOfMemoryError");
-        AWT_UNLOCK ();
-        return;
-    }
-    JNU_SetLongFieldFromPtr(env, this, mComponentPeerIDs.pData, cdata);
-
-    adata = copyGraphicsConfigToPeer(env, this);
-
-    XtVaGetValues (wdata->widget, XmNbackground, &bg, NULL);
-
-    label =
-      (*env)->GetObjectField (env, target, buttonIDs.label);
-
-    if (IsMultiFont) {
-        /*
-         * We don't use makeCString() function here.
-         * We create Motif multi-font compound string to display
-         * unicode on the platform which is not spporting unicode.
-         */
-        if (JNU_IsNull (env, label) || ((*env)->GetStringLength (env, label) == 0)) {
-            mfstr = XmStringCreateLocalized ("");
-        } else {
-            mfstr = awtJNI_MakeMultiFontString (env, label, font);
-        }
-
-        cdata->widget = XtVaCreateManagedWidget
-            ("", xmPushButtonWidgetClass,
-             wdata->widget,
-             XmNlabelString, mfstr,
-             XmNrecomputeSize, False,
-             XmNbackground, bg,
-             XmNhighlightOnEnter, False,
-             XmNshowAsDefault, 0,
-             XmNdefaultButtonShadowThickness, 0,
-             XmNmarginTop, 0,
-             XmNmarginBottom, 0,
-             XmNmarginLeft, 0,
-             XmNmarginRight, 0,
-             XmNuserData, (XtPointer) globalRef,
-             XmNscreen, ScreenOfDisplay(awt_display,
-                                        adata->awt_visInfo.screen),
-             NULL);
-        if (mfstr != NULL) {
-            XmStringFree(mfstr);
-            mfstr = NULL;
-        }
-
-    } else {
-        if (JNU_IsNull (env, label)) {
-            clabel = emptyString;
-        } else {
-            clabel = (char *) JNU_GetStringPlatformChars (env, label, NULL);
-            if (clabel == NULL) {        /* Exception? */
-                AWT_UNLOCK ();
-                return;
-            }
-        }
-
-        cdata->widget = XtVaCreateManagedWidget
-            (clabel, xmPushButtonWidgetClass,
-             wdata->widget,
-             XmNrecomputeSize, False,
-             XmNbackground, bg,
-             XmNhighlightOnEnter, False,
-             XmNshowAsDefault, 0,
-             XmNdefaultButtonShadowThickness, 0,
-             XmNmarginTop, 0,
-             XmNmarginBottom, 0,
-             XmNmarginLeft, 0,
-             XmNmarginRight, 0,
-             XmNuserData, (XtPointer) globalRef,
-             XmNscreen, ScreenOfDisplay(awt_display,
-                                        adata->awt_visInfo.screen),
-             NULL);
-
-        if (clabel != emptyString) {
-            JNU_ReleaseStringPlatformChars (env, label, (const char *) clabel);;
-        }
-    }
-
-    XtSetMappedWhenManaged (cdata->widget, False);
-    XtAddCallback (cdata->widget,
-                   XmNactivateCallback,
-                   (XtCallbackProc) Button_callback,
-                   (XtPointer) globalRef);
-
-    AWT_UNLOCK ();
-}
-
-/*
- * Class:     sun_awt_motif_MButtonPeer
- * Method:    setLabel
- * Signature: (Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MButtonPeer_setLabel
-  (JNIEnv * env, jobject this, jstring label)
-{
-    struct ComponentData *wdata;
-    char *clabel;
-    XmString xim;
-
-    AWT_LOCK ();
-
-    wdata = (struct ComponentData *)
-      JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL) {
-        JNU_ThrowNullPointerException (env, "NullPointerException");
-        AWT_UNLOCK ();
-        return;
-    }
-    if (JNU_IsNull (env, label) || ((*env)->GetStringLength (env, label) == 0)) {
-        xim = XmStringCreateLocalized ("");
-    } else {
-        jobject font = awtJNI_GetFont (env, this);
-
-        if (awtJNI_IsMultiFont (env, font)) {
-            xim = awtJNI_MakeMultiFontString (env, label, font);
-        } else {
-            if (JNU_IsNull (env, label)) {
-                clabel = emptyString;
-            } else {
-                clabel = (char *) JNU_GetStringPlatformChars (env, label, NULL);
-
-                if (clabel == NULL) {      /* Exception? */
-                    AWT_UNLOCK ();
-                    return;
-                }
-            }
-
-            xim = XmStringCreate (clabel, "labelFont");
-
-            if (clabel != emptyString) {
-                JNU_ReleaseStringPlatformChars (env, label, (const char *) clabel);;
-            }
-        }
-    }
-
-    XtVaSetValues (wdata->widget, XmNlabelString, xim, NULL);
-    XmStringFree (xim);
-    AWT_FLUSH_UNLOCK ();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Canvas.c openjdk/jdk/src/solaris/native/sun/awt/awt_Canvas.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Canvas.c	2014-04-08 05:27:03.430874794 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Canvas.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,130 +0,0 @@
-/*
- * Copyright (c) 1995, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "java_awt_Canvas.h"
-#include "sun_awt_motif_MCanvasPeer.h"
-#include "sun_awt_motif_MComponentPeer.h"
-#include "color.h"
-#include "canvas.h"
-#include "awt_util.h"
-
-#include "awt_Component.h"
-#include "awt_GraphicsEnv.h"
-
-#include <jni.h>
-#include <jni_util.h>
-#include "multi_font.h"
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern struct X11GraphicsConfigIDs x11GraphicsConfigIDs;
-extern AwtGraphicsConfigDataPtr
-    copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-struct CanvasIDs mCanvasIDs;
-
-/*
- * Class:     sun_awt_motif_MCanvasPeer
- * Method:    create
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MCanvasPeer_create
-  (JNIEnv * env, jobject this, jobject parent)
-{
-    AwtGraphicsConfigDataPtr awtData;
-
-    struct CanvasData *wdata;
-    struct CanvasData *cdata;
-    jobject globalRef = awtJNI_CreateAndSetGlobalRef(env, this);
-
-    AWT_LOCK();
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    cdata = (struct CanvasData *)
-        JNU_GetLongFieldAsPtr(env, parent, mComponentPeerIDs.pData);
-    if (cdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    wdata = ZALLOC(CanvasData);
-    if (wdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-    JNU_SetLongFieldFromPtr(env, this, mComponentPeerIDs.pData, wdata);
-
-    awtData = copyGraphicsConfigToPeer(env, this);
-
-    wdata->comp.widget = awt_canvas_create((XtPointer) globalRef,
-                                           cdata->comp.widget,
-                                           "",
-                                           1, 1, False, NULL, awtData);
-    XtVaSetValues(wdata->comp.widget,
-                  XmNinsertPosition, awt_util_insertCallback,
-                  NULL);
-
-    /* Add an event handler so that we can track focus change requests
-       which will be initiated by Motif in response to ButtonPress events */
-
-    wdata->flags = 0;
-    wdata->shell = cdata->shell;
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MCanvasPeer
- * Method:    resetTargetGC
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MCanvasPeer_resetTargetGC
-(JNIEnv * env, jobject this, jobject target)
-{
-    (*env)->CallVoidMethod(env, target, mCanvasIDs.setGCFromPeerMID);
-}
-
-/*
- * Class:     sun_awt_motif_MCanvasPeer
- * Method:    initIDs
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MCanvasPeer_initIDs
-(JNIEnv * env, jclass cls)
-{
-    jclass canvasCls = (*env)->FindClass(env, "java/awt/Canvas");
-    mCanvasIDs.setGCFromPeerMID =
-     (*env)->GetMethodID(env, canvasCls, "setGCFromPeer","()V");
-
-    DASSERT(mCanvasIDs.setGCFromPeerMID);
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Checkbox.c openjdk/jdk/src/solaris/native/sun/awt/awt_Checkbox.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Checkbox.c	2014-04-08 05:27:03.430874794 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Checkbox.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,428 +0,0 @@
-/*
- * Copyright (c) 1995, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "sun_awt_motif_MComponentPeer.h"
-#include "sun_awt_motif_MCheckboxPeer.h"
-#include "java_awt_Checkbox.h"
-#include "java_awt_CheckboxGroup.h"
-
-#include "awt_Component.h"
-
-#include "multi_font.h"
-#include <jni.h>
-#include <jni_util.h>
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern AwtGraphicsConfigDataPtr
-    copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-
-/* fieldIDs for Checkbox fields that may be accessed from C */
-static struct CheckboxIDs {
-    jfieldID label;
-} checkboxIDs;
-
-static char emptyString[] = "";
-
-
-/*
- * Class:     java_awt_Checkbox
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for Checkbox.java
-   to initialize the fieldIDs for fields that may be accessed from C */
-
-JNIEXPORT void JNICALL
-Java_java_awt_Checkbox_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    checkboxIDs.label =
-      (*env)->GetFieldID(env, cls, "label", "Ljava/lang/String;");
-}
-
-/*
- * client_data is MCheckboxPeer instance pointer
- */
-static void
-Toggle_callback(Widget w,
-                XtPointer client_data,
-                XmAnyCallbackStruct * call_data)
-{
-    Boolean state;
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-    XtVaGetValues(w, XmNset, &state, NULL);
-
-    JNU_CallMethodByName(env, NULL, (jobject) client_data, "action", "(Z)V", state);
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-/*
- * Class:     sun_awt_motif_MCheckboxPeer
- * Method:    create
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MCheckboxPeer_create
-  (JNIEnv * env, jobject this, jobject parent)
-{
-    jobject target;
-    struct ComponentData *bdata;
-    struct ComponentData *wdata;
-    char *clabel;
-#define MAX_ARGC 10
-    Arg args[MAX_ARGC];
-    Cardinal argc;
-    jobject label;
-    XmString mfstr = NULL;
-    jobject font = awtJNI_GetFont(env, this);
-    jboolean isMultiFont = awtJNI_IsMultiFont(env, font);
-    jobject globalRef = awtJNI_CreateAndSetGlobalRef(env, this);
-    AwtGraphicsConfigDataPtr adata;
-    XmFontList fontlist = NULL;
-    Dimension height;
-    Boolean labelIsEmpty = FALSE;
-
-    AWT_LOCK();
-
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-
-        return;
-    }
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-    wdata = (struct ComponentData *)
-      JNU_GetLongFieldAsPtr(env, parent, mComponentPeerIDs.pData);
-
-    if (JNU_IsNull(env, target) || wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-
-        return;
-    }
-    bdata = ZALLOC(ComponentData);
-    if (bdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-
-        return;
-    }
-    JNU_SetLongFieldFromPtr(env, this, mComponentPeerIDs.pData, bdata);
-
-    adata = copyGraphicsConfigToPeer(env, this);
-
-    argc = 0;
-    XtSetArg(args[argc], XmNrecomputeSize, False);
-    argc++;
-    XtSetArg(args[argc], XmNvisibleWhenOff, True);
-    argc++;
-    XtSetArg(args[argc], XmNtraversalOn, True);
-    argc++;
-    XtSetArg(args[argc], XmNspacing, 0);
-    argc++;
-    XtSetArg(args[argc], XmNuserData, (XtPointer) globalRef);
-    argc++;
-    XtSetArg (args[argc], XmNscreen,
-              ScreenOfDisplay(awt_display,
-                              adata->awt_visInfo.screen));
-    argc++;
-
-    label = (*env)->GetObjectField(env, target, checkboxIDs.label);
-
-    // fix for 4383735.
-    // If the label is empty we need to set the indicator size
-    // proportional to the size of the font.
-    // kdm@sparc.spb.su
-    if (JNU_IsNull(env, label) || ((*env)->GetStringLength(env, label) == 0)) {
-        labelIsEmpty = TRUE;
-        if (!JNU_IsNull(env, font)) {
-            mfstr = XmStringCreateLocalized(" ");
-            if (mfstr != NULL) {
-                fontlist = awtJNI_GetFontList(env, font);
-                if (fontlist != NULL) {
-                    height = XmStringHeight(fontlist, mfstr);
-                    XtSetArg(args[argc], XmNindicatorSize, height);
-                    argc++;
-                    XmFontListFree(fontlist);
-                    fontlist = NULL;
-                }
-                XmStringFree(mfstr);
-                mfstr = NULL;
-            }
-        }
-    }
-
-    if (isMultiFont) {
-        /*
-         * We don't use makeCString() function here.
-         * We create Motif multi-font compound string to display
-         * unicode on the platform which is not spporting unicode.
-         */
-        if (labelIsEmpty) {
-            mfstr = XmStringCreateLocalized("");
-        } else {
-            mfstr = awtJNI_MakeMultiFontString(env, label, font);
-        }
-
-        XtSetArg(args[argc], XmNlabelString, mfstr);
-        argc++;
-
-        DASSERT(!(argc > MAX_ARGC));
-        bdata->widget = XmCreateToggleButton(wdata->widget, "", args, argc);
-
-        if (mfstr != NULL) {
-            XmStringFree(mfstr);
-            mfstr = NULL;
-        }
-    } else {
-        if (labelIsEmpty) {
-            clabel = emptyString;
-        } else {
-            clabel = (char *) JNU_GetStringPlatformChars(env, label, NULL);
-
-            if (clabel == NULL) {        /* Exception? */
-                AWT_UNLOCK();
-                return;
-            }
-        }
-
-        DASSERT(!(argc > MAX_ARGC));
-        bdata->widget = XmCreateToggleButton(wdata->widget, clabel, args, argc);
-
-        if (clabel != emptyString) {
-            JNU_ReleaseStringPlatformChars(env, label, (const char *) clabel);;
-        }
-    }
-
-    XtAddCallback(bdata->widget,
-                  XmNvalueChangedCallback,
-                  (XtCallbackProc) Toggle_callback,
-                  (XtPointer) globalRef);
-
-    XtSetMappedWhenManaged(bdata->widget, False);
-    XtManageChild(bdata->widget);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MCheckboxPeer
- * Method:    setLabel
- * Signature: (Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MCheckboxPeer_setLabel
-  (JNIEnv * env, jobject this, jstring label)
-{
-    struct ComponentData *wdata;
-    char *clabel;
-    XmString xim;
-    jobject font;
-
-    AWT_LOCK();
-
-    wdata = (struct ComponentData *)
-      JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (JNU_IsNull(env, label) || ((*env)->GetStringLength(env, label) == 0)) {
-        xim = XmStringCreateLocalized("");
-    } else {
-        font = awtJNI_GetFont(env, this);
-
-        if (awtJNI_IsMultiFont(env, font)) {
-            xim = awtJNI_MakeMultiFontString(env, label, font);
-        } else {
-            clabel = (char *) JNU_GetStringPlatformChars(env, label, NULL);
-
-            if (clabel == NULL) {
-                AWT_UNLOCK();
-                return;
-            }
-            xim = XmStringCreate(clabel, "labelFont");
-
-            JNU_ReleaseStringPlatformChars(env, label, (const char *) clabel);;
-        }
-    }
-
-    XtVaSetValues(wdata->widget, XmNlabelString, xim, NULL);
-    XmStringFree(xim);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MCheckboxPeer
- * Method:    pSetState
- * Signature: (Z)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MCheckboxPeer_pSetState
-  (JNIEnv * env, jobject this, jboolean state)
-{
-    struct ComponentData *bdata;
-
-    AWT_LOCK();
-
-    bdata = (struct ComponentData *)
-      JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (bdata == NULL || bdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaSetValues(bdata->widget, XmNset, (Boolean) state, NULL);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MCheckboxPeer
- * Method:    pGetState
- * Signature: ()Z
- */
-JNIEXPORT jboolean JNICALL Java_sun_awt_motif_MCheckboxPeer_pGetState
-  (JNIEnv * env, jobject this)
-{
-    struct ComponentData *bdata;
-    Boolean               state;
-
-    AWT_LOCK();
-
-    bdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (bdata == NULL || bdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return JNI_FALSE;
-    }
-    XtVaGetValues(bdata->widget, XmNset, &state, NULL);
-    AWT_FLUSH_UNLOCK();
-    return ((state) ? JNI_TRUE : JNI_FALSE);
-}
-
-
-/*
- * Class:     sun_awt_motif_MCheckboxPeer
- * Method:    setCheckboxGroup
- * Signature: (Ljava/awt/CheckboxGroup;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MCheckboxPeer_setCheckboxGroup
-  (JNIEnv * env, jobject this, jobject group)
-{
-    struct ComponentData *bdata;
-
-    AWT_LOCK();
-
-    bdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (bdata == NULL || bdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (JNU_IsNull(env, group)) {
-        XtVaSetValues(bdata->widget,
-                      XmNindicatorType, XmN_OF_MANY,
-                      NULL);
-    } else {
-        XtVaSetValues(bdata->widget,
-                      XmNindicatorType, XmONE_OF_MANY,
-                      NULL);
-    }
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MCheckboxPeer
- * Method:    getIndicatorSize
- * Signature: (V)I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MCheckboxPeer_getIndicatorSize
-  (JNIEnv * env, jobject this)
-{
-    struct ComponentData *wdata;
-    Dimension size;
-
-    AWT_LOCK();
-
-    wdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL || wdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "Null pData");
-        AWT_UNLOCK();
-        return 0;
-    }
-    XtVaGetValues(wdata->widget,
-                  XmNindicatorSize, &size,
-                  NULL);
-
-    AWT_FLUSH_UNLOCK();
-
-    return size;
-}
-
-/*
- * Class:     sun_awt_motif_MCheckboxPeer
- * Method:    getSpacing
- * Signature: (V)I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MCheckboxPeer_getSpacing
-  (JNIEnv * env, jobject this)
-{
-    struct ComponentData *wdata;
-    Dimension dim;
-
-    AWT_LOCK();
-
-    wdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL || wdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "Null pData");
-        AWT_UNLOCK();
-        return 0;
-    }
-    XtVaGetValues(wdata->widget,
-                  XmNspacing, &dim,
-                  NULL);
-
-    AWT_FLUSH_UNLOCK();
-
-    return dim;
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Choice12.c openjdk/jdk/src/solaris/native/sun/awt/awt_Choice12.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Choice12.c	2014-04-08 05:27:03.430874794 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Choice12.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,843 +0,0 @@
-/*
- * Copyright (c) 1995, 2001, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "java_awt_Component.h"
-#include "sun_awt_motif_MComponentPeer.h"
-#include "sun_awt_motif_MChoicePeer.h"
-
-#include "awt_Component.h"
-#include "awt_MToolkit.h"
-
-#include "multi_font.h"
-#include <jni.h>
-#include <jni_util.h>
-#include <Xm/CascadeBG.h>
-
-extern struct ComponentIDs componentIDs;
-extern struct ContainerIDs containerIDs;
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern AwtGraphicsConfigDataPtr
-    copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-
-static void geometry_hook(Widget wid, Widget hooked_widget, XtGeometryHookData call_data) {
-    XtWidgetGeometry *request;
-    JNIEnv *env;
-    struct ChoiceData *cdata;
-    struct WidgetInfo *winfo = NULL;
-
-    jobject target;
-    jobject parent;
-    jint y, height;
-
-    if ((call_data->widget == hooked_widget) &&
-        (call_data->type == XtHpostGeometry) &&
-        (call_data->result == XtGeometryYes)) {
-
-        request = call_data->request;
-
-        env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-        DASSERT(env != NULL);
-
-        winfo=findWidgetInfo(hooked_widget);
-
-        if (winfo != NULL && XmIsRowColumn(hooked_widget)) {
-            target = (*env)->GetObjectField(env, (jobject)winfo->peer, mComponentPeerIDs.target);
-            cdata = (struct ChoiceData *) JNU_GetLongFieldAsPtr(env, (jobject)winfo->peer, mComponentPeerIDs.pData);
-            DASSERT(target != NULL);
-            DASSERT(cdata != NULL && cdata->comp.widget != NULL)
-            if (request->request_mode & CWHeight) {
-                height = (*env)->GetIntField(env, target, componentIDs.height);
-                if (request->height > 0 && request->height != height) {
-                  parent = (*env)->CallObjectMethod(env, target, componentIDs.getParent);
-                  if ((parent != NULL) && ((*env)->GetObjectField(env, parent, containerIDs.layoutMgr) != NULL)) {
-                      y = cdata->bounds_y;
-                      if (request->height < cdata->bounds_height) {
-                          y += (cdata->bounds_height - request->height) / 2;
-                      }
-                      XtVaSetValues(hooked_widget, XmNy, y, NULL);
-                      (*env)->SetIntField(env, target, componentIDs.y, y);
-                  }
-                  if (parent != NULL) {
-                      (*env)->DeleteLocalRef(env, parent);
-                  }
-                }
-                (*env)->SetIntField(env, target, componentIDs.height, request->height);
-            }
-            if (request->request_mode & CWWidth) {
-                (*env)->SetIntField(env, target, componentIDs.width, request->width);
-            }
-            (*env)->DeleteLocalRef(env, target);
-        }
-    }
-}
-
-static void
-Choice_callback(Widget menu_item,
-                jobject this,
-                XmAnyCallbackStruct * cbs)
-{
-    intptr_t index;
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-    XtVaGetValues(menu_item, XmNuserData, &index, NULL);
-    /* index stored in user-data is 1-based instead of 0-based because */
-    /* of a bug in XmNuserData */
-    index--;
-
-    JNU_CallMethodByName(env, NULL, this, "action", "(I)V", (jint)index);
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-static void  addItems
-  (JNIEnv *env, jobject this, jstring *items, jsize nItems, jint index)
-{
-    char *citem = NULL;
-    struct ChoiceData *odata;
-    Widget bw;
-#define MAX_ARGC 10
-    Arg args[MAX_ARGC];
-    Cardinal argc, argc1;
-    jsize i;
-    Pixel bg;
-    Pixel fg;
-    short cols;
-    int32_t sheight;
-    Dimension height;
-    Widget *firstNewItem = NULL;
-
-    XmString mfstr = NULL;
-    XmFontList fontlist = NULL;
-    jobject font = awtJNI_GetFont(env, this);
-    Boolean IsMultiFont = awtJNI_IsMultiFont(env, font);
-
-    if ((items == NULL) || (nItems == 0)) {
-        return;
-    }
-
-    AWT_LOCK();
-
-    odata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (odata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-
-        return;
-    }
-    if (odata->maxitems == 0 || (index + nItems) > odata->maxitems) {
-        odata->maxitems = index + nItems + 20;
-        if (odata->n_items > 0) {
-            /* grow the list of items */
-            odata->items = (Widget *)
-                realloc((void *) (odata->items)
-                        ,sizeof(Widget) * odata->maxitems);
-        } else {
-            odata->items = (Widget *) malloc(sizeof(Widget) * odata->maxitems);
-        }
-        if (odata->items == NULL) {
-            JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-            AWT_UNLOCK();
-            return;
-        }
-    }
-    XtVaGetValues(odata->comp.widget, XmNbackground, &bg, NULL);
-    XtVaGetValues(odata->comp.widget, XmNforeground, &fg, NULL);
-
-    argc = 0;
-    XtSetArg(args[argc], XmNbackground, bg);
-    argc++;
-    XtSetArg(args[argc], XmNforeground, fg);
-    argc++;
-
-    firstNewItem = &(odata->items[index]);
-    for (i = 0; i < nItems; i++) {
-        argc1 = argc;
-        if (IsMultiFont) {
-            mfstr = awtJNI_MakeMultiFontString(env, items[i], font);
-            fontlist = awtJNI_GetFontList(env, font);
-            /* XXX: XmNuserData doesn't seem to work when passing in zero */
-            /* so we increment the index before passing it in. */
-            XtSetArg(args[argc1], XmNuserData, (XtPointer)((intptr_t)(index + i + 1)));
-            argc1++;
-            XtSetArg(args[argc1], XmNfontList, fontlist);
-            argc1++;
-            XtSetArg(args[argc1], XmNlabelString, mfstr);
-            argc1++;
-
-            DASSERT(!(argc1 > MAX_ARGC));
-
-            bw = XmCreatePushButton(odata->menu, "", args, argc1);
-
-            /* Free resurces */
-            if ( fontlist != NULL )
-            {
-                XmFontListFree(fontlist);
-                fontlist = NULL;
-            }
-            if (mfstr != NULL) {
-                XmStringFree(mfstr);
-                mfstr = NULL;
-            }
-        } else {
-            citem = (char *) JNU_GetStringPlatformChars(env, items[i], NULL);
-            /* XXX: XmNuserData doesn't seem to work when passing in zero */
-            /* so we increment the index before passing it in. */
-            XtSetArg(args[argc1], XmNuserData, (XtPointer)((intptr_t)(index + i + 1)));
-            argc1++;
-            DASSERT(!(argc1> MAX_ARGC));
-            bw = XmCreatePushButton(odata->menu, citem, args, argc1);
-            JNU_ReleaseStringPlatformChars(env, items[i], (const char *) citem);
-            citem = NULL;
-        }
-
-         XtAddCallback(bw,
-                       XmNactivateCallback,
-                       (XtCallbackProc) Choice_callback,
-                       (XtPointer) JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.jniGlobalRef));
-        odata->items[index + i] = bw;
-        odata->n_items++;
-    }
-
-    XtManageChildren(firstNewItem, nItems);
-
-    sheight = DisplayHeight(awt_display, DefaultScreen(awt_display));
-
-    XtVaGetValues(odata->menu, XmNheight, &height, NULL);
-
-    while ( height > sheight ) {
-        cols = ++odata->n_columns;
-        XtVaSetValues(odata->menu, XmNnumColumns, cols, NULL);
-        XtVaGetValues(odata->menu, XmNheight, &height, NULL);
-    }
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    create
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MChoicePeer_create
-  (JNIEnv * env, jobject this, jobject parent)
-{
-    struct ChoiceData *odata;
-    struct ComponentData *wdata;
-#undef MAX_ARGC
-#define MAX_ARGC 30
-    Arg args[MAX_ARGC];
-    Cardinal argc;
-    Pixel bg;
-    Pixel fg;
-    Widget label;
-    Widget button;
-    Widget hookobj;
-    jobject globalRef = awtJNI_CreateAndSetGlobalRef(env, this);
-    AwtGraphicsConfigDataPtr adata;
-    jobject target;
-    Dimension width = 0, height = 0;
-    jclass clsDimension;
-    jobject dimension;
-    jobject peer;
-
-    AWT_LOCK();
-
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-
-    adata = copyGraphicsConfigToPeer(env, this);
-
-    wdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,parent,mComponentPeerIDs.pData);
-
-    if (wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-
-        return;
-    }
-
-    odata = ZALLOC(ChoiceData);
-    if (odata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-    JNU_SetLongFieldFromPtr(env,this,mComponentPeerIDs.pData,odata);
-
-    odata->items = NULL;
-    odata->maxitems = 0;
-    odata->n_items = 0;
-    odata->n_columns = 1;
-
-    XtVaGetValues(wdata->widget, XmNbackground, &bg, NULL);
-    XtVaGetValues(wdata->widget, XmNforeground, &fg, NULL);
-
-    argc = 0;
-    XtSetArg(args[argc], XmNx, 0);
-    argc++;
-    XtSetArg(args[argc], XmNy, 0);
-    argc++;
-    XtSetArg(args[argc], XmNvisual, adata->awt_visInfo.visual);
-    argc++;
-    XtSetArg(args[argc], XmNbackground, bg);
-    argc++;
-    XtSetArg(args[argc], XmNforeground, fg);
-    argc++;
-
-    XtSetArg(args[argc], XmNorientation, XmVERTICAL);
-    argc++;
-    XtSetArg(args[argc], XmNpacking, XmPACK_COLUMN);
-    argc++;
-    XtSetArg(args[argc], XmNnumColumns, (short)1);
-    argc++;
-    /* Fix for 4303064 by ibd@sparc.spb.su: pop-up shells will have
-     * ancestor_sensitive False if the parent was insensitive when the shell
-     * was created.  Since XtSetSensitive on the parent will not modify the
-     * resource of the pop-up child, clients are advised to include a resource
-     * specification of the form '*TransientShell.ancestorSensitive: True' in
-     * the application defaults resource file or to otherwise ensure that the
-     * parent is sensitive when creating pop-up shells.
-     */
-    XtSetArg(args[argc], XmNancestorSensitive, True);
-    argc++;
-
-    DASSERT(!(argc > MAX_ARGC));
-    odata->menu = XmCreatePulldownMenu(wdata->widget, "pulldown", args, argc);
-
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-    clsDimension = (*env)->FindClass(env, "java/awt/Dimension");
-    dimension = JNU_CallMethodByName(env,
-                                     NULL,
-                                     this,
-                                     "getPreferredSize",
-                                     "()Ljava/awt/Dimension;").l;
-    DASSERT(clsDimension != NULL);
-    width  = (Dimension)((*env)->GetIntField(env, dimension, (*env)->GetFieldID(env, clsDimension, "width" , "I")));
-    height = (Dimension)((*env)->GetIntField(env, dimension, (*env)->GetFieldID(env, clsDimension, "height", "I")));
-
-    argc = 0;
-    XtSetArg(args[argc], XmNx, 0);
-    argc++;
-    XtSetArg(args[argc], XmNy, 0);
-    argc++;
-    XtSetArg(args[argc], XmNwidth, width);
-    argc++;
-    XtSetArg(args[argc], XmNheight, height);
-    argc++;
-    XtSetArg(args[argc], XmNmarginHeight, 0);
-    argc++;
-    XtSetArg(args[argc], XmNmarginWidth, 0);
-    argc++;
-    XtSetArg(args[argc], XmNrecomputeSize, False);
-    argc++;
-    XtSetArg(args[argc], XmNresizeHeight, False);
-    argc++;
-    XtSetArg(args[argc], XmNresizeWidth, False);
-    argc++;
-    XtSetArg(args[argc], XmNspacing, False);
-    argc++;
-    XtSetArg(args[argc], XmNborderWidth, 0);
-    argc++;
-    XtSetArg(args[argc], XmNnavigationType, XmTAB_GROUP);
-    argc++;
-    XtSetArg(args[argc], XmNtraversalOn, True);
-    argc++;
-    XtSetArg(args[argc], XmNorientation, XmVERTICAL);
-    argc++;
-    XtSetArg(args[argc], XmNadjustMargin, False);
-    argc++;
-    XtSetArg(args[argc], XmNbackground, bg);
-    argc++;
-    XtSetArg(args[argc], XmNforeground, fg);
-    argc++;
-    XtSetArg(args[argc], XmNsubMenuId, odata->menu);
-    argc++;
-    XtSetArg (args[argc], XmNscreen,
-              ScreenOfDisplay(awt_display, adata->awt_visInfo.screen));
-    argc++;
-
-    DASSERT(!(argc > MAX_ARGC));
-    odata->comp.widget = XmCreateOptionMenu(wdata->widget, "", args, argc);
-
-    hookobj = XtHooksOfDisplay(XtDisplayOfObject(odata->comp.widget));
-    XtAddCallback(hookobj,
-                  XtNgeometryHook,
-                  (XtCallbackProc) geometry_hook,
-                  (XtPointer) odata->comp.widget);
-
-    label = XmOptionLabelGadget(odata->comp.widget);
-    if (label != NULL) {
-        XtUnmanageChild(label);
-    }
-    XtSetMappedWhenManaged(odata->comp.widget, False);
-    XtManageChild(odata->comp.widget);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    addItem
- * Signature: (Ljava/lang/String;I)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MChoicePeer_addItem
-  (JNIEnv *env, jobject this, jstring item, jint index)
-{
-    if (JNU_IsNull(env, item)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    addItems(env, this, &item, 1, index);
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    pSelect
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MChoicePeer_pSelect
-  (JNIEnv *env, jobject this, jint index, jboolean init)
-{
-    struct ChoiceData *odata;
-
-    AWT_LOCK();
-
-    odata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (odata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (index > odata->n_items || index < 0) {
-        JNU_ThrowIllegalArgumentException(env, "IllegalArgumentException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaSetValues(odata->comp.widget,
-                  XmNmenuHistory, odata->items[index],
-                  NULL);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    setFont
- * Signature: (Ljava/awt/Font;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MChoicePeer_setFont
-  (JNIEnv *env, jobject this, jobject f)
-{
-    struct ChoiceData *cdata;
-    struct FontData *fdata;
-    XmFontList fontlist;
-    char *err;
-
-    if (JNU_IsNull(env, f)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-
-    fdata = awtJNI_GetFontData(env, f, &err);
-    if (fdata == NULL) {
-        JNU_ThrowInternalError(env, err);
-        AWT_UNLOCK();
-        return;
-    }
-    cdata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (awtJNI_IsMultiFont(env, f)) {
-        fontlist = awtJNI_GetFontList(env, f);
-    } else {
-        fontlist = XmFontListCreate(fdata->xfont, "labelFont");
-    }
-
-    if (fontlist != NULL) {
-        jint i;
-
-        XtVaSetValues(cdata->comp.widget,
-                      XmNfontList, fontlist,
-                      NULL);
-        XtVaSetValues(cdata->menu,
-                      XmNfontList, fontlist,
-                      NULL);
-        for (i = 0; i < cdata->n_items; i++) {
-            XtVaSetValues(cdata->items[i],
-                          XmNfontList, fontlist,
-                          NULL);
-        }
-
-        XmFontListFree(fontlist);
-    } else {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-    }
-    AWT_UNLOCK();
-}
-
-/* Fix for bug 4326619 */
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    freeNativeData
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MChoicePeer_freeNativeData
-  (JNIEnv *env, jobject this)
-{
-    struct ChoiceData *cdata;
-
-    AWT_LOCK();
-
-    cdata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    cdata->n_items = 0;
-    free((void *)cdata->items);
-    cdata->items = NULL;
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    setBackground
- * Signature: (Ljava/awt/Color;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MChoicePeer_setBackground
-  (JNIEnv *env, jobject this, jobject c)
-{
-    struct ChoiceData *bdata;
-    Pixel bg;
-    Pixel fg;
-    WidgetList children;
-    Cardinal numChildren;
-    int32_t i;
-
-    if (JNU_IsNull(env, c)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException: null color");
-        return;
-    }
-    AWT_LOCK();
-
-    bdata = (struct ChoiceData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (bdata == NULL || bdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    /* Get background color */
-    bg = awtJNI_GetColor(env, c);
-
-    /*
-       XmChangeColor(), in addtion to changing the background and
-       selection colors, also changes the foreground color to be
-       what it thinks should be. However, we want to use the color
-       that gets set by setForeground() instead. We therefore need to
-       save the current foreground color here, and then set it again
-       after the XmChangeColor() occurs.
-    */
-    XtVaGetValues(bdata->comp.widget, XmNforeground, &fg, NULL);
-
-    /* Set color */
-    XmChangeColor(bdata->comp.widget, bg);
-    XtVaSetValues(bdata->comp.widget, XmNforeground, fg, NULL);
-
-    /*
-     * The following recursion fixes a bug in Motif 2.1 that caused
-     * black colored choice buttons (change has no effect on Motif 1.2).
-     */
-    XtVaGetValues(bdata->comp.widget,
-                  XmNchildren, &children,
-                  XmNnumChildren, &numChildren,
-                  NULL);
-    for (i = 0; i < numChildren; i++) {
-        XmChangeColor(children[i], bg);
-        XtVaSetValues(children[i], XmNforeground, fg, NULL);
-    }
-
-
-    XmChangeColor(bdata->menu, bg);
-    XtVaSetValues(bdata->menu, XmNforeground, fg, NULL);
-
-    for (i = 0; i < bdata->n_items; i++) {
-        XmChangeColor(bdata->items[i], bg);
-        XtVaSetValues(bdata->items[i], XmNforeground, fg, NULL);
-    }
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    setForeground
- * Signature: (Ljava/awt/Color;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MChoicePeer_setForeground
-  (JNIEnv *env, jobject this, jobject c)
-{
-    struct ChoiceData *bdata;
-    Pixel color;
-    int32_t i;
-
-    if (JNU_IsNull(env, c)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException: null color");
-        return;
-    }
-    AWT_LOCK();
-
-    bdata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (bdata == NULL || bdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    color = awtJNI_GetColor(env, c);
-
-    XtVaSetValues(bdata->comp.widget, XmNforeground, color, NULL);
-
-    XtVaSetValues(bdata->menu, XmNforeground, color, NULL);
-    for (i = 0; i < bdata->n_items; i++) {
-        XtVaSetValues(bdata->items[i], XmNforeground, color, NULL);
-    }
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    pReshape
- * Signature: (IIII)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MChoicePeer_pReshape
-  (JNIEnv *env, jobject this, jint x, jint y, jint w, jint h)
-{
-    struct ChoiceData *cdata;
-    Widget button;
-    jobject target;
-    Dimension width=0, height=0;
-    Position new_y = 0;
-
-    AWT_LOCK();
-
-    cdata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    button = XmOptionButtonGadget(cdata->comp.widget);
-    cdata->bounds_y = y;
-    cdata->bounds_height = h;
-    awt_util_reshape(cdata->comp.widget, x, y, w, h);
-    awt_util_reshape(button, x, y, w, h);
-
-    /* Bug 4255631 Solaris: Size returned by Choice.getSize() does not match
-     * actual size
-     */
-    XtVaGetValues(cdata->comp.widget, XmNy, &new_y, NULL);
-    XtVaGetValues(button, XmNwidth, &width, XmNheight, &height , NULL);
-    awt_util_reshape(cdata->comp.widget, x, new_y, width, height);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    remove
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MChoicePeer_remove
-  (JNIEnv *env, jobject this, jint index)
-{
-    struct ChoiceData *cdata;
-    Widget selected;
-    jint i;
-    short cols;
-    int32_t sheight;
-    Dimension height;
-
-    AWT_LOCK();
-
-    cdata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (index < 0 || index > cdata->n_items) {
-        JNU_ThrowIllegalArgumentException(env, "IllegalArgumentException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtUnmanageChild(cdata->items[index]);
-    awt_util_consumeAllXEvents(cdata->items[index]);
-    awt_util_cleanupBeforeDestroyWidget(cdata->items[index]);
-    XtDestroyWidget(cdata->items[index]);
-    for (i = index; i < cdata->n_items-1; i++) {
-        cdata->items[i] = cdata->items[i + 1];
-        /* need to reset stored index value, (adding 1 to disambiguate it */
-        /* from an arg list terminator)                                   */
-        /* bug fix 4079027 robi.khan@eng                                  */
-        XtVaSetValues(cdata->items[i],  XmNuserData, (XtPointer)((intptr_t)(i+1)), NULL);
-    }
-    cdata->items[cdata->n_items-1] = NULL;
-    cdata->n_items--;
-
-    XtVaGetValues(cdata->menu, XmNheight, &height, NULL);
-
-    sheight = DisplayHeight(awt_display, DefaultScreen(awt_display));
-    cols = cdata->n_columns;
-
-    if (cols >1) {
-        /* first try to remove a column */
-        cols = --cdata->n_columns;
-        XtVaSetValues(cdata->menu, XmNnumColumns, cols, NULL);
-
-        /* then see if it fits, if not add it back */
-        XtVaGetValues(cdata->menu, XmNheight, &height, NULL);
-        if ( height > sheight ) {
-            cols = ++cdata->n_columns;
-            XtVaSetValues(cdata->menu, XmNnumColumns, cols, NULL);
-        }
-    }
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    removeAll
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MChoicePeer_removeAll
-  (JNIEnv *env, jobject this)
-{
-    struct ChoiceData *cdata;
-    Widget selected;
-    jint i;
-
-    AWT_LOCK();
-
-    cdata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    XtUnmanageChildren(cdata->items, cdata->n_items);
-
-    for (i = cdata->n_items-1; i >= 0; i--) {
-        awt_util_consumeAllXEvents(cdata->items[i]);
-        awt_util_cleanupBeforeDestroyWidget(cdata->items[i]);
-        XtDestroyWidget(cdata->items[i]);
-        cdata->items[i] = NULL;
-    }
-
-    cdata->n_items = 0;
-
-    if (cdata->n_columns > 1) {
-        cdata->n_columns = 1;
-        XtVaSetValues(cdata->menu, XmNnumColumns, cdata->n_columns, NULL);
-    }
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    appendItems
- * Signature: ([Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MChoicePeer_appendItems
-  (JNIEnv *env, jobject this, jarray items)
-{
-    struct ChoiceData *odata = NULL;
-    jstring *strItems = NULL;
-    jsize nItems, i; // MP
-
-    if (JNU_IsNull(env, items)) {
-        return;
-    }
-    nItems  = (*env)->GetArrayLength(env, items);
-    if (nItems == 0) {
-        return;
-    }
-
-    AWT_LOCK();
-
-    odata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (odata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        goto cleanup;
-    }
-
-    strItems = (jstring *) malloc(sizeof(jstring) * nItems);
-    if (strItems == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        goto cleanup;
-    }
-
-    for (i = 0; i < nItems; i++) {
-        strItems[i] = (jstring)(*env)->GetObjectArrayElement(env, items, i);
-        if (JNU_IsNull(env, strItems[i])) {
-            JNU_ThrowNullPointerException(env, "NullPointerException");
-            goto cleanup;
-        }
-    }
-
-    addItems(env, this, strItems, nItems, odata->n_items);
-
-cleanup:
-    if (strItems != NULL) {
-        free(strItems);
-    }
-    AWT_UNLOCK();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Choice21.c openjdk/jdk/src/solaris/native/sun/awt/awt_Choice21.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Choice21.c	2014-04-08 05:27:03.430874794 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Choice21.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,764 +0,0 @@
-/*
- * Copyright (c) 2001, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#if MOTIF_VERSION!=2
-    #error This file should only be compiled with motif 2.1
-#endif
-
-#include "awt_p.h"
-#include "java_awt_Component.h"
-#include "java_awt_AWTEvent.h"
-#include "sun_awt_motif_MComponentPeer.h"
-#include "sun_awt_motif_MChoicePeer.h"
-
-#include "awt_Component.h"
-#include "canvas.h"
-
-#include "multi_font.h"
-
-#include <jni.h>
-#include <jni_util.h>
-#include <Xm/ComboBox.h>
-
-#define MAX_VISIBLE 10
-
-extern struct ComponentIDs componentIDs;
-extern struct ContainerIDs containerIDs;
-extern struct MComponentPeerIDs mComponentPeerIDs;
-
-extern AwtGraphicsConfigDataPtr
-    copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-
-/*
-   setSelection
-   Set the selected text on the XmTextField of the XmComboBox.
-*/
-static void
-setSelection(JNIEnv *env,
-              jobject this,
-              Widget comboBox,
-              jint index)
-{
-    jstring item = NULL;
-    jobject target;
-    Widget text=NULL;
-
-    AWT_LOCK();
-    /* Get the java Choice component. */
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-    if (target == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    /* Get the XmTextField widget in the XmComboBox. */
-    text = XtNameToWidget(comboBox, "*Text");
-    /* Get the selected Unicode string from the java Choice component. */
-    item = (jstring) JNU_CallMethodByName(env, NULL,
-        target, "getItem", "(I)Ljava/lang/String;", index).l;
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-    if (!JNU_IsNull(env, item)) {
-        /* Convert the Unicode string to a multibyte string. */
-        char *temp = (char *)JNU_GetStringPlatformChars(env, item, NULL);
-        /* Assign the multibyte string to the XmTextField of the XmComboBox. */
-        XmTextSetString(text, temp);
-        JNU_ReleaseStringPlatformChars(env, item, (const char *)temp);
-    }
-    AWT_UNLOCK();
-}
-
-extern Boolean skipNextNotifyWhileGrabbed;
-extern Boolean skipNextFocusIn;
-
-static void
-GrabShellPopup(Widget grab_shell,
-                jobject this,
-                XmAnyCallbackStruct * call_data)
-{
-    skipNextNotifyWhileGrabbed = True;
-}
-static void
-GrabShellPopdown(Widget grab_shell,
-                jobject this,
-                XmAnyCallbackStruct * call_data)
-{
-    skipNextNotifyWhileGrabbed = True;
-    skipNextFocusIn = True;
-}
-
-static void
-Choice_callback(Widget list,
-                jobject this,
-                XmAnyCallbackStruct * call_data)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    XmListCallbackStruct *cbs = (XmListCallbackStruct *)call_data;
-    struct ChoiceData *cdata;
-
-
-    AWT_LOCK();
-    /* Get the Choice data. */
-    cdata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    setSelection(env, this, cdata->comp.widget, cbs->item_position - 1);
-    /* Get the Choice data. */
-    JNU_CallMethodByName(env, NULL,
-        this, "action", "(I)V", cbs->item_position - 1);
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-    AWT_UNLOCK();
-}
-
-static void
-addItems(JNIEnv *env, jobject this,
-    jstring *items, int32_t nItems, jint index)
-{
-    struct ChoiceData *cdata;
-    int32_t i;
-    Widget list;
-    XmString mfstr = NULL;
-    XmFontList fontlist = NULL;
-    jobject font = awtJNI_GetFont(env, this);
-    Boolean IsMultiFont = awtJNI_IsMultiFont(env, font);
-
-    if ((items == NULL) || (nItems == 0)) {
-        return;
-    }
-
-    AWT_LOCK();
-
-    cdata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (cdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    for (i = 0; i < nItems; ++i) {
-        char *temp = (char *)JNU_GetStringPlatformChars(env, items[i], NULL);
-        mfstr = XmStringCreateLocalized(temp);
-        JNU_ReleaseStringPlatformChars(env, items[i], (const char *)temp);
-        XmComboBoxAddItem(cdata->comp.widget, mfstr, index + i + 1, FALSE);
-
-        if (mfstr != NULL) {
-            XmStringFree(mfstr);
-            mfstr = NULL;
-        }
-    }
-
-    cdata->n_items += nItems;
-
-    list = XtNameToWidget(cdata->comp.widget, "*List");
-    XtVaSetValues(list,
-                  XmNvisibleItemCount, min(MAX_VISIBLE, cdata->n_items),
-                  NULL);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    create
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MChoicePeer_create(JNIEnv * env, jobject this,
-    jobject parent)
-{
-    jobject globalRef = awtJNI_CreateAndSetGlobalRef(env, this);
-
-    struct ComponentData *wdata; /* parent's peer data */
-    struct ChoiceData *cdata;    /* our own peer data */
-    Widget list, text, list_shell;               /* components of drop dowwn list widget */
-
-    AwtGraphicsConfigDataPtr adata;
-    Pixel fg, bg;                /* colors inherited from parent */
-    Dimension width = 0, height = 0;
-    jclass clsDimension;
-    jobject dimension;
-
-#undef MAX_ARGC
-#define MAX_ARGC 30
-    Arg args[MAX_ARGC];
-    int32_t argc;
-
-    AWT_LOCK();
-
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-
-    /* get parent's peer data */
-    wdata = (struct ComponentData *)JNU_GetLongFieldAsPtr(env,
-                parent, mComponentPeerIDs.pData);
-    if (wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    /* create our own peer data */
-    cdata = ZALLOC(ChoiceData);
-    if (cdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-    JNU_SetLongFieldFromPtr(env, this, mComponentPeerIDs.pData, cdata);
-
-    /* get desired size */
-    clsDimension = (*env)->FindClass(env, "java/awt/Dimension");
-    DASSERT(clsDimension != NULL);
-
-    dimension = JNU_CallMethodByName(env, NULL,
-                    this, "getPreferredSize", "()Ljava/awt/Dimension;").l;
-    width  = (Dimension)((*env)->GetIntField(env, dimension,
-                             (*env)->GetFieldID(env, clsDimension,
-                                 "width" , "I")));
-    height = (Dimension)((*env)->GetIntField(env, dimension,
-                             (*env)->GetFieldID(env, clsDimension,
-                                 "height", "I")));
-
-    /* Inherit visual/colors from parent component */
-    XtVaGetValues(wdata->widget, XmNbackground, &bg, NULL);
-    XtVaGetValues(wdata->widget, XmNforeground, &fg, NULL);
-    adata = copyGraphicsConfigToPeer(env, this);
-
-    argc = 0;
-    XtSetArg(args[argc], XmNuserData, (XtPointer)globalRef);            ++argc;
-    XtSetArg(args[argc], XmNx, 0);                                      ++argc;
-    XtSetArg(args[argc], XmNy, 0);                                      ++argc;
-    XtSetArg(args[argc], XmNmarginHeight, 2);                           ++argc;
-    XtSetArg(args[argc], XmNmarginWidth, 1);                            ++argc;
-    XtSetArg(args[argc], XmNvisibleItemCount, 0);                       ++argc;
-    XtSetArg(args[argc], XmNancestorSensitive, True);                   ++argc;
-    /* Don't ding on key press */
-    XtSetArg(args[argc], XmNverifyBell, False);                         ++argc;
-    XtSetArg(args[argc], XmNvisual, adata->awt_visInfo.visual);         ++argc;
-    XtSetArg(args[argc], XmNscreen,
-             ScreenOfDisplay(awt_display, adata->awt_visInfo.screen));  ++argc;
-    XtSetArg(args[argc], XmNbackground, bg);                            ++argc;
-    XtSetArg(args[argc], XmNforeground, fg);                            ++argc;
-
-    DASSERT(!(argc > MAX_ARGC));
-    cdata->comp.widget = XmCreateDropDownList(wdata->widget,
-                                              "combobox", args, argc);
-    cdata->n_items = 0;
-
-    list = XtNameToWidget(cdata->comp.widget, "*List");
-    text = XtNameToWidget(cdata->comp.widget, "*Text");
-    list_shell = XtNameToWidget(cdata->comp.widget, "*GrabShell");
-    XtAddCallback(list_shell,
-                  XmNpopupCallback,
-                  (XtCallbackProc)GrabShellPopup,
-                  globalRef);
-    XtAddCallback(list_shell,
-                  XmNpopdownCallback,
-                  (XtCallbackProc)GrabShellPopdown,
-                  globalRef);
-
-    /*
-     * Bug 4477410:  Setting the width of the XmComboBox made the XmTextField
-     * too small, cutting off the dropdown list knob on the right side. Set
-     * the width of the TextField because it is the widget actually seen.
-    */
-    /* Set the width and height of the TextField widget. */
-    XtVaSetValues(text,
-                  XmNwidth, width,
-                  XmNheight, height,
-                  NULL);
-
-    XtAddCallback(list,
-                  XmNbrowseSelectionCallback,
-                  (XtCallbackProc)Choice_callback,
-                  (XtPointer)globalRef);
-
-    XtAddEventHandler(text, FocusChangeMask, True,
-                      awt_canvas_event_handler, globalRef);
-
-    awt_addWidget(text, cdata->comp.widget, globalRef,
-                  java_awt_AWTEvent_KEY_EVENT_MASK
-                  | java_awt_AWTEvent_MOUSE_EVENT_MASK
-                  | java_awt_AWTEvent_MOUSE_MOTION_EVENT_MASK);
-
-    XtSetMappedWhenManaged(cdata->comp.widget, False);
-    XtManageChild(cdata->comp.widget);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    pSelect
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MChoicePeer_pSelect(JNIEnv *env, jobject this,
-    jint index, jboolean init)
-{
-    struct ChoiceData *cdata;
-    Widget list;
-
-    AWT_LOCK();
-
-    cdata = (struct ChoiceData *)JNU_GetLongFieldAsPtr(env,
-                this, mComponentPeerIDs.pData);
-    if (cdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    list = XtNameToWidget(cdata->comp.widget, "*List");
-
-    XmListDeselectAllItems(list);
-    XmListSelectPos(list, index + 1, False);
-    setSelection(env, this, cdata->comp.widget, index);
-    XmComboBoxUpdate(cdata->comp.widget);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    setFont
- * Signature: (Ljava/awt/Font;)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MChoicePeer_setFont(JNIEnv *env, jobject this,
-    jobject f)
-{
-    struct ChoiceData *cdata;
-    struct FontData *fdata;
-    XmFontList fontlist;
-    Widget list;
-    Widget text;
-    char *err;
-    XmFontListEntry fontentry;
-    Position x=0, y=0;
-
-    if (JNU_IsNull(env, f)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-
-    fdata = awtJNI_GetFontData(env, f, &err);
-    if (fdata == NULL) {
-        JNU_ThrowInternalError(env, err);
-        AWT_UNLOCK();
-        return;
-    }
-
-    cdata = (struct ChoiceData *)JNU_GetLongFieldAsPtr(env,
-                this, mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    /* Make a fontset and set it. */
-    if (awtJNI_IsMultiFont(env, f)) {
-        if (fdata->xfs == NULL) {
-            fdata->xfs = awtJNI_MakeFontSet(env, f);
-        }
-        if (fdata->xfs != NULL) {
-            fontentry = XmFontListEntryCreate("labelFont",
-                                              XmFONT_IS_FONTSET,
-                                              (XtPointer) (fdata->xfs));
-            fontlist = XmFontListAppendEntry(NULL, fontentry);
-            /*
-             * Some versions of motif have a bug in
-             * XmFontListEntryFree() which causes it to free more than it
-             * should.  Use XtFree() instead.  See O'Reilly's
-             * Motif Reference Manual for more information.
-             */
-            XmFontListEntryFree(&fontentry);
-        } else {
-            fontlist = XmFontListCreate(fdata->xfont, "labelFont");
-        }
-    } else {
-        fontlist = XmFontListCreate(fdata->xfont, "labelFont");
-    }
-    XtVaSetValues(cdata->comp.widget,
-                  XmNfontList, fontlist,
-                  NULL);
-    list = XtNameToWidget(cdata->comp.widget, "*List");
-    XtVaSetValues(list,
-                  XmNfontList, fontlist,
-                  NULL);
-
-    text = XtNameToWidget(cdata->comp.widget, "*Text");
-    XtVaSetValues(text,
-                  XmNfontList, fontlist,
-                  NULL);
-    XmFontListFree(fontlist);
-    XtVaGetValues(cdata->comp.widget,
-                  XmNx, &x,
-                  XmNy, &y,
-                  NULL);
-    Java_sun_awt_motif_MChoicePeer_pReshape(env, this, x, y, 0, 0);
-    AWT_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    freeNativeData
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MChoicePeer_freeNativeData(JNIEnv *env, jobject this)
-{
-    /*
-     * Fix for bug 4326619 - not necessary for Motif 2.1
-     */
-}
-
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    setBackground
- * Signature: (Ljava/awt/Color;)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MChoicePeer_setBackground(JNIEnv *env, jobject this,
-    jobject c)
-{
-    struct ChoiceData *cdata;
-    Pixel bg;
-    Pixel fg;
-    int32_t i;
-
-    if (JNU_IsNull(env, c)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException: null color");
-        return;
-    }
-    AWT_LOCK();
-
-    cdata = (struct ChoiceData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    /* Get background color */
-    bg = awtJNI_GetColor(env, c);
-
-    /*
-       XmChangeColor(), in addtion to changing the background and
-       selection colors, also changes the foreground color to be
-       what it thinks should be. However, we want to use the color
-       that gets set by setForeground() instead. We therefore need to
-       save the current foreground color here, and then set it again
-       after the XmChangeColor() occurs.
-    */
-    XtVaGetValues(cdata->comp.widget, XmNforeground, &fg, NULL);
-
-    /* Set color */
-    XmChangeColor(cdata->comp.widget, bg);
-    XtVaSetValues(cdata->comp.widget, XmNforeground, fg, NULL);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    setForeground
- * Signature: (Ljava/awt/Color;)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MChoicePeer_setForeground(JNIEnv *env, jobject this,
-    jobject c)
-{
-    struct ChoiceData *cdata;
-    Pixel color;
-    int32_t i;
-
-    if (JNU_IsNull(env, c)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException: null color");
-        return;
-    }
-    AWT_LOCK();
-
-    cdata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    color = awtJNI_GetColor(env, c);
-
-    XtVaSetValues(cdata->comp.widget, XmNforeground, color, NULL);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    pReshape
- * Signature: (IIII)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MChoicePeer_pReshape(JNIEnv *env, jobject this,
-    jint x, jint y, jint w, jint h)
-{
-    struct ChoiceData *cdata;
-    Widget list;
-    Dimension width = 0, height = 0;
-    jclass clsDimension;
-    jobject dimension;
-    jobject target;
-    Widget text=NULL;
-
-    AWT_LOCK();
-
-    cdata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    if (w == 0) {
-        /* Set the width and height of the TextField widget to the
-         * PreferredSize, based on the font size.
-        */
-        clsDimension = (*env)->FindClass(env, "java/awt/Dimension");
-        DASSERT(clsDimension != NULL);
-        dimension = JNU_CallMethodByName(env, NULL,
-                        this, "getPreferredSize", "()Ljava/awt/Dimension;").l;
-        width  = (Dimension)((*env)->GetIntField(env, dimension,
-                                 (*env)->GetFieldID(env, clsDimension,
-                                     "width" , "I")));
-        height = (Dimension)((*env)->GetIntField(env, dimension,
-                                 (*env)->GetFieldID(env, clsDimension,
-                                     "height", "I")));
-    } else {
-        /* Set the width and height of the TextField widget to the
-         * given values. BorderLayout passes these values, for example.
-        */
-        width = w;
-        height = h;
-    }
-    text = XtNameToWidget(cdata->comp.widget, "*Text");
-    /*
-     * Bug 4477410:  Setting the width of the XmComboBox made the XmTextField
-     * too small, cutting off the dropdown list knob on the right side. Set
-     * the width of the TextField because it is the widget actually seen.
-    */
-    XtVaSetValues(text,
-                  XmNwidth, width,
-                  XmNheight, height,
-                  NULL);
-
-    awt_util_reshape(cdata->comp.widget, x, y, width, height);
-
-    list = XtNameToWidget(cdata->comp.widget, "*List");
-
-    XtVaSetValues(list, XmNwidth, width, NULL);
-
-    /* Set the width and height of the Choice component. */
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-    if (target == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    (*env)->SetIntField(env, target, componentIDs.width, (jint)width);
-    (*env)->SetIntField(env, target, componentIDs.height, (jint)height);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    addItem
- * Signature: (Ljava/lang/String;I)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MChoicePeer_addItem(JNIEnv *env, jobject this,
-    jstring item, jint index)
-{
-    if (JNU_IsNull(env, item)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    addItems(env, this, &item, 1, index);
-}
-
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    appendItems
- * Signature: ([Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MChoicePeer_appendItems(JNIEnv *env, jobject this,
-    jarray items)
-{
-    struct ChoiceData *cdata = NULL;
-    jstring *strItems = NULL;
-    int32_t nItems, i;
-
-    if (JNU_IsNull(env, items)) {
-        return;
-    }
-    nItems  = (*env)->GetArrayLength(env, items);
-    if (nItems == 0) {
-        return;
-    }
-
-    AWT_LOCK();
-
-    cdata = (struct ChoiceData *)JNU_GetLongFieldAsPtr(env,
-                this, mComponentPeerIDs.pData);
-    if (cdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        goto cleanup;
-    }
-
-    strItems = (jstring *)malloc(sizeof(jstring) * nItems);
-    if (strItems == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        goto cleanup;
-    }
-
-    for (i = 0; i < nItems; ++i) {
-        strItems[i] = (jstring)(*env)->GetObjectArrayElement(env,
-                                   items, (jsize)i);
-        if (JNU_IsNull(env, strItems[i])) {
-            JNU_ThrowNullPointerException(env, "NullPointerException");
-            goto cleanup;
-        }
-    }
-
-    addItems(env, this, strItems, nItems, (jint)cdata->n_items);
-
-  cleanup:
-    if (strItems != NULL) {
-        free(strItems);
-    }
-    AWT_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    remove
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MChoicePeer_remove(JNIEnv *env, jobject this,
-    jint index)
-{
-    struct ChoiceData *cdata;
-    Widget list;
-    Widget text=NULL;
-
-    AWT_LOCK();
-
-    cdata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    XmComboBoxDeletePos(cdata->comp.widget, index + 1);
-    --(cdata->n_items);
-
-    list = XtNameToWidget(cdata->comp.widget, "*List");
-    XtVaSetValues(list, XmNvisibleItemCount, min(MAX_VISIBLE, cdata->n_items), NULL);
-
-    if (cdata->n_items == 0) {
-        /* No item is selected, so clear the TextField. */
-        text = XtNameToWidget(cdata->comp.widget, "*Text");
-        XtVaSetValues(text, XmNvalue, "", NULL);
-    }
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MChoicePeer
- * Method:    removeAll
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MChoicePeer_removeAll(JNIEnv *env, jobject this)
-{
-    struct ChoiceData *cdata;
-    int32_t i;
-    Widget text=NULL;
-    Widget list;
-
-    AWT_LOCK();
-
-    cdata = (struct ChoiceData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    for (i = cdata->n_items - 1; i >= 0; --i) {
-        XmComboBoxDeletePos(cdata->comp.widget, i);
-    }
-    cdata->n_items = 0;
-
-    /* No item is selected, so clear the TextField. */
-    text = XtNameToWidget(cdata->comp.widget, "*Text");
-    XtVaSetValues(text, XmNvalue, "", NULL);
-
-    /* should set XmNvisibleItemCount to 1 as 0 is invalid value */
-    list = XtNameToWidget(cdata->comp.widget, "*List");
-    XtVaSetValues(list, XmNvisibleItemCount, 1, NULL);
-
-    AWT_UNLOCK();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Component.c openjdk/jdk/src/solaris/native/sun/awt/awt_Component.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Component.c	2014-04-08 05:27:03.430874794 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Component.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1656 +0,0 @@
-/*
- * Copyright (c) 1995, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-#error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "canvas.h"
-#include "awt_AWTEvent.h"
-#include "VDrawingArea.h"
-#include "awt_KeyboardFocusManager.h"
-#include "awt_MToolkit.h"
-#include "awt_TopLevel.h"
-#include "java_awt_Color.h"
-#include "java_awt_Cursor.h"
-#include "java_awt_Font.h"
-#include "java_awt_Point.h"
-#include "java_awt_Component.h"
-#include "java_awt_AWTEvent.h"
-#include "java_awt_KeyboardFocusManager.h"
-#include "java_awt_event_KeyEvent.h"
-#include "java_awt_event_MouseEvent.h"
-#include "sun_awt_motif_MComponentPeer.h"
-
-#include "multi_font.h"
-#include "jni.h"
-#include "jni_util.h"
-#include <jawt.h>
-#include <Xm/PrimitiveP.h>
-#include <Xm/ManagerP.h>
-#include <Xm/ComboBox.h>
-
-/* CanvasType widgets: Frame, Dialog, Window, Panel, Canvas,
- *                     &  all lightweights (Component, Container)
- */
-#define IsCanvasTypeWidget(w) \
-        XtIsSubclass(w, xmDrawingAreaWidgetClass) ||\
-        XtIsSubclass(w, vDrawingAreaClass)
-
-
-#include "awt_Component.h"
-#include "awt_GraphicsEnv.h"
-
-#include "awt_AWTEvent.h"
-#include "awt_Cursor.h"
-
-extern struct CursorIDs cursorIDs;
-extern struct X11GraphicsConfigIDs x11GraphicsConfigIDs;
-extern struct KeyboardFocusManagerIDs keyboardFocusManagerIDs;
-
-/* fieldIDs for Component fields that may be accessed from C */
-struct ComponentIDs componentIDs;
-
-/*
- * Class:     java_awt_Component
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for Component.java
-   to initialize the fieldIDs for fields that may be accessed from C */
-
-JNIEXPORT void JNICALL
-Java_java_awt_Component_initIDs
-(JNIEnv *env, jclass cls)
-{
-    jclass keyclass = NULL;
-
-    componentIDs.x = (*env)->GetFieldID(env, cls, "x", "I");
-    componentIDs.y = (*env)->GetFieldID(env, cls, "y", "I");
-    componentIDs.width = (*env)->GetFieldID(env, cls, "width", "I");
-    componentIDs.height = (*env)->GetFieldID(env, cls, "height", "I");
-    componentIDs.isPacked = (*env)->GetFieldID(env, cls, "isPacked", "Z");
-    componentIDs.peer =
-        (*env)->GetFieldID(env, cls, "peer", "Ljava/awt/peer/ComponentPeer;");
-    componentIDs.background =
-        (*env)->GetFieldID(env, cls, "background", "Ljava/awt/Color;");
-    componentIDs.foreground =
-        (*env)->GetFieldID(env, cls, "foreground", "Ljava/awt/Color;");
-    componentIDs.graphicsConfig =
-        (*env)->GetFieldID(env, cls, "graphicsConfig",
-                           "Ljava/awt/GraphicsConfiguration;");
-    componentIDs.name =
-        (*env)->GetFieldID(env, cls, "name", "Ljava/lang/String;");
-
-    /* Use _NoClientCode() methods for trusted methods, so that we
-     *  know that we are not invoking client code on trusted threads
-     */
-    componentIDs.getParent =
-        (*env)->GetMethodID(env, cls, "getParent_NoClientCode",
-                            "()Ljava/awt/Container;");
-
-    componentIDs.getLocationOnScreen =
-        (*env)->GetMethodID(env, cls, "getLocationOnScreen_NoTreeLock",
-                            "()Ljava/awt/Point;");
-
-    componentIDs.resetGCMID =
-        (*env)->GetMethodID(env, cls, "resetGC", "()V");
-
-    keyclass = (*env)->FindClass(env, "java/awt/event/KeyEvent");
-    DASSERT (keyclass != NULL);
-
-    componentIDs.isProxyActive =
-        (*env)->GetFieldID(env, keyclass, "isProxyActive",
-                           "Z");
-
-    componentIDs.appContext =
-        (*env)->GetFieldID(env, cls, "appContext",
-                           "Lsun/awt/AppContext;");
-
-    (*env)->DeleteLocalRef(env, keyclass);
-
-    DASSERT(componentIDs.resetGCMID);
-}
-
-/* fieldIDs for MComponentPeer fields that may be accessed from C */
-struct MComponentPeerIDs mComponentPeerIDs;
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for
-   MComponentPeer.java to initialize the fieldIDs for fields that may
-   be accessed from C */
-
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_initIDs
-(JNIEnv *env, jclass cls)
-{
-    mComponentPeerIDs.pData = (*env)->GetFieldID(env, cls, "pData", "J");
-    mComponentPeerIDs.target =
-        (*env)->GetFieldID(env, cls, "target", "Ljava/awt/Component;");
-    mComponentPeerIDs.jniGlobalRef =
-        (*env)->GetFieldID(env, cls, "jniGlobalRef", "J");
-    mComponentPeerIDs.graphicsConfig =
-        (*env)->GetFieldID(env, cls, "graphicsConfig",
-                           "Lsun/awt/X11GraphicsConfig;");
-    mComponentPeerIDs.drawState =
-        (*env)->GetFieldID(env, cls, "drawState", "I");
-    mComponentPeerIDs.isFocusableMID =
-        (*env)->GetMethodID(env, cls, "isFocusable", "()Z");
-}
-
-/* field and method IDs for java.awt.Container. */
-struct ContainerIDs containerIDs;
-
-/*
- * Class:     java_awt_Container
- * Method:    initIDs
- * Signature: ()V
- */
-/* This function gets called from the static initializer for java.awt.Container
-   to initialize the fieldIDs for fields that may be accessed from C */
-JNIEXPORT void JNICALL
-Java_java_awt_Container_initIDs
-(JNIEnv *env, jclass cls)
-{
-    containerIDs.layoutMgr =
-        (*env)->GetFieldID(env, cls, "layoutMgr", "Ljava/awt/LayoutManager;");
-
-    containerIDs.getComponents =
-        (*env)->GetMethodID(env, cls, "getComponents_NoClientCode",
-                            "()[Ljava/awt/Component;");
-    containerIDs.findComponentAt =
-        (*env)->GetMethodID(env, cls, "findComponentAt",
-                            "(IIZ)Ljava/awt/Component;");
-}
-
-/*
- * Fix for 4090493.  When Motif computes indicator size, it uses
- * (effectively) XmTextExtents, so the size of the indicator depends
- * on the text of the label.  The side effect is that if the label
- * text is rendered using different platform fonts (for a single Java
- * logical font) the display is inconsistent.  E.g. for 12pt font
- * English label will have a check mark, while Japanese label will
- * not, because underlying X11 fonts have different metrics.
- *
- * The fix is to override Motif calculations for the indicatorSize and
- * compute it ourselves based on the font metrics for all the platform
- * fonts given Java font maps onto.  Every time we set XmNfontList we
- * should set XmNindicatorSize as well.
- *
- * The logic is in awt_computeIndicatorSize that just compute the
- * arithmetic mean of platform fonts by now.  HIE should take a look
- * at this.
- */
-
-struct changeFontInfo {
-    XmFontList fontList;        /* value to set */
-    Boolean isMultiFont;        /* only need to compute for multifont */
-    struct FontData *fontData;  /* need this to compute indicator size */
-    Dimension indSize;          /* computed once by changeFont */
-
-    Boolean    initialized;
-    Boolean    error;
-    JNIEnv     *env;
-    jobject    fObj;
-};
-
-static void
-changeFont(Widget w, void *info)
-{
-    struct changeFontInfo *f = (struct changeFontInfo *)info;
-    WidgetClass widgetClass;
-
-    if (f->error)
-        return;
-
-    /* Some widgets use no fonts - skip them! */
-    /* Also skip the Text widgets, since they each have their own setFont. */
-    widgetClass = XtClass(w);
-    if (widgetClass == xmDrawingAreaWidgetClass    ||
-        widgetClass == xmScrollBarWidgetClass      ||
-        widgetClass == xmScrolledWindowWidgetClass ||
-        widgetClass == xmComboBoxWidgetClass       ||
-        widgetClass == xmTextWidgetClass           ||
-        widgetClass == xmTextFieldWidgetClass)
-        return;
-
-    if (!f->initialized) {
-        struct FontData *fdata;
-        char *err;
-
-        f->initialized = TRUE;
-
-        fdata = awtJNI_GetFontData(f->env, f->fObj, &err);
-        if (fdata == NULL) {
-            JNU_ThrowInternalError(f->env, err);
-            f->error = TRUE;
-            return;
-        }
-
-        if (awtJNI_IsMultiFont(f->env, f->fObj)) {
-            f->fontList = awtJNI_GetFontList(f->env, f->fObj);
-            f->isMultiFont = TRUE;
-        } else {
-            f->fontList = XmFontListCreate(fdata->xfont, "labelFont");
-            f->isMultiFont = FALSE;
-        }
-
-        if (f->fontList == NULL) {
-            JNU_ThrowNullPointerException(f->env, "NullPointerException");
-            f->error = TRUE;
-            return;
-        }
-    }
-
-    /* Fix for 4090493. */
-    if (f->isMultiFont && XmIsToggleButton(w)) {
-        Dimension indSize;
-
-        /* Compute indicator size if first time through.  Note that
-           ToggleButtons that are children of menus live in different
-           hierarchy (MenuComponent), so we don't check for this case
-           here.  In fact, the only time the XmNfontList is set on
-           MCheckboxMenuItemPeer widget is when it is created. */
-        if (f->indSize == 0)
-            f->indSize = awt_computeIndicatorSize(f->fontData);
-
-        XtVaSetValues(w, XmNfontList, f->fontList, NULL);
-        if (f->indSize != MOTIF_XmINVALID_DIMENSION)
-            XtVaSetValues(w, XmNindicatorSize, f->indSize, NULL);
-    }
-    else {                      /* usual case */
-        XtVaSetValues(w, XmNfontList, f->fontList, NULL);
-    }
-}
-
-static void
-changeForeground(Widget w, void *fg)
-{
-    XtVaSetValues(w, XmNforeground, fg, NULL);
-}
-
-static void
-changeBackground(Widget w, void *bg)
-{
-    Pixel fg;
-
-    XtVaGetValues(w, XmNforeground, &fg, NULL);
-    XmChangeColor(w, (Pixel) bg);
-    XtVaSetValues(w, XmNforeground, fg, NULL);
-}
-
-// Sets widget's traversalOn property into value 'value'
-void setTraversal(Widget w, Boolean value) {
-    if (w == NULL) {
-        return;
-    }
-    if (XmIsPrimitive(w)) {
-        XmPrimitiveWidget prim = (XmPrimitiveWidget)w;
-        prim->primitive.traversal_on = value;
-    } else
-        if (XmIsManager(w)) {
-            XmManagerWidget man = (XmManagerWidget)w;
-            man->manager.traversal_on = value;
-        }
-}
-
-
-AwtGraphicsConfigDataPtr
-getGraphicsConfigFromComponentPeer(JNIEnv *env, jobject this) {
-    AwtGraphicsConfigDataPtr adata;
-    jobject gc_object;
-
-    /* GraphicsConfiguration object of MComponentPeer */
-    gc_object = (*env)->GetObjectField(env, this,
-                                       mComponentPeerIDs.graphicsConfig);
-
-    if (gc_object != NULL) {
-        adata = (AwtGraphicsConfigDataPtr)
-            JNU_GetLongFieldAsPtr(env, gc_object,
-                                  x11GraphicsConfigIDs.aData);
-    } else {
-        adata = getDefaultConfig(DefaultScreen(awt_display));
-    }
-
-    return adata;
-}
-
-AwtGraphicsConfigDataPtr
-copyGraphicsConfigToPeer(JNIEnv *env, jobject this) {
-
-    jobject component_object, gc_object;
-    AwtGraphicsConfigDataPtr adata;
-
-    /**
-     * Copy the GraphicsConfiguration object from Component object to
-     * MComponentPeer object.
-     */
-    component_object = (*env)->GetObjectField(env, this,
-                                              mComponentPeerIDs.target);
-    /* GraphicsConfiguration object of Component */
-    gc_object = (JNU_CallMethodByName(env, NULL, component_object,
-                                      "getGraphicsConfiguration",
-                                      "()Ljava/awt/GraphicsConfiguration;")).l;
-
-    if (gc_object != NULL) {
-        /* Set graphicsConfig field of MComponentPeer */
-        (*env)->SetObjectField (env, this,
-                                mComponentPeerIDs.graphicsConfig,
-                                gc_object);
-        adata = (AwtGraphicsConfigDataPtr)
-            JNU_GetLongFieldAsPtr(env, gc_object,
-                                  x11GraphicsConfigIDs.aData);
-    } else {
-        /* Component was not constructed with a GraphicsConfiguration
-           object */
-        adata = getDefaultConfig(DefaultScreen(awt_display));
-    }
-
-    return adata;
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    getNativeColor
- * Signature  (Ljava/awt/Color;Ljava/awt/GraphicsConfiguration;)I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MComponentPeer_getNativeColor
-(JNIEnv *env, jobject this, jobject color, jobject gc_object) {
-    AwtGraphicsConfigDataPtr adata;
-    adata = (AwtGraphicsConfigDataPtr) JNU_GetLongFieldAsPtr(env, gc_object,
-                                                             x11GraphicsConfigIDs.aData);
-    return awtJNI_GetColorForVis(env, color, adata);
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pInitialize
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pInitialize
-(JNIEnv *env, jobject this)
-{
-    struct ComponentData *cdata;
-    Widget parent;
-    jobject target;
-    jobject globalRef;
-    EventMask xtMask;
-    jlong awtMask = (jlong) 0;
-    AwtGraphicsConfigDataPtr adata;
-    Boolean initialTraversal = False;
-
-    globalRef = (jobject)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.jniGlobalRef);
-
-    adata = copyGraphicsConfigToPeer(env, this);
-
-    AWT_LOCK();
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (JNU_IsNull(env, cdata) || (cdata == NULL)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    /* Allow FileDialog to have its own traversal policy because
-     * it doesn't interfer with our.
-     */
-    if (XtIsSubclass(cdata->widget, xmFileSelectionBoxWidgetClass)) {
-        initialTraversal = True;
-    }
-    XtVaSetValues(cdata->widget,
-                  XmNx, (*env)->GetIntField(env, target, componentIDs.x),
-                  XmNy, (*env)->GetIntField(env, target, componentIDs.y),
-                  XmNvisual, adata->awt_visInfo.visual,
-                  XmNscreen, ScreenOfDisplay(awt_display,
-                                             adata->awt_visInfo.screen),
-                  /**
-                   * From now we keep all but the focus owner widget unable
-                   * to receive focus. This will prevent Motif from unexpected
-                   * focus transfers.
-                   */
-                  XmNtraversalOn, initialTraversal,
-                  NULL);
-
-
-    /* For all but canvas-style components, pre-process
-     * mouse and keyboard events (which means posting them
-     * to the Java EventQueue before dispatching them to Xt).
-     * For canvas-style components ONLY pre-process mouse events
-     * because the input-method currently relies on key events
-     * being processed by Xt first.
-     */
-    awtMask = java_awt_AWTEvent_MOUSE_EVENT_MASK |
-        java_awt_AWTEvent_MOUSE_MOTION_EVENT_MASK;
-    xtMask = ExposureMask | FocusChangeMask;
-
-    if (!IsCanvasTypeWidget(cdata->widget)) {
-        awtMask |= java_awt_AWTEvent_KEY_EVENT_MASK;
-    } else {
-        xtMask |= (KeyPressMask | KeyReleaseMask);
-    }
-    XtAddEventHandler(cdata->widget, xtMask,
-                      True, awt_canvas_event_handler, globalRef);
-
-    awt_addWidget(cdata->widget, cdata->widget, globalRef, awtMask);
-
-    cdata->repaintPending = RepaintPending_NONE;
-
-    AWT_UNLOCK();
-}
-
-/**
- * Updates stacking order of X windows according to the order of children widgets in
- * parent widget
- */
-void restack(Widget parent) {
-    WidgetList children;
-    int32_t num_children;
-    Window *windows;
-    int32_t num_windows = 0;
-    int32_t i;
-    XtVaGetValues(parent,
-                  XmNnumChildren, &num_children,
-                  XmNchildren, &children,
-                  NULL);
-
-    windows = (Window *) XtMalloc(num_children * sizeof(Window));
-    for (i = 0; i < num_children; i++) {
-        if (XtIsRealized(children[i])) {
-            windows[num_windows++] = XtWindow(children[i]);
-        }
-    }
-    XRestackWindows(awt_display, windows, num_windows);
-    XtFree((char *) windows);
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pShow
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pShow
-(JNIEnv *env, jobject this)
-{
-    struct ComponentData *cdata;
-
-    AWT_LOCK();
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    awt_util_show(cdata->widget);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pHide
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pHide
-(JNIEnv *env, jobject this)
-{
-    struct ComponentData *cdata;
-
-    AWT_LOCK();
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    awt_util_hide(cdata->widget);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pEnable
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pEnable
-(JNIEnv *env, jobject this)
-{
-    struct ComponentData *cdata;
-
-    AWT_LOCK();
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    awt_util_enable(cdata->widget);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pDisable
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pDisable
-(JNIEnv *env, jobject this)
-{
-    struct ComponentData *cdata;
-
-    AWT_LOCK();
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    awt_util_disable(cdata->widget);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pReshape
- * Signature: (IIII)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pReshape
-(JNIEnv *env, jobject this, jint x, jint y, jint w, jint h)
-{
-    struct ComponentData *cdata;
-    jint drawState;
-
-    AWT_LOCK();
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    /* Set the draw state */
-    drawState = (*env)->GetIntField(env, this,
-                                    mComponentPeerIDs.drawState);
-    (*env)->SetIntField(env, this,
-                        mComponentPeerIDs.drawState,
-                        drawState | JAWT_LOCK_BOUNDS_CHANGED | JAWT_LOCK_CLIP_CHANGED);
-    awt_util_reshape(cdata->widget, x, y, w, h);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pDispose
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pDispose
-(JNIEnv *env, jobject this)
-{
-    struct ComponentData *cdata;
-
-    AWT_LOCK();
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    XtUnmanageChild(cdata->widget);
-
-    awt_delWidget(cdata->widget);
-    awt_util_consumeAllXEvents(cdata->widget);
-    awt_util_cleanupBeforeDestroyWidget(cdata->widget);
-    XtDestroyWidget(cdata->widget);
-
-    free((void *) cdata);
-    (*env)->SetLongField(env,this,mComponentPeerIDs.pData, (int64_t) 0);
-
-    awtJNI_DeleteGlobalRef(env, this);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pMakeCursorVisible
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pMakeCursorVisible
-(JNIEnv *env, jobject this)
-{
-    struct ComponentData *cdata;
-
-    AWT_LOCK();
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    // need to change, may not be needed
-    // awt_util_setCursor(cdata->widget, cdata->cursor);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-
-/*
- * Call with AWT_LOCK held.
- */
-static jobject
-MComponentPeer_doGetLocationOnScreen(JNIEnv *env, jobject this)
-{
-    jobject point = NULL;
-    struct ComponentData *cdata;
-    int32_t x = 0, y = 0;
-    Screen *widget_screen = NULL;
-    Window child_ignored;
-
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return NULL;
-    }
-    if (!XtIsRealized(cdata->widget)) {
-        JNU_ThrowInternalError(env, "widget not visible on screen");
-        return NULL;
-    }
-
-    /* Translate the component to the screen coordinate system */
-    XtVaGetValues(cdata->widget, XmNscreen, &widget_screen, NULL);
-    XTranslateCoordinates(awt_display, XtWindow(cdata->widget),
-                          XRootWindowOfScreen(widget_screen),
-                          0, 0, &x, &y,
-                          &child_ignored);
-
-    point = JNU_NewObjectByName(env, "java/awt/Point", "(II)V",
-                                (jint)x, (jint)y);
-    if (((*env)->ExceptionOccurred(env)) || JNU_IsNull(env, point)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return NULL;
-    }
-
-    return point;
-}
-
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pGetLocationOnScreen
- * Signature: ()Ljava/awt/Point;
- */
-JNIEXPORT jobject JNICALL
-Java_sun_awt_motif_MComponentPeer_pGetLocationOnScreen(JNIEnv *env,
-                                                       jobject this)
-{
-    jobject point;
-
-    AWT_LOCK();
-    point = MComponentPeer_doGetLocationOnScreen(env, this);
-    AWT_UNLOCK();
-    return point;
-}
-
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pGetLocationOnScreen
- * Signature: (Ljava/awt/Window;Lsun/awt/motif/MWindowPeer;)Ljava/awt/Point;
- */
-JNIEXPORT jobject JNICALL
-Java_sun_awt_motif_MComponentPeer_pGetLocationOnScreen2(
-    JNIEnv *env, jobject this, jobject wtarget, jobject wpeer)
-{
-    jobject point;
-    struct ComponentData *cdata;
-    struct FrameData *wdata;
-    Screen *widget_screen = NULL;
-    Window child_ignored;
-    int32_t x = 0, y = 0;
-
-    AWT_LOCK();
-
-    wdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, wpeer, mComponentPeerIDs.pData);
-
-    if (wdata == NULL || wdata->winData.comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return NULL;
-    }
-    if (!XtIsRealized(wdata->winData.comp.widget)) {
-        JNU_ThrowInternalError(env, "widget not visible on screen");
-        AWT_UNLOCK();
-        return NULL;
-    }
-
-    /*
-     * Translate directly if the parent window is already adopted by WM.
-     */
-    if (wdata->configure_seen) {
-        point = MComponentPeer_doGetLocationOnScreen(env, this);
-        AWT_UNLOCK();
-        return point;
-    }
-
-    /*
-     * We are called while the parent window is still not adopted by
-     * WM (but may already be in the process of being reparented).
-     * Translate to the parent and add parent target's (x,y) to avoid
-     * racing with WM shuffling us into the final position.
-     */
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (cdata == &wdata->winData.comp) { /* called for the window itself */
-        x = y = 0;
-    }
-    else {
-        if (cdata == NULL || cdata->widget == NULL) {
-            JNU_ThrowNullPointerException(env, "NullPointerException");
-            AWT_UNLOCK();
-            return NULL;
-        }
-        if (!XtIsRealized(cdata->widget)) {
-            JNU_ThrowInternalError(env, "widget not visible on screen");
-            AWT_UNLOCK();
-            return NULL;
-        }
-
-        /* Translate to the outer canvas coordinate system first */
-        XtVaGetValues(cdata->widget, XmNscreen, &widget_screen, NULL);
-        XTranslateCoordinates(awt_display, XtWindow(cdata->widget),
-                              XtWindow(wdata->winData.comp.widget),
-                              0, 0, &x, &y,
-                              &child_ignored);
-    }
-
-    x += (*env)->GetIntField(env, wtarget, componentIDs.x);
-    y += (*env)->GetIntField(env, wtarget, componentIDs.y);
-
-    point = JNU_NewObjectByName(env, "java/awt/Point", "(II)V",
-                                (jint)x, (jint)y);
-    if (((*env)->ExceptionOccurred(env)) || JNU_IsNull(env, point)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return NULL;
-    }
-
-    AWT_UNLOCK();
-    return point;
-}
-
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    getParent_NoClientCode
- * Signature: (Ljava/awt/Component)Ljava/awt/Container;
- *
- * NOTE: This method may be called by privileged threads.
- *       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
- */
-JNIEXPORT jobject JNICALL Java_sun_awt_motif_MComponentPeer_getParent_1NoClientCode
-(JNIEnv *env, jclass thisClass, jobject component)
-{
-    jobject parent = NULL;
-
-    /* getParent is actually getParent_NoClientCode() */
-    parent = (*env)->CallObjectMethod(env,component,componentIDs.getParent);
-    DASSERT(!((*env)->ExceptionOccurred(env)));
-    return parent;
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    getComponents_NoClientCode
- * Signature: (Ljava/awt/Container)[Ljava/awt/Component;
- *               REMIND: Signature is incorrect for returned array value
- *
- * NOTE: This method may be called by privileged threads.
- *       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
- */
-JNIEXPORT jobjectArray JNICALL Java_sun_awt_motif_MComponentPeer_getComponents_1NoClientCode
-(JNIEnv *env, jclass thisClass, jobject container)
-{
-    jobjectArray contents = NULL;
-    contents = (*env)->CallObjectMethod(
-        env, container, containerIDs.getComponents);
-    DASSERT(!((*env)->ExceptionOccurred(env)));
-    return contents;
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pSetForeground
- * Signature: (Ljava/awt/Color;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pSetForeground
-(JNIEnv *env, jobject this, jobject c)
-{
-    struct ComponentData *bdata;
-    Pixel color;
-    AwtGraphicsConfigDataPtr adata;
-
-    if (JNU_IsNull(env, c)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-    bdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (bdata == NULL || bdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    adata = getGraphicsConfigFromComponentPeer(env, this);
-
-    color = (Pixel) awtJNI_GetColorForVis (env, c, adata);
-    XtVaSetValues(bdata->widget, XmNforeground, color, NULL);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pSetBackground
- * Signature: (Ljava/awt/Color;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pSetBackground
-(JNIEnv *env, jobject this, jobject c)
-{
-    struct ComponentData *bdata;
-    Pixel color;
-    Pixel fg;
-    AwtGraphicsConfigDataPtr adata;
-
-    if (JNU_IsNull(env, c)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-    bdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (bdata == NULL || bdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    adata = getGraphicsConfigFromComponentPeer(env, this);
-
-    color = (Pixel) awtJNI_GetColorForVis (env, c, adata);
-    XtVaGetValues(bdata->widget, XmNforeground, &fg, NULL);
-    XmChangeColor(bdata->widget, color);
-    XtVaSetValues(bdata->widget, XmNforeground, fg, NULL);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pSetScrollbarBackground
- * Signature: (Ljava/awt/Color;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pSetScrollbarBackground
-(JNIEnv *env, jobject this, jobject c)
-{
-    struct ComponentData *bdata;
-    Pixel color;
-    Pixel fg;
-    int32_t                 i;
-    WidgetList          wlist;
-    Cardinal            wlen = 0;
-
-    /* This method propagates the specified background color to the scrollbars in the composite widget.
-     * Used to set background scrollbar color in List, TextArea, ScrollPane to its parent.
-     */
-    if (JNU_IsNull(env, c)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-    bdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (bdata == NULL || bdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (!XtIsComposite(bdata->widget)) {
-        AWT_UNLOCK();
-        return;
-    }
-    color = (Pixel) awtJNI_GetColor(env, c);
-
-    XtVaGetValues(bdata->widget,
-                  XmNchildren, &wlist,
-                  XmNnumChildren, &wlen,
-                  NULL);
-    if (wlen > 0) { /* this test doesn't make much sense, since wlen
-                       is a Cardinal and cardinal is unsigned int... */
-        for (i=0; i < wlen; i++) {
-            if (XtIsSubclass(wlist[i], xmScrollBarWidgetClass)) {
-                XtVaGetValues(wlist[i], XmNforeground, &fg, NULL);
-                XmChangeColor(wlist[i], color);
-                XtVaSetValues(wlist[i], XmNforeground, fg, NULL);
-            }
-        }
-        XtVaGetValues(bdata->widget, XmNforeground, &fg, NULL);
-        XmChangeColor(bdata->widget, color);
-        XtVaSetValues(bdata->widget, XmNforeground, fg, NULL);
-    }
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pSetInnerForeground
- * Signature: (Ljava/awt/Color;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pSetInnerForeground
-(JNIEnv *env, jobject this, jobject c)
-{
-    struct ComponentData *bdata;
-    Pixel color;
-
-    /* This method propagates the specified foreground color to all its children.
-     * It is called to set foreground color in List, TextArea, ScrollPane.
-     */
-    if (JNU_IsNull(env, c)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-    bdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (bdata == NULL || bdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    color = awtJNI_GetColor(env, c);
-    awt_util_mapChildren(bdata->widget, changeForeground, 1, (void *) color);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pSetFont
- * Signature: (Ljava/awt/Font;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pSetFont
-(JNIEnv *env, jobject this, jobject f)
-{
-    struct ComponentData *cdata;
-
-    struct changeFontInfo finfo = { NULL, FALSE, NULL, 0,
-                                    FALSE, FALSE, NULL, NULL };
-
-    if (JNU_IsNull(env, f)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    finfo.env = env;
-    finfo.fObj = f;
-    awt_util_mapChildren(cdata->widget, changeFont, 1, (void *)&finfo);
-    if (!finfo.error && finfo.fontList != NULL) {
-        XmFontListFree(finfo.fontList);
-    }
-
-    AWT_FLUSH_UNLOCK();
-} /* MComponentPeer.pSetFont() */
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    setTargetBackground
- * Signature: (Ljava/awt/Color;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_setTargetBackground
-(JNIEnv *env, jobject this, jobject c)
-{
-    jobject target = NULL;
-
-    if ((*env)->EnsureLocalCapacity(env, 1) < 0) {
-        return;
-    }
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-    (*env)->SetObjectField(env, target, componentIDs.background, c);
-    (*env)->DeleteLocalRef(env, target);
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    pSetCursor
- * Signature: (Ljava/awt/Cursor;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_pSetCursor
-(JNIEnv *env, jobject this, jobject cursor)
-{
-    Cursor xcursor;
-    struct ComponentData *cdata;
-
-    AWT_LOCK();
-
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL || JNU_IsNull(env, cursor)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    awt_util_setCursor(cdata->widget, getCursor(env, cursor));
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    nativeHandleEvent
- * Signature: (Ljava/awt/AWTEvent;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_nativeHandleEvent
-(JNIEnv *env, jobject this, jobject event)
-{
-    extern void awt_modify_KeyEvent(JNIEnv *env, XEvent * xevent, jobject jevent);
-    jbyteArray array;
-    XEvent *xevent;
-    Widget widget = NULL;
-    Boolean consumed;
-
-    if (JNU_IsNull(env, event)) {
-        return;
-    }
-    AWT_LOCK();
-
-    consumed = (*env)->GetBooleanField(env, event, awtEventIDs.consumed);
-
-    /*
-     * Fix for bug 4280561
-     *
-     * If a menu is up, we must dispatch all XEvents, to allow
-     * mouse grabs to be released and prevent server hangs.
-     */
-    consumed = consumed && !awt_util_focusIsOnMenu(awt_display);
-
-    if (consumed) {
-        AWT_UNLOCK();
-        return;
-    }
-
-    array = (jbyteArray)(*env)->GetObjectField(env, event, awtEventIDs.bdata);
-    if (array == NULL) {
-        AWT_UNLOCK();
-        return;
-    }
-
-    xevent = (XEvent *)(*env)->GetByteArrayElements(env, array, NULL);
-    if (xevent == NULL) {
-        AWT_UNLOCK();
-        return;
-    }
-
-    switch ((*env)->GetIntField(env, event, awtEventIDs.id)) {
-      case java_awt_event_KeyEvent_KEY_RELEASED:
-      case java_awt_event_KeyEvent_KEY_PRESSED:
-          awt_modify_KeyEvent(env, xevent, event);
-          if ((*env)->GetBooleanField(env, event, componentIDs.isProxyActive) == JNI_TRUE) {
-              xevent->xany.send_event = SPECIAL_KEY_EVENT;
-          }
-          break;
-      default:
-          break;
-    }
-    widget = XtWindowToWidget(awt_display, xevent->xany.window);
-
-    if (!((widget == NULL) || (!XtIsObject(widget)) ||
-          (widget->core.being_destroyed))) {
-        /* Queue the event to be handled by the AWT-Motif thread */
-        if (!IsCanvasTypeWidget(widget)) {
-            awt_put_back_event(env, xevent);
-        }
-    }
-
-    (*env)->ReleaseByteArrayElements(env, array, (jbyte *)xevent, JNI_ABORT);
-    (*env)->DeleteLocalRef(env, array);
-
-    AWT_UNLOCK();
-    return;
-}
-
-// Returns the widget from parent's hierarchy which should be
-// used for focus operations. This widget is stored in WidgetInfo
-// structure and should be prepared by the appropriate component
-// type constructor
-Widget getFocusWidget(Widget parent) {
-    struct WidgetInfo * winfo = NULL;
-    DASSERT(parent != NULL);
-    if (parent == NULL) {
-        return NULL;
-    }
-    winfo = findWidgetInfo(parent);
-    if (winfo == NULL) {
-        return NULL;
-    }
-    return winfo->widget;
-}
-
-
-// Returns value of widget's traversalOn property
-Boolean getTraversal(Widget w) {
-    if (w == NULL) {
-        return False;
-    }
-    if (XmIsPrimitive(w)) {
-        XmPrimitiveWidget prim = (XmPrimitiveWidget)w;
-        return prim->primitive.traversal_on;
-    }
-    if (XmIsManager(w)) {
-        XmManagerWidget man = (XmManagerWidget)w;
-        return man->manager.traversal_on;
-    }
-    return False;
-}
-
-
-void processTree(Widget from, Widget to, Boolean action) {
-// Workhorse function that makes sure that the only widgets
-// which have traversalOn == true are the ones on the path from
-// shell to current focus widget. Function uses two widgets -
-// the one which is supposed to have focus currently(from) and
-// the one which will receive focus(to). Function disables and
-// enables the appropriate widgets so 'to' can become focus owner.
-    JNIEnv      *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    int32_t count_from = 0, count_to = 0;
-    Widget parent_from = NULL, parent_to = NULL;
-    Widget * parents_from = NULL, * parents_to = NULL;
-    int32_t index = 0;
-
-    // Count amount of parents up the tree from widget
-    parent_from = from;
-    while (parent_from != NULL) {
-        parent_from = XtParent(parent_from);
-        count_from++;
-    }
-    parent_to = to;
-    while (parent_to != NULL) {
-        parent_to = XtParent(parent_to);
-        count_to++;
-    }
-
-    // Store all the parents in the list. Both list wittingly
-    // have common parts starting from the beginning. We need
-    // to find the end of this common part.
-    parents_from = (Widget*)malloc(count_from*sizeof(Widget*));
-    parents_to = (Widget*)malloc(count_to*sizeof(Widget*));
-    parent_from = from;
-    index = count_from;
-    while (parent_from != NULL) {
-        parents_from[index-1] = parent_from;
-        parent_from = XtParent(parent_from);
-        index--;
-    }
-    parent_to = to;
-    index = count_to;
-    while (parent_to != NULL) {
-        parents_to[index-1] = parent_to;
-        parent_to = XtParent(parent_to);
-        index--;
-    }
-
-    // Process parents list. Find common part which is usually doesn't
-    // require changes. At the exit of the cycle index will point
-    // to the first widget which requeires the change.
-
-    if (from != NULL && to != NULL) {
-        do {
-            if (index >= count_from-1 || index >= count_to-1) {
-                break;
-            }
-            if (parents_from[index] == parents_to[index])
-            {
-                if (XtIsShell(parents_from[index])) {
-                    index++;
-                    continue;
-                }
-                if (action) {
-                    if (getTraversal(parents_from[index])) {
-                        index++;
-                    } else {
-                        break;
-                    }
-                } else {
-                    index++;
-                }
-            } else {
-                break;
-            }
-        } while (True);
-    }
-
-
-    if (action) { // enable the tree starting from uncommon part till 'to'
-        if (to != NULL) {
-            while (index < count_to - 1) {
-                if (!getTraversal(parents_to[index])) {
-                    XtVaSetValues(parents_to[index], XmNtraversalOn, True, NULL);
-                }
-                index++;
-            }
-            XtVaSetValues(to, XmNtraversalOn, True, NULL);
-        }
-    } else if (from != NULL) {
-        // disable the tree starting from uncommon part to 'from'
-        if (parents_from[index] == parents_to[index]) {
-            if (index == count_from - 1) {
-                // 'from' is one of the parents of 'to' - no need
-                // to disable 'from'
-                goto skip_disable;
-            }
-            index++;
-        }
-        while (index < count_from - 1) {
-            if (!XmIsGadget(parents_from[index]) && !XtIsShell(parents_from[index])) {
-                setTraversal(parents_from[index], False);
-            }
-            index++;
-        }
-        if (!XmIsGadget(from)) {
-            setTraversal(parents_from[index], False);
-        }
-    }
-  skip_disable:
-    free(parents_from);
-    free(parents_to);
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    requestFocus
- * Signature: (Ljava/awt/Component;ZZJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_sun_awt_motif_MComponentPeer__1requestFocus
-(JNIEnv *env, jobject this, jobject lightweightChild, jboolean temporary,
-     jboolean focusedWindowChangeAllowed, jlong time, jobject cause)
-{
-    struct ComponentData *bdata;
-    Boolean result;
-    jobject target;
-    jint retval;
-    Widget currentOwner = NULL;
-    jobject curPeer = NULL;
-    Widget shell;
-    Widget widgetToFocus = NULL;
-
-    AWT_LOCK();
-
-    bdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (bdata == NULL || bdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return JNI_FALSE;
-    }
-    if ((*env)->EnsureLocalCapacity(env, 1) < 0) {
-        AWT_UNLOCK();
-        return JNI_FALSE;
-    }
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-    /* Don't need to free target explicitly. That will happen automatically
-       when this function returns. */
-
-    if (target == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return JNI_FALSE;
-    }
-
-    /* The X11 implementation does not permit cross-Window focus transfers,
-       so always pass JNI_FALSE for that parameter. */
-    retval = (*env)->CallStaticIntMethod
-        (env, keyboardFocusManagerIDs.keyboardFocusManagerCls,
-         keyboardFocusManagerIDs.shouldNativelyFocusHeavyweightMID,
-         target, lightweightChild, temporary, JNI_FALSE, time, cause);
-
-    if (retval == java_awt_KeyboardFocusManager_SNFH_SUCCESS_HANDLED) {
-        AWT_UNLOCK();
-        (*env)->DeleteLocalRef(env, target);
-        return JNI_TRUE;
-    }
-    if (retval == java_awt_KeyboardFocusManager_SNFH_FAILURE) {
-        AWT_UNLOCK();
-        (*env)->DeleteLocalRef(env, target);
-        return JNI_FALSE;
-    }
-
-    DASSERT(retval == java_awt_KeyboardFocusManager_SNFH_SUCCESS_PROCEED);
-
-    shell = getShellWidget(bdata->widget);
-    currentOwner = XmGetFocusWidget(shell);
-
-    widgetToFocus = getFocusWidget(bdata->widget);
-
-    globalClearFocusPath(shell);
-
-    // Prepare widgets tree
-    processTree(currentOwner, widgetToFocus, False);
-    processTree(currentOwner, widgetToFocus, True);
-
-    /*
-      Fix for bug 4157017: replace XmProcessTraversal with
-      XtSetKeyboardFocus because XmProcessTraversal does not allow
-      focus to go to non-visible widgets.
-
-      (There is a corresponding change to awt_MToolkit.c:dispatchToWidget)
-
-      I found a last minute problem with this fix i.e. it broke the test
-      case for bug 4053856. XmProcessTraversal does something else (that
-      XtSetKeyboardFocus does not do) that stops this test case from
-      failing. So, as I do not have time to investigate, and having
-      both XmProcessTraversal and XtSetKeyboardFocus fixes 4157017 and
-      4053856 and should be harmless (reviewer agreed), we have both
-      below - XmProcessTraversal AND XtSetKeyboardFocus.
-    */
-    result = XmProcessTraversal(widgetToFocus, XmTRAVERSE_CURRENT);
-    if (!result)
-    {
-        Widget w = widgetToFocus;
-
-        shell = getShellWidget(w);
-        XtSetKeyboardFocus(shell, w);
-    }
-    /* end 4157017 */
-
-    // Because Motif focus callbacks are disabled we need to generate
-    // the required events by ourselves.
-    // First, check if the current focused widget has the entry in focus
-    // list. If not, add it because it is required for further processing
-    if (currentOwner != NULL) {
-        jobject last = NULL;
-        curPeer = findPeer(&currentOwner);
-        if (curPeer == NULL) {
-            currentOwner = findTopLevelByShell(currentOwner);
-            if (currentOwner != NULL) {
-                curPeer = findPeer(&currentOwner);
-            }
-        }
-        if (curPeer != NULL) {
-            curPeer = (*env)->GetObjectField(env, curPeer, mComponentPeerIDs.target);
-            if (focusList == NULL) {
-                awt_canvas_addToFocusListWithDuplicates(curPeer, JNI_TRUE);
-            } else {
-                last = (*env)->NewLocalRef(env, focusList->requestor);
-                if (!(*env)->IsSameObject(env, last, curPeer)) {
-                    awt_canvas_addToFocusList(curPeer);
-                }
-                if (!JNU_IsNull(env, last)) {
-                    (*env)->DeleteLocalRef(env, last);
-                }
-            }
-            (*env)->DeleteLocalRef(env, curPeer);
-        }
-    }
-    awt_canvas_addToFocusList(target);
-
-    // If new and current focus owners are the same do not generate FOCUS_LOST
-    // event because we don't expect it, but generate FOCUS_GAIN because we
-    // wait for it.
-    if ( currentOwner != NULL && !JNU_IsNull(env, curPeer) &&
-         !(*env)->IsSameObject(env, curPeer, target)) {
-        callFocusHandler(currentOwner, FocusOut, cause);
-    }
-    callFocusHandler(widgetToFocus, FocusIn, cause);
-    (*env)->DeleteLocalRef(env, target);
-
-    AWT_FLUSH_UNLOCK();
-    return JNI_TRUE;
-}
-
-Dimension
-awt_computeIndicatorSize(struct FontData *fdata)
-{
-    int32_t height;
-    int32_t acc;
-    int32_t i;
-
-    if (fdata == (struct FontData *) NULL)
-        return MOTIF_XmINVALID_DIMENSION;
-
-    /*
-     * If Java font maps into single platform font - there's no
-     * problem.  Let Motif use its usual calculations in this case.
-     */
-    if (fdata->charset_num == 1)
-        return MOTIF_XmINVALID_DIMENSION;
-
-    acc = 0;
-    for (i = 0; i < fdata->charset_num; ++i) {
-        XFontStruct *xfont = fdata->flist[i].xfont;
-        acc += xfont->ascent + xfont->descent;
-    }
-
-    height = acc / fdata->charset_num;
-    if (height < MOTIF_XmDEFAULT_INDICATOR_DIM)
-        height = MOTIF_XmDEFAULT_INDICATOR_DIM;
-
-    return height;
-}
-
-Dimension
-awt_adjustIndicatorSizeForMenu(Dimension indSize)
-{
-    if (indSize == 0 || indSize == MOTIF_XmINVALID_DIMENSION)
-        return MOTIF_XmINVALID_DIMENSION; /* let motif do the job */
-
-    /* Indicators in menus are smaller.
-       2/3 is a magic number from Motif internals. */
-    indSize = indSize * 2 / 3;
-    if (indSize < MOTIF_XmDEFAULT_INDICATOR_DIM)
-        indSize = MOTIF_XmDEFAULT_INDICATOR_DIM;
-
-    return indSize;
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    getWindow
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_sun_awt_motif_MComponentPeer_getWindow
-(JNIEnv *env, jobject this, jlong pData)
-{
-    jlong ret = (jlong)0;
-    struct ComponentData* cdata;
-    cdata = (struct ComponentData*)pData;
-    AWT_LOCK();
-    ret = (jlong)XtWindow(cdata->widget);
-    AWT_FLUSH_UNLOCK();
-    return ret;
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    restore_Focus
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_restoreFocus
-(JNIEnv *env, jobject this)
-{
-    jobject focus_peer;
-    AWT_LOCK();
-
-    focus_peer = awt_canvas_getFocusOwnerPeer();
-    if (!JNU_IsNull(env, focus_peer)) {
-        struct ComponentData *bdata;
-        Boolean result;
-
-        bdata = (struct ComponentData *)
-            JNU_GetLongFieldAsPtr(env, focus_peer, mComponentPeerIDs.pData);
-        if (bdata != NULL) {
-            Widget widgetToFocus = getFocusWidget(bdata->widget);
-            result = XmProcessTraversal(widgetToFocus, XmTRAVERSE_CURRENT);
-            if (!result)
-            {
-                XtSetKeyboardFocus(getShellWidget(widgetToFocus), widgetToFocus);
-            }
-        }
-    }
-    (*env)->DeleteLocalRef(env, focus_peer);
-
-    AWT_UNLOCK();
-}
-
-JNIEXPORT jboolean JNICALL
-Java_sun_awt_motif_MComponentPeer_processSynchronousLightweightTransfer(
-    JNIEnv * env, jclass cls, jobject heavyweight, jobject descendant,
-    jboolean temporary, jboolean focusedWindowChangeAllowed, jlong time)
-{
-    return (*env)->CallStaticBooleanMethod(env, keyboardFocusManagerIDs.keyboardFocusManagerCls,
-                                           keyboardFocusManagerIDs.processSynchronousTransferMID,
-                                           heavyweight, descendant, temporary,
-                                           focusedWindowChangeAllowed, time);
-}
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    getNativeFocusedWindow
- * Signature: ()Ljava/awt/Window;
- */
-JNIEXPORT jobject JNICALL
-Java_sun_awt_motif_MComponentPeer_getNativeFocusedWindow
-(JNIEnv *env, jclass cls)
-{
-    jobject l_peer;
-
-    AWT_LOCK();
-    l_peer = awt_canvas_getFocusedWindowPeer();
-    AWT_UNLOCK();
-
-    return (l_peer != NULL)
-        ? (*env)->GetObjectField(env, l_peer, mComponentPeerIDs.target)
-        : NULL;
-}
-
-/**
- * Makes sure that child has correct index inside parent
- * Note: there was a short time when we were counting index in the
- * opposite order when it seemed that X and Java z-order notions
- * are different. Now we know they are not: last component is
- * painted first and appears below all other components with
- * smaller indices.
- */
-void ensureIndex(Widget parent, Widget child, int index) {
-    WidgetList children;
-    int32_t num_children;
-    int32_t i;
-
-    if (parent == NULL) {
-        return;
-    }
-    if (child == NULL) {
-        return;
-    }
-    XtVaGetValues(parent,
-                  XmNnumChildren, &num_children,
-                  XmNchildren, &children,
-                  NULL);
-    if (index < 0 || index >= num_children) {
-        return;
-    }
-    if (children[index] != child) {
-        for (i = 0; i < num_children; i++) {
-            if (children[i] == child) {
-                break;
-            }
-        }
-        if (i < num_children) {
-            Widget temp = children[index];
-            children[index] = child;
-            children[i] = temp;
-        }
-    }
-}
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MPanelPeer_pEnsureIndex(JNIEnv * env, jobject this, jobject child, jint index) {
-    struct ComponentData *cdata;
-    Widget w_parent, w_child;
-    AWT_LOCK();
-
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    w_parent = cdata->widget;
-
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, child, mComponentPeerIDs.pData);
-    w_child = cdata->widget;
-    ensureIndex(w_parent, w_child, index);
-    AWT_UNLOCK();
-}
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MPanelPeer_pRestack(JNIEnv * env, jobject this) {
-    struct ComponentData *cdata;
-    Widget w_parent;
-    AWT_LOCK();
-
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    w_parent = cdata->widget;
-    restack(w_parent);
-    AWT_UNLOCK();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Cursor.c openjdk/jdk/src/solaris/native/sun/awt/awt_Cursor.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Cursor.c	2014-04-08 05:27:03.430874794 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Cursor.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,216 +0,0 @@
-/*
- * Copyright (c) 1998, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include <Xm/Display.h>
-#include "awt_Component.h"
-#include "awt_Cursor.h"
-#include "java_awt_Cursor.h"
-#include <X11/cursorfont.h>
-
-#include "jni.h"
-#include "jni_util.h"
-
-/* fieldIDs for Cursor fields that may be accessed from C */
-struct CursorIDs cursorIDs;
-extern struct MComponentPeerIDs mComponentPeerIDs;
-
-static jweak curComp = 0;
-
-/*
- * Class:     java_awt_Cursor
- * Method:    initIDs
- * Signature: ()V
- */
-/*
- * This function gets called from the static initializer for Cursor.java
- * to initialize the fieldIDs for fields that may be accessed from C
- */
-JNIEXPORT void JNICALL
-Java_java_awt_Cursor_initIDs(JNIEnv *env, jclass cls)
-{
-    cursorIDs.type = (*env)->GetFieldID(env, cls, "type", "I");
-    cursorIDs.mSetPData = (*env)->GetMethodID(env, cls, "setPData", "(J)V");
-    cursorIDs.pData = (*env)->GetFieldID(env, cls, "pData", "J");
-}
-
-/*
- * A utility to retrieve cursor from java.awt.Cursor
- * Create and save the cursor first if it is not yet
- */
-Cursor getCursor(JNIEnv *env, jobject jCur)
-{
-    int32_t cursorType = 0;
-    Cursor  xcursor;
-
-    xcursor = (Cursor)(*env)->GetLongField(env, jCur, cursorIDs.pData);
-
-    if (xcursor != None) {
-        return xcursor;
-    }
-
-    cursorType = (*env)->GetIntField(env, jCur, cursorIDs.type);
-
-    DASSERT(cursorType != java_awt_Cursor_CUSTOM_CURSOR);
-
-    switch (cursorType) {
-    case java_awt_Cursor_DEFAULT_CURSOR:
-        cursorType = XC_left_ptr;
-        break;
-    case java_awt_Cursor_CROSSHAIR_CURSOR:
-        cursorType = XC_crosshair;
-        break;
-    case java_awt_Cursor_TEXT_CURSOR:
-        cursorType = XC_xterm;
-        break;
-    case java_awt_Cursor_WAIT_CURSOR:
-        cursorType = XC_watch;
-        break;
-    case java_awt_Cursor_SW_RESIZE_CURSOR:
-        cursorType = XC_bottom_left_corner;
-        break;
-    case java_awt_Cursor_NW_RESIZE_CURSOR:
-        cursorType = XC_top_left_corner;
-        break;
-    case java_awt_Cursor_SE_RESIZE_CURSOR:
-        cursorType = XC_bottom_right_corner;
-        break;
-    case java_awt_Cursor_NE_RESIZE_CURSOR:
-        cursorType = XC_top_right_corner;
-        break;
-    case java_awt_Cursor_S_RESIZE_CURSOR:
-        cursorType = XC_bottom_side;
-        break;
-    case java_awt_Cursor_N_RESIZE_CURSOR:
-        cursorType = XC_top_side;
-        break;
-    case java_awt_Cursor_W_RESIZE_CURSOR:
-        cursorType = XC_left_side;
-        break;
-    case java_awt_Cursor_E_RESIZE_CURSOR:
-        cursorType = XC_right_side;
-        break;
-    case java_awt_Cursor_HAND_CURSOR:
-        cursorType = XC_hand2;
-        break;
-    case java_awt_Cursor_MOVE_CURSOR:
-        cursorType = XC_fleur;
-        break;
-    }
-    xcursor = XCreateFontCursor(awt_display, cursorType);
-
-    (*env)->CallVoidMethod(env, jCur, cursorIDs.mSetPData, xcursor);
-    return xcursor;
-}
-
-/*
- * Class:     java_awt_Cursor
- * Method:    finalizeImpl
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_java_awt_Cursor_finalizeImpl(JNIEnv *env, jclass clazz, jlong pData)
-{
-    Cursor xcursor;
-
-    xcursor = (Cursor)pData;
-    if (xcursor != None) {
-        AWT_LOCK();
-        XFreeCursor(awt_display, xcursor);
-        AWT_UNLOCK();
-    }
-}
-
-/*
- *  normal replace : CACHE_UDPATE  => update curComp and updateCursor
- *  not replace    : UPDATE_ONLY   => intact curComp but updateCursor
- *  only replace   : CACHE_ONLY    => update curComp only, not updateCursor
- *
- *  This function should only be called under AWT_LOCK(). Otherwise
- *  multithreaded access can corrupt the value of curComp variable.
- */
-void updateCursor(XPointer client_data, int32_t replace) {
-
-    static jclass globalCursorManagerClass = NULL;
-    static jmethodID updateCursorID = NULL;
-
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject peer = (jobject) client_data;
-    jobject target;
-
-    if ((*env)->PushLocalFrame(env, 16) < 0)
-        return;
-
-    target = (*env)->GetObjectField(env, peer, mComponentPeerIDs.target);
-    if (replace != UPDATE_ONLY) {
-        if (!JNU_IsNull(env, curComp)) {
-            (*env)->DeleteWeakGlobalRef(env, curComp);
-        }
-        curComp = (*env)->NewWeakGlobalRef(env, target);
-        if (replace == CACHE_ONLY) {
-            (*env)->PopLocalFrame(env, 0);
-            return;
-        }
-    }
-
-    /* Initialize our java identifiers once. Checking before locking
-     * is a huge performance win.
-     */
-    if (globalCursorManagerClass == NULL) {
-        jobject sysClass = (*env)->FindClass(env, "sun/awt/motif/MGlobalCursorManager");
-        if (sysClass != NULL) {
-            /* Make this class 'sticky', we don't want it GC'd */
-            globalCursorManagerClass = (*env)->NewGlobalRef(env, sysClass);
-
-            updateCursorID = (*env)->GetStaticMethodID(env,
-                                                       globalCursorManagerClass,
-                                                       "nativeUpdateCursor",
-                                                       "(Ljava/awt/Component;)V"
-                                                       );
-        }
-        if (JNU_IsNull(env, globalCursorManagerClass) || updateCursorID == NULL) {
-            JNU_ThrowClassNotFoundException(env, "sun/awt/motif/MGlobalCursorManager");
-            (*env)->PopLocalFrame(env, 0);
-            return;
-        }
-    } /* globalCursorManagerClass == NULL*/
-
-    (*env)->CallStaticVoidMethod(env, globalCursorManagerClass,
-                                 updateCursorID, target);
-    DASSERT(!((*env)->ExceptionOccurred(env)));
-    (*env)->PopLocalFrame(env, 0);
-}
-
-/*
- * Only call this function under AWT_LOCK(). Otherwise multithreaded
- * access can corrupt the value of curComp variable.
- */
-jobject getCurComponent() {
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    return (*env)->NewLocalRef(env, curComp);
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_DataTransferer.c openjdk/jdk/src/solaris/native/sun/awt/awt_DataTransferer.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_DataTransferer.c	2014-04-08 05:27:03.434874852 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_DataTransferer.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1068 +0,0 @@
-/*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include <X11/Intrinsic.h>
-#include <X11/Xutil.h>
-
-#include <sys/utsname.h>
-
-#include <jni.h>
-#include <jni_util.h>
-
-#include "sun_awt_datatransfer_DataTransferer.h"
-#include "sun_awt_motif_MDataTransferer.h"
-
-#include "awt_XmDnD.h"
-#include "awt_DataTransferer.h"
-
-static jclass string;
-
-XContext awt_convertDataContext = 0;
-
-Atom XA_TARGETS;
-
-extern struct X11GraphicsConfigIDs x11GraphicsConfigIDs;
-
-typedef enum {
-    SelectionPending,
-    SelectionSuccess,
-    SelectionFailure,
-    SelectionOwnerTimedOut
-} SelectionStatus;
-
-/* Should only be accessed by the current owner of AWT_LOCK. */
-static SelectionStatus globalSelectionStatus = SelectionPending;
-
-static SelectionStatus get_selection_status() {
-    return globalSelectionStatus;
-}
-
-static void set_selection_status(SelectionStatus status) {
-    globalSelectionStatus = status;
-}
-
-static void
-selection_request_filter(Widget widget, XtPointer closure, XEvent *event,
-                         Boolean *cont) {
-    if (event->type == SelectionRequest) {
-        Window awt_root_window = XtWindow(awt_root_shell);
-        Atom selection = event->xselectionrequest.selection;
-        Window owner = XGetSelectionOwner(event->xany.display, selection);
-
-        if (owner != awt_root_window) {
-            XSelectionEvent notify;
-
-            notify.type = SelectionNotify;
-            notify.display = event->xselectionrequest.display;
-            notify.requestor = event->xselectionrequest.requestor;
-            notify.selection = event->xselectionrequest.selection;
-            notify.time = event->xselectionrequest.time;
-            notify.target = event->xselectionrequest.target;
-            notify.property = None;
-
-            XSendEvent(notify.display, notify.requestor, False,
-                       (unsigned long)0, (XEvent*)&notify);
-            *cont = False;
-        }
-    }
-}
-
-/**
- * global function to initialize this client as a Dynamic-only app.
- *
- * gets called once during toolkit initialization.
- */
-
-void awt_initialize_DataTransferer() {
-    JNIEnv* env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jclass stringClassLocal = NULL;
-
-    DASSERT(string == NULL);
-
-    stringClassLocal = (*env)->FindClass(env, "java/lang/String");
-
-    if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-        DASSERT(False);
-    }
-
-    if (JNU_IsNull(env, stringClassLocal)) return;
-
-    string = (*env)->NewGlobalRef(env, stringClassLocal); /* never freed! */
-    (*env)->DeleteLocalRef(env, stringClassLocal);
-
-    if (JNU_IsNull(env, string)) {
-        JNU_ThrowOutOfMemoryError(env, "");
-        return;
-    }
-
-    DASSERT(awt_convertDataContext == 0);
-    awt_convertDataContext = XUniqueContext();
-    DASSERT(awt_convertDataContext != 0);
-
-    /*
-     * Fixes for 4513976 and 4818143.
-     */
-    XtAppSetSelectionTimeout(awt_appContext,
-            JNU_CallStaticMethodByName(env, NULL, "sun/awt/UNIXToolkit",
-                                       "getDatatransferTimeout", "()I").i);
-
-    /*
-     * Xt selection machinery doesn't respond to SelectionRequests if the
-     * event arrives on a widget that is not the current selection owner.
-     * This can happen if XtDisownSelection was called when SelectionRequest was
-     * already on the native queue.
-     * If the requestor is another JVM, it hangs for the selection timeout
-     * as SelectionNotify is never sent.
-     * We install an event handler that filters out SelectionRequests if the
-     * awt_root_shell is not the current selection owner.
-     */
-    XtAddEventHandler(awt_root_shell, (EventMask)0, True,
-                      selection_request_filter, NULL);
-
-    XA_TARGETS = XInternAtom(awt_display, "TARGETS", False);
-}
-
-/*
- * Single routine to convert to target FILE_NAME or _DT_FILENAME
- */
-Boolean
-convertFileType(jbyteArray data, Atom * type, XtPointer * value,
-                unsigned long *length, int32_t *format)
-{
-    /*
-     * Convert the internal representation to an File Name.
-     * The data passed is an array of
-     * null separated bytes. Each series of bytes is a string
-     * that is then converted to an XString which are then put
-     * into an XStringList and put into an XTextProperty for
-     * usage in other programs.
-     *
-     * It would be desireable to have dataConvert to this conversion
-     * but it isn't possible to return a byte array that represents
-     * the XTextProperty.
-     */
-
-    JNIEnv*       env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jboolean      isCopy=JNI_FALSE;
-    XTextProperty tp;
-    jsize         len;
-    jsize         strings = 0;
-    jsize         i;
-    char**        stringList;
-    Status        s;
-    jbyte*        bytes;
-    char*         start;
-    size_t        slen;
-    char*         utf;
-
-    if ((*env)->PushLocalFrame(env, 16) < 0) {
-        return False;
-    }
-
-    /* convert the data to an Array of Byte Elements */
-    bytes = (*env)->GetByteArrayElements(env, data, &isCopy);
-    if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-        (*env)->PopLocalFrame(env, NULL);
-        return False;
-    }
-
-    if (JNU_IsNull(env, bytes)) {
-        (*env)->PopLocalFrame(env, NULL);
-        return False;
-    }
-
-    /* Get the length of the area */
-    len = (*env)->GetArrayLength(env, data);
-    if (len == 0) {
-        (*env)->ReleaseByteArrayElements(env, data, bytes, JNI_ABORT);
-        (*env)->PopLocalFrame(env, NULL);
-        return False;
-    }
-
-    /*
-     * determine the number of lists. The byteArray is null separated list of
-     * strings.
-     */
-    for (i = 0; i < len; i++) {
-        if (bytes[i] == '\0') {
-            strings++;
-        }
-    }
-
-    /* Allocate an X11 string list */
-    stringList = (char **)XtCalloc(strings, sizeof(char *));
-    if (stringList == (char**)NULL) {
-        (*env)->ReleaseByteArrayElements(env, data, bytes, JNI_ABORT);
-        (*env)->PopLocalFrame(env, NULL);
-        return False;
-    }
-
-    for (i = 0; i < strings; i++) {
-        if (i == 0) {
-            start = (char*)bytes;
-        } else {
-            start = (char*)&bytes[slen];
-        }
-
-        /*
-         * if start is a NULL we're at the end of the list
-         * We'll just a have null entry on the end of the list
-         */
-        if (start[0] == '\0') {
-            stringList[i] = NULL;
-            continue;
-        }
-        slen = strlen(start) + 1;
-
-        stringList[i] = (char*)XtCalloc(slen, sizeof(char));
-
-        if (stringList[i] == (char *)NULL) {
-            jsize j;
-
-            (*env)->ReleaseByteArrayElements(env, data, bytes, JNI_ABORT);
-
-            for (j = 0; j < i; j++) {
-                XtFree((void *)stringList[j]);
-            }
-
-            (*env)->PopLocalFrame(env, NULL);
-
-            return False;
-        }
-
-        memcpy((void *)stringList[i], (const void*)start, slen);
-    }
-
-    (*env)->ReleaseByteArrayElements(env, data, bytes, JNI_ABORT);
-    s = XStringListToTextProperty(stringList, strings, &tp);
-
-    /* free the strings that were created */
-    for (i = 0; i < strings; i++) {
-        if (stringList[i] != NULL) {
-            XtFree((void*)stringList[i]);
-        }
-    }
-
-    XtFree((void*)stringList);
-
-    if (s == 0) {
-        (*env)->PopLocalFrame(env, NULL);
-        return False;
-    }
-
-    *value = (XtPointer)XtCalloc(tp.nitems, sizeof(char));
-
-    if (*value == (XtPointer)NULL) {
-        XFree((void*)tp.value);
-
-        (*env)->PopLocalFrame(env, NULL);
-
-        return False;
-    }
-
-    memcpy((void *)(*value), (const void *)tp.value, tp.nitems);
-
-    XFree((void*)tp.value);
-
-    *length = tp.nitems;
-    *type   = tp.encoding;
-    *format = tp.format;
-    (*env)->PopLocalFrame(env, NULL);
-    return True;
-}
-
-/*
- * Class:     sun_awt_motif_MDataTransferer
- * Method:    getAtomForTarget
- * Signature: (Ljava/lang/String;)J
- */
-
-JNIEXPORT jlong JNICALL
-Java_sun_awt_motif_MDataTransferer_getAtomForTarget(JNIEnv *env,
-                                                    jclass cls,
-                                                    jstring targetString)
-{
-    Atom target;
-    char *target_str;
-
-    if (JNU_IsNull(env, targetString)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return -1;
-    }
-    target_str = (char *) JNU_GetStringPlatformChars(env, targetString, NULL);
-
-    AWT_LOCK();
-
-    target = XInternAtom(awt_display, target_str, False);
-
-    AWT_UNLOCK();
-
-    JNU_ReleaseStringPlatformChars(env, targetString,
-                                   (const char *) target_str);
-    return target;
-}
-
-/*
- * Class:     sun_awt_motif_MDataTransferer
- * Method:    getTargetNameForAtom
- * Signature: (J)Ljava/lang/String;
- */
-
-JNIEXPORT jstring JNICALL
-Java_sun_awt_motif_MDataTransferer_getTargetNameForAtom(JNIEnv *env,
-                                                        jclass cls,
-                                                        jlong atom)
-{
-    jstring targetString;
-    char *name;
-
-    AWT_LOCK();
-
-    name = XGetAtomName(awt_display, (Atom) atom);
-
-    if (name == NULL) {
-        JNU_ThrowNullPointerException(env, "Failed to retrieve atom name.");
-        AWT_UNLOCK();
-        return NULL;
-    }
-
-    targetString = (*env)->NewStringUTF(env, (const char *)name);
-
-    if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-        XFree (name);
-        AWT_UNLOCK();
-        return NULL;
-    }
-
-    if (JNU_IsNull(env, targetString)) {
-        JNU_ThrowNullPointerException(env, "Failed to create a string.");
-        XFree (name);
-        AWT_UNLOCK();
-        return NULL;
-    }
-
-    XFree (name);
-
-    AWT_UNLOCK();
-    return targetString;
-}
-
-/*
- * Class:     sun_awt_datatransfer_DataTransferer
- * Method:    dragQueryFile
- * Signature: ([B)[Ljava/lang/String;
- *
- * This method converts a byte array that came from File most likely from a
- * drag operation into a String array.
- */
-
-JNIEXPORT jobjectArray JNICALL
-Java_sun_awt_motif_MDataTransferer_dragQueryFile
-    (JNIEnv *env, jobject this, jbyteArray bytes)
-{
-    XTextProperty tp;
-    jbyte         *value;
-
-    char**        strings  = (char **)NULL;
-    int32_t       nstrings = 0;
-    jobject       filenames;
-    jobject       ret = NULL;
-    int32_t       i;
-    jsize         len;
-    jboolean      isCopy=JNI_FALSE;
-
-    /*
-     * If the length of the byte array is 0 just return a null
-     */
-    len = (*env)->GetArrayLength(env, bytes);
-    if (len == 0) {
-        return NULL;
-    }
-
-    value = (*env)->GetByteArrayElements(env, bytes, &isCopy);
-    if (JNU_IsNull(env, value)) {
-        return NULL;
-    }
-
-    AWT_LOCK();
-
-    tp.encoding = XInternAtom(awt_display, "STRING", False);
-    tp.value    = (unsigned char *)value;
-    tp.nitems   = len;
-    tp.format   = 8;
-
-    /*
-     * Convert the byte stream into a list of X11 strings
-     */
-    if (XTextPropertyToStringList(&tp, &strings, &nstrings) == 0 ||
-        nstrings == 0)
-        {
-            (*env)->ReleaseByteArrayElements(env, bytes, value, JNI_ABORT);
-            AWT_UNLOCK();
-            return NULL;
-        }
-
-    (*env)->ReleaseByteArrayElements(env, bytes, value, JNI_ABORT);
-
-    filenames = (*env)->NewObjectArray(env, nstrings, string, NULL);
-
-    if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-        goto wayout;
-    }
-
-    if (JNU_IsNull(env, filenames)) {
-        goto wayout;
-    }
-
-    /*
-     * Actuall conversion code per X11 String
-     */
-    for (i = 0; i < nstrings; i++) {
-        jstring string = (*env)->NewStringUTF(env,
-                                              (const char *)strings[i]);
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-            goto wayout;
-        }
-
-        if (JNU_IsNull(env, string)) {
-            goto wayout;
-        }
-
-        (*env)->SetObjectArrayElement(env, filenames, i, string);
-
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-            goto wayout;
-        }
-
-        (*env)->DeleteLocalRef(env, string);
-    }
-
-    ret = filenames;
- wayout:
-    /*
-     * Clean up and return
-     */
-    XFreeStringList(strings);
-    AWT_UNLOCK();
-    return ret;
-}
-
-DECLARE_JAVA_CLASS(dataTransfererClazz, "sun/awt/datatransfer/DataTransferer")
-
-/**
- * Returns a local reference to the singleton DataTransferer instance.
- * The caller should delete the reference when done.
- */
-static jobject
-get_data_transferer(JNIEnv* env) {
-    jobject transferer = NULL;
-
-    DECLARE_STATIC_OBJECT_JAVA_METHOD(getInstanceMethodID, dataTransfererClazz,
-                                     "getInstance",
-                                     "()Lsun/awt/datatransfer/DataTransferer;");
-
-    transferer = (*env)->CallStaticObjectMethod(env, clazz, getInstanceMethodID);
-
-    if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-
-    DASSERT(!JNU_IsNull(env, transferer));
-
-    return transferer;
-}
-
-static jobject
-call_convertData(JNIEnv* env, jobject source, jobject contents, jlong format,
-                 jobject formatMap) {
-    jobject transferer = get_data_transferer(env);
-    jobject ret = NULL;
-    DECLARE_OBJECT_JAVA_METHOD(convertDataMethodID, dataTransfererClazz,
-                               "convertData",
-                               "(Ljava/lang/Object;Ljava/awt/datatransfer/Transferable;JLjava/util/Map;Z)[B");
-
-    ret = (*env)->CallObjectMethod(env, transferer, convertDataMethodID,
-                                   source, contents, format, formatMap,
-                                   awt_currentThreadIsPrivileged(env));
-
-    if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-
-    (*env)->DeleteLocalRef(env, transferer);
-
-    return ret;
-}
-
-static void
-process_convert_data_requests() {
-    JNIEnv* env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    jobject transferer = get_data_transferer(env);
-
-    DECLARE_VOID_JAVA_METHOD(processDataConversionRequestsMethodID,
-                             dataTransfererClazz,
-                             "processDataConversionRequests",
-                             "()V");
-
-    (*env)->CallVoidMethod(env, transferer,
-                           processDataConversionRequestsMethodID);
-
-    if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-
-    (*env)->DeleteLocalRef(env, transferer);
-}
-
-Boolean
-awt_convertData(Widget w, Atom * selection, Atom * target, Atom * type,
-                XtPointer * value, unsigned long *length, int32_t *format) {
-    JNIEnv*  env  = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    Display* dpy = XtDisplay(w);
-    awt_convertDataCallbackStruct* structPtr = NULL;
-
-    if (XFindContext(dpy, *selection, awt_convertDataContext,
-                     (XPointer*)&structPtr) == XCNOMEM || structPtr == NULL) {
-        return False;
-    }
-
-    if ((*env)->PushLocalFrame(env, 2) < 0) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-        return False;
-    }
-
-    if (*target == XA_TARGETS) {
-        jlongArray formats = structPtr->formats;
-        jsize      count;
-        jlong*     targets;
-        jboolean   isCopy;
-
-#ifndef _LP64 /* Atom and jlong are different sizes in the 32-bit build */
-        Atom*      aValue;
-        jlong*     saveTargets;
-        jsize      i;
-#endif
-
-        if (JNU_IsNull(env, formats)) {
-            (*env)->PopLocalFrame(env, NULL);
-            return False;
-        }
-
-        count = (*env)->GetArrayLength(env, formats);
-        if (count == 0) {
-            (*env)->PopLocalFrame(env, NULL);
-            return False;
-        }
-
-        targets = (*env)->GetLongArrayElements(env, formats, &isCopy);
-
-        *type = XA_ATOM;
-        *format = 32;
-
-#ifdef _LP64
-        *value = XtMalloc(count * sizeof(Atom));
-        memcpy((void *)*value, (void *)targets, count * sizeof(Atom));
-#else
-        *value = aValue = (Atom *)XtMalloc(count * sizeof(Atom));
-        saveTargets = targets;
-        for (i = 0; i < count; i++, aValue++, targets++) {
-            *aValue = (Atom)*targets;
-        }
-        targets = saveTargets;
-#endif
-        (*env)->ReleaseLongArrayElements(env, formats, targets, JNI_ABORT);
-
-        *length = count;
-
-    } else if (*target == XInternAtom(dpy, _XA_DELETE, False)) {
-
-        /*
-         * acknowledge the DELETE target here ... the "delete" semantic
-         * of move will take place after the drop is complete.
-         */
-
-        *type   = XInternAtom(dpy, _XA_NULL, False);
-        *length = 0;
-        *value  = (XtPointer)NULL;
-        /* Uninitialized format can cause crash in Xt conversion code. */
-        *format = 8;
-    } else if (*target == XInternAtom(dpy, _XA_HOSTNAME, False)) {
-        struct utsname name;
-        XTextProperty  tp;
-
-        uname(&name);
-
-        if (!XStringListToTextProperty((char **)&name.nodename, 1, &tp)) {
-            (*env)->PopLocalFrame(env, NULL);
-            return False;
-        }
-
-        *value = (XtPointer)XtCalloc(tp.nitems, sizeof(char));
-
-        memcpy((void *)*value, (const void *)tp.value, tp.nitems);
-
-        XFree((void *)tp.value);
-
-        *type   = tp.encoding;
-        *length = tp.nitems + 1;
-        *format = tp.format;
-    } else if (*target == XInternAtom(dpy, _XA_FILENAME, False) ||
-               *target == XInternAtom(dpy, _DT_FILENAME, False)) {
-
-        /*
-         * Convert the internal representation to an File Name.
-         * The data returned from dataConvert is a an array of
-         * null separated bytes. Each series of bytes is a string
-         * that is then converted to an XString which are then put
-         * into an XStringList and put into an XTextProperty for
-         * usage in other programs.
-         *
-         * It would be desireable to have dataConvert to this conversion
-         * but it isn't possible to return a byte array that represents
-         * the XTextProperty.
-         */
-        jbyteArray    data;
-
-        /*
-         * Fix for 4513976.
-         * Type None should be used instead of XT_CONVERT_FAIL
-         * to report conversion failure.
-         */
-        /*  assume forthcoming error */
-        *type   = None;
-        *value  = (XtPointer)NULL;
-        *length = 0;
-        *format = 8;
-
-        data = call_convertData(env, structPtr->source, structPtr->transferable,
-                                (jlong)*target, structPtr->formatMap);
-
-        /* error test */
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-            (*env)->PopLocalFrame(env, NULL);
-            return False;
-        }
-        if (JNU_IsNull(env, data)) {
-            (*env)->PopLocalFrame(env, NULL);
-            return False;
-        }
-
-        if (convertFileType(data, type, value, length, format) == False) {
-            (*env)->PopLocalFrame(env, NULL);
-            return False;
-        }
-    } else {
-        jbyteArray bytes = NULL;
-        jbyte*     copy = NULL;
-
-        /*
-         * Fix for 4513976.
-         * Type None should be used instead of XT_CONVERT_FAIL
-         * to report conversion failure.
-         */
-        *type   = None; /* assume forthcoming error */
-        *value  = (XtPointer)NULL;
-        *length = 0;
-        *format = 8;
-
-        bytes = call_convertData(env, structPtr->source, structPtr->transferable,
-                                 (jlong)*target, structPtr->formatMap);
-
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-            (*env)->PopLocalFrame(env, NULL);
-            return False;
-        }
-
-        if (bytes == NULL) {
-            (*env)->PopLocalFrame(env, NULL);
-            return False;
-        } else {
-            jsize len = (*env)->GetArrayLength(env, bytes);
-
-            if (len == 0) {
-                *type   = *target;
-                *format = 8;
-                (*env)->PopLocalFrame(env, NULL);
-                return True;
-            }
-
-            copy = (jbyte*)XtCalloc(1, len * sizeof(jbyte));
-            if (copy == (jbyte*)NULL) {
-                JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-                (*env)->PopLocalFrame(env, NULL);
-                return False;
-            }
-
-            (*env)->GetByteArrayRegion(env, (jbyteArray)bytes, 0, len, copy);
-
-            if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-                XtFree((void *)copy);
-                (*env)->PopLocalFrame(env, NULL);
-                return False;
-            }
-
-            *value  = (XtPointer)copy;
-            *type   = *target;
-            *length = len;
-            *format = 8;
-        }
-    }
-
-    (*env)->PopLocalFrame(env, NULL);
-    return True;
-}
-
-
-jlongArray
-getSelectionTargetsHelper(JNIEnv* env, XtPointer value, unsigned long length)
-{
-    Atom* targets = (Atom*)value;
-    jlongArray targetArray = NULL;
-    jlong* checkedTargets = NULL;
-    size_t count = 0, i = 0, j = 0;
-
-    /* Get rid of zero atoms if there are any. */
-    for (; i < length; i++) {
-        if (targets[i] != 0) {
-            count++;
-        }
-    }
-    checkedTargets = calloc(count, sizeof(jlong));
-    if (checkedTargets == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "");
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    } else {
-        for (i = 0; i < length; i++) {
-            if (targets[i] != 0) {
-                checkedTargets[j++] = targets[i];
-            }
-        }
-
-        DASSERT(j == count);
-
-        if ((*env)->EnsureLocalCapacity(env, 1) >= 0) {
-
-            targetArray = (*env)->NewLongArray(env, count);
-
-            if (!JNU_IsNull(env, targetArray)) {
-                (*env)->SetLongArrayRegion(env, targetArray, 0, count,
-                                           checkedTargets);
-
-                if ((*env)->ExceptionCheck(env)) {
-                    (*env)->ExceptionDescribe(env);
-                    (*env)->ExceptionClear(env);
-
-                    (*env)->DeleteLocalRef(env, targetArray);
-                    targetArray = NULL;
-                }
-            }
-        }
-        free(checkedTargets);
-    }
-
-    return targetArray;
-}
-
-static void
-get_selection_targets_callback(Widget w, XtPointer client_data, Atom* selection,
-                               Atom* type, XtPointer value,
-                               unsigned long* length, int32_t* format) {
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject* pReturnArray = (jobject*)client_data;
-    SelectionStatus status = SelectionFailure;
-
-    /*
-     * It is highly unlikely that TARGETS will ever be passed even though that
-     * was what was requested. However, XA_ATOM ("ATOM") is likely.
-     * Actually they are the same so treat them as such. See XToolKit
-     * Intrinsic Manual on XtSelectionCallbackProc for more details on type.
-     */
-    if (*type == XA_TARGETS || *type == XA_ATOM) {
-        jlongArray targetArray = getSelectionTargetsHelper(env, value, *length);
-        if (!JNU_IsNull(env, targetArray)) {
-            *pReturnArray = (*env)->NewGlobalRef(env, targetArray);
-            status = SelectionSuccess;
-            (*env)->DeleteLocalRef(env, targetArray);
-        }
-    } else if (*type == XT_CONVERT_FAIL) {
-        status = SelectionOwnerTimedOut;
-    } else {
-        /*
-         * A part of the fix for 4259272.
-         * Actually Xt Intrinsics says about XtSelectionCallback that
-         * "if there is no owner for the specified selection, or that owner
-         * cannot convert the selected data to the requested type, then this
-         * callback is called with value NULL and length zero".
-         * But we report success if type is not TARGETS, XA_ATOM or XT_CONVERT_FAIL,
-         * and we should not change this behaviour. We just return zero-length
-         * array instead of null, because null denotes that we could not get
-         * selection targets at the time of tracking changes of available on
-         * the selection data flavors.
-         */
-        jlongArray targetArray = (*env)->NewLongArray(env, 0);
-        *pReturnArray = (*env)->NewGlobalRef(env, targetArray);
-        /*
-         * Fix for 4655996.
-         * Report success if there is no owner for this selection or the owner
-         * fails to provide target types.
-         */
-        status = SelectionSuccess;
-        (*env)->DeleteLocalRef(env, targetArray);
-    }
-
-    if (value != NULL) {
-        XtFree(value);
-        value = NULL;
-    }
-
-    set_selection_status(status);
-}
-
-static void
-get_selection_data_callback(Widget w, XtPointer client_data, Atom * selection,
-                            Atom * type, XtPointer value, unsigned long *length,
-                            int32_t *format) {
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject* pData = (jobject*)client_data;
-    SelectionStatus status = SelectionFailure;
-
-    if (*type == XT_CONVERT_FAIL) {
-        status = SelectionOwnerTimedOut;
-    } else if (*type != None) {
-        if ((*env)->EnsureLocalCapacity(env, 1) >= 0) {
-            jsize size = (*length <= INT_MAX) ? *length : INT_MAX;
-            jbyteArray array = (*env)->NewByteArray(env, size);
-
-            if (!JNU_IsNull(env, array)) {
-                (*env)->SetByteArrayRegion(env, array, 0, size, (jbyte*)value);
-                if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-                    (*env)->ExceptionDescribe(env);
-                    (*env)->ExceptionClear(env);
-                } else {
-                    *pData = (*env)->NewGlobalRef(env, array);
-                    status = SelectionSuccess;
-                }
-
-                (*env)->DeleteLocalRef(env, array);
-            }
-        }
-    }
-
-    if (value != NULL) {
-        XtFree(value);
-        value = NULL;
-    }
-
-    set_selection_status(status);
-}
-
-static int32_t
-wait_for_selection_event(void *data) {
-    process_convert_data_requests();
-    return get_selection_status() != SelectionPending;
-}
-
-jlongArray
-get_selection_targets(JNIEnv *env, Atom selection, Time time_stamp) {
-    jlongArray ret     = NULL;
-    jlongArray targets = NULL;
-    SelectionStatus status = SelectionPending;
-
-    AWT_LOCK();
-
-    XtAppSetSelectionTimeout(awt_appContext,
-            JNU_CallStaticMethodByName(env, NULL, "sun/awt/UNIXToolkit",
-                                       "getDatatransferTimeout", "()I").i);
-
-    set_selection_status(SelectionPending);
-    XtGetSelectionValue(awt_root_shell, selection, XA_TARGETS,
-                        get_selection_targets_callback, (XtPointer)&targets,
-                        time_stamp);
-
-    awt_MToolkit_modalWait(wait_for_selection_event, NULL);
-    status = get_selection_status();
-
-    AWT_FLUSH_UNLOCK();
-
-    if (!JNU_IsNull(env, targets)) {
-        ret = (*env)->NewLocalRef(env, targets);
-        (*env)->DeleteGlobalRef(env, targets);
-    }
-
-    switch (status) {
-    case SelectionSuccess:
-        break;
-    case SelectionFailure:
-        JNU_ThrowByName(env, "java/lang/IllegalStateException",
-                        "Failed to get selection targets");
-        break;
-    case SelectionOwnerTimedOut:
-        // return an empty array of targets if the selection owner timed out
-        ret = (*env)->NewLongArray(env, 0);
-        break;
-    default:
-        JNU_ThrowByName(env, "java/lang/IllegalStateException",
-                        "Unexpected selection status");
-        break;
-    }
-
-    return ret;
-}
-
-jbyteArray
-get_selection_data(JNIEnv *env, Atom selection, Atom target, Time time_stamp) {
-    jbyteArray ret    = NULL;
-    jbyteArray data   = NULL;
-    SelectionStatus status = SelectionPending;
-
-    AWT_LOCK();
-
-    XtAppSetSelectionTimeout(awt_appContext,
-            JNU_CallStaticMethodByName(env, NULL, "sun/awt/UNIXToolkit",
-                                       "getDatatransferTimeout", "()I").i);
-
-    set_selection_status(SelectionPending);
-    XtGetSelectionValue(awt_root_shell, selection, target,
-                        get_selection_data_callback,
-                        (XtPointer)&data, time_stamp);
-
-    awt_MToolkit_modalWait(wait_for_selection_event, NULL);
-    status = get_selection_status();
-
-    AWT_FLUSH_UNLOCK();
-
-    if (!JNU_IsNull(env, data)) {
-        ret = (*env)->NewLocalRef(env, data);
-        (*env)->DeleteGlobalRef(env, data);
-    }
-
-    switch (status) {
-    case SelectionSuccess:
-        break;
-    case SelectionFailure:
-        JNU_ThrowIOException(env, "Failed to get selection data");
-        break;
-    case SelectionOwnerTimedOut:
-        JNU_ThrowIOException(env, "Selection owner timed out");
-        break;
-    default:
-        JNU_ThrowIOException(env, "Unexpected selection status");
-        break;
-    }
-
-    return ret;
-}
-
-void
-awt_cleanupConvertDataContext(JNIEnv *env, Atom selectionAtom) {
-    awt_convertDataCallbackStruct* structPtr = NULL;
-
-    if (XFindContext(awt_display, selectionAtom, awt_convertDataContext,
-                     (XPointer*)&structPtr) == 0 && structPtr != NULL) {
-
-        (*env)->DeleteGlobalRef(env, structPtr->source);
-        (*env)->DeleteGlobalRef(env, structPtr->transferable);
-        (*env)->DeleteGlobalRef(env, structPtr->formatMap);
-        (*env)->DeleteGlobalRef(env, structPtr->formats);
-        free(structPtr);
-    }
-    /*
-     * Xlib Programming Manual says that it is better to erase
-     * the current entry with XDeleteContext() before XSaveContext().
-     */
-    XDeleteContext(awt_display, selectionAtom, awt_convertDataContext);
-    if (XSaveContext(awt_display, selectionAtom, awt_convertDataContext,
-                     (XPointer)NULL) == XCNOMEM) {
-        JNU_ThrowInternalError(env, "XError");
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-static Bool exitSecondaryLoop = True;
-
-/*
- * This predicate procedure allows the Toolkit thread to process specific events
- * while it is blocked waiting for the event dispatch thread to process
- * a SunDropTargetEvent. We need this to prevent deadlock when the client code
- * processing SunDropTargetEvent sets or gets the contents of the system
- * clipboard/selection. In this case the event dispatch thread waits for the
- * Toolkit thread to process PropertyNotify or SelectionNotify events.
- */
-static Bool
-secondary_loop_event(Display* dpy, XEvent* event, char* arg) {
-    return (event->type == SelectionNotify ||
-            event->type == SelectionClear  ||
-            event->type == PropertyNotify) ? True : False;
-}
-
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MToolkitThreadBlockedHandler_enter(JNIEnv *env, jobject this) {
-    DASSERT(exitSecondaryLoop && awt_currentThreadIsPrivileged(env));
-    exitSecondaryLoop = False;
-    while (!exitSecondaryLoop) {
-        XEvent event;
-        while (XCheckIfEvent(awt_display, &event, secondary_loop_event, NULL)) {
-            XtDispatchEvent(&event);
-        }
-        AWT_WAIT(AWT_DND_POLL_INTERVAL);
-    }
-}
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MToolkitThreadBlockedHandler_exit(JNIEnv *env, jobject this) {
-    DASSERT(!exitSecondaryLoop && !awt_currentThreadIsPrivileged(env));
-    exitSecondaryLoop = True;
-    AWT_NOTIFY_ALL();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_DataTransferer.h openjdk/jdk/src/solaris/native/sun/awt/awt_DataTransferer.h
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_DataTransferer.h	2014-04-08 05:27:03.434874852 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_DataTransferer.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,275 +0,0 @@
-/*
- * Copyright (c) 2000, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifndef AWT_DATATRANSFERER_H
-#define AWT_DATATRANSFERER_H
-
-#include <X11/Intrinsic.h>
-#include <inttypes.h>
-
-#define _XA_DELETE          "DELETE"
-#define _XA_FILENAME        "FILE_NAME"
-#define _XA_HOSTNAME        "HOST_NAME"
-#define _XA_NULL            "NULL"
-#define _DT_FILENAME        "_DT_NETFILE"
-
-#define AWT_DND_POLL_INTERVAL ((unsigned long)250) /* milliseconds */
-
-typedef struct {
-    jobject    source;
-    jobject    transferable;
-    jobject    formatMap;
-    jlongArray formats;
-} awt_convertDataCallbackStruct;
-
-extern XContext awt_convertDataContext; /* XContext is not 64 bits */
-
-extern Atom XA_TARGETS;
-
-/*
- * Single routine to convert to target FILE_NAME or _DT_FILENAME
- */
-Boolean
-convertFileType(jbyteArray data, Atom * type, XtPointer * value,
-                unsigned long *length, int32_t *format);
-
-Boolean
-awt_convertData(Widget w, Atom * selection, Atom * target, Atom * type,
-                XtPointer * value, unsigned long *length, int32_t *format);
-
-jlongArray
-get_selection_targets(JNIEnv *env, Atom selection, Time time_stamp);
-
-jlongArray
-getSelectionTargetsHelper(JNIEnv* env, XtPointer value, unsigned long length);
-
-jbyteArray
-get_selection_data(JNIEnv *env, Atom selection, Atom format, Time time_stamp);
-
-void
-awt_cleanupConvertDataContext(JNIEnv *env, Atom selectionAtom);
-
-/*
- * NOTE: You need these macros only if you take care of performance, since they
- * provide proper caching. Otherwise you can use JNU_CallMethodByName etc.
- */
-
-/*
- * This macro defines a function which returns the class for the specified
- * class name with proper caching and error handling.
- */
-#define DECLARE_JAVA_CLASS(javaclazz, name)                                    \
-static jclass                                                                  \
-get_ ## javaclazz(JNIEnv* env) {                                               \
-    static jclass javaclazz = NULL;                                            \
-                                                                               \
-    if (JNU_IsNull(env, javaclazz)) {                                          \
-        jclass javaclazz ## Local = (*env)->FindClass(env, name);              \
-                                                                               \
-        if (!JNU_IsNull(env, javaclazz ## Local)) {                            \
-            javaclazz = (jclass)(*env)->NewGlobalRef(env, javaclazz ## Local); \
-            (*env)->DeleteLocalRef(env, javaclazz ## Local);                   \
-            if (JNU_IsNull(env, javaclazz)) {                                  \
-                JNU_ThrowOutOfMemoryError(env, "");                            \
-            }                                                                  \
-        }                                                                      \
-                                                                               \
-        if (!JNU_IsNull(env, ((*env)->ExceptionOccurred(env)))) {              \
-            (*env)->ExceptionDescribe(env);                                    \
-            (*env)->ExceptionClear(env);                                       \
-        }                                                                      \
-    }                                                                          \
-                                                                               \
-    DASSERT(!JNU_IsNull(env, javaclazz));                                      \
-                                                                               \
-    return javaclazz;                                                          \
-}
-
-/*
- * The following macros defines blocks of code which retrieve a method of the
- * specified class identified with the specified name and signature.
- * The specified class should be previously declared with DECLARE_JAVA_CLASS.
- * These macros should be placed at the beginning of a block, after definition
- * of local variables, but before the code begins.
- */
-#define DECLARE_VOID_JAVA_METHOD(method, javaclazz, name, signature)           \
-    static jmethodID method = NULL;                                            \
-                                                                               \
-    if (JNU_IsNull(env, method)) {                                             \
-        jclass clazz = get_ ## javaclazz(env);                                 \
-                                                                               \
-        if (JNU_IsNull(env, clazz)) {                                          \
-            return;                                                            \
-        }                                                                      \
-                                                                               \
-        method = (*env)->GetMethodID(env, clazz, name, signature);             \
-                                                                               \
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {                         \
-            (*env)->ExceptionDescribe(env);                                    \
-            (*env)->ExceptionClear(env);                                       \
-        }                                                                      \
-                                                                               \
-        if (JNU_IsNull(env, method)) {                                         \
-            DASSERT(False);                                                    \
-            return;                                                            \
-        }                                                                      \
-    }
-
-#define DECLARE_BOOLEAN_JAVA_METHOD(method, javaclazz, name, signature)        \
-    static jmethodID method = NULL;                                            \
-                                                                               \
-    if (JNU_IsNull(env, method)) {                                             \
-        jclass clazz = get_ ## javaclazz(env);                                 \
-                                                                               \
-        if (JNU_IsNull(env, clazz)) {                                          \
-            return False;                                                      \
-        }                                                                      \
-                                                                               \
-        method = (*env)->GetMethodID(env, clazz, name, signature);             \
-                                                                               \
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {                         \
-            (*env)->ExceptionDescribe(env);                                    \
-            (*env)->ExceptionClear(env);                                       \
-        }                                                                      \
-                                                                               \
-        if (JNU_IsNull(env, method)) {                                         \
-            DASSERT(False);                                                    \
-            return False;                                                      \
-        }                                                                      \
-    }
-
-#define DECLARE_JINT_JAVA_METHOD(method, javaclazz, name, signature)           \
-    static jmethodID method = NULL;                                            \
-                                                                               \
-    if (JNU_IsNull(env, method)) {                                             \
-        jclass clazz = get_ ## javaclazz(env);                                 \
-                                                                               \
-        if (JNU_IsNull(env, clazz)) {                                          \
-            return java_awt_dnd_DnDConstants_ACTION_NONE;                      \
-        }                                                                      \
-                                                                               \
-        method = (*env)->GetMethodID(env, clazz, name, signature);             \
-                                                                               \
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {                         \
-            (*env)->ExceptionDescribe(env);                                    \
-            (*env)->ExceptionClear(env);                                       \
-        }                                                                      \
-                                                                               \
-        if (JNU_IsNull(env, method)) {                                         \
-            DASSERT(False);                                                    \
-            return java_awt_dnd_DnDConstants_ACTION_NONE;                      \
-        }                                                                      \
-    }
-
-#define DECLARE_OBJECT_JAVA_METHOD(method, javaclazz, name, signature)         \
-    static jmethodID method = NULL;                                            \
-                                                                               \
-    if (JNU_IsNull(env, method)) {                                             \
-        jclass clazz = get_ ## javaclazz(env);                                 \
-                                                                               \
-        if (JNU_IsNull(env, clazz)) {                                          \
-            return NULL;                                                       \
-        }                                                                      \
-                                                                               \
-        method = (*env)->GetMethodID(env, clazz, name, signature);             \
-                                                                               \
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {                         \
-            (*env)->ExceptionDescribe(env);                                    \
-            (*env)->ExceptionClear(env);                                       \
-        }                                                                      \
-                                                                               \
-        if (JNU_IsNull(env, method)) {                                         \
-            DASSERT(False);                                                    \
-            return NULL;                                                       \
-        }                                                                      \
-    }
-
-#define DECLARE_STATIC_OBJECT_JAVA_METHOD(method, javaclazz, name, signature)  \
-    static jmethodID method = NULL;                                            \
-    jclass clazz = get_ ## javaclazz(env);                                     \
-                                                                               \
-    if (JNU_IsNull(env, clazz)) {                                              \
-        return NULL;                                                           \
-    }                                                                          \
-                                                                               \
-    if (JNU_IsNull(env, method)) {                                             \
-        method = (*env)->GetStaticMethodID(env, clazz, name, signature);       \
-                                                                               \
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {                         \
-            (*env)->ExceptionDescribe(env);                                    \
-            (*env)->ExceptionClear(env);                                       \
-        }                                                                      \
-                                                                               \
-        if (JNU_IsNull(env, method)) {                                         \
-            DASSERT(False);                                                    \
-            return NULL;                                                       \
-        }                                                                      \
-    }
-
-#define DECLARE_STATIC_VOID_JAVA_METHOD(method, javaclazz, name, signature)    \
-    static jmethodID method = NULL;                                            \
-    jclass clazz = get_ ## javaclazz(env);                                     \
-                                                                               \
-    if (JNU_IsNull(env, clazz)) {                                              \
-        return;                                                                \
-    }                                                                          \
-                                                                               \
-    if (JNU_IsNull(env, method)) {                                             \
-        method = (*env)->GetStaticMethodID(env, clazz, name, signature);       \
-                                                                               \
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {                         \
-            (*env)->ExceptionDescribe(env);                                    \
-            (*env)->ExceptionClear(env);                                       \
-        }                                                                      \
-                                                                               \
-        if (JNU_IsNull(env, method)) {                                         \
-            DASSERT(False);                                                    \
-            return;                                                            \
-        }                                                                      \
-    }
-
-#define DECLARE_STATIC_JINT_JAVA_METHOD(method, javaclazz, name, signature)    \
-    static jmethodID method = NULL;                                            \
-    jclass clazz = get_ ## javaclazz(env);                                     \
-                                                                               \
-    if (JNU_IsNull(env, clazz)) {                                              \
-        return java_awt_dnd_DnDConstants_ACTION_NONE;                          \
-    }                                                                          \
-                                                                               \
-    if (JNU_IsNull(env, method)) {                                             \
-        method = (*env)->GetStaticMethodID(env, clazz, name, signature);       \
-                                                                               \
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {                         \
-            (*env)->ExceptionDescribe(env);                                    \
-            (*env)->ExceptionClear(env);                                       \
-        }                                                                      \
-                                                                               \
-        if (JNU_IsNull(env, method)) {                                         \
-            DASSERT(False);                                                    \
-            return java_awt_dnd_DnDConstants_ACTION_NONE;                      \
-        }                                                                      \
-    }
-
-#endif /* AWT_DATATRANSFERER_H */
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_dnd.c openjdk/jdk/src/solaris/native/sun/awt/awt_dnd.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_dnd.c	2014-04-08 05:27:03.454875147 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_dnd.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,887 +0,0 @@
-/*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_dnd.h"
-
-#include "awt_p.h"
-
-#include "java_awt_dnd_DnDConstants.h"
-
-/* Shared atoms */
-
-Atom XA_WM_STATE;
-Atom XA_DELETE;
-
-/* XDnD atoms */
-
-Atom XA_XdndAware;
-Atom XA_XdndProxy;
-
-Atom XA_XdndEnter;
-Atom XA_XdndPosition;
-Atom XA_XdndLeave;
-Atom XA_XdndDrop;
-Atom XA_XdndStatus;
-Atom XA_XdndFinished;
-
-Atom XA_XdndTypeList;
-Atom XA_XdndSelection;
-
-Atom XA_XdndActionCopy;
-Atom XA_XdndActionMove;
-Atom XA_XdndActionLink;
-Atom XA_XdndActionAsk;
-Atom XA_XdndActionPrivate;
-Atom XA_XdndActionList;
-
-/* Motif DnD atoms */
-
-Atom _XA_MOTIF_DRAG_WINDOW;
-Atom _XA_MOTIF_DRAG_TARGETS;
-Atom _XA_MOTIF_DRAG_INITIATOR_INFO;
-Atom _XA_MOTIF_DRAG_RECEIVER_INFO;
-Atom _XA_MOTIF_DRAG_AND_DROP_MESSAGE;
-Atom _XA_MOTIF_ATOM_0;
-Atom XA_XmTRANSFER_SUCCESS;
-Atom XA_XmTRANSFER_FAILURE;
-
-unsigned char MOTIF_BYTE_ORDER = 0;
-
-static Window awt_root_window = None;
-
-static Boolean
-init_atoms(Display* display) {
-    struct atominit {
-        Atom *atomptr;
-        const char *name;
-    };
-
-    /* Add new atoms to this list */
-    static struct atominit atom_list[] = {
-        /* Shared atoms */
-        { &XA_WM_STATE,                     "WM_STATE"                     },
-        { &XA_DELETE,                       "DELETE"                       },
-
-        /* XDnD atoms */
-        { &XA_XdndAware,                    "XdndAware"                    },
-        { &XA_XdndProxy,                    "XdndProxy"                    },
-        { &XA_XdndEnter,                    "XdndEnter"                    },
-        { &XA_XdndPosition,                 "XdndPosition"                 },
-        { &XA_XdndLeave,                    "XdndLeave"                    },
-        { &XA_XdndDrop,                     "XdndDrop"                     },
-        { &XA_XdndStatus,                   "XdndStatus"                   },
-        { &XA_XdndFinished,                 "XdndFinished"                 },
-        { &XA_XdndTypeList,                 "XdndTypeList"                 },
-        { &XA_XdndSelection,                "XdndSelection"                },
-        { &XA_XdndActionCopy,               "XdndActionCopy"               },
-        { &XA_XdndActionMove,               "XdndActionMove"               },
-        { &XA_XdndActionLink,               "XdndActionLink"               },
-        { &XA_XdndActionAsk,                "XdndActionAsk"                },
-        { &XA_XdndActionPrivate,            "XdndActionPrivate"            },
-        { &XA_XdndActionList,               "XdndActionList"               },
-
-        /* Motif DnD atoms */
-        { &_XA_MOTIF_DRAG_WINDOW,           "_MOTIF_DRAG_WINDOW"           },
-        { &_XA_MOTIF_DRAG_TARGETS,          "_MOTIF_DRAG_TARGETS"          },
-        { &_XA_MOTIF_DRAG_INITIATOR_INFO,   "_MOTIF_DRAG_INITIATOR_INFO"   },
-        { &_XA_MOTIF_DRAG_RECEIVER_INFO,    "_MOTIF_DRAG_RECEIVER_INFO"    },
-        { &_XA_MOTIF_DRAG_AND_DROP_MESSAGE, "_MOTIF_DRAG_AND_DROP_MESSAGE" },
-        { &_XA_MOTIF_ATOM_0,                "_MOTIF_ATOM_0"                },
-        { &XA_XmTRANSFER_SUCCESS,           "XmTRANSFER_SUCCESS"           },
-        { &XA_XmTRANSFER_FAILURE,           "XmTRANSFER_FAILURE"           }
-    };
-
-#define ATOM_LIST_LENGTH (sizeof(atom_list)/sizeof(atom_list[0]))
-
-    const char *names[ATOM_LIST_LENGTH];
-    Atom atoms[ATOM_LIST_LENGTH];
-    Status status;
-    size_t i;
-
-    /* Fill the array of atom names */
-    for (i = 0; i < ATOM_LIST_LENGTH; ++i) {
-        names[i] = atom_list[i].name;
-    }
-
-    DTRACE_PRINT2("%s:%d initializing atoms ... ", __FILE__, __LINE__);
-
-    status = XInternAtoms(awt_display, (char**)names, ATOM_LIST_LENGTH,
-                          False, atoms);
-    if (status == 0) {
-        DTRACE_PRINTLN("failed");
-        return False;
-    }
-
-    /* Store returned atoms into corresponding global variables */
-    DTRACE_PRINTLN("ok");
-    for (i = 0; i < ATOM_LIST_LENGTH; ++i) {
-        *atom_list[i].atomptr = atoms[i];
-    }
-
-    return True;
-#undef ATOM_LIST_LENGTH
-}
-
-/*
- * NOTE: must be called after awt_root_shell is created and realized.
- */
-Boolean
-awt_dnd_init(Display* display) {
-    static Boolean inited = False;
-
-    if (!inited) {
-        Boolean atoms_inited = False;
-        Boolean ds_inited = False;
-        unsigned int value = 1;
-        MOTIF_BYTE_ORDER = (*((char*)&value) != 0) ? 'l' : 'B';
-
-        /* NOTE: init_atoms() should be called before the rest of initialization
-           so that atoms can be used. */
-        inited = init_atoms(display);
-
-        if (inited) {
-            if (XtIsRealized(awt_root_shell)) {
-                awt_root_window = XtWindow(awt_root_shell);
-            } else {
-                inited = False;
-            }
-        }
-
-        inited = inited && awt_dnd_ds_init(display);
-    }
-
-    return inited;
-}
-
-/*
- * Returns a window of awt_root_shell.
- */
-Window
-get_awt_root_window() {
-    return awt_root_window;
-}
-
-static unsigned char local_xerror_code = Success;
-
-static int
-xerror_handler(Display *dpy, XErrorEvent *err) {
-    local_xerror_code = err->error_code;
-    return 0;
-}
-
-/**************** checked_X* wrappers *****************************************/
-#undef NO_SYNC
-#undef SYNC_TRACE
-
-unsigned char
-checked_XChangeProperty(Display* display, Window w, Atom property, Atom type,
-                        int format, int mode, unsigned char* data,
-                        int nelements) {
-    XErrorHandler xerror_saved_handler;
-
-#ifndef NO_SYNC
-    XSync(display, False);
-#ifdef SYNC_TRACE
-    fprintf(stderr,"XSync 1\n");
-#endif
-#endif
-    local_xerror_code = Success;
-    xerror_saved_handler = XSetErrorHandler(xerror_handler);
-
-    XChangeProperty(display, w, property, type, format, mode, data, nelements);
-
-#ifndef NO_SYNC
-    XSync(display, False);
-#ifdef SYNC_TRACE
-    fprintf(stderr,"XSync 2\n");
-#endif
-#endif
-    XSetErrorHandler(xerror_saved_handler);
-
-    return local_xerror_code;
-}
-
-unsigned char
-checked_XGetWindowProperty(Display* display, Window w, Atom property, long long_offset,
-                           long long_length, Bool delete, Atom req_type,
-                           Atom* actual_type_return, int* actual_format_return,
-                           unsigned long* nitems_return, unsigned long* bytes_after_return,
-                           unsigned char** prop_return) {
-
-    XErrorHandler xerror_saved_handler;
-    int ret_val = Success;
-
-#ifndef NO_SYNC
-    XSync(display, False);
-#ifdef SYNC_TRACE
-    fprintf(stderr,"XSync 3\n");
-#endif
-#endif
-    local_xerror_code = Success;
-    xerror_saved_handler = XSetErrorHandler(xerror_handler);
-
-    ret_val = XGetWindowProperty(display, w, property, long_offset, long_length,
-                                 delete, req_type, actual_type_return,
-                                 actual_format_return, nitems_return,
-                                 bytes_after_return, prop_return);
-
-#ifndef NO_SYNC
-    XSync(display, False);
-#ifdef SYNC_TRACE
-    fprintf(stderr,"XSync 4\n");
-#endif
-#endif
-    XSetErrorHandler(xerror_saved_handler);
-
-    return ret_val != Success ? local_xerror_code : Success;
-}
-
-unsigned char
-checked_XSendEvent(Display* display, Window w, Bool propagate, long event_mask,
-                   XEvent* event_send) {
-
-    XErrorHandler xerror_saved_handler;
-    Status ret_val = 0;
-
-#ifndef NO_SYNC
-    XSync(display, False);
-#ifdef SYNC_TRACE
-    fprintf(stderr,"XSync 5\n");
-#endif
-#endif
-    local_xerror_code = Success;
-    xerror_saved_handler = XSetErrorHandler(xerror_handler);
-
-    ret_val = XSendEvent(display, w, propagate, event_mask, event_send);
-
-#ifndef NO_SYNC
-    XSync(display, False);
-#ifdef SYNC_TRACE
-    fprintf(stderr,"XSync 6\n");
-#endif
-#endif
-    XSetErrorHandler(xerror_saved_handler);
-
-    return ret_val == 0 ? local_xerror_code : Success;
-}
-
-/*
- * NOTE: returns Success even if the two windows aren't on the same screen.
- */
-unsigned char
-checked_XTranslateCoordinates(Display* display, Window src_w, Window dest_w,
-                              int src_x, int src_y, int* dest_x_return,
-                              int* dest_y_return, Window* child_return) {
-
-    XErrorHandler xerror_saved_handler;
-    Bool ret_val = True;
-
-#ifndef NO_SYNC
-    XSync(display, False);
-#ifdef SYNC_TRACE
-    fprintf(stderr,"XSync 7\n");
-#endif
-#endif
-    local_xerror_code = Success;
-    xerror_saved_handler = XSetErrorHandler(xerror_handler);
-
-    ret_val = XTranslateCoordinates(display, src_w, dest_w, src_x, src_y,
-                                    dest_x_return, dest_y_return, child_return);
-
-#ifndef NO_SYNC
-    XSync(display, False);
-#ifdef SYNC_TRACE
-    fprintf(stderr,"XSync 8\n");
-#endif
-#endif
-    XSetErrorHandler(xerror_saved_handler);
-
-    return local_xerror_code;
-}
-
-unsigned char
-checked_XSelectInput(Display* display, Window w, long event_mask) {
-    XErrorHandler xerror_saved_handler;
-    Bool ret_val = True;
-
-#ifndef NO_SYNC
-    XSync(display, False);
-#ifdef SYNC_TRACE
-    fprintf(stderr,"XSync 7\n");
-#endif
-#endif
-    local_xerror_code = Success;
-    xerror_saved_handler = XSetErrorHandler(xerror_handler);
-
-    XSelectInput(display, w, event_mask);
-
-#ifndef NO_SYNC
-    XSync(display, False);
-#ifdef SYNC_TRACE
-    fprintf(stderr,"XSync 8\n");
-#endif
-#endif
-    XSetErrorHandler(xerror_saved_handler);
-
-    return local_xerror_code;
-}
-/******************************************************************************/
-
-jint
-xdnd_to_java_action(Atom action) {
-    if (action == XA_XdndActionCopy) {
-        return java_awt_dnd_DnDConstants_ACTION_COPY;
-    } else if (action == XA_XdndActionMove) {
-        return java_awt_dnd_DnDConstants_ACTION_MOVE;
-    } else if (action == XA_XdndActionLink) {
-        return java_awt_dnd_DnDConstants_ACTION_LINK;
-    } else if (action == None) {
-        return java_awt_dnd_DnDConstants_ACTION_NONE;
-    } else {
-        /* XdndActionCopy is the default. */
-        return java_awt_dnd_DnDConstants_ACTION_COPY;
-    }
-}
-
-Atom
-java_to_xdnd_action(jint action) {
-    switch (action) {
-    case java_awt_dnd_DnDConstants_ACTION_COPY: return XA_XdndActionCopy;
-    case java_awt_dnd_DnDConstants_ACTION_MOVE: return XA_XdndActionMove;
-    case java_awt_dnd_DnDConstants_ACTION_LINK: return XA_XdndActionLink;
-    default:                                    return None;
-    }
-}
-
-void
-write_card8(void** p, CARD8 value) {
-    CARD8** card8_pp = (CARD8**)p;
-    **card8_pp = value;
-    (*card8_pp)++;
-}
-
-void
-write_card16(void** p, CARD16 value) {
-    CARD16** card16_pp = (CARD16**)p;
-    **card16_pp = value;
-    (*card16_pp)++;
-}
-
-void
-write_card32(void** p, CARD32 value) {
-    CARD32** card32_pp = (CARD32**)p;
-    **card32_pp = value;
-    (*card32_pp)++;
-}
-
-CARD8
-read_card8(char* data, size_t offset) {
-    return *((CARD8*)(data + offset));
-}
-
-CARD16
-read_card16(char* data, size_t offset, char byte_order) {
-    CARD16 card16 = *((CARD16*)(data + offset));
-
-    if (byte_order != MOTIF_BYTE_ORDER) {
-        SWAP2BYTES(card16);
-    }
-
-    return card16;
-}
-
-CARD32
-read_card32(char* data, size_t offset, char byte_order) {
-    CARD32 card32 = *((CARD32*)(data + offset));
-
-    if (byte_order != MOTIF_BYTE_ORDER) {
-        SWAP4BYTES(card32);
-    }
-
-    return card32;
-}
-
-static Window
-read_motif_window(Display* dpy) {
-    Window         root_window = DefaultRootWindow(dpy);
-    Window         motif_window = None;
-
-    unsigned char  ret;
-    Atom           type;
-    int            format;
-    unsigned long  nitems;
-    unsigned long  after;
-    unsigned char  *data;
-
-    ret = checked_XGetWindowProperty(dpy, root_window, _XA_MOTIF_DRAG_WINDOW,
-                                     0, 0xFFFF, False, AnyPropertyType, &type,
-                                     &format, &nitems, &after, &data);
-
-    if (ret != Success) {
-        DTRACE_PRINTLN2("%s:%d Failed to read _MOTIF_DRAG_WINDOW.",
-                        __FILE__, __LINE__);
-        return None;
-    }
-
-
-    if (type == XA_WINDOW && format == 32 && nitems == 1) {
-        motif_window = *((Window*)data);
-    }
-
-    XFree ((char *)data);
-
-    return motif_window;
-}
-
-static Window
-create_motif_window(Display* dpy) {
-    Window   root_window = DefaultRootWindow(dpy);
-    Window   motif_window = None;
-    Display* display = NULL;
-    XSetWindowAttributes swa;
-
-    display = XOpenDisplay(XDisplayString(dpy));
-    if (display == NULL) {
-        return None;
-    }
-
-    XGrabServer(display);
-
-    XSetCloseDownMode(display, RetainPermanent);
-
-    swa.override_redirect = True;
-    swa.event_mask = PropertyChangeMask;
-    motif_window = XCreateWindow(display, root_window,
-                                 -10, -10, 1, 1, 0, 0,
-                                 InputOnly, CopyFromParent,
-                                 (CWOverrideRedirect|CWEventMask),
-                                 &swa);
-    XMapWindow(display, motif_window);
-
-    XChangeProperty(display, root_window, _XA_MOTIF_DRAG_WINDOW, XA_WINDOW, 32,
-                    PropModeReplace, (unsigned char *)&motif_window, 1);
-
-    XUngrabServer(display);
-
-    XCloseDisplay(display);
-
-    return motif_window;
-}
-
-Window
-get_motif_window(Display* dpy) {
-    /*
-     * Note: it is unsafe to cache the motif drag window handle, as another
-     * client can change the _MOTIF_DRAG_WINDOW property on the root, the handle
-     * becomes out-of-sync and all subsequent drag operations will fail.
-     */
-    Window motif_window = read_motif_window(dpy);
-    if (motif_window == None) {
-        motif_window = create_motif_window(dpy);
-    }
-
-    return motif_window;
-}
-
-typedef struct {
-    CARD16 num_targets;
-    Atom* targets;
-} TargetsTableEntry;
-
-typedef struct {
-    CARD16 num_entries;
-    TargetsTableEntry* entries;
-} TargetsTable;
-
-typedef struct {
-    CARD8       byte_order;
-    CARD8       protocol_version;
-    CARD16      num_entries B16;
-    CARD32      heap_offset B32;
-} TargetsPropertyRec;
-
-static TargetsTable*
-get_target_list_table(Display* dpy) {
-    Window motif_window = get_motif_window(dpy);
-    TargetsTable* targets_table = NULL;
-    TargetsPropertyRec* targets_property_rec_ptr;
-    char* bufptr;
-
-    unsigned char  ret;
-    Atom           type;
-    int            format;
-    unsigned long  nitems;
-    unsigned long  after;
-    unsigned char  *data;
-    unsigned int   i, j;
-
-    ret = checked_XGetWindowProperty(dpy, motif_window, _XA_MOTIF_DRAG_TARGETS,
-                                     0L, 100000L, False, _XA_MOTIF_DRAG_TARGETS,
-                                     &type, &format, &nitems, &after,
-                                     (unsigned char**)&targets_property_rec_ptr);
-
-    if (ret != Success || type != _XA_MOTIF_DRAG_TARGETS ||
-        targets_property_rec_ptr == NULL) {
-
-        DTRACE_PRINT2("%s:%d Cannot read _XA_MOTIF_DRAG_TARGETS", __FILE__, __LINE__);
-        return NULL;
-    }
-
-    if (targets_property_rec_ptr->protocol_version !=
-        MOTIF_DND_PROTOCOL_VERSION) {
-        DTRACE_PRINT2("%s:%d incorrect protocol version", __FILE__, __LINE__);
-        return NULL;
-    }
-
-    if (targets_property_rec_ptr->byte_order != MOTIF_BYTE_ORDER) {
-        SWAP2BYTES(targets_property_rec_ptr->num_entries);
-        SWAP4BYTES(targets_property_rec_ptr->heap_offset);
-    }
-
-    targets_table = (TargetsTable*)malloc(sizeof(TargetsTable));
-    if (targets_table == NULL) {
-        DTRACE_PRINT2("%s:%d malloc failed", __FILE__, __LINE__);
-        return NULL;
-    }
-    targets_table->num_entries = targets_property_rec_ptr->num_entries;
-    targets_table->entries =
-        (TargetsTableEntry*)malloc(sizeof(TargetsTableEntry) *
-                                   targets_property_rec_ptr->num_entries);
-    if (targets_table->entries == NULL) {
-        DTRACE_PRINT2("%s:%d malloc failed", __FILE__, __LINE__);
-        free(targets_table);
-        return NULL;
-    }
-
-    bufptr = (char *)targets_property_rec_ptr + sizeof(TargetsPropertyRec);
-    for (i = 0; i < targets_table->num_entries; i++) {
-        CARD16 num_targets;
-        Atom* targets;
-        memcpy(&num_targets, bufptr, 2 );
-        bufptr += 2;
-        if (targets_property_rec_ptr->byte_order != MOTIF_BYTE_ORDER) {
-            SWAP2BYTES(num_targets);
-        }
-
-        targets = (Atom*)malloc(sizeof(Atom) * num_targets);
-        if (targets == NULL) {
-            DTRACE_PRINT2("%s:%d malloc failed", __FILE__, __LINE__);
-            free(targets_table->entries);
-            free(targets_table);
-            return NULL;
-        }
-        for (j = 0; j < num_targets; j++) {
-            CARD32 target;
-            memcpy(&target, bufptr, 4 );
-            bufptr += 4;
-            if (targets_property_rec_ptr->byte_order != MOTIF_BYTE_ORDER) {
-                SWAP4BYTES(target);
-            }
-            targets[j] = (Atom)target;
-        }
-
-        targets_table->entries[i].num_targets = num_targets;
-        targets_table->entries[i].targets = targets;
-    }
-
-    free(targets_property_rec_ptr);
-
-    return targets_table;
-}
-
-static void
-put_target_list_table(Display* dpy, TargetsTable* table) {
-    Window motif_window = get_motif_window(dpy);
-    TargetsPropertyRec* targets_property_rec_ptr;
-    size_t table_size = sizeof(TargetsPropertyRec);
-    unsigned char ret;
-    int i, j;
-    char* buf;
-
-    for (i = 0; i < table->num_entries; i++) {
-        table_size += table->entries[i].num_targets * sizeof(Atom) + 2;
-    }
-
-    targets_property_rec_ptr = (TargetsPropertyRec*)malloc(table_size);
-    if (targets_property_rec_ptr == NULL) {
-        DTRACE_PRINT2("%s:%d malloc failed", __FILE__, __LINE__);
-        return;
-    }
-    targets_property_rec_ptr->byte_order = MOTIF_BYTE_ORDER;
-    targets_property_rec_ptr->protocol_version = MOTIF_DND_PROTOCOL_VERSION;
-    targets_property_rec_ptr->num_entries = table->num_entries;
-    targets_property_rec_ptr->heap_offset = table_size;
-
-    buf = (char*)targets_property_rec_ptr + sizeof(TargetsPropertyRec);
-
-    for (i = 0; i < table->num_entries; i++) {
-        CARD16 num_targets = table->entries[i].num_targets;
-        memcpy(buf, &num_targets, 2);
-        buf += 2;
-
-        for (j = 0; j < num_targets; j++) {
-            CARD32 target = table->entries[i].targets[j];
-            memcpy(buf, &target, 4);
-            buf += 4;
-        }
-    }
-
-    ret = checked_XChangeProperty(dpy, motif_window, _XA_MOTIF_DRAG_TARGETS,
-                                  _XA_MOTIF_DRAG_TARGETS, 8, PropModeReplace,
-                                  (unsigned char*)targets_property_rec_ptr,
-                                  (int)table_size);
-
-    if (ret != Success) {
-        DTRACE_PRINT2("%s:%d XChangeProperty failed", __FILE__, __LINE__);
-    }
-
-    XtFree((char*)targets_property_rec_ptr);
-}
-
-static int
-_compare(const void* p1, const void* p2) {
-    long diff = *(Atom*)p1 - *(Atom*)p2;
-
-    if (diff > 0) {
-        return 1;
-    } else if (diff < 0) {
-        return -1;
-    } else {
-        return 0;
-    }
-}
-
-/*
- * Returns the index for the specified target list or -1 on failure.
- */
-int
-get_index_for_target_list(Display* dpy, Atom* targets, unsigned int num_targets) {
-    TargetsTable* targets_table = NULL;
-    Atom* sorted_targets = NULL;
-    int i, j;
-    int ret = -1;
-
-    if (targets == NULL && num_targets > 0) {
-        DTRACE_PRINT4("%s:%d targets=%X num_targets=%d",
-                      __FILE__, __LINE__, targets, num_targets);
-        return -1;
-    }
-
-    if (num_targets > 0) {
-        sorted_targets = (Atom*)malloc(sizeof(Atom) * num_targets);
-        if (sorted_targets == NULL) {
-            DTRACE_PRINT2("%s:%d malloc failed.", __FILE__, __LINE__);
-            return -1;
-        }
-
-        memcpy(sorted_targets, targets, sizeof(Atom) * num_targets);
-        qsort ((void *)sorted_targets, (size_t)num_targets, (size_t)sizeof(Atom),
-               _compare);
-    }
-
-    XGrabServer(dpy);
-    targets_table = get_target_list_table(dpy);
-
-    if (targets_table != NULL) {
-        for (i = 0; i < targets_table->num_entries; i++) {
-            TargetsTableEntry* entry_ptr = &targets_table->entries[i];
-            Boolean equals = True;
-            if (num_targets == entry_ptr->num_targets) {
-                for (j = 0; j < entry_ptr->num_targets; j++) {
-                    if (sorted_targets[j] != entry_ptr->targets[j]) {
-                        equals = False;
-                        break;
-                    }
-                }
-            } else {
-                equals = False;
-            }
-
-            if (equals) {
-                XUngrabServer(dpy);
-                /* Workaround for bug 5039226 */
-                XSync(dpy, False);
-                free((char*)sorted_targets);
-                return i;
-            }
-        }
-    } else {
-        targets_table = (TargetsTable*)malloc(sizeof(TargetsTable));
-        targets_table->num_entries = 0;
-        targets_table->entries = NULL;
-    }
-
-    /* Index not found - expand the table. */
-    targets_table->entries =
-        (TargetsTableEntry*)realloc((char*)targets_table->entries,
-                                    sizeof(TargetsTableEntry) *
-                                    (targets_table->num_entries + 1));
-    if (targets_table->entries == NULL) {
-        DTRACE_PRINT2("%s:%d realloc failed.", __FILE__, __LINE__);
-        XUngrabServer(dpy);
-        /* Workaround for bug 5039226 */
-        XSync(dpy, False);
-        free((char*)sorted_targets);
-        return -1;
-    }
-
-    /* Fill in the new entry */
-    {
-        TargetsTableEntry* new_entry =
-            &targets_table->entries[targets_table->num_entries];
-
-        new_entry->num_targets = num_targets;
-        if (num_targets > 0) {
-            new_entry->targets = (Atom*)malloc(sizeof(Atom) * num_targets);
-            if (new_entry->targets == NULL) {
-                DTRACE_PRINT2("%s:%d malloc failed.", __FILE__, __LINE__);
-                XUngrabServer(dpy);
-                /* Workaround for bug 5039226 */
-                XSync(dpy, False);
-                free((char*)sorted_targets);
-                return -1;
-            }
-            memcpy(new_entry->targets, sorted_targets,
-                   sizeof(Atom) * num_targets);
-        } else {
-            new_entry->targets = NULL;
-        }
-    }
-
-    targets_table->num_entries++;
-
-    put_target_list_table(dpy, targets_table);
-
-    XUngrabServer(dpy);
-    /* Workaround for bug 5039226 */
-    XSync(dpy, False);
-
-    ret = targets_table->num_entries - 1;
-
-    free((char*)sorted_targets);
-
-    for (i = 0; i < targets_table->num_entries; i++) {
-        free((char*)targets_table->entries[i].targets);
-    }
-
-    free((char*)targets_table->entries);
-    free((char*)targets_table);
-    return ret;
-}
-
-/*
- * Retrieves the target list for the specified index.
- * Stores the number of targets in the list to 'num_targets' and the targets
- * to 'targets'. On failure stores 0 and NULL respectively.
- * The caller should free the allocated array when done with it.
- */
-void
-get_target_list_for_index(Display* dpy, int index, Atom** targets, unsigned int* num_targets) {
-    TargetsTable* table = get_target_list_table(dpy);
-    TargetsTableEntry* entry = NULL;
-
-    if (table == NULL) {
-        DTRACE_PRINT2("%s:%d No target table.", __FILE__, __LINE__);
-        *targets = NULL;
-        *num_targets = 0;
-        return;
-    }
-
-    if (table->num_entries <= index) {
-        DTRACE_PRINT4("%s:%d index out of bounds idx=%d entries=%d",
-                      __FILE__, __LINE__, index, table->num_entries);
-        *targets = NULL;
-        *num_targets = 0;
-        return;
-    }
-
-    entry = &table->entries[index];
-
-    *targets = (Atom*)malloc(entry->num_targets * sizeof(Atom));
-
-    if (*targets == NULL) {
-        DTRACE_PRINT2("%s:%d malloc failed.", __FILE__, __LINE__);
-        *num_targets = 0;
-        return;
-    }
-
-    memcpy(*targets, entry->targets, entry->num_targets * sizeof(Atom));
-    *num_targets = entry->num_targets;
-}
-
-jint
-motif_to_java_actions(unsigned char motif_action) {
-    jint java_action = java_awt_dnd_DnDConstants_ACTION_NONE;
-
-    if (motif_action & MOTIF_DND_COPY) {
-        java_action |= java_awt_dnd_DnDConstants_ACTION_COPY;
-    }
-
-    if (motif_action & MOTIF_DND_MOVE) {
-        java_action |= java_awt_dnd_DnDConstants_ACTION_MOVE;
-    }
-
-    if (motif_action & MOTIF_DND_LINK) {
-        java_action |= java_awt_dnd_DnDConstants_ACTION_LINK;
-    }
-
-    return java_action;
-}
-
-unsigned char
-java_to_motif_actions(jint java_action) {
-    unsigned char motif_action = MOTIF_DND_NOOP;
-
-    if (java_action & java_awt_dnd_DnDConstants_ACTION_COPY) {
-        motif_action |= MOTIF_DND_COPY;
-    }
-
-    if (java_action & java_awt_dnd_DnDConstants_ACTION_MOVE) {
-        motif_action |= MOTIF_DND_MOVE;
-    }
-
-    if (java_action & java_awt_dnd_DnDConstants_ACTION_LINK) {
-        motif_action |= MOTIF_DND_LINK;
-    }
-
-    return motif_action;
-}
-
-Boolean
-awt_dnd_process_event(XEvent* event) {
-    Boolean ret = awt_dnd_ds_process_event(event) ||
-        awt_dnd_dt_process_event(event);
-
-    /* Extract the event from the queue if it is processed. */
-    if (ret) {
-        XNextEvent(event->xany.display, event);
-    }
-
-    return ret;
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_dnd_ds.c openjdk/jdk/src/solaris/native/sun/awt/awt_dnd_ds.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_dnd_ds.c	2014-04-08 05:27:03.458875205 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_dnd_ds.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1796 +0,0 @@
-/*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_dnd.h"
-
-/* Declares getCursor(JNIEnv, jobject) */
-#include "awt_Cursor.h"
-
-/* Define java constants */
-#include "java_awt_dnd_DnDConstants.h"
-#include "sun_awt_dnd_SunDragSourceContextPeer.h"
-
-/* Define DECLARE_* macros */
-#include "awt_DataTransferer.h"
-
-#define GRAB_EVENT_MASK                                          \
-   (ButtonPressMask | ButtonMotionMask | ButtonReleaseMask)
-
-/* Events selected on the root window during drag. */
-#define ROOT_EVENT_MASK                                          \
-   (ButtonMotionMask | KeyPressMask | KeyReleaseMask)
-
-/* Events selected on registered receiver windows during drag. */
-#define RECEIVER_EVENT_MASK                                      \
-   (StructureNotifyMask)
-
-
-/* in canvas.c */
-extern jint getModifiers(uint32_t state, jint button, jint keyCode);
-
-typedef struct {
-    CARD8    byte_order;
-    CARD8    protocol_version;
-    CARD16   index;
-    CARD32   selection_atom;
-} InitiatorInfo;
-
-typedef enum {
-    /*
-     * Communicate with receivers of both protocols.
-     * If the receiver supports both protocols,
-     * choose Motif DnD for communication.
-     */
-    DS_POLICY_PREFER_MOTIF,
-    /*
-     * Communicate with receivers of both protocols.
-     * If the receiver supports both protocols,
-     * choose XDnD for communication. [default]
-     */
-    DS_POLICY_PREFER_XDND,
-    /* Communicate only with Motif DnD receivers. */
-    DS_POLICY_ONLY_MOTIF,
-    /* Communicate only with XDnD receivers. */
-    DS_POLICY_ONLY_XDND
-} DragSourcePolicy;
-
-
-/* The drag source policy. */
-static DragSourcePolicy drag_source_policy = DS_POLICY_PREFER_XDND;
-
-static Boolean dnd_in_progress = False;
-static Boolean drag_in_progress = False;
-static jobject source_peer = NULL;
-static Atom* data_types = NULL;
-static unsigned int data_types_count = 0;
-static Window drag_root_window = None;
-static EventMask your_root_event_mask = NoEventMask;
-static Time latest_time_stamp = CurrentTime;
-
-/* The child of the root which is currently under the mouse. */
-static Window target_root_subwindow = None;
-
-static Window target_window = None;
-static long target_window_mask = 0;
-static Window target_proxy_window = None;
-static Protocol target_protocol = NO_PROTOCOL;
-static unsigned int target_protocol_version = 0;
-/*
- * The server time when the pointer entered the current target -
- * needed on Motif DnD to filter out messages from the previous
- * target.
- * It is updated whenever the target_window is updated.
- * If the target_window is set to non-None, it is set to the time stamp
- * of the X event that trigger the update. Otherwise, it is set to CurrentTime.
- */
-static Time target_enter_server_time = CurrentTime;
-
-static int x_root = 0;
-static int y_root = 0;
-static unsigned int event_state = 0;
-
-static jint source_action = java_awt_dnd_DnDConstants_ACTION_NONE;
-static jint source_actions = java_awt_dnd_DnDConstants_ACTION_NONE;
-static jint target_action = java_awt_dnd_DnDConstants_ACTION_NONE;
-
-/* Forward declarations */
-static void cleanup_drag(Display* dpy, Time time);
-static Boolean process_proxy_mode_event(XEvent* xev);
-
-/**************************** XEmbed server DnD support ***********************/
-static Window proxy_mode_source_window = None;
-/******************************************************************************/
-
-/**************************** JNI stuff ***************************************/
-
-DECLARE_JAVA_CLASS(dscp_clazz, "sun/awt/dnd/SunDragSourceContextPeer")
-
-static void
-ds_postDragSourceDragEvent(JNIEnv* env, jint targetAction, unsigned int state,
-                           int x, int y, jint dispatch_type) {
-    DECLARE_VOID_JAVA_METHOD(dscp_postDragSourceDragEvent, dscp_clazz,
-                             "postDragSourceDragEvent", "(IIIII)V");
-
-    DASSERT(!JNU_IsNull(env, source_peer));
-    if (JNU_IsNull(env, source_peer)) {
-        return;
-    }
-
-    (*env)->CallVoidMethod(env, source_peer, dscp_postDragSourceDragEvent,
-                           targetAction, getModifiers(state, 0, 0), x, y,
-                           dispatch_type);
-}
-
-static jint
-ds_convertModifiersToDropAction(JNIEnv* env, unsigned int state) {
-    jint action;
-    DECLARE_STATIC_JINT_JAVA_METHOD(dscp_convertModifiersToDropAction, dscp_clazz,
-                                    "convertModifiersToDropAction", "(II)I");
-    action = (*env)->CallStaticIntMethod(env, clazz, dscp_convertModifiersToDropAction,
-                                              getModifiers(state, 0, 0), source_actions);
-    if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-        return java_awt_dnd_DnDConstants_ACTION_NONE;
-    }
-    return action;
-}
-
-static void
-ds_postDragSourceEvent(JNIEnv* env, int x, int y) {
-    DECLARE_VOID_JAVA_METHOD(dscp_dragExit, dscp_clazz,
-                             "dragExit", "(II)V");
-
-    DASSERT(!JNU_IsNull(env, source_peer));
-    if (JNU_IsNull(env, source_peer)) {
-        return;
-    }
-
-    (*env)->CallVoidMethod(env, source_peer, dscp_dragExit, x, y);
-}
-
-static void
-ds_postDragSourceDropEvent(JNIEnv* env, jboolean success, jint targetAction,
-                           int x, int y) {
-    DECLARE_VOID_JAVA_METHOD(dscp_dragDropFinished, dscp_clazz,
-                             "dragDropFinished", "(ZIII)V");
-
-    DASSERT(!JNU_IsNull(env, source_peer));
-    if (JNU_IsNull(env, source_peer)) {
-        return;
-    }
-
-    (*env)->CallVoidMethod(env, source_peer, dscp_dragDropFinished,
-                           success, targetAction, x, y);
-}
-
-/******************************************************************************/
-
-static void
-cancel_drag(XtPointer client_data, XtIntervalId* id) {
-    Time time_stamp = awt_util_getCurrentServerTime();
-
-    cleanup_drag(awt_display, time_stamp);
-}
-
-#define DONT_CARE -1
-
-static void
-awt_popupCallback(Widget shell, XtPointer closure, XtPointer call_data) {
-    XtGrabKind grab_kind = XtGrabNone;
-
-    if (call_data != NULL) {
-        grab_kind = *((XtGrabKind*)call_data);
-    }
-
-    if (XmIsVendorShell(shell)) {
-        int input_mode;
-        XtVaGetValues(shell, XmNmwmInputMode, &input_mode, NULL);
-        switch (input_mode) {
-        case DONT_CARE:
-        case MWM_INPUT_MODELESS:
-            grab_kind = XtGrabNonexclusive; break;
-        case MWM_INPUT_PRIMARY_APPLICATION_MODAL:
-        case MWM_INPUT_SYSTEM_MODAL:
-        case MWM_INPUT_FULL_APPLICATION_MODAL:
-            grab_kind = XtGrabExclusive; break;
-        }
-    }
-
-    if (grab_kind == XtGrabExclusive) {
-        /*
-         * We should cancel the drag on the toolkit thread. Otherwise, it can be
-         * called while the toolkit thread is waiting inside some drag callback.
-         * In this case Motif will crash when the drag callback returns.
-         */
-        XtAppAddTimeOut(awt_appContext, 0L, cancel_drag, NULL);
-    }
-}
-
-static XtInitProc xt_shell_initialize = NULL;
-
-static void
-awt_ShellInitialize(Widget req, Widget new, ArgList args, Cardinal *num_args) {
-    XtAddCallback(new, XtNpopupCallback, awt_popupCallback, NULL);
-    (*xt_shell_initialize)(req, new, args, num_args);
-}
-
-/*
- * Fix for 4484572 (copied from awt_XmDnD.c).
- * Modify the 'initialize' routine for all ShellWidget instances, so that it
- * will install an XtNpopupCallback that cancels the current drag operation.
- * It is needed, since AWT doesn't have full control over all ShellWidget
- * instances (e.g. XmPopupMenu internally creates and popups an XmMenuShell).
- */
-static void
-awt_set_ShellInitialize() {
-    static Boolean inited = False;
-
-    DASSERT(!inited);
-    if (inited) {
-        return;
-    }
-
-    xt_shell_initialize = shellWidgetClass->core_class.initialize;
-    shellWidgetClass->core_class.initialize = (XtInitProc)awt_ShellInitialize;
-    inited = True;
-}
-
-/*
- * Returns True if initialization completes successfully.
- */
-Boolean
-awt_dnd_ds_init(Display* display) {
-    if (XSaveContext(display, XA_XdndSelection, awt_convertDataContext,
-                     (XPointer)NULL) == XCNOMEM) {
-        return False;
-    }
-
-    if (XSaveContext(display, _XA_MOTIF_ATOM_0, awt_convertDataContext,
-                     (XPointer)NULL) == XCNOMEM) {
-        return False;
-    }
-
-    {
-        char *ev = getenv("_JAVA_DRAG_SOURCE_POLICY");
-
-        /* By default XDnD protocol is preferred. */
-        drag_source_policy = DS_POLICY_PREFER_XDND;
-
-        if (ev != NULL) {
-            if (strcmp(ev, "PREFER_XDND") == 0) {
-                drag_source_policy = DS_POLICY_PREFER_XDND;
-            } else if (strcmp(ev, "PREFER_MOTIF") == 0) {
-                drag_source_policy = DS_POLICY_PREFER_MOTIF;
-            } else if (strcmp(ev, "ONLY_MOTIF") == 0) {
-                drag_source_policy = DS_POLICY_ONLY_MOTIF;
-            } else if (strcmp(ev, "ONLY_XDND") == 0) {
-                drag_source_policy = DS_POLICY_ONLY_XDND;
-            }
-        }
-    }
-
-    awt_set_ShellInitialize();
-
-    return True;
-}
-
-/*
- * Returns a handle of the window used as a drag source.
- */
-Window
-awt_dnd_ds_get_source_window() {
-    return get_awt_root_window();
-}
-
-/*
- * Returns True if a drag operation initiated by this client
- * is still in progress.
- */
-Boolean
-awt_dnd_ds_in_progress() {
-    return dnd_in_progress;
-}
-
-static void
-ds_send_event_to_target(XClientMessageEvent* xclient) {
-    /* Shortcut if the source is in the same JVM. */
-    if (XtWindowToWidget(xclient->display, target_proxy_window) != NULL) {
-        awt_dnd_dt_process_event((XEvent*)xclient);
-    } else {
-        XSendEvent(xclient->display, target_proxy_window, False, NoEventMask,
-                   (XEvent*)xclient);
-    }
-}
-
-static void
-xdnd_send_enter(Display* dpy, Time time) {
-    XClientMessageEvent enter;
-
-    enter.display = dpy;
-    enter.type = ClientMessage;
-    enter.window = target_window;
-    enter.format = 32;
-    enter.message_type = XA_XdndEnter;
-    enter.data.l[0] = awt_dnd_ds_get_source_window();
-    enter.data.l[1] = target_protocol_version << XDND_PROTOCOL_SHIFT;
-    enter.data.l[1] |= data_types_count > 3 ? XDND_DATA_TYPES_BIT : 0;
-    enter.data.l[2] = data_types_count > 0 ? data_types[0] : None;
-    enter.data.l[3] = data_types_count > 1 ? data_types[1] : None;
-    enter.data.l[4] = data_types_count > 2 ? data_types[2] : None;
-
-    ds_send_event_to_target(&enter);
-}
-
-static void
-motif_send_enter(Display* dpy, Time time) {
-    XClientMessageEvent enter;
-
-    enter.display = dpy;
-    enter.type = ClientMessage;
-    enter.window = target_window;
-    enter.format = 8;
-    enter.message_type = _XA_MOTIF_DRAG_AND_DROP_MESSAGE;
-
-    {
-        void* p = &enter.data.b[0];
-        int flags = 0;
-
-        flags |= java_to_motif_actions(source_action) << MOTIF_DND_ACTION_SHIFT;
-        flags |= java_to_motif_actions(source_actions) << MOTIF_DND_ACTIONS_SHIFT;
-
-        write_card8(&p, TOP_LEVEL_ENTER | MOTIF_MESSAGE_FROM_INITIATOR);
-        write_card8(&p, MOTIF_BYTE_ORDER);
-        write_card16(&p, flags);
-        write_card32(&p, time);
-        write_card32(&p, awt_dnd_ds_get_source_window());
-        write_card32(&p, _XA_MOTIF_ATOM_0);
-    }
-
-    ds_send_event_to_target(&enter);
-}
-
-static void
-send_enter(Display* dpy, Time time) {
-    switch (target_protocol) {
-    case XDND_PROTOCOL:
-        xdnd_send_enter(dpy, time);
-        break;
-    case MOTIF_DND_PROTOCOL:
-        motif_send_enter(dpy, time);
-        break;
-    case NO_PROTOCOL:
-    default:
-        DTRACE_PRINTLN2("%s:%d send_enter: unknown DnD protocol.", __FILE__, __LINE__);
-        break;
-    }
-}
-
-static void
-xdnd_send_move(XMotionEvent* event) {
-    XClientMessageEvent move;
-
-    move.display = event->display;
-    move.type = ClientMessage;
-    move.window = target_window;
-    move.format = 32;
-    move.message_type = XA_XdndPosition;
-    move.data.l[0] = awt_dnd_ds_get_source_window();
-    move.data.l[1] = 0; /* flags */
-    move.data.l[2] = event->x_root << 16 | event->y_root;
-    move.data.l[3] = event->time;
-    move.data.l[4] = java_to_xdnd_action(source_action);
-
-    ds_send_event_to_target(&move);
-}
-
-static void
-motif_send_move(XMotionEvent* event) {
-    XClientMessageEvent move;
-
-    move.display = event->display;
-    move.type = ClientMessage;
-    move.window = target_window;
-    move.format = 8;
-    move.message_type = _XA_MOTIF_DRAG_AND_DROP_MESSAGE;
-
-    {
-        void* p = move.data.b;
-        int flags = 0;
-
-        flags |= java_to_motif_actions(source_action) << MOTIF_DND_ACTION_SHIFT;
-        flags |= java_to_motif_actions(source_actions) << MOTIF_DND_ACTIONS_SHIFT;
-
-        write_card8(&p, DRAG_MOTION | MOTIF_MESSAGE_FROM_INITIATOR);
-        write_card8(&p, MOTIF_BYTE_ORDER);
-        write_card16(&p, flags);
-        write_card32(&p, event->time);
-        write_card16(&p, event->x_root);
-        write_card16(&p, event->y_root);
-    }
-
-    ds_send_event_to_target(&move);
-}
-
-static void
-send_move(XMotionEvent* event) {
-    switch (target_protocol) {
-    case XDND_PROTOCOL:
-        xdnd_send_move(event);
-        break;
-    case MOTIF_DND_PROTOCOL:
-        motif_send_move(event);
-        break;
-    case NO_PROTOCOL:
-    default:
-        DTRACE_PRINTLN2("%s:%d send_move: unknown DnD protocol.", __FILE__, __LINE__);
-        break;
-    }
-}
-
-static void
-xdnd_send_leave(Display* dpy, Time time) {
-    XClientMessageEvent leave;
-
-    leave.display = dpy;
-    leave.type = ClientMessage;
-    leave.window = target_window;
-    leave.format = 32;
-    leave.message_type = XA_XdndLeave;
-    leave.data.l[0] = awt_dnd_ds_get_source_window();
-    leave.data.l[1] = 0;
-    leave.data.l[2] = 0;
-    leave.data.l[3] = 0;
-    leave.data.l[4] = 0;
-
-    ds_send_event_to_target(&leave);
-}
-
-static void
-motif_send_leave(Display* dpy, Time time) {
-    XClientMessageEvent leave;
-
-    leave.display = dpy;
-    leave.type = ClientMessage;
-    leave.window = target_window;
-    leave.format = 8;
-    leave.message_type = _XA_MOTIF_DRAG_AND_DROP_MESSAGE;
-
-    {
-        void* p = &leave.data.b[0];
-
-        write_card8(&p, TOP_LEVEL_LEAVE | MOTIF_MESSAGE_FROM_INITIATOR);
-        write_card8(&p, MOTIF_BYTE_ORDER);
-        write_card16(&p, 0);
-        write_card32(&p, time);
-        write_card32(&p, awt_dnd_ds_get_source_window());
-    }
-
-    ds_send_event_to_target(&leave);
-}
-
-static void
-send_leave(Display* dpy, Time time) {
-    switch (target_protocol) {
-    case XDND_PROTOCOL:
-        xdnd_send_leave(dpy, time);
-        break;
-    case MOTIF_DND_PROTOCOL:
-        motif_send_leave(dpy, time);
-        break;
-    case NO_PROTOCOL:
-    default:
-        DTRACE_PRINTLN2("%s:%d send_leave: unknown DnD protocol.", __FILE__, __LINE__);
-        break;
-    }
-}
-
-
-static void
-xdnd_send_drop(XButtonEvent* event) {
-    XClientMessageEvent drop;
-
-    drop.display = event->display;
-    drop.type = ClientMessage;
-    drop.window = target_window;
-    drop.format = 32;
-    drop.message_type = XA_XdndDrop;
-    drop.data.l[0] = awt_dnd_ds_get_source_window();
-    drop.data.l[1] = 0; /* flags */
-    drop.data.l[2] = event->time; /* ### */
-    drop.data.l[3] = 0;
-    drop.data.l[4] = 0;
-
-    ds_send_event_to_target(&drop);
-}
-
-static void
-motif_send_drop(XButtonEvent* event) {
-    XClientMessageEvent drop;
-
-    /*
-     * Motif drop sites expect TOP_LEVEL_LEAVE before DROP_START.
-     */
-    motif_send_leave(event->display, event->time);
-
-    drop.display = event->display;
-    drop.type = ClientMessage;
-    drop.window = target_window;
-    drop.format = 8;
-    drop.message_type = _XA_MOTIF_DRAG_AND_DROP_MESSAGE;
-
-    {
-        void* p = &drop.data.b[0];
-        int flags = 0;
-
-        flags |= java_to_motif_actions(source_action) << MOTIF_DND_ACTION_SHIFT;
-        flags |= java_to_motif_actions(source_actions) << MOTIF_DND_ACTIONS_SHIFT;
-
-        write_card8(&p, DROP_START | MOTIF_MESSAGE_FROM_INITIATOR);
-        write_card8(&p, MOTIF_BYTE_ORDER);
-        write_card16(&p, flags);
-        write_card32(&p, event->time);
-        write_card16(&p, event->x_root);
-        write_card16(&p, event->y_root);
-        write_card32(&p, _XA_MOTIF_ATOM_0);
-        write_card32(&p, awt_dnd_ds_get_source_window());
-    }
-
-    ds_send_event_to_target(&drop);
-}
-
-static void
-send_drop(XButtonEvent* event) {
-    switch (target_protocol) {
-    case XDND_PROTOCOL:
-        xdnd_send_drop(event);
-        break;
-    case MOTIF_DND_PROTOCOL:
-        motif_send_drop(event);
-        break;
-    case NO_PROTOCOL:
-    default:
-        DTRACE_PRINTLN2("%s:%d send_drop: unknown DnD protocol.", __FILE__, __LINE__);
-        break;
-    }
-}
-
-static void
-remove_dnd_grab(Display* dpy, Time time) {
-    XUngrabPointer(dpy, time);
-    XUngrabKeyboard(dpy, time);
-
-    /* Restore the root event mask if it was changed. */
-    if ((your_root_event_mask | ROOT_EVENT_MASK) != your_root_event_mask &&
-        drag_root_window != None) {
-
-        XSelectInput(dpy, drag_root_window, your_root_event_mask);
-
-        drag_root_window = None;
-        your_root_event_mask = NoEventMask;
-    }
-}
-
-static void
-cleanup_target_info(Display* dpy) {
-    target_root_subwindow = None;
-
-    target_window = None;
-    target_proxy_window = None;
-    target_protocol = NO_PROTOCOL;
-    target_protocol_version = 0;
-    target_enter_server_time = CurrentTime;
-    target_action = java_awt_dnd_DnDConstants_ACTION_NONE;
-}
-
-static void
-cleanup_drag(Display* dpy, Time time) {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-
-    if (dnd_in_progress) {
-        if (target_window != None) {
-            send_leave(dpy, time);
-        }
-
-        if (target_action != java_awt_dnd_DnDConstants_ACTION_NONE) {
-            JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-            ds_postDragSourceEvent(env, x_root, y_root);
-        }
-
-        ds_postDragSourceDropEvent(env, JNI_FALSE,
-                                   java_awt_dnd_DnDConstants_ACTION_NONE,
-                                   x_root, y_root);
-    }
-
-    /* Cleanup the global state */
-    dnd_in_progress = False;
-    drag_in_progress = False;
-    data_types_count = 0;
-    if (data_types != NULL) {
-        free(data_types);
-        data_types = NULL;
-    }
-    if (!JNU_IsNull(env, source_peer)) {
-        (*env)->DeleteGlobalRef(env, source_peer);
-        source_peer = NULL;
-    }
-
-    cleanup_target_info(dpy);
-
-    remove_dnd_grab(dpy, time);
-
-    XDeleteProperty(awt_display, awt_dnd_ds_get_source_window(), _XA_MOTIF_ATOM_0);
-    XDeleteProperty(awt_display, awt_dnd_ds_get_source_window(), XA_XdndTypeList);
-    XDeleteProperty(awt_display, awt_dnd_ds_get_source_window(), XA_XdndActionList);
-    XtDisownSelection(awt_root_shell, _XA_MOTIF_ATOM_0, time);
-    XtDisownSelection(awt_root_shell, XA_XdndSelection, time);
-
-    awt_cleanupConvertDataContext(env, _XA_MOTIF_ATOM_0);
-    awt_cleanupConvertDataContext(env, XA_XdndSelection);
-}
-
-static void
-process_drop(XButtonEvent* event) {
-    unsigned char ret;
-    XWindowAttributes xwa;
-
-    DASSERT(target_window != None);
-
-    XGetWindowAttributes(event->display, target_window, &xwa);
-
-    target_window_mask = xwa.your_event_mask;
-
-    /* Select for DestoyNotify to cleanup if the target crashes. */
-    ret = checked_XSelectInput(event->display, target_window,
-                               (target_window_mask | StructureNotifyMask));
-
-    if (ret == Success) {
-        send_drop(event);
-    } else {
-        DTRACE_PRINTLN2("%s:%d drop rejected - invalid window.",
-                        __FILE__, __LINE__);
-        cleanup_drag(event->display, event->time);
-    }
-}
-
-static Window
-find_client_window(Display* dpy, Window window) {
-    Window root, parent, *children;
-    unsigned int nchildren, idx;
-
-    Atom           type;
-    int            format;
-    unsigned long  nitems;
-    unsigned long  after;
-    unsigned char  *data;
-    Status ret;
-
-    if (XGetWindowProperty(dpy, window, XA_WM_STATE, 0, 0, False,
-                           AnyPropertyType, &type, &format, &nitems,
-                           &after, &data) == Success) {
-        XFree(data);
-    }
-
-    if (type != None) {
-        return window;
-    }
-
-    if (!XQueryTree(dpy, window, &root, &parent, &children, &nchildren)) {
-        return None;
-    }
-
-    if (children == NULL) {
-        return None;
-    }
-
-    for (idx = 0; idx < nchildren; idx++) {
-        Window win = find_client_window(dpy, children[idx]);
-        if (win != None) {
-            XFree(children);
-            return win;
-        }
-    }
-
-    XFree(children);
-    return None;
-}
-
-static void
-do_update_target_window(Display* dpy, Window subwindow, Time time) {
-    Window client_window = None;
-    Window proxy_window = None;
-    Protocol protocol = NO_PROTOCOL;
-    unsigned int protocol_version = 0;
-    Boolean is_receiver = False;
-
-    client_window = find_client_window(dpy, subwindow);
-
-    if (client_window != None) {
-        /* Request status */
-        int            status;
-
-        /* Returns of XGetWindowProperty */
-        Atom           type;
-        int            format;
-        unsigned long  nitems;
-        unsigned long  after;
-        unsigned char  *data;
-
-        /*
-         * No need for checked_XGetWindowProperty, since we check the returned
-         * property type anyway.
-         */
-        if (drag_source_policy != DS_POLICY_ONLY_XDND) {
-
-            data = NULL;
-            status = XGetWindowProperty(dpy, client_window,
-                                        _XA_MOTIF_DRAG_RECEIVER_INFO,
-                                        0, 0xFFFF, False, AnyPropertyType,
-                                        &type, &format, &nitems, &after, &data);
-
-            if (status == Success && data != NULL && type != None && format == 8
-                && nitems >= MOTIF_RECEIVER_INFO_SIZE) {
-                unsigned char byte_order = read_card8((char*)data, 0);
-                unsigned char drag_protocol_style = read_card8((char*)data, 2);
-
-                switch (drag_protocol_style) {
-                case MOTIF_PREFER_PREREGISTER_STYLE :
-                case MOTIF_PREFER_DYNAMIC_STYLE :
-                case MOTIF_DYNAMIC_STYLE :
-                case MOTIF_PREFER_RECEIVER_STYLE :
-                    proxy_window = read_card32((char*)data, 4, byte_order);
-                    protocol = MOTIF_DND_PROTOCOL;
-                    protocol_version = read_card8((char*)data, 1);
-                    is_receiver = True;
-                    break;
-                default:
-                    DTRACE_PRINTLN3("%s:%d unsupported protocol style (%d).",
-                                    __FILE__, __LINE__, (int)drag_protocol_style);
-                }
-            }
-
-            if (status == Success) {
-                XFree(data);
-                data = NULL;
-            }
-        }
-
-        if (drag_source_policy != DS_POLICY_ONLY_MOTIF &&
-            (drag_source_policy != DS_POLICY_PREFER_MOTIF || !is_receiver)) {
-
-            data = NULL;
-            status = XGetWindowProperty(dpy, client_window, XA_XdndAware, 0, 1,
-                                        False, AnyPropertyType, &type, &format,
-                                        &nitems, &after, &data);
-
-            if (status == Success && data != NULL && type == XA_ATOM) {
-                unsigned int target_version = *((unsigned int*)data);
-
-                if (target_version >= XDND_MIN_PROTOCOL_VERSION) {
-                    proxy_window = None;
-                    protocol = XDND_PROTOCOL;
-                    protocol_version = target_version < XDND_PROTOCOL_VERSION ?
-                        target_version : XDND_PROTOCOL_VERSION;
-                    is_receiver = True;
-                }
-            }
-
-            /* Retrieve the proxy window handle and check if it is valid. */
-            if (protocol == XDND_PROTOCOL) {
-                if (status == Success) {
-                    XFree(data);
-                }
-
-                data = NULL;
-                status = XGetWindowProperty(dpy, client_window, XA_XdndProxy, 0,
-                                            1, False, XA_WINDOW, &type, &format,
-                                            &nitems, &after, &data);
-
-                if (status == Success && data != NULL && type == XA_WINDOW) {
-                    proxy_window = *((Window*)data);
-                }
-
-                if (proxy_window != None) {
-                    if (status == Success) {
-                        XFree(data);
-                    }
-
-                    data = NULL;
-                    status = XGetWindowProperty(dpy, proxy_window, XA_XdndProxy,
-                                                0, 1, False, XA_WINDOW, &type,
-                                                &format, &nitems, &after, &data);
-
-                    if (status != Success || data == NULL || type != XA_WINDOW ||
-                        *((Window*)data) != proxy_window) {
-                        proxy_window = None;
-                    } else {
-                        if (status == Success) {
-                            XFree(data);
-                        }
-
-                        data = NULL;
-                        status = XGetWindowProperty(dpy, proxy_window,
-                                                    XA_XdndAware,  0, 1, False,
-                                                    AnyPropertyType, &type,
-                                                    &format, &nitems, &after,
-                                                    &data);
-
-                        if (status != Success || data == NULL || type != XA_ATOM) {
-                            proxy_window = None;
-                        }
-                    }
-                }
-            }
-
-            XFree(data);
-        }
-
-        if (proxy_window == None) {
-            proxy_window = client_window;
-        }
-    }
-
-    if (is_receiver) {
-        target_window = client_window;
-        target_proxy_window = proxy_window;
-        target_protocol = protocol;
-        target_protocol_version = protocol_version;
-    } else {
-        target_window = None;
-        target_proxy_window = None;
-        target_protocol = NO_PROTOCOL;
-        target_protocol_version = 0;
-    }
-
-    target_action = java_awt_dnd_DnDConstants_ACTION_NONE;
-
-    if (target_window != None) {
-        target_enter_server_time = time;
-    } else {
-        target_enter_server_time = CurrentTime;
-    }
-
-    target_root_subwindow = subwindow;
-}
-
-static void
-update_target_window(XMotionEvent* event) {
-    Display* dpy = event->display;
-    int x = event->x_root;
-    int y = event->x_root;
-    Time time = event->time;
-    Window subwindow = event->subwindow;
-
-    /*
-     * If this event had occurred before the pointer was grabbed,
-     * query the server for the current root subwindow.
-     */
-    if (event->window != event->root) {
-        int xw, yw, xr, yr;
-        unsigned int modifiers;
-        XQueryPointer(dpy, event->root, &event->root, &subwindow,
-                      &xr, &yr, &xw, &yw, &modifiers);
-    }
-
-    if (target_root_subwindow != subwindow) {
-        if (target_window != None) {
-            send_leave(dpy, time);
-
-            /*
-             * Neither Motif DnD nor XDnD provide a mean for the target
-             * to notify the source that the pointer exits the drop site
-             * that occupies the whole top level.
-             * We detect this situation and post dragExit.
-             */
-            if (target_action != java_awt_dnd_DnDConstants_ACTION_NONE) {
-                JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-                ds_postDragSourceEvent(env, x, y);
-            }
-        }
-
-        /* Update the global state. */
-        do_update_target_window(dpy, subwindow, time);
-
-        if (target_window != None) {
-            send_enter(dpy, time);
-        }
-    }
-}
-
-/*
- * Updates the source action based on the specified event state.
- * Returns True if source action changed, False otherwise.
- */
-static Boolean
-update_source_action(unsigned int state) {
-    JNIEnv* env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    jint action = ds_convertModifiersToDropAction(env, state);
-    if (source_action == action) {
-        return False;
-    }
-    source_action = action;
-    return True;
-}
-
-static void
-handle_mouse_move(XMotionEvent* event) {
-    if (!drag_in_progress) {
-        return;
-    }
-
-    if (x_root != event->x_root || y_root != event->y_root) {
-        JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-        ds_postDragSourceDragEvent(env, target_action, event->state,
-                                   event->x_root, event->y_root,
-                                   sun_awt_dnd_SunDragSourceContextPeer_DISPATCH_MOUSE_MOVED);
-
-        x_root = event->x_root;
-        y_root = event->y_root;
-    }
-
-    if (event_state != event->state) {
-        if (update_source_action(event->state) && target_window != None) {
-            JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-            ds_postDragSourceDragEvent(env, target_action, event->state,
-                                       event->x_root, event->y_root,
-                                       sun_awt_dnd_SunDragSourceContextPeer_DISPATCH_CHANGED);
-        }
-        event_state = event->state;
-    }
-
-    update_target_window(event);
-
-    if (target_window != None) {
-        send_move(event);
-    }
-}
-
-static Boolean
-handle_xdnd_status(XClientMessageEvent* event) {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    long* event_data = event->data.l;
-    Window target_win = None;
-    jint action = java_awt_dnd_DnDConstants_ACTION_NONE;
-
-    DTRACE_PRINTLN4("%s:%d XdndStatus target_window=%ld target_protocol=%d.",
-                    __FILE__, __LINE__, target_window, target_protocol);
-
-    if (target_protocol != XDND_PROTOCOL) {
-        DTRACE_PRINTLN2("%s:%d XdndStatus rejected - invalid state.",
-                        __FILE__, __LINE__);
-        return True;
-    }
-
-    target_win = event_data[0];
-
-    /* Ignore XDnD messages from all other windows. */
-    if (target_window != target_win) {
-        DTRACE_PRINTLN4("%s:%d XdndStatus rejected - invalid target window cur=%ld this=%ld.",
-                        __FILE__, __LINE__, target_window, target_win);
-        return True;
-    }
-
-    if (event_data[1] & XDND_ACCEPT_DROP_FLAG) {
-        /* This feature is new in XDnD version 2, but we can use it as XDnD
-           compliance only requires supporting version 3 and up. */
-        action = xdnd_to_java_action(event_data[4]);
-    }
-
-    if (action == java_awt_dnd_DnDConstants_ACTION_NONE &&
-        target_action != java_awt_dnd_DnDConstants_ACTION_NONE) {
-        ds_postDragSourceEvent(env, x_root, y_root);
-    } else if (action != java_awt_dnd_DnDConstants_ACTION_NONE) {
-        jint type = 0;
-
-        if (target_action == java_awt_dnd_DnDConstants_ACTION_NONE) {
-            type = sun_awt_dnd_SunDragSourceContextPeer_DISPATCH_ENTER;
-        } else {
-            type = sun_awt_dnd_SunDragSourceContextPeer_DISPATCH_MOTION;
-        }
-
-        ds_postDragSourceDragEvent(env, action, event_state,
-                                   x_root, y_root, type);
-    }
-
-    target_action = action;
-
-    return True;
-}
-
-static Boolean
-handle_xdnd_finished(XClientMessageEvent* event) {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    long* event_data = event->data.l;
-    Window target_win = None;
-    jboolean success = JNI_TRUE;
-    jint action = java_awt_dnd_DnDConstants_ACTION_NONE;
-
-    if (target_protocol != XDND_PROTOCOL) {
-        DTRACE_PRINTLN2("%s:%d XdndStatus rejected - invalid state.",
-                        __FILE__, __LINE__);
-        return True;
-    }
-
-    target_win = event_data[0];
-
-    /* Ignore XDnD messages from all other windows. */
-    if (target_window != target_win) {
-        DTRACE_PRINTLN4("%s:%d XdndStatus rejected - invalid target window cur=%ld this=%ld.",
-                        __FILE__, __LINE__, target_window, target_win);
-        return True;
-    }
-
-    if (target_protocol_version >= 5) {
-        success = (event_data[1] & XDND_ACCEPT_DROP_FLAG) != 0 ?
-            JNI_TRUE : JNI_FALSE;
-        action = xdnd_to_java_action(event_data[2]);
-    } else {
-        /* Assume that the drop was successful and the performed drop action is
-           the drop action accepted with the latest XdndStatus message. */
-        success = JNI_TRUE;
-        action = target_action;
-    }
-
-    ds_postDragSourceDropEvent(env, success, action, x_root, y_root);
-
-    dnd_in_progress = False;
-
-    XSelectInput(event->display, target_win, target_window_mask);
-
-    cleanup_drag(event->display, CurrentTime);
-
-    return True;
-}
-
-static Boolean
-handle_motif_client_message(XClientMessageEvent* event) {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    int reason = (int)(event->data.b[0] & MOTIF_MESSAGE_REASON_MASK);
-    int origin = (int)(event->data.b[0] & MOTIF_MESSAGE_SENDER_MASK);
-    unsigned char byte_order = event->data.b[1];
-    jint action = java_awt_dnd_DnDConstants_ACTION_NONE;
-    Time time = CurrentTime;
-    int x = 0, y = 0;
-
-    /* Only receiver messages should be handled. */
-    if (origin != MOTIF_MESSAGE_FROM_RECEIVER) {
-        return False;
-    }
-
-    if (target_protocol != MOTIF_DND_PROTOCOL) {
-        DTRACE_PRINTLN2("%s:%d _MOTIF_DRAG_AND_DROP_MESSAGE rejected - invalid state.",
-                        __FILE__, __LINE__);
-        return True;
-    }
-
-    switch (reason) {
-    case DROP_SITE_ENTER:
-    case DROP_SITE_LEAVE:
-    case DRAG_MOTION:
-    case OPERATION_CHANGED:
-        break;
-    default:
-        return False;
-    }
-
-    time = read_card32(event->data.b, 4, byte_order);
-
-    /* Discard events from the previous receiver. */
-    if (target_enter_server_time == CurrentTime ||
-        time < target_enter_server_time) {
-        DTRACE_PRINTLN2("%s:%d _MOTIF_DRAG_AND_DROP_MESSAGE rejected - invalid time.",
-                        __FILE__, __LINE__);
-        return True;
-    }
-
-    if (reason != DROP_SITE_LEAVE) {
-        CARD16 flags = read_card16(event->data.b, 2, byte_order);
-        unsigned char status = (flags & MOTIF_DND_STATUS_MASK) >>
-            MOTIF_DND_STATUS_SHIFT;
-        unsigned char motif_action = (flags & MOTIF_DND_ACTION_MASK) >>
-            MOTIF_DND_ACTION_SHIFT;
-
-        if (status == MOTIF_VALID_DROP_SITE) {
-            action = motif_to_java_actions(motif_action);
-        } else {
-            action = java_awt_dnd_DnDConstants_ACTION_NONE;
-        }
-
-        x = read_card16(event->data.b, 8, byte_order);
-        y = read_card16(event->data.b, 10, byte_order);
-    }
-
-    /*
-     * We should derive the type of java event to post not from the message
-     * reason, but from the combination of the current and previous target
-     * actions:
-     * Even if the reason is DROP_SITE_LEAVE we shouldn't post dragExit
-     * if the drag was rejected earlier.
-     * Even if the reason is DROP_SITE_ENTER we shouldn't post dragEnter
-     * if the drag is not accepted.
-     */
-    if (target_action != java_awt_dnd_DnDConstants_ACTION_NONE &&
-        action == java_awt_dnd_DnDConstants_ACTION_NONE) {
-
-        ds_postDragSourceEvent(env, x, y);
-    } else if (action != java_awt_dnd_DnDConstants_ACTION_NONE) {
-        jint type = 0;
-
-        if (target_action == java_awt_dnd_DnDConstants_ACTION_NONE) {
-            type = sun_awt_dnd_SunDragSourceContextPeer_DISPATCH_ENTER;
-        } else {
-            type = sun_awt_dnd_SunDragSourceContextPeer_DISPATCH_MOTION;
-        }
-
-        ds_postDragSourceDragEvent(env, action, event_state, x, y, type);
-    }
-
-    target_action = action;
-
-    return True;
-}
-
-/*
- * Handles client messages.
- * Returns True if the event is processed, False otherwise.
- */
-static Boolean
-handle_client_message(XClientMessageEvent* event) {
-    if (event->message_type == XA_XdndStatus) {
-        return handle_xdnd_status(event);
-    } else if (event->message_type == XA_XdndFinished) {
-        return handle_xdnd_finished(event);
-    } else if (event->message_type == _XA_MOTIF_DRAG_AND_DROP_MESSAGE) {
-        return handle_motif_client_message(event);
-    }
-    return False;
-}
-
-/*
- * Similar to XtLastTimestampProcessed(). We cannot use Xt time stamp, as it is
- * updated in XtDispatchEvent that may not be called if a java event is
- * consumed. This can make Xt time stamp out-of-date and cause XGrab* failures
- * with GrabInvalidTime reason.
- */
-static Time
-get_latest_time_stamp() {
-    return latest_time_stamp;
-}
-
-static void
-update_latest_time_stamp(XEvent* event) {
-    Time time = latest_time_stamp;
-
-    switch (event->type) {
-    case KeyPress:
-    case KeyRelease:     time = event->xkey.time;            break;
-    case ButtonPress:
-    case ButtonRelease:  time = event->xbutton.time;         break;
-    case MotionNotify:   time = event->xmotion.time;         break;
-    case EnterNotify:
-    case LeaveNotify:    time = event->xcrossing.time;       break;
-    case PropertyNotify: time = event->xproperty.time;       break;
-    case SelectionClear: time = event->xselectionclear.time; break;
-    }
-
-    latest_time_stamp = time;
-}
-
-Boolean
-awt_dnd_ds_process_event(XEvent* event) {
-    Display* dpy = event->xany.display;
-
-    update_latest_time_stamp(event);
-
-    if (process_proxy_mode_event(event)) {
-        return True;
-    }
-
-    if (!dnd_in_progress) {
-        return False;
-    }
-
-    /* Process drag and drop messages. */
-    switch (event->type) {
-    case ClientMessage:
-        return handle_client_message(&event->xclient);
-    case DestroyNotify:
-        /* Target crashed during drop processing - cleanup. */
-        if (!drag_in_progress &&
-            event->xdestroywindow.window == target_window) {
-            cleanup_drag(dpy, CurrentTime);
-            return True;
-        }
-        /* Pass along */
-        return False;
-    }
-
-    if (!drag_in_progress) {
-        return False;
-    }
-
-    /* Process drag-only messages. */
-    switch (event->type) {
-    case KeyRelease:
-    case KeyPress: {
-        KeySym keysym = XKeycodeToKeysym(dpy, event->xkey.keycode, 0);
-        switch (keysym) {
-        case XK_Escape: {
-            if (keysym == XK_Escape) {
-                remove_dnd_grab(dpy, event->xkey.time);
-                cleanup_drag(dpy, event->xkey.time);
-            }
-            break;
-        }
-        case XK_Control_R:
-        case XK_Control_L:
-        case XK_Shift_R:
-        case XK_Shift_L: {
-            Window subwindow;
-            int xw, yw, xr, yr;
-            unsigned int modifiers;
-            XQueryPointer(event->xkey.display, event->xkey.root, &event->xkey.root, &subwindow,
-                          &xr, &yr, &xw, &yw, &modifiers);
-            event->xkey.state = modifiers;
-            //It's safe to use key event as motion event since we use only their common fields.
-            handle_mouse_move(&event->xmotion);
-            break;
-        }
-        }
-        return True;
-    }
-    case ButtonPress:
-        return True;
-    case MotionNotify:
-        handle_mouse_move(&event->xmotion);
-        return True;
-    case ButtonRelease:
-        /*
-         * On some X servers it could happen that ButtonRelease coordinates
-         * differ from the latest MotionNotify coordinates, so we need to
-         * process it as a mouse motion.
-         * MotionNotify differs from ButtonRelease only in is_hint member, but
-         * we never use it, so it is safe to cast to MotionNotify.
-         */
-        handle_mouse_move(&event->xmotion);
-        if (event->xbutton.button == Button1 || event->xbutton.button == Button2) {
-            // drag is initiated with Button1 or Button2 pressed and
-            // ended on release of either of these buttons (as the same
-            // behavior was with our old Motif DnD-based implementation)
-            remove_dnd_grab(dpy, event->xbutton.time);
-            drag_in_progress = False;
-            if (target_window != None && target_action != java_awt_dnd_DnDConstants_ACTION_NONE) {
-                /*
-                 * ACTION_NONE indicates that either the drop target rejects the
-                 * drop or it haven't responded yet. The latter could happen in
-                 * case of fast drag, slow target-server connection or slow
-                 * drag notifications processing on the target side.
-                 */
-                process_drop(&event->xbutton);
-            } else {
-                cleanup_drag(dpy, event->xbutton.time);
-            }
-        }
-        return True;
-    default:
-        return False;
-    }
-}
-
-static Boolean
-motif_convert_proc(Widget w, Atom* selection, Atom* target, Atom* type,
-                   XtPointer* value, unsigned long* length, int32_t* format) {
-
-    if (*target == XA_XmTRANSFER_SUCCESS ||
-        *target == XA_XmTRANSFER_FAILURE) {
-
-        JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-        jboolean success =
-            (*target == XA_XmTRANSFER_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-
-        ds_postDragSourceDropEvent(env, success, target_action,
-                                   x_root, y_root);
-
-        dnd_in_progress = False;
-
-        XSelectInput(XtDisplay(w), target_window, target_window_mask);
-
-        cleanup_drag(XtDisplay(w), CurrentTime);
-
-        *type = *target;
-        *length = 0;
-        *format = 32;
-        *value = NULL;
-
-        return True;
-    } else {
-        return awt_convertData(w, selection, target, type, value, length,
-                               format);
-    }
-}
-
-static Boolean
-set_convert_data_context(JNIEnv* env, Display* dpy, XID xid, jobject component,
-                         jobject transferable, jobject formatMap,
-                         jlongArray formats) {
-    awt_convertDataCallbackStruct* structPtr = NULL;
-
-    if (XFindContext(awt_display, xid, awt_convertDataContext,
-                     (XPointer*)&structPtr) == XCNOMEM || structPtr != NULL) {
-        return False;
-    }
-
-    structPtr = calloc(1, sizeof(awt_convertDataCallbackStruct));
-    if (structPtr == NULL) {
-        return False;
-    }
-
-    structPtr->source              = (*env)->NewGlobalRef(env, component);
-    structPtr->transferable        = (*env)->NewGlobalRef(env, transferable);
-    structPtr->formatMap           = (*env)->NewGlobalRef(env, formatMap);
-    structPtr->formats             = (*env)->NewGlobalRef(env, formats);
-
-    if (JNU_IsNull(env, structPtr->source) ||
-        JNU_IsNull(env, structPtr->transferable) ||
-        JNU_IsNull(env, structPtr->formatMap) ||
-        JNU_IsNull(env, structPtr->formats)) {
-
-        if (!JNU_IsNull(env, structPtr->source)) {
-            (*env)->DeleteGlobalRef(env, structPtr->source);
-        }
-        if (!JNU_IsNull(env, structPtr->transferable)) {
-            (*env)->DeleteGlobalRef(env, structPtr->transferable);
-        }
-        if (!JNU_IsNull(env, structPtr->formatMap)) {
-            (*env)->DeleteGlobalRef(env, structPtr->formatMap);
-        }
-        if (!JNU_IsNull(env, structPtr->formats)) {
-            (*env)->DeleteGlobalRef(env, structPtr->formats);
-        }
-        free(structPtr);
-        return False;
-    }
-
-    if (XSaveContext(dpy, xid, awt_convertDataContext,
-                     (XPointer)structPtr) == XCNOMEM) {
-        free(structPtr);
-        return False;
-    }
-
-    return True;
-}
-
-/*
- * Convenience routine. Constructs an appropriate exception message based on the
- * specified prefix and the return code of XGrab* function and throws an
- * InvalidDnDOperationException with the constructed message.
- */
-static void
-throw_grab_failure_exception(JNIEnv* env, int ret_code, char* msg_prefix) {
-    char msg[200];
-    char* msg_cause = "";
-
-    switch (ret_code) {
-    case GrabNotViewable:  msg_cause = "not viewable";    break;
-    case AlreadyGrabbed:   msg_cause = "already grabbed"; break;
-    case GrabInvalidTime:  msg_cause = "invalid time";    break;
-    case GrabFrozen:       msg_cause = "grab frozen";     break;
-    default:               msg_cause = "unknown failure"; break;
-    }
-
-    sprintf(msg, "%s: %s.", msg_prefix, msg_cause);
-    JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                    msg);
-}
-
-/*
- * Sets the proxy mode source window - the source window which the drag
- * notifications from an XEmbed client should be forwarded to.
- * If the window is not None and there is a drag operation in progress,
- * throws InvalidDnDOperationException and doesn't change
- * proxy_mode_source_window.
- * The caller mush hold AWT_LOCK.
- */
-void
-set_proxy_mode_source_window(Window window) {
-    if (window != None && dnd_in_progress) {
-        JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-        JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                        "Drag and drop is already in progress.");
-        return;
-    }
-
-    proxy_mode_source_window = window;
-}
-
-/*
- * Checks if the event is a drag notification from an XEmbed client.
- * If it is, forwards this event back to the current source and returns True.
- * Otherwise, returns False.
- * Currently only XDnD protocol notifications are recognized.
- * The caller must hold AWT_LOCK.
- */
-static Boolean
-process_proxy_mode_event(XEvent* event) {
-    if (proxy_mode_source_window == None) {
-        return False;
-    }
-
-    if (event->type == ClientMessage) {
-        XClientMessageEvent* xclient = &event->xclient;
-        if (xclient->message_type == XA_XdndStatus ||
-            xclient->message_type == XA_XdndFinished) {
-            Window source = proxy_mode_source_window;
-
-            xclient->data.l[0] = xclient->window;
-            xclient->window = source;
-
-            XSendEvent(xclient->display, source, False, NoEventMask,
-                       (XEvent*)xclient);
-
-            if (xclient->message_type == XA_XdndFinished) {
-                proxy_mode_source_window = None;
-            }
-
-            return True;
-        }
-    }
-
-    return False;
-}
-
-/*
- * Class:     sun_awt_motif_X11DragSourceContextPeer
- * Method:    startDrag
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_X11DragSourceContextPeer_startDrag(JNIEnv *env,
-                                                      jobject this,
-                                                      jobject component,
-                                                      jobject wpeer,
-                                                      jobject transferable,
-                                                      jobject trigger,
-                                                      jobject cursor,
-                                                      jint ctype,
-                                                      jint actions,
-                                                      jlongArray formats,
-                                                      jobject formatMap) {
-    Time time_stamp = CurrentTime;
-    Cursor xcursor = None;
-    Window root_window = None;
-    Atom* targets = NULL;
-    jsize num_targets = 0;
-
-    AWT_LOCK();
-
-    if (dnd_in_progress) {
-        JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                        "Drag and drop is already in progress.");
-        AWT_UNLOCK();
-        return;
-    }
-
-    if (proxy_mode_source_window != None) {
-        JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                        "Proxy drag is in progress.");
-        AWT_UNLOCK();
-        return;
-    }
-
-    if (!awt_dnd_init(awt_display)) {
-        JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                        "DnD subsystem initialization failed.");
-        AWT_UNLOCK();
-        return;
-    }
-
-    if (!JNU_IsNull(env, cursor)) {
-        xcursor = getCursor(env, cursor);
-
-        if (xcursor == None) {
-            JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                            "Invalid drag cursor");
-            AWT_UNLOCK();
-        }
-    }
-
-    /* Determine the root window for the drag operation. */
-    {
-        struct FrameData* wdata = (struct FrameData*)
-            JNU_GetLongFieldAsPtr(env, wpeer, mComponentPeerIDs.pData);
-
-        if (wdata == NULL) {
-            JNU_ThrowNullPointerException(env, "Null component data");
-            AWT_UNLOCK();
-            return;
-        }
-
-        if (wdata->winData.shell == NULL) {
-            JNU_ThrowNullPointerException(env, "Null shell widget");
-            AWT_UNLOCK();
-            return;
-        }
-
-        root_window = RootWindowOfScreen(XtScreen(wdata->winData.shell));
-
-        if (root_window == None) {
-            JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                            "Cannot get the root window for the drag operation.");
-            AWT_UNLOCK();
-            return;
-        }
-    }
-
-    time_stamp = get_latest_time_stamp();
-
-    /* Extract the targets from java array. */
-    {
-        targets = NULL;
-        num_targets = (*env)->GetArrayLength(env, formats);
-
-        /*
-         * In debug build GetLongArrayElements aborts with assertion on an empty
-         * array.
-         */
-        if (num_targets > 0) {
-            jboolean isCopy = JNI_TRUE;
-            jlong* java_targets = (*env)->GetLongArrayElements(env, formats,
-                                                               &isCopy);
-
-            if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-                AWT_UNLOCK();
-                return;
-            }
-
-            if (java_targets != NULL) {
-                targets = (Atom*)malloc(num_targets * sizeof(Atom));
-                if (targets != NULL) {
-#ifdef _LP64
-                    memcpy(targets, java_targets, num_targets * sizeof(Atom));
-#else
-                    jsize i;
-
-                    for (i = 0; i < num_targets; i++) {
-                        targets[i] = (Atom)java_targets[i];
-                    }
-#endif
-                }
-                (*env)->ReleaseLongArrayElements(env, formats, java_targets,
-                                                 JNI_ABORT);
-            }
-        }
-        if (targets == NULL) {
-            num_targets = 0;
-        }
-    }
-
-    /* Write the XDnD initiator info on the awt_root_shell. */
-    {
-        unsigned char ret;
-        Atom action_atoms[3];
-        unsigned int action_count = 0;
-
-        if (actions & java_awt_dnd_DnDConstants_ACTION_COPY) {
-            action_atoms[action_count] = XA_XdndActionCopy;
-            action_count++;
-        }
-        if (actions & java_awt_dnd_DnDConstants_ACTION_MOVE) {
-            action_atoms[action_count] = XA_XdndActionMove;
-            action_count++;
-        }
-        if (actions & java_awt_dnd_DnDConstants_ACTION_LINK) {
-            action_atoms[action_count] = XA_XdndActionLink;
-            action_count++;
-        }
-
-        ret = checked_XChangeProperty(awt_display, awt_dnd_ds_get_source_window(),
-                                      XA_XdndActionList, XA_ATOM, 32,
-                                      PropModeReplace, (unsigned char*)action_atoms,
-                                      action_count * sizeof(Atom));
-
-        if (ret != Success) {
-            cleanup_drag(awt_display, time_stamp);
-            JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                            "Cannot write XdndActionList property");
-            AWT_UNLOCK();
-            return;
-        }
-
-        ret = checked_XChangeProperty(awt_display, awt_dnd_ds_get_source_window(),
-                                      XA_XdndTypeList, XA_ATOM, 32,
-                                      PropModeReplace, (unsigned char*)targets,
-                                      num_targets);
-
-        if (ret != Success) {
-            cleanup_drag(awt_display, time_stamp);
-            JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                            "Cannot write XdndTypeList property");
-            AWT_UNLOCK();
-            return;
-        }
-    }
-
-    /* Write the Motif DnD initiator info on the awt_root_shell. */
-    {
-        InitiatorInfo info;
-        unsigned char ret;
-        int target_list_index =
-            get_index_for_target_list(awt_display, targets, num_targets);
-
-        if (target_list_index == -1) {
-            cleanup_drag(awt_display, time_stamp);
-            JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                            "Cannot determine the target list index.");
-            AWT_UNLOCK();
-            return;
-        }
-
-        info.byte_order = MOTIF_BYTE_ORDER;
-        info.protocol_version = MOTIF_DND_PROTOCOL_VERSION;
-        info.index = target_list_index;
-        info.selection_atom = _XA_MOTIF_ATOM_0;
-
-        ret = checked_XChangeProperty(awt_display, awt_dnd_ds_get_source_window(),
-                                      _XA_MOTIF_ATOM_0,
-                                      _XA_MOTIF_DRAG_INITIATOR_INFO, 8,
-                                      PropModeReplace, (unsigned char*)&info,
-                                      sizeof(InitiatorInfo));
-
-        if (ret != Success) {
-            cleanup_drag(awt_display, time_stamp);
-            JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                            "Cannot write the Motif DnD initiator info");
-            AWT_UNLOCK();
-            return;
-        }
-    }
-
-    /* Acquire XDnD selection ownership. */
-    if (XtOwnSelection(awt_root_shell, XA_XdndSelection, time_stamp,
-                       awt_convertData, NULL, NULL) != True) {
-        cleanup_drag(awt_display, time_stamp);
-        JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                        "Cannot acquire XdndSelection ownership.");
-        AWT_UNLOCK();
-        return;
-    }
-
-    /* Acquire Motif DnD selection ownership. */
-    if (XtOwnSelection(awt_root_shell, _XA_MOTIF_ATOM_0, time_stamp,
-                       motif_convert_proc, NULL, NULL) != True) {
-        cleanup_drag(awt_display, time_stamp);
-        JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                        "Cannot acquire Motif DnD selection ownership.");
-        AWT_UNLOCK();
-        return;
-    }
-
-    /*
-     * Store the information needed to convert data for both selections
-     * in awt_convertDataContext.
-     */
-    {
-        if (!set_convert_data_context(env, awt_display, XA_XdndSelection,
-                                      component, transferable, formatMap,
-                                      formats)) {
-            cleanup_drag(awt_display, time_stamp);
-            JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                            "Cannot save context for XDnD selection data conversion.");
-            AWT_UNLOCK();
-            return;
-        }
-
-        if (!set_convert_data_context(env, awt_display, _XA_MOTIF_ATOM_0,
-                                      component, transferable, formatMap,
-                                      formats)) {
-            cleanup_drag(awt_display, time_stamp);
-            JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                            "Cannot save context for Motif DnD selection data conversion.");
-            AWT_UNLOCK();
-            return;
-        }
-    }
-
-    /* Install X grabs. */
-    {
-        XWindowAttributes xwa;
-        int ret;
-
-        XGetWindowAttributes(awt_display, root_window, &xwa);
-
-        your_root_event_mask = xwa.your_event_mask;
-
-        XSelectInput(awt_display, root_window,
-                     your_root_event_mask | ROOT_EVENT_MASK);
-
-        ret = XGrabPointer(awt_display,
-                           root_window,
-                           False,
-                           GRAB_EVENT_MASK,
-                           GrabModeAsync,
-                           GrabModeAsync,
-                           None,
-                           xcursor,
-                           time_stamp);
-
-        if (ret != GrabSuccess) {
-            cleanup_drag(awt_display, time_stamp);
-            throw_grab_failure_exception(env, ret, "Cannot grab pointer");
-            AWT_UNLOCK();
-            return;
-        }
-
-        ret = XGrabKeyboard(awt_display,
-                            root_window,
-                            False,
-                            GrabModeAsync,
-                            GrabModeAsync,
-                            time_stamp);
-
-        if (ret != GrabSuccess) {
-            cleanup_drag(awt_display, time_stamp);
-            throw_grab_failure_exception(env, ret, "Cannot grab keyboard");
-            AWT_UNLOCK();
-            return;
-        }
-    }
-
-    /* Update the global state. */
-    source_peer = (*env)->NewGlobalRef(env, this);
-    dnd_in_progress = True;
-    drag_in_progress = True;
-    data_types = targets;
-    data_types_count = num_targets;
-    source_actions = actions;
-    drag_root_window = root_window;
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_X11DragSourceContextPeer
- * Method:    setNativeCursor
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_X11DragSourceContextPeer_setNativeCursor(JNIEnv *env,
-                                                            jobject this,
-                                                            jlong nativeCtxt,
-                                                            jobject cursor,
-                                                            jint type) {
-    if (JNU_IsNull(env, cursor)) {
-        return;
-    }
-
-    XChangeActivePointerGrab(awt_display,
-                             GRAB_EVENT_MASK,
-                             getCursor(env, cursor),
-                             CurrentTime);
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_dnd_dt.c openjdk/jdk/src/solaris/native/sun/awt/awt_dnd_dt.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_dnd_dt.c	2014-04-08 05:27:03.458875205 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_dnd_dt.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,3700 +0,0 @@
-/*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_dnd.h"
-
-#include "jlong.h"
-
-#include "awt_DataTransferer.h"
-#include "awt_MToolkit.h"
-
-#include "java_awt_dnd_DnDConstants.h"
-#include "java_awt_event_MouseEvent.h"
-
-#include "sun_awt_motif_MComponentPeer.h"
-#include "awt_xembed.h"
-
-#define DT_INITIAL_STATE 0
-#define DT_ENTERED_STATE 1
-#define DT_OVER_STATE    2
-
-extern struct ComponentIDs componentIDs;
-extern struct MComponentPeerIDs mComponentPeerIDs;
-
-/**************************** XEmbed server DnD support ***********************/
-extern void
-set_xembed_drop_target(JNIEnv* env, jobject server);
-extern void
-remove_xembed_drop_target(JNIEnv* env, jobject server);
-extern Boolean
-is_xembed_client(Window window);
-
-DECLARE_JAVA_CLASS(MEmbedCanvasPeerClass, "sun/awt/motif/MEmbedCanvasPeer");
-/******************************************************************************/
-
-typedef enum {
-    EventSuccess,    /* Event is successfully processed. */
-    EventFailure     /* Failed to process the event. */
-} EventStatus;
-
-typedef enum {
-    EnterEvent,    /* XdndEnter, TOP_LEVEL_ENTER */
-    MotionEvent,   /* XdndPosition, DRAG_MOTION, OPERATION_CHANGED */
-    LeaveEvent,    /* XdndLeave, TOP_LEVEL_LEAVE */
-    DropEvent,     /* XdndDrop, DROP_START */
-    UnknownEvent
-} EventType;
-
-static Protocol source_protocol = NO_PROTOCOL;
-static unsigned int source_protocol_version = 0;
-static Window source_window = None;
-static Atom source_atom = None;
-static long source_window_mask = None;
-static jint source_actions = java_awt_dnd_DnDConstants_ACTION_NONE;
-/*
- * According to XDnD protocol, XdndActionList is optional.
- * In case if XdndActionList is not set on the source, the list of drop actions
- * supported by the source is constructed as follows:
- *  - "copy" is always included;
- *  - "move" is included if at least one XdndPosition message received
- *    after the latest XdndEnter passed XdndActionMove in data.l[4];
- *  - "link" is included if at least one XdndPosition message received
- *    after the latest XdndEnter passed XdndActionLink in data.l[4].
- * We use a boolean flag to signal that we are building the list of drop actions
- * supported by the source.
- */
-static Boolean track_source_actions = False;
-static jint user_action = java_awt_dnd_DnDConstants_ACTION_NONE;
-static jlongArray source_data_types = NULL;
-static Atom* source_data_types_native = NULL;
-static unsigned int source_data_types_count = 0;
-static int source_x = 0;
-static int source_y = 0;
-static jobject target_component = NULL;
-/*
- * The Motif DnD protocol prescribes that DROP_START message should always be
- * preceeded with TOP_LEVEL_LEAVE message. We need to cleanup on TOP_LEVEL_LEAVE
- * message, but DROP_START wouldn't be processed properly.
- * To resolve this issue we postpone cleanup using a boolean flag this flag is
- * set when we receive the TOP_LEVEL_LEAVE message and cleared when the next
- * client message arrives if that message is not DROP_START. If that message is
- * a DROP_START message, the flag is cleared after the DROP_START is processed.
- */
-static Boolean motif_top_level_leave_postponed = False;
-/*
- * We store a postponed TOP_LEVEL_LEAVE message here.
- */
-static XClientMessageEvent motif_top_level_leave_postponed_event;
-
-/* Forward declarations */
-static Window get_root_for_window(Window window);
-static Window get_outer_canvas_for_window(Window window);
-static Boolean register_drop_site(Widget outer_canvas, XtPointer componentRef);
-static Boolean is_xdnd_drag_message_type(unsigned long message_type);
-static Boolean register_xdnd_drop_site(Display* dpy, Window toplevel,
-                                       Window window);
-
-/**************************** JNI stuff ***************************************/
-
-DECLARE_JAVA_CLASS(dtcp_clazz, "sun/awt/motif/X11DropTargetContextPeer")
-
-static void
-dt_postDropTargetEvent(JNIEnv* env, jobject component, int x, int y,
-                       jint dropAction, jint event_id,
-                       XClientMessageEvent* event) {
-    DECLARE_STATIC_VOID_JAVA_METHOD(dtcp_postDropTargetEventToPeer, dtcp_clazz,
-                                    "postDropTargetEventToPeer",
-                                    "(Ljava/awt/Component;IIII[JJI)V");
-
-    {
-        void* copy = NULL;
-
-        if (event != NULL) {
-            /*
-             * For XDnD messages we append the information from the latest
-             * XdndEnter to the context. It is done to be able to reconstruct
-             * XdndEnter for an XEmbed client.
-             */
-            Boolean isXDnDMessage =
-                is_xdnd_drag_message_type(event->message_type);
-
-            if (isXDnDMessage) {
-                copy = malloc(sizeof(XClientMessageEvent) +
-                                                 4 * sizeof(long));
-            } else {
-                copy = malloc(sizeof(XClientMessageEvent));
-            }
-
-            if (copy == NULL) {
-                DTRACE_PRINTLN2("%s:%d malloc failed.", __FILE__, __LINE__);
-                return;
-            }
-
-            memcpy(copy, event, sizeof(XClientMessageEvent));
-
-            if (isXDnDMessage) {
-                size_t msgSize = sizeof(XClientMessageEvent);
-                long data1 = source_protocol_version << XDND_PROTOCOL_SHIFT;
-                long * appended_data;
-                if (source_data_types_native != NULL &&
-                    source_data_types_count > 3) {
-
-                    data1 |= XDND_DATA_TYPES_BIT;
-                }
-
-                appended_data = (long*)((char*)copy + msgSize);
-                appended_data[0] = data1;
-                appended_data[1] = source_data_types_count > 0 ?
-                    source_data_types_native[0] : 0;
-                appended_data[2] = source_data_types_count > 1 ?
-                    source_data_types_native[1] : 0;
-                appended_data[3] = source_data_types_count > 2 ?
-                    source_data_types_native[2] : 0;
-            }
-        }
-
-        DASSERT(!JNU_IsNull(env, component));
-
-        (*env)->CallStaticVoidMethod(env, clazz, dtcp_postDropTargetEventToPeer,
-                                     component, x, y, dropAction,
-                                     source_actions, source_data_types,
-                                     ptr_to_jlong(copy), event_id);
-    }
-}
-
-/******************************************************************************/
-
-/********************* Embedded drop site list support ************************/
-
-struct EmbeddedDropSiteListEntryRec;
-
-typedef struct EmbeddedDropSiteListEntryRec EmbeddedDropSiteListEntry;
-
-struct EmbeddedDropSiteListEntryRec {
-    Window toplevel;
-    Window root;
-    /*
-     * We select for PropertyNotify events on the toplevel, so we need to
-     * restore the event mask when we are done with this toplevel.
-     */
-    long event_mask;
-    unsigned int embedded_sites_count;
-    Window* embedded_sites;
-    EmbeddedDropSiteListEntry* next;
-};
-
-static EmbeddedDropSiteListEntry* embedded_drop_site_list = NULL;
-
-struct EmbeddedDropSiteProtocolListEntryRec;
-
-typedef struct EmbeddedDropSiteProtocolListEntryRec EmbeddedDropSiteProtocolListEntry;
-
-struct EmbeddedDropSiteProtocolListEntryRec {
-    Window window;
-    Window proxy;
-    /*
-     * We override the XdndAware property on the toplevel, so we should keep its
-     * original contents - the XDnD protocol version supported by the browser.
-     * This is needed to adjust XDnD messages forwarded to the browser.
-     */
-    unsigned int protocol_version;
-    /* True if the toplevel was already registered as a drag receiver and
-       we just changed the proxy. False, otherwise */
-    Boolean overriden;
-    EmbeddedDropSiteProtocolListEntry* next;
-};
-
-static EmbeddedDropSiteProtocolListEntry* embedded_motif_protocol_list = NULL;
-static EmbeddedDropSiteProtocolListEntry* embedded_xdnd_protocol_list = NULL;
-
-typedef enum {
-    RegFailure, /* Proxy registration failed */
-    RegSuccess, /* The new drop site is registered with the new proxy */
-    RegOverride, /* The new proxy is set for the existing drop site */
-    RegAlreadyRegistered /* This proxy is already set for this drop site */
-} ProxyRegistrationStatus;
-
-/* Forward declarations. */
-static EmbeddedDropSiteProtocolListEntry*
-get_xdnd_protocol_entry_for_toplevel(Window toplevel);
-static EmbeddedDropSiteProtocolListEntry*
-get_motif_protocol_entry_for_toplevel(Window toplevel);
-static void remove_xdnd_protocol_entry_for_toplevel(Window toplevel);
-static void remove_motif_protocol_entry_for_toplevel(Window toplevel);
-
-/*
- * Registers the toplevel as a Motif drag receiver if it is not registered yet,
- * sets the specified new_proxy for it and returns the previous proxy in old_proxy.
- * Does nothing if the new_proxy is already set as a proxy for this toplevel.
- * Returns the completion status.
- */
-static ProxyRegistrationStatus
-set_motif_proxy(Display* dpy, Window toplevel, Window new_proxy, Window *old_proxy) {
-    Boolean        override = False;
-
-    Atom           type;
-    int            format;
-    unsigned long  nitems;
-    unsigned long  after;
-    unsigned char* data;
-    unsigned char  ret;
-
-    DASSERT(old_proxy != NULL);
-
-    *old_proxy = None;
-
-    data = NULL;
-    ret = checked_XGetWindowProperty(dpy, toplevel,
-                                     _XA_MOTIF_DRAG_RECEIVER_INFO, 0, 0xFFFF,
-                                     False, AnyPropertyType, &type, &format,
-                                     &nitems, &after, &data);
-
-    /* Check if toplevel is a valid window. */
-    if (ret != Success) {
-        return RegFailure;
-    }
-
-    if (ret == Success && data != NULL && type != None && format == 8
-        && nitems >= MOTIF_RECEIVER_INFO_SIZE) {
-        unsigned char byte_order = read_card8((char*)data, 0);
-        void* p = (char*)data + 4;
-
-        /* Browser and plugin have different byte orders - report failure for now. */
-        if (MOTIF_BYTE_ORDER != byte_order) {
-            XFree(data);
-            return RegFailure;
-        }
-
-        *old_proxy = read_card32((char*)data, 4, byte_order);
-
-        /* If the proxy is already set to the specified window - return. */
-        if (*old_proxy == new_proxy) {
-            XFree(data);
-            return RegAlreadyRegistered;
-        }
-
-        /* replace the proxy window */
-        write_card32(&p, new_proxy);
-
-        override = True;
-    } else {
-        void* p;
-
-        if (ret == Success) {
-            XFree(data);
-            data = NULL;
-        }
-
-        data = malloc(MOTIF_RECEIVER_INFO_SIZE);
-
-        if (data == NULL) {
-            DTRACE_PRINTLN2("%s:%d malloc failed.", __FILE__, __LINE__);
-            return RegFailure;
-        }
-
-        p = data;
-
-        write_card8(&p, MOTIF_BYTE_ORDER);
-        write_card8(&p, MOTIF_DND_PROTOCOL_VERSION); /* protocol version */
-        write_card8(&p, MOTIF_DYNAMIC_STYLE); /* protocol style */
-        write_card8(&p, 0); /* pad */
-        write_card32(&p, new_proxy); /* proxy window */
-        write_card16(&p, 0); /* num_drop_sites */
-        write_card16(&p, 0); /* pad */
-        write_card32(&p, MOTIF_RECEIVER_INFO_SIZE);
-    }
-
-    ret = checked_XChangeProperty(dpy, toplevel,
-                                  _XA_MOTIF_DRAG_RECEIVER_INFO,
-                                  _XA_MOTIF_DRAG_RECEIVER_INFO, 8,
-                                  PropModeReplace, (unsigned char*)data,
-                                  MOTIF_RECEIVER_INFO_SIZE);
-
-    if (data != NULL) {
-        XFree(data);
-        data = NULL;
-    }
-
-    if (ret == Success) {
-        if (override) {
-            return RegOverride;
-        } else {
-            return RegSuccess;
-        }
-    } else {
-        return RegFailure;
-    }
-}
-
-/*
- * Registers the toplevel as a XDnD drag receiver if it is not registered yet,
- * sets the specified new_proxy for it and returns the previous proxy in
- * old_proxy and the original XDnD protocol version in old_version.
- * Does nothing if the new_proxy is already set as a proxy for this toplevel.
- * Returns the completion status.
- */
-static ProxyRegistrationStatus
-set_xdnd_proxy(Display* dpy, Window toplevel, Window new_proxy,
-               Window* old_proxy, unsigned int* old_version) {
-    Atom version_atom = XDND_PROTOCOL_VERSION;
-    Window xdnd_proxy = None;
-    Boolean override = False;
-
-    Atom           type;
-    int            format;
-    unsigned long  nitems;
-    unsigned long  after;
-    unsigned char* data;
-    unsigned char  ret;
-
-    DASSERT(old_proxy != NULL);
-
-    *old_proxy = None;
-
-    data = NULL;
-    ret = checked_XGetWindowProperty(dpy, toplevel, XA_XdndAware, 0, 1,
-                                     False, AnyPropertyType, &type, &format,
-                                     &nitems, &after, &data);
-
-    if (ret != Success) {
-        return RegFailure;
-    }
-
-    if (ret == Success && data != NULL && type == XA_ATOM) {
-        unsigned int protocol_version = *((unsigned int*)data);
-
-        override = True;
-        *old_version = protocol_version;
-
-        /* XdndProxy is not supported for prior to XDnD version 4 */
-        if (protocol_version >= 4) {
-            int status;
-
-            XFree(data);
-
-            data = NULL;
-            status = XGetWindowProperty(dpy, toplevel, XA_XdndProxy, 0, 1,
-                                        False, XA_WINDOW, &type, &format,
-                                        &nitems, &after, &data);
-
-            if (status == Success && data != NULL && type == XA_WINDOW) {
-                xdnd_proxy = *((Window*)data);
-
-                if (xdnd_proxy != None) {
-                    XFree(data);
-
-                    data = NULL;
-                    status = XGetWindowProperty(dpy, xdnd_proxy, XA_XdndProxy,
-                                                0, 1, False, XA_WINDOW, &type,
-                                                &format, &nitems, &after, &data);
-
-                    if (status != Success || data == NULL || type != XA_WINDOW ||
-                        *((Window*)data) != xdnd_proxy) {
-                        /* Ignore invalid proxy. */
-                        xdnd_proxy = None;
-                    }
-                }
-
-                if (xdnd_proxy != None) {
-                    XFree(data);
-
-                    data = NULL;
-                    status = XGetWindowProperty(dpy, xdnd_proxy, XA_XdndAware,
-                                                0, 1, False, AnyPropertyType,
-                                                &type, &format, &nitems, &after,
-                                                &data);
-
-                    if (status == Success && data != NULL && type == XA_ATOM) {
-                        unsigned int proxy_version = *((unsigned int*)data);
-
-                        if (proxy_version != protocol_version) {
-                            /* Ignore invalid proxy. */
-                            xdnd_proxy = None;
-                        }
-                    } else {
-                        /* Ignore invalid proxy. */
-                        xdnd_proxy = None;
-                    }
-                }
-            }
-
-            *old_proxy = xdnd_proxy;
-        }
-    }
-
-    XFree(data);
-
-    /* If the proxy is already set to the specified window - return. */
-    if (xdnd_proxy == new_proxy) {
-        return RegAlreadyRegistered;
-    }
-
-    /* The proxy window must have the XdndAware set, as XDnD protocol prescribes
-       to check the proxy window for XdndAware. */
-    ret = checked_XChangeProperty(dpy, new_proxy, XA_XdndAware, XA_ATOM, 32,
-                                  PropModeReplace,
-                                  (unsigned char*)&version_atom, 1);
-
-    if (ret != Success) {
-        return RegFailure;
-    }
-
-    /* The proxy window must have the XdndProxy set to point to itself. */
-    ret = checked_XChangeProperty(dpy, new_proxy, XA_XdndProxy, XA_WINDOW, 32,
-                                  PropModeReplace,
-                                  (unsigned char*)&new_proxy, 1);
-
-    if (ret != Success) {
-        return RegFailure;
-    }
-
-    ret = checked_XChangeProperty(dpy, toplevel, XA_XdndAware, XA_ATOM, 32,
-                                  PropModeReplace,
-                                  (unsigned char*)&version_atom, 1);
-
-    if (ret != Success) {
-        return RegFailure;
-    }
-
-    ret = checked_XChangeProperty(dpy, toplevel, XA_XdndProxy, XA_WINDOW, 32,
-                                  PropModeReplace,
-                                  (unsigned char*)&new_proxy, 1);
-
-    if (ret == Success) {
-        if (override) {
-            return RegOverride;
-        } else {
-            return RegSuccess;
-        }
-    } else {
-        return RegFailure;
-    }
-}
-
-/*
- * 'toplevel' is the browser toplevel window. To register a drop site on the
- * plugin window we set the proxy for the browser toplevel window to point to
- * the awt_root_shell window.
- *
- * We assume that only one JVM per browser instance is possible. This
- * assumption is true with the current plugin implementation - it creates a
- * single JVM for all plugin instances created by the given plugin factory.
- *
- * When a client message event for the browser toplevel window is received, we
- * will iterate over drop sites registered with this toplevel and determine if
- * the mouse pointer is currently over one of them (there could be several
- * plugin windows in one browser window - for example if an HTML page contains
- * frames and several frames contain a plugin object).
- *
- * If the pointer is not over any of the plugin drop sites the client message
- * will be resent to the browser, otherwise it will be processed normally.
- */
-static EmbeddedDropSiteListEntry*
-awt_dnd_dt_init_proxy(Display* dpy, Window root, Window toplevel, Window window) {
-    Window         awt_root_window = get_awt_root_window();
-    Window         motif_proxy = None;
-    Boolean        motif_override = False;
-    unsigned long  event_mask = 0;
-
-    if (awt_root_window == None) {
-        return NULL;
-    }
-
-    /* Grab server, since we are working with the window that belongs to
-       another client. REMIND: ungrab when done!!! */
-    XGrabServer(dpy);
-
-    {
-        ProxyRegistrationStatus motif_status = RegFailure;
-
-        motif_status = set_motif_proxy(dpy, toplevel, awt_root_window, &motif_proxy);
-
-        switch (motif_status) {
-        case RegFailure:
-        case RegAlreadyRegistered:
-            XUngrabServer(dpy);
-            /* Workaround for bug 5039226 */
-            XSync(dpy, False);
-            return NULL;
-        case RegOverride:
-            motif_override = True;
-            break;
-        case RegSuccess:
-            motif_override = False;
-            break;
-        default:
-            DASSERT(False);
-        }
-
-
-    }
-
-    {
-        XWindowAttributes xwa;
-        XGetWindowAttributes(dpy, toplevel, &xwa);
-        event_mask = xwa.your_event_mask;
-        if ((event_mask & PropertyChangeMask) == 0) {
-            XSelectInput(dpy, toplevel, event_mask | PropertyChangeMask);
-        }
-    }
-
-    XUngrabServer(dpy);
-    /* Workaround for bug 5039226 */
-    XSync(dpy, False);
-
-    /* Add protocol specific entries for the toplevel. */
-    {
-        EmbeddedDropSiteProtocolListEntry* motif_entry = NULL;
-
-        motif_entry = malloc(sizeof(EmbeddedDropSiteProtocolListEntry));
-
-        if (motif_entry == NULL) {
-            return NULL;
-        }
-
-        motif_entry->window = toplevel;
-        motif_entry->proxy = motif_proxy;
-        motif_entry->protocol_version = 0;
-        motif_entry->overriden = motif_override;
-        motif_entry->next = embedded_motif_protocol_list;
-        embedded_motif_protocol_list = motif_entry;
-    }
-
-    {
-        EmbeddedDropSiteListEntry* entry = NULL;
-        Window* sites = NULL;
-
-        entry = malloc(sizeof(EmbeddedDropSiteListEntry));
-
-        if (entry == NULL) {
-            return NULL;
-        }
-
-        sites = malloc(sizeof(Window));
-
-        if (sites == NULL) {
-            free(entry);
-            return NULL;
-        }
-
-        sites[0] = window;
-
-        entry->toplevel = toplevel;
-        entry->root = root;
-        entry->event_mask = event_mask;
-        entry->embedded_sites_count = 1;
-        entry->embedded_sites = sites;
-        entry->next = NULL;
-
-        return entry;
-    }
-}
-
-static void
-register_xdnd_embedder(Display* dpy, EmbeddedDropSiteListEntry* entry, long window) {
-    Window         awt_root_window = get_awt_root_window();
-    Window         toplevel = entry->toplevel;
-    Window         xdnd_proxy = None;
-    unsigned int   xdnd_protocol_version = 0;
-    Boolean        xdnd_override = False;
-    Boolean        register_xdnd = True;
-    Boolean        motif_overriden = False;
-
-    EmbeddedDropSiteProtocolListEntry* motif_entry = embedded_motif_protocol_list;
-    while (motif_entry != NULL) {
-        if (motif_entry->window == toplevel) {
-            motif_overriden = motif_entry->overriden;
-            break;
-        }
-        motif_entry = motif_entry->next;
-    }
-
-    /*
-     * First check if the window is an XEmbed client.
-     * In this case we don't have to setup a proxy on the toplevel,
-     * instead we register the XDnD drop site on the embedded window.
-     */
-    if (isXEmbedActiveByWindow(window)) {
-        register_xdnd_drop_site(dpy, toplevel, window);
-        return;
-    }
-
-    /*
-     * By default, we register a drop site that supports both dnd
-     * protocols. This approach is not appropriate in plugin
-     * scenario if the browser doesn't support XDnD. If we forcibly set
-     * XdndAware on the browser toplevel, any drag source that supports both
-     * protocols and prefers XDnD will be unable to drop anything on the
-     * browser.
-     * The solution for this problem is not to register XDnD drop site
-     * if the browser supports only Motif DnD.
-     */
-    if (motif_overriden) {
-        int            status;
-        Atom           type;
-        int            format;
-        unsigned long  nitems;
-        unsigned long  after;
-        unsigned char* data;
-
-        data = NULL;
-        status = XGetWindowProperty(dpy, toplevel, XA_XdndAware, 0, 1,
-                                    False, AnyPropertyType, &type, &format,
-                                    &nitems, &after, &data);
-
-        XFree(data);
-        data = NULL;
-
-        if (type != XA_ATOM) {
-            register_xdnd = False;
-        }
-    }
-
-    if (register_xdnd) {
-        ProxyRegistrationStatus xdnd_status;
-        /* Grab server, since we are working with the window that belongs to
-           another client. REMIND: ungrab when done!!! */
-        XGrabServer(dpy);
-
-        xdnd_status =
-            set_xdnd_proxy(dpy, toplevel, awt_root_window, &xdnd_proxy,
-                           &xdnd_protocol_version);
-
-        XUngrabServer(dpy);
-
-        switch (xdnd_status) {
-        case RegFailure:
-        case RegAlreadyRegistered:
-            return;
-        case RegOverride:
-            xdnd_override = True;
-            break;
-        case RegSuccess:
-            xdnd_override = False;
-            break;
-        default:
-            DASSERT(False);
-        }
-
-        {
-            EmbeddedDropSiteProtocolListEntry* xdnd_entry = NULL;
-
-            xdnd_entry = malloc(sizeof(EmbeddedDropSiteProtocolListEntry));
-
-            if (xdnd_entry == NULL) {
-                return;
-            }
-
-            xdnd_entry->window = toplevel;
-            xdnd_entry->proxy = xdnd_proxy;
-            xdnd_entry->protocol_version = xdnd_protocol_version;
-            xdnd_entry->overriden = xdnd_override;
-            xdnd_entry->next = embedded_xdnd_protocol_list;
-            embedded_xdnd_protocol_list = xdnd_entry;
-        }
-    }
-}
-
-/*
- * If embedded_drop_site_list already contains an entry with the specified
- * 'toplevel', the method registers the specified 'window' as an embedded drop
- * site for this 'toplevel' and returns True.
- * Otherwise, it checks if the 'toplevel' is a registered drop site for adds
- * (window, component) pair to the list and returns True
- * if completes successfully.
- */
-static Boolean
-add_to_embedded_drop_site_list(Display* dpy, Window root, Window toplevel,
-                               Window window) {
-    EmbeddedDropSiteListEntry* entry = embedded_drop_site_list;
-
-    while (entry != NULL) {
-        if (entry->toplevel == toplevel) {
-            void* p = realloc(entry->embedded_sites,
-                              sizeof(Window) *
-                              (entry->embedded_sites_count + 1));
-            if (p == NULL) {
-                return False;
-            }
-            entry->embedded_sites = p;
-            entry->embedded_sites[entry->embedded_sites_count++] = window;
-
-            register_xdnd_embedder(dpy, entry, window);
-
-            return True;
-        }
-        entry = entry->next;
-    }
-
-    entry = awt_dnd_dt_init_proxy(dpy, root, toplevel, window);
-
-    if (entry == NULL) {
-        return False;
-    }
-
-    register_xdnd_embedder(dpy, entry, window);
-
-    entry->next = embedded_drop_site_list;
-    embedded_drop_site_list = entry;
-
-    return True;
-}
-
-/*
- * Removes the window from the list of embedded drop sites for the toplevel.
- * Returns True if the window was successfully removed, False otherwise.
- */
-static Boolean
-remove_from_embedded_drop_site_list(Display* dpy, Window toplevel, Window window) {
-    EmbeddedDropSiteListEntry* entry = embedded_drop_site_list;
-    EmbeddedDropSiteListEntry* prev = NULL;
-
-    while (entry != NULL) {
-        if (entry->toplevel == toplevel) {
-            unsigned int idx;
-
-            for (idx = 0; idx < entry->embedded_sites_count; idx++) {
-                if (entry->embedded_sites[idx] == window) {
-                    int tail = entry->embedded_sites_count - idx - 1;
-                    if (tail > 0) {
-                        memmove(entry->embedded_sites + idx,
-                                entry->embedded_sites + idx + 1,
-                                tail * sizeof(Window));
-                    }
-                    entry->embedded_sites_count--;
-
-                    /* If the list of embedded drop sites for this toplevel
-                       becomes empty - restore the original proxies and remove
-                       the entry. */
-                    if (entry->embedded_sites_count == 0) {
-                        Widget w = XtWindowToWidget(dpy, toplevel);
-
-                        if (w != NULL) {
-                            JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-                            Widget copy = w;
-                            jobject peer = findPeer(&w);
-
-                            if (!JNU_IsNull(env, peer) &&
-                                (*env)->IsInstanceOf(env, peer,
-                                                     get_MEmbedCanvasPeerClass(env)) == JNI_TRUE) {
-                                remove_xembed_drop_target(env, peer);
-                            }
-                        } else {
-                            EmbeddedDropSiteProtocolListEntry* xdnd_entry =
-                                get_xdnd_protocol_entry_for_toplevel(toplevel);
-                            EmbeddedDropSiteProtocolListEntry* motif_entry =
-                                get_motif_protocol_entry_for_toplevel(toplevel);
-
-                            if (xdnd_entry != NULL) {
-                                if (xdnd_entry->overriden == True) {
-                                    XChangeProperty(dpy, toplevel, XA_XdndAware,
-                                                    XA_ATOM, 32,
-                                                    PropModeReplace,
-                                                    (unsigned char*)&xdnd_entry->protocol_version,
-                                                    1);
-
-                                    XChangeProperty(dpy, toplevel, XA_XdndProxy,
-                                                    XA_WINDOW, 32,
-                                                    PropModeReplace,
-                                                    (unsigned char*)&xdnd_entry->proxy, 1);
-                                } else {
-                                    XDeleteProperty(dpy, toplevel, XA_XdndAware);
-                                    XDeleteProperty(dpy, toplevel, XA_XdndProxy);
-                                }
-                                remove_xdnd_protocol_entry_for_toplevel(toplevel);
-                            }
-
-                            if (motif_entry != NULL) {
-                                if (motif_entry->overriden == True) {
-                                    /* Request status */
-                                    int status;
-
-                                    Atom           type;
-                                    int            format;
-                                    unsigned long  nitems;
-                                    unsigned long  after;
-                                    unsigned char* data;
-
-                                    data = NULL;
-                                    status = XGetWindowProperty(dpy, toplevel,
-                                                                _XA_MOTIF_DRAG_RECEIVER_INFO, 0, 0xFFFF,
-                                                                False, AnyPropertyType, &type, &format,
-                                                                &nitems, &after, &data);
-
-                                    if (status == Success && data != NULL && type != None &&
-                                        format == 8 && nitems >= MOTIF_RECEIVER_INFO_SIZE) {
-                                        unsigned char byte_order = read_card8((char*)data, 0);
-                                        void* p = (char*)data + 4;
-
-                                        DASSERT(MOTIF_BYTE_ORDER == byte_order);
-
-                                        if (MOTIF_BYTE_ORDER == byte_order) {
-                                            /* restore the original proxy window */
-                                            write_card32(&p, motif_entry->proxy);
-
-                                            XChangeProperty(dpy, toplevel,
-                                                            _XA_MOTIF_DRAG_RECEIVER_INFO,
-                                                            _XA_MOTIF_DRAG_RECEIVER_INFO, 8,
-                                                            PropModeReplace,
-                                                            (unsigned char*)data,
-                                                            MOTIF_RECEIVER_INFO_SIZE);
-                                        }
-                                    }
-
-                                    if (status == Success) {
-                                        XFree(data);
-                                    }
-                                } else {
-                                    XDeleteProperty(dpy, toplevel, _XA_MOTIF_DRAG_RECEIVER_INFO);
-                                }
-
-                                remove_motif_protocol_entry_for_toplevel(toplevel);
-                            }
-
-                            if ((entry->event_mask & PropertyChangeMask) == 0) {
-                                XSelectInput(dpy, toplevel, entry->event_mask);
-                            }
-                        }
-
-                        if (prev == NULL) {
-                            embedded_drop_site_list = entry->next;
-                        } else {
-                            prev->next = entry->next;
-                        }
-
-                        free(entry);
-                    }
-                    return True;
-                }
-            }
-            return False;
-        }
-        prev = entry;
-        entry = entry->next;
-    }
-    return False;
-}
-
-static EmbeddedDropSiteListEntry*
-get_entry_for_toplevel(Window toplevel) {
-    EmbeddedDropSiteListEntry* entry = embedded_drop_site_list;
-
-    while (entry != NULL) {
-        if (entry->toplevel == toplevel) {
-            return entry;
-        }
-        entry = entry->next;
-    }
-    return NULL;
-}
-
-static EmbeddedDropSiteProtocolListEntry*
-get_motif_protocol_entry_for_toplevel(Window toplevel) {
-    EmbeddedDropSiteProtocolListEntry* entry = embedded_motif_protocol_list;
-
-    while (entry != NULL) {
-        if (entry->window == toplevel) {
-            return entry;
-        }
-        entry = entry->next;
-    }
-    return NULL;
-}
-
-static EmbeddedDropSiteProtocolListEntry*
-get_xdnd_protocol_entry_for_toplevel(Window toplevel) {
-    EmbeddedDropSiteProtocolListEntry* entry = embedded_xdnd_protocol_list;
-
-    while (entry != NULL) {
-        if (entry->window == toplevel) {
-            return entry;
-        }
-        entry = entry->next;
-    }
-    return NULL;
-}
-
-static void
-remove_motif_protocol_entry_for_toplevel(Window toplevel) {
-    EmbeddedDropSiteProtocolListEntry* entry = embedded_motif_protocol_list;
-    EmbeddedDropSiteProtocolListEntry* prev_entry = NULL;
-
-    while (entry != NULL) {
-        if (entry->window == toplevel) {
-            if (prev_entry != NULL) {
-                prev_entry->next = entry->next;
-            } else {
-                embedded_motif_protocol_list = entry->next;
-            }
-            free(entry);
-        }
-        entry = entry->next;
-        prev_entry = entry;
-    }
-}
-
-static void
-remove_xdnd_protocol_entry_for_toplevel(Window toplevel) {
-    EmbeddedDropSiteProtocolListEntry* entry = embedded_xdnd_protocol_list;
-    EmbeddedDropSiteProtocolListEntry* prev_entry = NULL;
-
-    while (entry != NULL) {
-        if (entry->window == toplevel) {
-            if (prev_entry != NULL) {
-                prev_entry->next = entry->next;
-            } else {
-                embedded_xdnd_protocol_list = entry->next;
-            }
-            free(entry);
-        }
-        entry = entry->next;
-    }
-}
-
-static Boolean
-is_embedding_toplevel(Window toplevel) {
-    return get_entry_for_toplevel(toplevel) != NULL;
-}
-
-static Window
-get_embedded_window(Display* dpy, Window toplevel, int x, int y) {
-    EmbeddedDropSiteListEntry* entry = get_entry_for_toplevel(toplevel);
-
-    if (entry != NULL) {
-        unsigned int idx;
-
-        for (idx = 0; idx < entry->embedded_sites_count; idx++) {
-            Window site = entry->embedded_sites[idx];
-            Window child = None;
-            int x_return, y_return;
-
-            if (XTranslateCoordinates(dpy, entry->root, site, x, y,
-                                      &x_return, &y_return, &child)) {
-                if (x_return >= 0 && y_return >= 0) {
-                    XWindowAttributes xwa;
-                    XGetWindowAttributes(dpy, site, &xwa);
-                    if (xwa.map_state != IsUnmapped &&
-                        x_return < xwa.width && y_return < xwa.height) {
-                        return site;
-                    }
-                }
-            }
-        }
-    }
-
-    return None;
-}
-
-/*
- * If the toplevel is not an embedding toplevel does nothing and returns False.
- * Otherwise, sets xdnd_proxy for the specified toplevel to the 'proxy_window',
- * xdnd_protocol_version to 'version', xdnd_override to 'override', returns True.
- */
-static Boolean
-set_xdnd_proxy_for_toplevel(Window toplevel, Window proxy_window,
-                            unsigned int version, Boolean override) {
-    EmbeddedDropSiteProtocolListEntry* entry =
-        get_xdnd_protocol_entry_for_toplevel(toplevel);
-
-    if (entry == NULL) {
-        return False;
-    }
-
-    entry->proxy = proxy_window;
-    entry->protocol_version = version;
-    entry->overriden = override;
-
-    return True;
-}
-
-/*
- * If the toplevel is not an embedding toplevel does nothing and returns False.
- * Otherwise, sets motif_proxy for the specified toplevel to the proxy_window,
- * motif_override to 'override' and returns True.
- */
-static Boolean
-set_motif_proxy_for_toplevel(Window toplevel, Window proxy_window, Boolean override) {
-    EmbeddedDropSiteProtocolListEntry* entry =
-        get_motif_protocol_entry_for_toplevel(toplevel);
-
-    if (entry == NULL) {
-        return False;
-    }
-
-    entry->proxy = proxy_window;
-    entry->overriden = override;
-
-    return True;
-}
-
-/*
- * Forwards a drag notification to the embedding toplevel modifying the event
- * to match the protocol version supported by the toplevel.
- * Returns True if the event is sent, False otherwise.
- */
-static Boolean
-forward_client_message_to_toplevel(Window toplevel, XClientMessageEvent* event) {
-    EmbeddedDropSiteProtocolListEntry* protocol_entry = NULL;
-    Window proxy = None;
-
-    if (event->message_type == _XA_MOTIF_DRAG_AND_DROP_MESSAGE) {
-        protocol_entry = get_motif_protocol_entry_for_toplevel(toplevel);
-    } else {
-        /* Assume XDnD */
-        protocol_entry = get_xdnd_protocol_entry_for_toplevel(toplevel);
-        if (protocol_entry != NULL) {
-            /* Adjust the event to match the XDnD protocol version. */
-            unsigned int version = protocol_entry->protocol_version;
-            if (event->message_type == XA_XdndEnter) {
-                unsigned int min_version = source_protocol_version < version ?
-                    source_protocol_version : version;
-                event->data.l[1] = min_version << XDND_PROTOCOL_SHIFT;
-                event->data.l[1] |= source_data_types_count > 3 ? XDND_DATA_TYPES_BIT : 0;
-            }
-        }
-    }
-
-    if (protocol_entry == NULL) {
-        return False;
-    }
-
-    if (!protocol_entry->overriden) {
-        return False;
-    }
-    proxy = protocol_entry->proxy;
-
-    if (proxy == None) {
-        proxy = toplevel;
-    }
-
-    event->window = toplevel;
-
-    XSendEvent(event->display, proxy, False, NoEventMask, (XEvent*)event);
-
-    return True;
-}
-
-/******************************************************************************/
-
-/********************* Drop site list support *********************************/
-
-struct DropSiteListEntryRec;
-
-typedef struct DropSiteListEntryRec DropSiteListEntry;
-
-struct DropSiteListEntryRec {
-    Window             window;
-    Window             root;
-    /*
-     * The closest to the root ancestor with WM_STATE property set.
-     * Normally toplevel == window.
-     * In plugin scenario toplevel is the browser toplevel window.
-     */
-    Window             toplevel;
-    /*
-     * Java top-level position is the outer canvas position, not the shell
-     * window position. We need to keep the outer canvas ID (and the root ID) to
-     * translate from mouse position root coordinates to the Java component
-     * coordinates.
-     */
-    Window             outer_canvas;
-    jobject            component;
-    DropSiteListEntry* next;
-};
-
-static DropSiteListEntry* drop_site_list = NULL;
-
-/*
- * If drop_site_list already contains an entry with the same window,
- * does nothing and returns False.
- * Otherwise, adds a new entry the list and returns True
- * if completes successfully.
- */
-static Boolean
-add_to_drop_site_list(Window window, Window root, Window toplevel,
-                      Window outer_canvas, jobject component) {
-    DropSiteListEntry* entry = drop_site_list;
-
-    while (entry != NULL) {
-        if (entry->window == window) {
-            return False;
-        }
-        entry = entry->next;
-    }
-
-    entry = malloc(sizeof(DropSiteListEntry));
-
-    if (entry == NULL) {
-        return False;
-    }
-
-    entry->window = window;
-    entry->root = root;
-    entry->toplevel = toplevel;
-    entry->outer_canvas = outer_canvas;
-    entry->component = component;
-    entry->next = drop_site_list;
-    drop_site_list = entry;
-
-    return True;
-}
-
-/*
- * Returns True if the list entry for the specified window has been successfully
- * removed from the list. Otherwise, returns False.
- */
-static Boolean
-remove_from_drop_site_list(Window window) {
-    DropSiteListEntry* entry = drop_site_list;
-    DropSiteListEntry* prev = NULL;
-
-    while (entry != NULL) {
-        if (entry->window == window) {
-            if (prev != NULL) {
-                prev->next = entry->next;
-            } else {
-                drop_site_list = entry->next;
-            }
-            free(entry);
-            return True;
-        }
-        prev = entry;
-        entry = entry->next;
-    }
-
-    return False;
-}
-
-static jobject
-get_component_for_window(Window window) {
-    DropSiteListEntry* entry = drop_site_list;
-
-    while (entry != NULL) {
-        if (entry->window == window) {
-            return entry->component;
-        }
-        entry = entry->next;
-    }
-
-    return NULL;
-}
-
-static Window
-get_root_for_window(Window window) {
-    DropSiteListEntry* entry = drop_site_list;
-
-    while (entry != NULL) {
-        if (entry->window == window) {
-            return entry->root;
-        }
-        entry = entry->next;
-    }
-
-    return None;
-}
-
-static Window
-get_toplevel_for_window(Window window) {
-    DropSiteListEntry* entry = drop_site_list;
-
-    while (entry != NULL) {
-        if (entry->window == window) {
-            return entry->toplevel;
-        }
-        entry = entry->next;
-    }
-
-    return None;
-}
-
-static Window
-get_outer_canvas_for_window(Window window) {
-    DropSiteListEntry* entry = drop_site_list;
-
-    while (entry != NULL) {
-        if (entry->window == window) {
-            return entry->outer_canvas;
-        }
-        entry = entry->next;
-    }
-
-    return None;
-}
-/******************************************************************************/
-
-/******************* Delayed drop site registration stuff *********************/
-struct DelayedRegistrationEntryRec;
-
-typedef struct DelayedRegistrationEntryRec DelayedRegistrationEntry;
-
-struct DelayedRegistrationEntryRec {
-    Widget outer_canvas;
-    jobject component;
-    XtIntervalId timer;
-    DelayedRegistrationEntry* next;
-};
-
-static DelayedRegistrationEntry* delayed_registration_list = NULL;
-
-static const int DELAYED_REGISTRATION_PERIOD = 500;
-
-/* Timer callback. */
-static void
-register_drop_site_later(XtPointer client_data, XtIntervalId* id);
-
-/*
- * Enqueues the specified widget and component for delayed drop site
- * registration. If this widget has already been registered, does nothing and
- * returns False. Otherwise, schedules a timer callback that will repeatedly
- * attempt to register the drop site until the registration succeeds.
- * To remove this widget from the queue of delayed registration call
- * remove_delayed_registration_entry().
- *
- * The caller must own AWT_LOCK.
- */
-static Boolean
-add_delayed_registration_entry(Widget outer_canvas, XtPointer componentRef) {
-    DelayedRegistrationEntry* entry = delayed_registration_list;
-
-    if (outer_canvas == NULL || componentRef == NULL) {
-        return False;
-    }
-
-    while (entry != NULL && entry->outer_canvas != outer_canvas) {
-        entry = entry->next;
-    }
-
-    if (entry != NULL) {
-        return False;
-    }
-
-    entry = malloc(sizeof(DelayedRegistrationEntry));
-
-    if (entry == NULL) {
-        return False;
-    }
-
-    entry->outer_canvas = outer_canvas;
-    entry->component = componentRef;
-    entry->timer = XtAppAddTimeOut(awt_appContext, DELAYED_REGISTRATION_PERIOD,
-                                   register_drop_site_later, entry);
-    entry->next = delayed_registration_list;
-    delayed_registration_list = entry;
-
-    return True;
-}
-
-/*
- * Unregisters the timer callback and removes this widget from the queue of
- * delayed drop site registration.
- *
- * The caller must own AWT_LOCK.
- */
-static Boolean
-remove_delayed_registration_entry(Widget outer_canvas) {
-    DelayedRegistrationEntry* entry = delayed_registration_list;
-    DelayedRegistrationEntry* prev = NULL;
-
-    if (outer_canvas == NULL) {
-        return False;
-    }
-
-    while (entry != NULL && entry->outer_canvas != outer_canvas) {
-        prev = entry;
-        entry = entry->next;
-    }
-
-    if (entry == NULL) {
-        return False;
-    }
-
-    if (prev != NULL) {
-        prev->next = entry->next;
-    } else {
-        delayed_registration_list = entry->next;
-    }
-
-    if (entry->timer) {
-        XtRemoveTimeOut(entry->timer);
-        entry->timer = (XtIntervalId)0;
-    }
-
-    free(entry);
-
-    return True;
-}
-
-static void
-register_drop_site_later(XtPointer client_data, XtIntervalId* id) {
-    DelayedRegistrationEntry* entry = (DelayedRegistrationEntry*)client_data;
-
-    if (XtIsRealized(entry->outer_canvas) &&
-        register_drop_site(entry->outer_canvas, entry->component)) {
-        remove_delayed_registration_entry(entry->outer_canvas);
-    } else {
-        entry->timer = XtAppAddTimeOut(awt_appContext, DELAYED_REGISTRATION_PERIOD,
-                                       register_drop_site_later, entry);
-    }
-}
-/******************************************************************************/
-
-static void
-awt_dnd_cleanup() {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-
-    if (!JNU_IsNull(env, target_component)) {
-        /* Trigger dragExit */
-        /*
-         * Note: we pass NULL native context. This indicates that response
-         * shouldn't be sent to the source.
-         */
-        dt_postDropTargetEvent(env, target_component, 0, 0,
-                               java_awt_dnd_DnDConstants_ACTION_NONE,
-                               java_awt_event_MouseEvent_MOUSE_EXITED,
-                               NULL);
-    }
-
-    if (motif_top_level_leave_postponed) {
-        XClientMessageEvent* leave = &motif_top_level_leave_postponed_event;
-        if (leave->type == ClientMessage) {
-            Window win = leave->window;
-            if (is_embedding_toplevel(win)) {
-                forward_client_message_to_toplevel(win, leave);
-            }
-        }
-    }
-
-    if (source_window != None) {
-        XSelectInput(awt_display, source_window, source_window_mask);
-    }
-
-    source_protocol = NO_PROTOCOL;
-    source_protocol_version = 0;
-    source_window = None;
-    source_atom = None;
-    source_window_mask = 0;
-    source_actions = java_awt_dnd_DnDConstants_ACTION_NONE;
-    track_source_actions = False;
-    (*env)->DeleteGlobalRef(env, source_data_types);
-    source_data_types = NULL;
-    if (source_data_types_native != NULL) {
-        free(source_data_types_native);
-        source_data_types_native = NULL;
-    }
-    source_data_types_count = 0;
-    source_x = 0;
-    source_y = 0;
-    target_component = NULL;
-    motif_top_level_leave_postponed = False;
-    memset(&motif_top_level_leave_postponed_event, 0,
-           sizeof(XClientMessageEvent));
-}
-
-static jlongArray
-get_data_types_array(JNIEnv* env, Atom* types, unsigned int types_count) {
-    jlongArray array = NULL;
-    jboolean isCopy;
-    jlong*   jTargets;
-#ifndef _LP64 /* Atom and jlong are different sizes in the 32-bit build */
-    unsigned int i;
-#endif
-
-    if ((*env)->PushLocalFrame(env, 1) < 0) {
-        return NULL;
-    }
-
-    array = (*env)->NewLongArray(env, types_count);
-
-    if (JNU_IsNull(env, array)) {
-        return NULL;
-    }
-
-    if (types_count == 0) {
-        return array;
-    }
-
-    jTargets = (*env)->GetLongArrayElements(env, array, &isCopy);
-    if (jTargets == NULL) {
-        (*env)->PopLocalFrame(env, NULL);
-        return NULL;
-    }
-
-#ifdef _LP64
-    memcpy(jTargets, types, types_count * sizeof(Atom));
-#else
-    for (i = 0; i < types_count; i++) {
-        jTargets[i] = (types[i] & 0xFFFFFFFFLU);
-    }
-#endif
-
-    (*env)->ReleaseLongArrayElements(env, array, jTargets, 0);
-
-    array = (*env)->NewGlobalRef(env, array);
-
-    (*env)->PopLocalFrame(env, NULL);
-
-    return array;
-}
-
-static Boolean
-is_xdnd_drag_message_type(unsigned long message_type) {
-    return message_type == XA_XdndEnter ||
-        message_type == XA_XdndPosition ||
-        message_type == XA_XdndLeave ||
-        message_type == XA_XdndDrop ? True : False;
-}
-
-/*
- * Returns EventConsume if the event should be consumed,
- * EventPassAlong otherwise.
- */
-static EventStatus
-handle_xdnd_enter(XClientMessageEvent* event) {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    Display* dpy = event->display;
-    long* event_data = event->data.l;
-    Window source_win = None;
-    long source_win_mask = 0;
-    unsigned int protocol_version = 0;
-    unsigned int data_types_count = 0;
-    Atom* data_types = NULL;
-    jlongArray java_data_types = NULL;
-    jint actions = java_awt_dnd_DnDConstants_ACTION_NONE;
-    Boolean track = False;
-
-    DTRACE_PRINTLN5("%s:%d XdndEnter comp=%X src_win=%ld protocol=%d.",
-                    __FILE__, __LINE__,
-                    target_component, source_window, source_protocol);
-
-    if (!JNU_IsNull(env, target_component) || source_window != None ||
-        source_protocol != NO_PROTOCOL) {
-        DTRACE_PRINTLN2("%s:%d XdndEnter rejected - invalid state.",
-                        __FILE__, __LINE__);
-        return EventFailure;
-    }
-
-    /*
-     * NOTE: the component can be NULL if the event was sent to the embedding
-     * toplevel.
-     */
-    if (JNU_IsNull(env, get_component_for_window(event->window)) &&
-        !is_embedding_toplevel(event->window)) {
-        DTRACE_PRINTLN2("%s:%d XdndEnter rejected - window is not a registered drop site.",
-                        __FILE__, __LINE__);
-        return EventFailure;
-    }
-
-    protocol_version =
-        (event_data[1] & XDND_PROTOCOL_MASK) >> XDND_PROTOCOL_SHIFT;
-
-    /* XDnD compliance only requires supporting version 3 and up. */
-    if (protocol_version < XDND_MIN_PROTOCOL_VERSION) {
-        DTRACE_PRINTLN2("%s:%d XdndEnter rejected - invalid protocol version.",
-                        __FILE__, __LINE__);
-        return EventFailure;
-    }
-
-    /* Ignore the source if the protocol version is higher than we support. */
-    if (protocol_version > XDND_PROTOCOL_VERSION) {
-        DTRACE_PRINTLN2("%s:%d XdndEnter rejected - invalid protocol version.",
-                        __FILE__, __LINE__);
-        return EventFailure;
-    }
-
-    source_win = event_data[0];
-
-    /* Extract the list of supported actions. */
-    if (protocol_version < 2) {
-        /* Prior to XDnD version 2 only COPY action was supported. */
-        actions = java_awt_dnd_DnDConstants_ACTION_COPY;
-    } else {
-        unsigned char  ret;
-        Atom           type;
-        int            format;
-        unsigned long  nitems;
-        unsigned long  after;
-        unsigned char  *data;
-
-        data = NULL;
-        ret = checked_XGetWindowProperty(dpy, source_win, XA_XdndActionList,
-                                         0, 0xFFFF, False, XA_ATOM, &type,
-                                         &format, &nitems, &after, &data);
-
-        /* Ignore the source if the window is destroyed. */
-        if (ret == BadWindow) {
-            DTRACE_PRINTLN2("%s:%d XdndEnter rejected - invalid window.",
-                            __FILE__, __LINE__);
-            return EventFailure;
-        }
-
-        if (ret == Success) {
-            if (type == XA_ATOM && format == 32) {
-                unsigned int i;
-                Atom* action_atoms = (Atom*)data;
-
-                for (i = 0; i < nitems; i++) {
-                    actions |= xdnd_to_java_action(action_atoms[i]);
-                }
-            }
-
-            /*
-             * According to XDnD protocol, XdndActionList is optional.
-             * If XdndActionList is not set we try to guess which actions are
-             * supported.
-             */
-            if (type == None) {
-                actions = java_awt_dnd_DnDConstants_ACTION_COPY;
-                track = True;
-            }
-
-            XFree(data);
-        }
-    }
-
-    /* Extract the available data types. */
-    if (event_data[1] & XDND_DATA_TYPES_BIT) {
-        unsigned char  ret;
-        Atom           type;
-        int            format;
-        unsigned long  nitems;
-        unsigned long  after;
-        unsigned char  *data;
-
-        data = NULL;
-        ret = checked_XGetWindowProperty(dpy, source_win, XA_XdndTypeList,
-                                         0, 0xFFFF, False, XA_ATOM, &type,
-                                         &format, &nitems, &after, &data);
-
-        /* Ignore the source if the window is destroyed. */
-        if (ret == BadWindow) {
-            DTRACE_PRINTLN2("%s:%d XdndEnter rejected - invalid window.",
-                            __FILE__, __LINE__);
-            return EventFailure;
-        }
-
-        if (ret == Success) {
-            if (type == XA_ATOM && format == 32 && nitems > 0) {
-                data_types_count = nitems;
-                data_types = (Atom*)malloc(data_types_count * sizeof(Atom));
-
-                if (data_types == NULL) {
-                    XFree(data);
-                    DTRACE_PRINTLN2("%s:%d XdndEnter rejected - malloc fails.",
-                                    __FILE__, __LINE__);
-                    return EventFailure;
-                }
-
-                memcpy((void *)data_types, (void *)data,
-                       data_types_count * sizeof(Atom));
-            }
-
-            XFree(data);
-        }
-    } else {
-        int i;
-        data_types = (Atom*)malloc(3 * sizeof (Atom));
-        if (data_types == NULL) {
-            DTRACE_PRINTLN2("%s:%d XdndEnter rejected - malloc fails.",
-                            __FILE__, __LINE__);
-            return EventFailure;
-        }
-        for (i = 0; i < 3; i++) {
-            Atom j;
-            if ((j = event_data[2 + i]) != None) {
-                data_types[data_types_count++] = j;
-            }
-        }
-    }
-
-    java_data_types = get_data_types_array(env, data_types, data_types_count);
-
-    if (JNU_IsNull(env, java_data_types)) {
-        DTRACE_PRINTLN2("%s:%d XdndEnter rejected - cannot create types array.",
-                        __FILE__, __LINE__);
-        free((char*)data_types);
-        return EventFailure;
-    }
-
-    /*
-     * Select for StructureNotifyMask to receive DestroyNotify in case of source
-     * crash.
-     */
-    {
-        unsigned char ret;
-        XWindowAttributes xwa;
-
-        XGetWindowAttributes(dpy, source_win, &xwa);
-
-        source_win_mask = xwa.your_event_mask;
-
-        ret = checked_XSelectInput(dpy, source_win,
-                                   (source_win_mask | StructureNotifyMask));
-
-        if (ret == BadWindow) {
-            DTRACE_PRINTLN2("%s:%d XdndEnter rejected - invalid window.",
-                            __FILE__, __LINE__);
-            free((char*)data_types);
-            (*env)->DeleteGlobalRef(env, java_data_types);
-            return EventFailure;
-        }
-    }
-
-    /* Update the global state. */
-    source_protocol = XDND_PROTOCOL;
-    source_protocol_version = protocol_version;
-    source_window = source_win;
-    source_window_mask = source_win_mask;
-    source_actions = actions;
-    track_source_actions = track;
-    source_data_types = java_data_types;
-    source_data_types_native = data_types;
-    source_data_types_count = data_types_count;
-
-    DTRACE_PRINTLN5("%s:%d XdndEnter handled src_win=%ld protocol=%d fmt=%d.",
-                    __FILE__, __LINE__,
-                    source_window, source_protocol, data_types_count);
-
-    return EventSuccess;
-}
-
-/*
- * Returns EventConsume if the event should be consumed,
- * EventPassAlong otherwise.
- */
-static EventStatus
-handle_xdnd_position(XClientMessageEvent* event) {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    long* event_data = event->data.l;
-    Window source_win = None;
-    Time time_stamp = CurrentTime;
-    Atom action_atom = None;
-    jint action = java_awt_dnd_DnDConstants_ACTION_NONE;
-    int x = 0;
-    int y = 0;
-    jint java_event_id = 0;
-    jobject component = NULL;
-    Window receiver = None;
-
-    DTRACE_PRINTLN5("%s:%d XdndPosition comp=%X src_win=%ld protocol=%d.",
-                    __FILE__, __LINE__,
-                    target_component, source_window, source_protocol);
-
-    if (source_protocol != XDND_PROTOCOL) {
-        DTRACE_PRINTLN2("%s:%d XdndPosition rejected - invalid state.",
-                        __FILE__, __LINE__);
-        return EventFailure;
-    }
-
-    source_win = event_data[0];
-
-    /* Ignore XDnD messages from all other windows. */
-    if (source_window != source_win) {
-        DTRACE_PRINTLN4("%s:%d XdndPosition rejected - invalid source window cur=%ld this=%ld.",
-                        __FILE__, __LINE__, source_window, source_win);
-        return EventFailure;
-    }
-
-    x = event_data[2] >> 16;
-    y = event_data[2] & 0xFFFF;
-
-    component = get_component_for_window(event->window);
-
-    if (JNU_IsNull(env, component)) {
-        /*
-         * The window must be the embedding toplevel, since otherwise we would reject the
-         * XdndEnter and never get to this point.
-         */
-        DASSERT(is_embedding_toplevel(event->window));
-
-        receiver = get_embedded_window(event->display, event->window, x, y);
-
-        if (receiver != None) {
-            component = get_component_for_window(receiver);
-        }
-    } else {
-        receiver = event->window;
-    }
-
-    /* Translate mouse position from root coordinates
-       to the target window coordinates. */
-    if (receiver != None) {
-        Window child = None;
-        XTranslateCoordinates(event->display,
-                              get_root_for_window(receiver),
-                              get_outer_canvas_for_window(receiver),
-                              x, y, &x, &y, &child);
-    }
-
-    /* Time stamp - new in XDnD version 1. */
-    if (source_protocol_version > 0) {
-        time_stamp = event_data[3];
-    }
-
-    /* User action - new in XDnD version 1. */
-    if (source_protocol_version > 1) {
-        action_atom = event_data[4];
-    } else {
-        /* The default action is XdndActionCopy */
-        action_atom = XA_XdndActionCopy;
-    }
-
-    action = xdnd_to_java_action(action_atom);
-
-    if (track_source_actions) {
-        source_actions |= action;
-    }
-
-    if (JNU_IsNull(env, component)) {
-        if (!JNU_IsNull(env, target_component)) {
-            dt_postDropTargetEvent(env, target_component, x, y,
-                                   java_awt_dnd_DnDConstants_ACTION_NONE,
-                                   java_awt_event_MouseEvent_MOUSE_EXITED,
-                                   NULL);
-        }
-    } else {
-        if (JNU_IsNull(env, target_component)) {
-            java_event_id = java_awt_event_MouseEvent_MOUSE_ENTERED;
-        } else {
-            java_event_id = java_awt_event_MouseEvent_MOUSE_DRAGGED;
-        }
-
-        dt_postDropTargetEvent(env, component, x, y, action,
-                               java_event_id, event);
-    }
-
-    user_action = action;
-    source_x = x;
-    source_y = y;
-    target_component = component;
-
-    return EventSuccess;
-}
-
-/*
- * Returns EventConsume if the event should be consumed,
- * EventPassAlong otherwise.
- */
-static EventStatus
-handle_xdnd_leave(XClientMessageEvent* event) {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    long* event_data = event->data.l;
-    Window source_win = None;
-
-    if (source_protocol != XDND_PROTOCOL) {
-        DTRACE_PRINTLN2("%s:%d XdndLeave rejected - invalid state.",
-                        __FILE__, __LINE__);
-        return EventFailure;
-    }
-
-    source_win = event_data[0];
-
-    /* Ignore XDnD messages from all other windows. */
-    if (source_window != source_win) {
-        DTRACE_PRINTLN4("%s:%d XdndLeave rejected - invalid source window cur=%ld this=%ld.",
-                        __FILE__, __LINE__, source_window, source_win);
-        return EventFailure;
-    }
-
-    awt_dnd_cleanup();
-
-    return EventSuccess;
-}
-
-/*
- * Returns EventConsume if the event should be consumed,
- * EventPassAlong otherwise.
- */
-static EventStatus
-handle_xdnd_drop(XClientMessageEvent* event) {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    long* event_data = event->data.l;
-    Window source_win = None;
-
-    DTRACE_PRINTLN5("%s:%d XdndDrop comp=%X src_win=%ld protocol=%d.",
-                    __FILE__, __LINE__,
-                    target_component, source_window, source_protocol);
-
-    if (source_protocol != XDND_PROTOCOL) {
-        DTRACE_PRINTLN2("%s:%d XdndDrop rejected - invalid state.",
-                        __FILE__, __LINE__);
-        return EventFailure;
-    }
-
-    source_win = event_data[0];
-
-    /* Ignore XDnD messages from all other windows. */
-    if (source_window != source_win) {
-        DTRACE_PRINTLN4("%s:%d XdndDrop rejected - invalid source window cur=%ld this=%ld.",
-                        __FILE__, __LINE__, source_window, source_win);
-        return EventFailure;
-    }
-
-    if (!JNU_IsNull(env, target_component)) {
-        dt_postDropTargetEvent(env, target_component, source_x, source_y, user_action,
-                               java_awt_event_MouseEvent_MOUSE_RELEASED, event);
-    }
-
-    return EventSuccess;
-}
-
-/*
- * Returns EventPassAlong if the event should be passed to the original proxy.
- * TOP_LEVEL_ENTER should be passed to the original proxy only if the event is
- * invalid.
- */
-static EventStatus
-handle_motif_top_level_enter(XClientMessageEvent* event) {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    Display* dpy = event->display;
-    char* event_data = event->data.b;
-    unsigned char event_byte_order = 0;
-    Window source_win = None;
-    long source_win_mask = 0;
-    unsigned int protocol_version = MOTIF_DND_PROTOCOL_VERSION;
-    Atom property_atom = None;
-    unsigned int data_types_count = 0;
-    Atom* data_types = NULL;
-    jlongArray java_data_types = NULL;
-
-    DTRACE_PRINTLN5("%s:%d TOP_LEVEL_ENTER comp=%X src_win=%ld protocol=%d.",
-                    __FILE__, __LINE__,
-                    target_component, source_window, source_protocol);
-
-    if (!JNU_IsNull(env, target_component) || source_window != None ||
-        source_protocol != NO_PROTOCOL) {
-        DTRACE_PRINTLN2("%s:%d TOP_LEVEL_ENTER rejected - invalid state.",
-                        __FILE__, __LINE__);
-        return EventFailure;
-    }
-
-    if (JNU_IsNull(env, get_component_for_window(event->window)) &&
-        !is_embedding_toplevel(event->window)) {
-        DTRACE_PRINTLN2("%s:%d TOP_LEVEL_ENTER rejected - window is not a registered drop site.",
-                        __FILE__, __LINE__);
-        return EventFailure;
-    }
-
-    event_byte_order = read_card8(event_data, 1);
-    source_win = read_card32(event_data, 8, event_byte_order);
-    property_atom = read_card32(event_data, 12, event_byte_order);
-
-    /* Extract the available data types. */
-    {
-        unsigned char  ret;
-        Atom           type;
-        int            format;
-        unsigned long  nitems;
-        unsigned long  after;
-        unsigned char  *data;
-
-        data = NULL;
-        ret = checked_XGetWindowProperty(dpy, source_win, property_atom, 0,
-                                         0xFFFF, False,
-                                         _XA_MOTIF_DRAG_INITIATOR_INFO, &type,
-                                         &format, &nitems, &after, &data);
-
-        /* Ignore the source if the window is destroyed. */
-        if (ret == BadWindow) {
-            DTRACE_PRINTLN2("%s:%d TOP_LEVEL_ENTER rejected - invalid window.",
-                            __FILE__, __LINE__);
-            return EventFailure;
-        }
-
-        if (ret == BadAtom) {
-            DTRACE_PRINTLN2("%s:%d TOP_LEVEL_ENTER rejected - invalid property atom.",
-                            __FILE__, __LINE__);
-            return EventFailure;
-        }
-
-        if (ret == Success) {
-            if (type == _XA_MOTIF_DRAG_INITIATOR_INFO && format == 8 &&
-                nitems == MOTIF_INITIATOR_INFO_SIZE) {
-                unsigned char property_byte_order = read_card8((char*)data, 0);
-                int index = read_card16((char*)data, 2, property_byte_order);
-
-                protocol_version = read_card8((char*)data, 1);
-
-                if (protocol_version > MOTIF_DND_PROTOCOL_VERSION) {
-                    DTRACE_PRINTLN3("%s:%d TOP_LEVEL_ENTER rejected - invalid protocol version: %d.",
-                                    __FILE__, __LINE__, protocol_version);
-                    XFree(data);
-                    return EventFailure;
-                }
-
-                get_target_list_for_index(dpy, index, &data_types, &data_types_count);
-            }
-
-            XFree(data);
-        }
-    }
-
-    java_data_types = get_data_types_array(env, data_types, data_types_count);
-
-    if (JNU_IsNull(env, java_data_types)) {
-        DTRACE_PRINTLN2("%s:%d TOP_LEVEL_ENTER rejected - cannot create types array.",
-                        __FILE__, __LINE__);
-        free((char*)data_types);
-        return EventFailure;
-    }
-
-    /*
-     * Select for StructureNotifyMask to receive DestroyNotify in case of source
-     * crash.
-     */
-    {
-        unsigned char ret;
-        XWindowAttributes xwa;
-
-        XGetWindowAttributes(dpy, source_win, &xwa);
-
-        source_win_mask = xwa.your_event_mask;
-
-        ret = checked_XSelectInput(dpy, source_win,
-                                   (source_win_mask | StructureNotifyMask));
-
-        if (ret == BadWindow) {
-            DTRACE_PRINTLN2("%s:%d XdndEnter rejected - invalid window.",
-                            __FILE__, __LINE__);
-            free((char*)data_types);
-            (*env)->DeleteGlobalRef(env, java_data_types);
-            return EventFailure;
-        }
-    }
-
-    source_protocol = MOTIF_DND_PROTOCOL;
-    source_protocol_version = protocol_version;
-    source_window = source_win;
-    source_atom = property_atom;
-    source_window_mask = source_win_mask;
-    /*
-     * TOP_LEVEL_ENTER doesn't communicate the list of supported actions
-     * They are provided in DRAG_MOTION.
-     */
-    source_actions = java_awt_dnd_DnDConstants_ACTION_NONE;
-    track_source_actions = False;
-    source_data_types = java_data_types;
-    source_data_types_native = data_types;
-    source_data_types_count = data_types_count;
-    DTRACE_PRINTLN6("%s:%d TOP_LEVEL_ENTER comp=%d src_win=%ld protocol=%d fmt=%d.",
-                    __FILE__, __LINE__,
-                    target_component, source_window, source_protocol, data_types_count);
-
-    return EventSuccess;
-}
-
-/*
- * Returns EventPassAlong if the event should be passed to the original proxy.
- * DRAG_MOTION event shouldn't be passed to the original proxy only if it is
- * a valid event and the mouse coordinates passed in it specify the point over
- * a Java component in this JVM.
- */
-static EventStatus
-handle_motif_drag_motion(XClientMessageEvent* event) {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    char* event_data = event->data.b;
-    unsigned char event_reason = 0;
-    unsigned char event_byte_order = 0;
-    Window source_win = None;
-    CARD16 flags = 0;
-    unsigned char motif_action = 0;
-    unsigned char motif_actions = 0;
-    jint java_action = java_awt_dnd_DnDConstants_ACTION_NONE;
-    jint java_actions = java_awt_dnd_DnDConstants_ACTION_NONE;
-    int x = 0;
-    int y = 0;
-    jint java_event_id = 0;
-    jobject component = NULL;
-
-    DTRACE_PRINTLN5("%s:%d DRAG_MOTION comp=%X src_win=%ld protocol=%d.",
-                    __FILE__, __LINE__,
-                    target_component, source_window, source_protocol);
-
-    if (source_protocol != MOTIF_DND_PROTOCOL) {
-        DTRACE_PRINTLN2("%s:%d DRAG_MOTION rejected - invalid state.",
-                        __FILE__, __LINE__);
-        return EventFailure;
-    }
-
-    event_reason = read_card8(event_data, 0) & MOTIF_MESSAGE_REASON_MASK;
-    event_byte_order = read_card8(event_data, 1);
-
-    flags = read_card16(event_data, 2, event_byte_order);
-
-    motif_action = (flags & MOTIF_DND_ACTION_MASK) >> MOTIF_DND_ACTION_SHIFT;
-    motif_actions = (flags & MOTIF_DND_ACTIONS_MASK) >> MOTIF_DND_ACTIONS_SHIFT;
-
-    java_action = motif_to_java_actions(motif_action);
-    java_actions = motif_to_java_actions(motif_actions);
-
-    /* Append source window id to the event data, so that we can send the
-       response properly. */
-    {
-        Window win = source_window;
-        void* p = &event->data.b[12];
-        if (event_byte_order != MOTIF_BYTE_ORDER) {
-            SWAP4BYTES(win);
-        }
-        write_card32(&p, (CARD32)win);
-    }
-
-    component = get_component_for_window(event->window);
-
-    if (event_reason == OPERATION_CHANGED) {
-        /* OPERATION_CHANGED event doesn't provide coordinates, so we use
-           previously stored position and component ref. */
-        x = source_x;
-        y = source_y;
-
-        if (JNU_IsNull(env, component)) {
-            component = target_component;
-        }
-    } else {
-        Window receiver = None;
-
-        x = read_card16(event_data, 8, event_byte_order);
-        y = read_card16(event_data, 10, event_byte_order);
-
-        if (JNU_IsNull(env, component)) {
-            /*
-             * The window must be the embedding toplevel, since otherwise we
-             * would reject the TOP_LEVEL_ENTER and never get to this point.
-             */
-            DASSERT(is_embedding_toplevel(event->window));
-
-            receiver = get_embedded_window(event->display, event->window, x, y);
-
-            if (receiver != None) {
-                component = get_component_for_window(receiver);
-            }
-        } else {
-            receiver = event->window;
-        }
-
-        /* Translate mouse position from root coordinates
-           to the target window coordinates. */
-        if (receiver != None) {
-            Window child = None;
-            XTranslateCoordinates(event->display,
-                                  get_root_for_window(receiver),
-                                  get_outer_canvas_for_window(receiver),
-                                  x, y, &x, &y, &child);
-        }
-    }
-
-    if (JNU_IsNull(env, component)) {
-        if (!JNU_IsNull(env, target_component)) {
-            /* Triggers dragExit */
-            dt_postDropTargetEvent(env, target_component, x, y,
-                                   java_awt_dnd_DnDConstants_ACTION_NONE,
-                                   java_awt_event_MouseEvent_MOUSE_EXITED,
-                                   NULL);
-        }
-    } else {
-        if (JNU_IsNull(env, target_component)) {
-            /* Triggers dragEnter */
-            java_event_id = java_awt_event_MouseEvent_MOUSE_ENTERED;
-        } else {
-            /* Triggers dragOver */
-            java_event_id = java_awt_event_MouseEvent_MOUSE_DRAGGED;
-        }
-
-        dt_postDropTargetEvent(env, component, x, y, java_action, java_event_id,
-                               event);
-    }
-
-    source_actions = java_actions;
-    track_source_actions = False;
-    user_action = java_action;
-    source_x = x;
-    source_y = y;
-    target_component = component;
-
-    return EventSuccess;
-}
-
-/*
- * Returns EventPassAlong if the event should be passed to the original proxy.
- * TOP_LEVEL_LEAVE should be passed to the original proxy only if the event
- * is invalid.
- */
-static EventStatus
-handle_motif_top_level_leave(XClientMessageEvent* event) {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    char* event_data = event->data.b;
-    unsigned char event_byte_order = 0;
-    Window source_win = None;
-
-    DTRACE_PRINTLN5("%s:%d TOP_LEVEL_LEAVE comp=%X src_win=%ld protocol=%d.",
-                    __FILE__, __LINE__,
-                    target_component, source_window, source_protocol);
-
-    if (source_protocol != MOTIF_DND_PROTOCOL) {
-        DTRACE_PRINTLN2("%s:%d TOP_LEVEL_LEAVE rejected - invalid state.",
-                        __FILE__, __LINE__);
-        return EventFailure;
-    }
-
-    event_byte_order = read_card8(event_data, 1);
-    source_win = read_card32(event_data, 8, event_byte_order);
-
-    /* Ignore Motif DnD messages from all other windows. */
-    if (source_window != source_win) {
-        DTRACE_PRINTLN4("%s:%d TOP_LEVEL_LEAVE rejected - invalid source window cur=%ld this=%ld.",
-                        __FILE__, __LINE__, source_window, source_win);
-        return EventFailure;
-    }
-
-    /*
-     * Postpone upcall to java, so that we can abort it in case
-     * if drop immediatelly follows (see BugTraq ID 4395290).
-     * Send a dummy ClientMessage event to guarantee that a postponed java
-     * upcall will be processed.
-     */
-    motif_top_level_leave_postponed = True;
-    {
-        XClientMessageEvent dummy;
-        Window proxy;
-
-        dummy.display      = event->display;
-        dummy.type         = ClientMessage;
-        dummy.window       = event->window;
-        dummy.format       = 32;
-        dummy.message_type = None;
-
-        /*
-         * If this is an embedded drop site, the event should go to the
-         * awt_root_window as this is a proxy for all embedded drop sites.
-         * Otherwise the event should go to the event->window, as we don't use
-         * proxies for normal drop sites.
-         */
-        if (is_embedding_toplevel(event->window)) {
-            proxy = get_awt_root_window();
-        } else {
-            proxy = event->window;
-        }
-
-        XSendEvent(event->display, proxy, False, NoEventMask,
-                   (XEvent*)&dummy);
-    }
-
-    return EventSuccess;
-}
-
-/*
- * Returns EventPassAlong if the event should be passed to the original proxy.
- * DROP_START event shouldn't be passed to the original proxy only if it is
- * a valid event and the mouse coordinates passed in it specify the point over
- * a Java component in this JVM.
- */
-static EventStatus
-handle_motif_drop_start(XClientMessageEvent* event) {
-    JNIEnv *env = (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-    char* event_data = event->data.b;
-    unsigned char event_byte_order = 0;
-    Window source_win = None;
-    Atom property_atom = None;
-    CARD16 flags = 0;
-    unsigned char motif_action = 0;
-    unsigned char motif_actions = 0;
-    jint java_action = java_awt_dnd_DnDConstants_ACTION_NONE;
-    jint java_actions = java_awt_dnd_DnDConstants_ACTION_NONE;
-    int x = 0;
-    int y = 0;
-    jobject component = NULL;
-    Window receiver = None;
-
-    DTRACE_PRINTLN5("%s:%d DROP_START comp=%X src_win=%ld protocol=%d.",
-                    __FILE__, __LINE__,
-                    target_component, source_window, source_protocol);
-
-    if (source_protocol != MOTIF_DND_PROTOCOL) {
-        DTRACE_PRINTLN2("%s:%d DROP_START rejected - invalid state.",
-                        __FILE__, __LINE__);
-        return EventFailure;
-    }
-
-    event_byte_order = read_card8(event_data, 1);
-    source_win = read_card32(event_data, 16, event_byte_order);
-
-    /* Ignore Motif DnD messages from all other windows. */
-    if (source_window != source_win) {
-        DTRACE_PRINTLN4("%s:%d DROP_START rejected - invalid source window cur=%ld this=%ld.",
-                        __FILE__, __LINE__, source_window, source_win);
-        return EventFailure;
-    }
-
-    property_atom = read_card32(event_data, 12, event_byte_order);
-
-    flags = read_card16(event_data, 2, event_byte_order);
-
-    motif_action = (flags & MOTIF_DND_ACTION_MASK) >> MOTIF_DND_ACTION_SHIFT;
-    motif_actions = (flags & MOTIF_DND_ACTIONS_MASK) >> MOTIF_DND_ACTIONS_SHIFT;
-
-    java_action = motif_to_java_actions(motif_action);
-    java_actions = motif_to_java_actions(motif_actions);
-
-    x = read_card16(event_data, 8, event_byte_order);
-    y = read_card16(event_data, 10, event_byte_order);
-
-    source_actions = java_actions;
-
-    component = get_component_for_window(event->window);
-
-    if (JNU_IsNull(env, component)) {
-        /*
-         * The window must be the embedding toplevel, since otherwise we would reject the
-         * TOP_LEVEL_ENTER and never get to this point.
-         */
-        DASSERT(is_embedding_toplevel(event->window));
-
-        receiver = get_embedded_window(event->display, event->window, x, y);
-
-        if (receiver != None) {
-            component = get_component_for_window(receiver);
-        }
-    } else {
-        receiver = event->window;
-    }
-
-    /* Translate mouse position from root coordinates
-       to the target window coordinates. */
-    if (receiver != None) {
-        Window child = None;
-        XTranslateCoordinates(event->display,
-                              get_root_for_window(receiver),
-                              get_outer_canvas_for_window(receiver),
-                              x, y, &x, &y, &child);
-    }
-
-    if (JNU_IsNull(env, component)) {
-        if (!JNU_IsNull(env, target_component)) {
-            /* Triggers dragExit */
-            dt_postDropTargetEvent(env, target_component, x, y,
-                                   java_awt_dnd_DnDConstants_ACTION_NONE,
-                                   java_awt_event_MouseEvent_MOUSE_EXITED,
-                                   NULL);
-        }
-    } else {
-        dt_postDropTargetEvent(env, component, x, y, java_action,
-                               java_awt_event_MouseEvent_MOUSE_RELEASED,
-                               event);
-    }
-
-    return EventSuccess;
-}
-
-static void
-send_enter_message_to_toplevel(Window toplevel, XClientMessageEvent* xclient) {
-    XClientMessageEvent enter;
-
-    if (source_protocol == XDND_PROTOCOL) {
-        enter.display = xclient->display;
-        enter.type = ClientMessage;
-        enter.window = toplevel;
-        enter.format = 32;
-        enter.message_type = XA_XdndEnter;
-        enter.data.l[0] = xclient->data.l[0]; /* XID of the source window */
-        enter.data.l[1] = source_protocol_version << XDND_PROTOCOL_SHIFT;
-        enter.data.l[1] |= source_data_types_count > 3 ? XDND_DATA_TYPES_BIT : 0;
-        enter.data.l[2] =
-            source_data_types_count > 0 ? source_data_types_native[0] : None;
-        enter.data.l[3] =
-            source_data_types_count > 1 ? source_data_types_native[1] : None;
-        enter.data.l[4] =
-            source_data_types_count > 2 ? source_data_types_native[2] : None;
-    } else if (source_protocol == MOTIF_DND_PROTOCOL) {
-        int reason = (int)(xclient->data.b[0] & MOTIF_MESSAGE_REASON_MASK);
-        unsigned char byte_order = xclient->data.b[1];
-
-        enter.display = xclient->display;
-        enter.type = ClientMessage;
-        enter.window = toplevel;
-        enter.format = 8;
-        enter.message_type = _XA_MOTIF_DRAG_AND_DROP_MESSAGE;
-
-        {
-            void* p = &enter.data.b[0];
-            int flags = 0;
-
-            flags |= java_to_motif_actions(user_action) << MOTIF_DND_ACTION_SHIFT;
-            flags |= java_to_motif_actions(source_actions) << MOTIF_DND_ACTIONS_SHIFT;
-
-            write_card8(&p, TOP_LEVEL_ENTER | MOTIF_MESSAGE_FROM_INITIATOR);
-            write_card8(&p, byte_order);
-            write_card16(&p, flags);
-            {
-                Time time_stamp = read_card32(xclient->data.b, 4, byte_order);
-                Window src_window = source_window;
-                Atom motif_atom = _XA_MOTIF_ATOM_0;
-
-                if (byte_order != MOTIF_BYTE_ORDER) {
-                    SWAP4BYTES(time_stamp);
-                    SWAP4BYTES(src_window);
-                    SWAP4BYTES(motif_atom);
-                }
-                write_card32(&p, time_stamp);
-                write_card32(&p, src_window);
-                write_card32(&p, motif_atom);
-            }
-        }
-    } else {
-        return;
-    }
-
-    forward_client_message_to_toplevel(toplevel, &enter);
-}
-
-static void
-send_leave_message_to_toplevel(Window toplevel, XClientMessageEvent* xclient) {
-    XClientMessageEvent leave;
-
-    if (source_protocol == XDND_PROTOCOL) {
-        leave.display = xclient->display;
-        leave.type = ClientMessage;
-        leave.window = toplevel;
-        leave.format = 32;
-        leave.message_type = XA_XdndLeave;
-        leave.data.l[0] = xclient->data.l[0]; /* XID of the source window */
-        leave.data.l[1] = 0; /* flags */
-    } else if (source_protocol == MOTIF_DND_PROTOCOL) {
-        int reason = (int)(xclient->data.b[0] & MOTIF_MESSAGE_REASON_MASK);
-        unsigned char byte_order = xclient->data.b[1];
-
-        leave.display = xclient->display;
-        leave.type = ClientMessage;
-        leave.window = toplevel;
-        leave.format = 8;
-        leave.message_type = _XA_MOTIF_DRAG_AND_DROP_MESSAGE;
-
-        {
-            void* p = &leave.data.b[0];
-            int flags = 0;
-
-            write_card8(&p, TOP_LEVEL_LEAVE | MOTIF_MESSAGE_FROM_INITIATOR);
-            write_card8(&p, byte_order);
-
-            {
-                Time time_stamp = read_card32(xclient->data.b, 4, byte_order);
-                Window src_window = source_window;
-
-                if (byte_order != MOTIF_BYTE_ORDER) {
-                    SWAP4BYTES(time_stamp);
-                    SWAP4BYTES(src_window);
-                }
-                write_card32(&p, time_stamp);
-                write_card32(&p, src_window);
-            }
-        }
-    } else {
-        return;
-    }
-
-    forward_client_message_to_toplevel(toplevel, &leave);
-}
-
-static void
-post_process_client_message(XClientMessageEvent* xclient, EventStatus status,
-                            EventType type) {
-    Window win = xclient->window;
-    Boolean postponed_leave = motif_top_level_leave_postponed;
-
-    motif_top_level_leave_postponed = False;
-
-    if (is_embedding_toplevel(win)) {
-        Boolean server_grabbed = False;
-
-        if (postponed_leave) {
-            XClientMessageEvent* leave = &motif_top_level_leave_postponed_event;
-            DASSERT(leave->type == ClientMessage && type == DropEvent);
-            /* Grab the server to ensure that no event is sent between
-               the TOP_LEVEL_LEAVE and the next message. */
-            XGrabServer(awt_display);
-            forward_client_message_to_toplevel(leave->window, leave);
-            memset(&motif_top_level_leave_postponed_event, 0,
-                   sizeof(XClientMessageEvent));
-        }
-
-        /*
-         * This code forwards drag notifications to the browser according to the
-         * following rules:
-         *  - the messages that we failed to process are always forwarded to the
-         *    browser;
-         *  - MotionEvents and DropEvents are forwarded if and only if the drag
-         *    is not over a plugin window;
-         *  - XDnD: EnterEvents and LeaveEvents are never forwarded, instead, we
-         *    send synthesized EnterEvents or LeaveEvents when the drag
-         *    respectively exits or enters plugin windows;
-         *  - Motif DnD: EnterEvents and LeaveEvents are always forwarded.
-         * Synthetic EnterEvents and LeaveEvents are needed, because the XDnD drop
-         * site implemented Netscape 6.2 has a nice feature: when it receives
-         * the first XdndPosition it continuously sends XdndStatus messages to
-         * the source (every 100ms) until the drag terminates or leaves the drop
-         * site. When the mouse is dragged over plugin window embedded in the
-         * browser frame, these XdndStatus messages are mixed with the XdndStatus
-         * messages sent from the plugin.
-         * For Motif DnD, synthetic events cause Motif warnings being displayed,
-         * so these events are always forwarded. However, Motif DnD drop site in
-         * Netscape 6.2 is implemented in the same way, so there could be similar
-         * problems if the drag source choose Motif DnD for communication.
-         */
-        switch (status) {
-        case EventFailure:
-            forward_client_message_to_toplevel(win, xclient);
-            break;
-        case EventSuccess:
-        {
-            /* True iff the previous notification was MotionEvent and it was
-               forwarded to the browser. */
-            static Boolean motion_passed_along = False;
-
-            Boolean motif_protocol =
-                xclient->message_type == _XA_MOTIF_DRAG_AND_DROP_MESSAGE;
-
-            switch (type) {
-            case MotionEvent:
-                if (JNU_IsNull(env, target_component)) {
-                    if (!motion_passed_along && !motif_protocol) {
-                        send_enter_message_to_toplevel(win, xclient);
-                    }
-                    forward_client_message_to_toplevel(win, xclient);
-                    motion_passed_along = True;
-                } else {
-                    if (motion_passed_along && !motif_protocol) {
-                        send_leave_message_to_toplevel(win, xclient);
-                    }
-                    motion_passed_along = False;
-                }
-                break;
-            case DropEvent:
-                if (JNU_IsNull(env, target_component)) {
-                    forward_client_message_to_toplevel(win, xclient);
-                    /* The last chance to cleanup. */
-                    awt_dnd_cleanup();
-                }
-                motion_passed_along = False;
-                break;
-            case EnterEvent:
-            case LeaveEvent:
-                if (motif_protocol) {
-                    forward_client_message_to_toplevel(win, xclient);
-                }
-                motion_passed_along = False;
-                break;
-            }
-        }
-        }
-
-        if (postponed_leave) {
-            XUngrabServer(awt_display);
-        }
-    }
-}
-
-/*
- * Returns True if the event is processed and shouldn't be passed along to Java.
- * Otherwise, return False.
- */
-Boolean
-awt_dnd_dt_process_event(XEvent* event) {
-    Display* dpy = event->xany.display;
-    EventStatus status = EventFailure;
-    EventType type = UnknownEvent;
-
-    if (event->type == DestroyNotify) {
-        if (event->xany.window == source_window) {
-            awt_dnd_cleanup();
-        }
-        /* pass along */
-        return False;
-    }
-
-    if (event->type == PropertyNotify) {
-        if (is_embedding_toplevel(event->xany.window)) {
-            Atom atom = event->xproperty.atom;
-            /*
-             * If some other client replaced the XDnD or Motif DnD proxy with
-             * another window we set the proxy back to the awt_root_window
-             * and update the entry in the embedded_drop_site_list.
-             * This code is needed, as for example Netscape 4.7 resets the proxy
-             * when the browser shell is resized.
-             */
-            if (atom == _XA_MOTIF_DRAG_RECEIVER_INFO) {
-                Window prev_motif_proxy;
-                ProxyRegistrationStatus status;
-                status = set_motif_proxy(event->xany.display, event->xany.window,
-                                         get_awt_root_window(), &prev_motif_proxy);
-                if (status != RegFailure && status != RegAlreadyRegistered) {
-                    set_motif_proxy_for_toplevel(event->xany.window,
-                                                 prev_motif_proxy,
-                                                 status == RegOverride);
-                }
-            }
-
-            if (atom == XA_XdndAware || atom == XA_XdndProxy) {
-                Window prev_xdnd_proxy;
-                unsigned int prev_protocol_version;
-                ProxyRegistrationStatus status;
-                status = set_xdnd_proxy(event->xany.display, event->xany.window,
-                                        get_awt_root_window(), &prev_xdnd_proxy,
-                                        &prev_protocol_version);
-                if (status != RegFailure && status != RegAlreadyRegistered) {
-                    set_xdnd_proxy_for_toplevel(event->xany.window,
-                                                prev_xdnd_proxy,
-                                                prev_protocol_version,
-                                                status == RegOverride);
-                }
-            }
-        }
-        /* pass along */
-        return False;
-    }
-
-    if (event->type != ClientMessage) {
-        return False;
-    }
-
-    if (get_component_for_window(event->xany.window) == NULL &&
-        !is_embedding_toplevel(event->xany.window)) {
-        return False;
-    }
-
-    if (motif_top_level_leave_postponed) {
-        /* Sanity check. */
-        if (source_protocol != MOTIF_DND_PROTOCOL) {
-            DTRACE_PRINTLN2("%s:%d TOP_LEVEL_LEAVE rejected - invalid state.",
-                            __FILE__, __LINE__);
-            awt_dnd_cleanup();
-        } else if (event->xclient.message_type ==
-                   _XA_MOTIF_DRAG_AND_DROP_MESSAGE) {
-            unsigned char first_byte = event->xclient.data.b[0];
-            unsigned char reason = first_byte & MOTIF_MESSAGE_REASON_MASK;
-            unsigned char origin = first_byte & MOTIF_MESSAGE_SENDER_MASK;
-
-            if (origin == MOTIF_MESSAGE_FROM_INITIATOR &&
-                reason != DROP_START) {
-                awt_dnd_cleanup();
-            }
-        } else {
-            awt_dnd_cleanup();
-        }
-    }
-
-    if (event->xclient.message_type == XA_XdndEnter) {
-        status = handle_xdnd_enter(&event->xclient);
-        type = EnterEvent;
-    } else if (event->xclient.message_type == XA_XdndPosition) {
-        status = handle_xdnd_position(&event->xclient);
-        type = MotionEvent;
-    } else if (event->xclient.message_type == XA_XdndLeave) {
-        status = handle_xdnd_leave(&event->xclient);
-        type = LeaveEvent;
-    } else if (event->xclient.message_type == XA_XdndDrop) {
-        status = handle_xdnd_drop(&event->xclient);
-        type = DropEvent;
-    } else if (event->xclient.message_type == _XA_MOTIF_DRAG_AND_DROP_MESSAGE) {
-        unsigned char reason = event->xclient.data.b[0] & MOTIF_MESSAGE_REASON_MASK;
-        unsigned char origin = event->xclient.data.b[0] & MOTIF_MESSAGE_SENDER_MASK;
-
-        /* Only initiator messages should be handled. */
-        if (origin == MOTIF_MESSAGE_FROM_INITIATOR) {
-            switch (reason) {
-            case DRAG_MOTION:
-            case OPERATION_CHANGED:
-                status = handle_motif_drag_motion(&event->xclient);
-                type = MotionEvent;
-                break;
-            case TOP_LEVEL_ENTER:
-                status = handle_motif_top_level_enter(&event->xclient);
-                type = EnterEvent;
-                break;
-            case TOP_LEVEL_LEAVE:
-                status = handle_motif_top_level_leave(&event->xclient);
-                type = LeaveEvent;
-                break;
-            case DROP_START:
-                status = handle_motif_drop_start(&event->xclient);
-                type = DropEvent;
-                break;
-            }
-        }
-    } else {
-        /* Unknown message type. */
-        return False;
-    }
-
-    /*
-     * We need to handle a special case here: Motif DnD protocol prescribed that
-     * DROP_START message should always be preceeded with TOP_LEVEL_LEAVE
-     * message. We need to cleanup on TOP_LEVEL_LEAVE message, but DROP_START
-     * wouldn't be processed properly. Instead we postpone the cleanup and
-     * send a dummy client message to ourselves. If dummy arrives first we do a
-     * normal cleanup. If DROP_START arrives before the dummy we discard delayed
-     * cleanup.
-     * In case of forwarding events from an embedded Java app to an embedding
-     * Java app it could happen that the embedding app receives the dummy before
-     * the DROP_START message arrives from the embedding app. In this case the
-     * drop operation on the embedding app fails to complete.
-     * To resolve this problem we postpone forwarding of TOP_LEVEL_LEAVE message
-     * until the next client message is about to be forwarded.
-     */
-    if (motif_top_level_leave_postponed && type == LeaveEvent) {
-        /* motif_top_level_leave_postponed can be set only if the latest client
-           message has been processed successfully. */
-        DASSERT(status == EventSuccess);
-        memcpy(&motif_top_level_leave_postponed_event, &event->xclient,
-               sizeof(XClientMessageEvent));
-    } else {
-        post_process_client_message(&event->xclient, status, type);
-    }
-
-    return True;
-}
-
-static Boolean
-register_xdnd_drop_site(Display* dpy, Window toplevel, Window window) {
-    unsigned char ret;
-    Atom version_atom = XDND_PROTOCOL_VERSION;
-
-    ret = checked_XChangeProperty(dpy, window, XA_XdndAware, XA_ATOM, 32,
-                                  PropModeReplace,
-                                  (unsigned char*)&version_atom, 1);
-
-    return (ret == Success);
-}
-
-static Boolean
-register_motif_drop_site(Display* dpy, Window toplevel, Window window) {
-    unsigned char status;
-    size_t data_size = MOTIF_RECEIVER_INFO_SIZE;
-    char* data = malloc(data_size);
-    void* p = data;
-
-    if (data == NULL) {
-        DTRACE_PRINTLN2("%s:%d malloc failed.", __FILE__, __LINE__);
-        return False;
-    }
-
-    write_card8(&p, MOTIF_BYTE_ORDER);
-    write_card8(&p, MOTIF_DND_PROTOCOL_VERSION); /* protocol version */
-    write_card8(&p, MOTIF_DYNAMIC_STYLE); /* protocol style */
-    write_card8(&p, 0); /* pad */
-    write_card32(&p, window); /* proxy window */
-    write_card16(&p, 0); /* num_drop_sites */
-    write_card16(&p, 0); /* pad */
-    write_card32(&p, data_size);
-
-    status = checked_XChangeProperty(dpy, window, _XA_MOTIF_DRAG_RECEIVER_INFO,
-                                     _XA_MOTIF_DRAG_RECEIVER_INFO, 8, PropModeReplace,
-                                     (unsigned char*)data, data_size);
-
-    free(data);
-
-    return (status == Success);
-}
-
-static Window
-find_toplevel_window(Display* dpy, Window window) {
-    Window         ret = None;
-    Window         root = None;
-    Window         parent = None;
-    Window         *children;
-    unsigned int   nchildren;
-
-    int            status;
-
-    Atom           type;
-    int            format;
-    unsigned long  nitems;
-    unsigned long  after;
-    unsigned char  *data;
-
-    /* Traverse the ancestor tree from window up to the root and find
-       the top-level client window nearest to the root. */
-    do {
-        type = None;
-
-        data = NULL;
-        status = XGetWindowProperty(dpy, window, XA_WM_STATE, 0, 0, False,
-                                    AnyPropertyType, &type, &format, &nitems,
-                                    &after, &data);
-
-        if (status == Success) {
-            XFree(data);
-        }
-
-        if (type != None) {
-            ret = window;
-        }
-
-        if (!XQueryTree(dpy, window, &root, &parent, &children, &nchildren)) {
-            return None;
-        }
-
-        XFree(children);
-
-        window = parent;
-    } while (window != root);
-
-    return ret;
-}
-
-static Boolean
-register_drop_site(Widget outer_canvas, XtPointer componentRef) {
-    Display* dpy = XtDisplay(outer_canvas);
-    Widget shell = NULL;
-    /* Shell window. */
-    Window window = None;
-    Window root = None;
-    Window toplevel = None;
-
-    for (shell = outer_canvas; shell != NULL && !XtIsShell(shell);
-         shell = XtParent(shell));
-
-    if (shell == NULL || !XtIsRealized(shell)) {
-        DTRACE_PRINTLN2("%s:%d Cannot find a realized shell for the widget.",
-                       __FILE__, __LINE__);
-        return False;
-    }
-
-    window = XtWindow(shell);
-
-    if (!awt_dnd_init(dpy)) {
-        DTRACE_PRINTLN2("%s:%d Fail to initialize.", __FILE__, __LINE__);
-        return False;
-    }
-
-    {
-        XWindowAttributes xwa;
-
-        if (!XGetWindowAttributes(dpy, window, &xwa)) {
-            DTRACE_PRINTLN2("%s:%d XGetWindowAttributes failed.", __FILE__, __LINE__);
-            return False;
-        }
-
-        root = xwa.root;
-
-        if (root == None) {
-            DTRACE_PRINTLN2("%s:%d Bad root.", __FILE__, __LINE__);
-            return False;
-        }
-    }
-
-    toplevel = find_toplevel_window(dpy, window);
-
-    /*
-     * No window with WM_STATE property is found.
-     * Since the window can be a plugin window reparented to the browser
-     * toplevel, we cannot determine which window will eventually have WM_STATE
-     * property set. So we schedule a timer callback that will periodically
-     * attempt to find an ancestor with WM_STATE and register the drop site
-     * appropriately.
-     */
-    if (toplevel == None) {
-        add_delayed_registration_entry(outer_canvas, componentRef);
-        return False;
-    }
-
-    if (toplevel == window) {
-        Boolean xdnd_registered = False;
-        Boolean motif_registered = False;
-
-        xdnd_registered = register_xdnd_drop_site(dpy, toplevel, window);
-
-        motif_registered = register_motif_drop_site(dpy, toplevel, window);
-
-        if (!xdnd_registered && !motif_registered) {
-            DTRACE_PRINTLN2("%s:%d Failed to register.", __FILE__, __LINE__);
-            return False;
-        }
-    } else {
-        if (!add_to_embedded_drop_site_list(dpy, root, toplevel, window)) {
-            DTRACE_PRINTLN2("%s:%d Failed to init proxy.", __FILE__, __LINE__);
-            return False;
-        }
-    }
-
-    /* There is no need to update the window for the component later, since the
-       window is destroyed only when the component is disposed in which case the
-       drop site will be unregistered as well. */
-    if (add_to_drop_site_list(window, root, toplevel, XtWindow(outer_canvas),
-                              (jobject)componentRef)) {
-        DTRACE_PRINTLN2("%s:%d Drop site registered.", __FILE__, __LINE__);
-        return True;
-    } else {
-        DTRACE_PRINTLN2("%s:%d Failed to register.", __FILE__, __LINE__);
-        return False;
-    }
-}
-
-static void
-register_drop_site_when_realized(Widget outer_canvas, XtPointer client_data,
-                                 XEvent *event, Boolean *dontSwallow) {
-    if (XtIsRealized(outer_canvas)) {
-        XtRemoveEventHandler(outer_canvas, StructureNotifyMask, False,
-                             register_drop_site_when_realized, client_data);
-
-        register_drop_site(outer_canvas, client_data);
-    }
-}
-
-/*
- * Registers the top-level Window that contains the specified widget as a drop
- * site that supports XDnD and Motif DnD protocols.
- * If the registration fails for some reason, adds an event handler that will
- * attempt to register the drop site later.
- *
- * Returns True if the drop site is registered successfully.
- */
-static Boolean
-awt_dnd_register_drop_site(Widget outer_canvas, XtPointer componentRef) {
-    if (XtIsRealized(outer_canvas)) {
-        return register_drop_site(outer_canvas, componentRef);
-    } else {
-        XtAddEventHandler(outer_canvas, StructureNotifyMask, False,
-                          register_drop_site_when_realized,
-                          componentRef);
-
-        DTRACE_PRINTLN2("%s:%d Unrealized shell. Register later.",
-                        __FILE__, __LINE__);
-
-        return True;
-    }
-}
-
-/*
- * Unregisters the drop site associated with the top-level Window that contains
- * the specified widget .
- *
- * Returns True if completes successfully, False otherwise.
- */
-static Boolean
-awt_dnd_unregister_drop_site(Widget outer_canvas, XtPointer componentRef) {
-    Widget shell = NULL;
-
-    XtRemoveEventHandler(outer_canvas, StructureNotifyMask, False,
-                         register_drop_site_when_realized, componentRef);
-
-    remove_delayed_registration_entry(outer_canvas);
-
-    for (shell = outer_canvas; shell != NULL && !XtIsShell(shell);
-         shell = XtParent(shell));
-
-    if (shell != NULL && XtIsShell(shell) && XtIsRealized(shell)) {
-        Window win = XtWindow(shell);
-        Window toplevel = get_toplevel_for_window(win);
-        /*
-         * Cleanup the global state if this drop site participate in the current
-         * drag operation. Particularly, this allows to delete global ref to the
-         * component safely.
-         */
-        if (get_component_for_window(win) == target_component) {
-            awt_dnd_cleanup();
-        }
-        if (toplevel != win) {
-            remove_from_embedded_drop_site_list(awt_display, toplevel, win);
-        }
-        return remove_from_drop_site_list(win);
-    }
-
-    return True;
-}
-
-/**************************** XEmbed server DnD support ***********************/
-
-/*
- *
- *
- */
-Boolean
-register_xembed_drop_site(JNIEnv* env, Display* dpy, jobject server,
-                          Window serverHandle, Window clientHandle) {
-    Atom           type;
-    int            format;
-    unsigned long  nitems;
-    unsigned long  after;
-    unsigned char* data;
-    unsigned char  ret;
-    unsigned int   protocol_version;
-
-    Window         xdnd_proxy = None;
-    unsigned int   xdnd_protocol_version = 0;
-    Boolean        xdnd_override = False;
-
-    if (!awt_dnd_init(dpy)) {
-        DTRACE_PRINTLN2("%s:%d Fail to initialize.", __FILE__, __LINE__);
-        return False;
-    }
-
-    /* Get the XDnD protocol version and XDnD proxy of the XEmbed client. */
-    data = NULL;
-    ret = checked_XGetWindowProperty(dpy, clientHandle, XA_XdndAware, 0, 1,
-                                     False, AnyPropertyType, &type, &format,
-                                     &nitems, &after, &data);
-
-    /* XEmbed client doesn't have an associated XDnD drop site -
-       do nothing and return True to indicate success. */
-    if (ret != Success || data == NULL || nitems == 0 || type != XA_ATOM) {
-        XFree(data);
-        return False;
-    }
-
-    protocol_version = *((unsigned int*)data);
-
-    XFree(data);
-
-    if (protocol_version < XDND_MIN_PROTOCOL_VERSION) {
-        return False;
-    }
-
-    xdnd_protocol_version = protocol_version;
-
-    /* XdndProxy is not supported prior to XDnD version 4 */
-    if (protocol_version >= 4) {
-        int status;
-
-        data = NULL;
-        status = XGetWindowProperty(dpy, clientHandle, XA_XdndProxy, 0, 1,
-                                    False, XA_WINDOW, &type, &format,
-                                    &nitems, &after, &data);
-
-        if (status == Success && data != NULL && type == XA_WINDOW) {
-            xdnd_proxy = *((Window*)data);
-
-            if (xdnd_proxy != None) {
-                XFree(data);
-
-                data = NULL;
-                status = XGetWindowProperty(dpy, xdnd_proxy, XA_XdndProxy,
-                                            0, 1, False, XA_WINDOW, &type,
-                                            &format, &nitems, &after,
-                                            &data);
-
-                if (status != Success || data == NULL || type != XA_WINDOW ||
-                    *((Window*)data) != xdnd_proxy) {
-                    /* Ignore invalid proxy. */
-                    xdnd_proxy = None;
-                }
-            }
-
-            if (xdnd_proxy != None) {
-                XFree(data);
-
-                data = NULL;
-                status = XGetWindowProperty(dpy, xdnd_proxy, XA_XdndAware, 0, 1,
-                                            False, AnyPropertyType, &type,
-                                            &format, &nitems, &after, &data);
-
-                if (status == Success && data != NULL && type == XA_ATOM) {
-                    unsigned int proxy_version = *((unsigned int*)data);
-
-                    if (proxy_version != protocol_version) {
-                        /* Ignore invalid proxy. */
-                        xdnd_proxy = None;
-                    }
-                } else {
-                    /* Ignore invalid proxy. */
-                    xdnd_proxy = None;
-                }
-            }
-        }
-
-        XFree(data);
-    }
-
-    set_xembed_drop_target(env, server);
-
-    /* Add protocol specific entries for the embedded window. */
-    /* Only XDnD protocol is supported for XEmbed clients. */
-    {
-        EmbeddedDropSiteProtocolListEntry* xdnd_entry = NULL;
-
-        xdnd_entry = malloc(sizeof(EmbeddedDropSiteProtocolListEntry));
-
-        if (xdnd_entry == NULL) {
-            return False;
-        }
-
-        xdnd_entry->window = clientHandle;
-        xdnd_entry->proxy = xdnd_proxy;
-        xdnd_entry->protocol_version = xdnd_protocol_version;
-        xdnd_entry->overriden = True;
-        xdnd_entry->next = embedded_xdnd_protocol_list;
-        embedded_xdnd_protocol_list = xdnd_entry;
-    }
-
-    {
-        EmbeddedDropSiteListEntry* entry = NULL;
-        Window* sites = NULL;
-
-        entry = malloc(sizeof(EmbeddedDropSiteListEntry));
-
-        if (entry == NULL) {
-            return False;
-        }
-
-        sites = malloc(sizeof(Window));
-
-        if (sites == NULL) {
-            free(entry);
-            return False;
-        }
-
-        sites[0] = clientHandle;
-
-        entry->toplevel = serverHandle;
-        entry->root = None;
-        entry->event_mask = 0;
-        entry->embedded_sites_count = 1;
-        entry->embedded_sites = sites;
-        entry->next = embedded_drop_site_list;
-        embedded_drop_site_list = entry;
-    }
-
-    return True;
-}
-
-Boolean
-unregister_xembed_drop_site(JNIEnv* env, Display* dpy, jobject server,
-                            Window serverHandle, Window clientHandle) {
-    remove_from_embedded_drop_site_list(dpy, serverHandle, clientHandle);
-    return True;
-}
-
-void
-forward_event_to_embedded(Window embedded, jlong ctxt, jint eventID) {
-    static XClientMessageEvent* prevMessage = NULL;
-    static Boolean overXEmbedClient = False;
-
-    XClientMessageEvent* xclient =
-        (XClientMessageEvent*)jlong_to_ptr(ctxt);
-
-    if (xclient == NULL && prevMessage == NULL) {
-        return;
-    }
-
-    if (xclient != NULL) {
-        /*
-         * NOTE: this check guarantees that prevMessage will always be an XDnD
-         * drag message.
-         */
-        if (!is_xdnd_drag_message_type(xclient->message_type)) {
-            return;
-        }
-
-        if (!overXEmbedClient) {
-            long* appended_data = jlong_to_ptr(ctxt) +
-                sizeof(XClientMessageEvent);
-
-            /* Copy XdndTypeList from source to proxy. */
-            if ((appended_data[0] & XDND_DATA_TYPES_BIT) != 0) {
-                unsigned char  ret;
-                Atom           type;
-                int            format;
-                unsigned long  nitems;
-                unsigned long  after;
-                unsigned char  *data;
-
-                data = NULL;
-                ret = checked_XGetWindowProperty(xclient->display,
-                                                 xclient->data.l[0],
-                                                 XA_XdndTypeList, 0, 0xFFFF,
-                                                 False, XA_ATOM, &type, &format,
-                                                 &nitems, &after, &data);
-
-                /* Ignore the source if the window is destroyed. */
-                if (ret == BadWindow) {
-                    return;
-                }
-
-                if (ret == Success) {
-                    if (type == XA_ATOM && format == 32) {
-                        ret = checked_XChangeProperty(xclient->display,
-                                                      xclient->window,
-                                                      XA_XdndTypeList, XA_ATOM,
-                                                      32, PropModeReplace, data,
-                                                      nitems);
-                    }
-
-                    XFree(data);
-                }
-            }
-
-            set_proxy_mode_source_window(xclient->data.l[0]);
-
-            {
-                XClientMessageEvent enter;
-                enter.display = xclient->display;
-                enter.type = ClientMessage;
-                enter.window = embedded;
-                enter.format = 32;
-                enter.message_type = XA_XdndEnter;
-
-                enter.data.l[0] = xclient->window; /* XID of the source window */
-                enter.data.l[1] = appended_data[0];
-                enter.data.l[2] = appended_data[1];
-                enter.data.l[3] = appended_data[2];
-                enter.data.l[4] = appended_data[3];
-
-                forward_client_message_to_toplevel(embedded, &enter);
-            }
-
-            overXEmbedClient = True;
-        }
-
-        /* Make a copy of the original event, since we are going to modify the
-           event while it still can be referenced from other Java events. */
-        {
-            XClientMessageEvent copy;
-            memcpy(&copy, xclient, sizeof(XClientMessageEvent));
-            copy.data.l[0] = xclient->window;
-
-            forward_client_message_to_toplevel(embedded, &copy);
-        }
-    }
-
-    if (eventID == java_awt_event_MouseEvent_MOUSE_EXITED) {
-        if (overXEmbedClient) {
-            if (xclient != NULL || prevMessage != NULL) {
-                /* Last chance to send XdndLeave to the XEmbed client. */
-                XClientMessageEvent leave;
-
-                leave.display = xclient != NULL ?
-                    xclient->display : prevMessage->display;
-                leave.type = ClientMessage;
-                leave.window = embedded;
-                leave.format = 32;
-                leave.message_type = XA_XdndLeave;
-                leave.data.l[0] = xclient != NULL ?
-                    xclient->window : prevMessage->window; /* XID of the source window */
-                leave.data.l[1] = 0; /* flags */
-
-                forward_client_message_to_toplevel(embedded, &leave);
-            }
-            overXEmbedClient = False;
-        }
-    }
-
-    if (eventID == java_awt_event_MouseEvent_MOUSE_RELEASED) {
-        overXEmbedClient = False;
-        awt_dnd_cleanup();
-    }
-
-    if (prevMessage != 0) {
-        free(prevMessage);
-        prevMessage = 0;
-    }
-
-    if (xclient != 0 && overXEmbedClient) {
-        prevMessage = malloc(sizeof(XClientMessageEvent));
-
-        memcpy(prevMessage, xclient, sizeof(XClientMessageEvent));
-    }
-}
-
-/******************************************************************************/
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    registerX11DropTarget
- * Signature: (Ljava/awt/Component;)V
- */
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowPeer_registerX11DropTarget(JNIEnv *env, jobject this,
-                                                     jobject target) {
-    struct FrameData* wdata = NULL;
-    DropSitePtr dsi = NULL;
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL || wdata->winData.comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NULL component data");
-        return;
-    }
-
-    if (wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "Null shell widget");
-        return;
-    }
-
-    DASSERT(wdata->winData.comp.dsi == NULL);
-
-    dsi = (DropSitePtr)calloc(1, sizeof(struct DropSiteInfo));
-
-    if (dsi == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "");
-        return;
-    }
-
-    dsi->component = (*env)->NewGlobalRef(env, target);
-    dsi->isComposite = False;
-
-    wdata->winData.comp.dsi = dsi;
-
-    AWT_LOCK();
-
-    awt_dnd_register_drop_site(wdata->winData.comp.widget,
-                               dsi->component);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    unregisterX11DropTarget
- * Signature: (Ljava/awt/Component;)V
- */
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowPeer_unregisterX11DropTarget(JNIEnv *env,
-                                                       jobject this,
-                                                       jobject target) {
-    struct FrameData* wdata = NULL;
-    DropSitePtr dsi = NULL;
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "Null component data");
-        return;
-    }
-
-    if (wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "Null shell widget");
-        return;
-    }
-
-    dsi = wdata->winData.comp.dsi;
-
-    if (dsi == NULL) {
-        JNU_ThrowNullPointerException(env, "Null DropSiteInfo");
-        return;
-    }
-
-    AWT_LOCK();
-
-    awt_dnd_unregister_drop_site(wdata->winData.comp.widget, dsi->component);
-
-    AWT_UNLOCK();
-
-    wdata->winData.comp.dsi = NULL;
-
-    (*env)->DeleteGlobalRef(env, dsi->component);
-
-    free(dsi);
-}
-
-static void
-dt_send_event_to_source(XClientMessageEvent* xclient) {
-    /* Shortcut if the source is in the same JVM. */
-    if (xclient->window == awt_dnd_ds_get_source_window()) {
-        awt_dnd_ds_process_event((XEvent*)xclient);
-    } else {
-        unsigned char ret;
-
-        ret = checked_XSendEvent(xclient->display, xclient->window, False,
-                                 NoEventMask, (XEvent*)xclient);
-
-        if (ret == BadWindow) {
-            DTRACE_PRINTLN2("%s:%d XSendEvent - invalid window.",
-                            __FILE__, __LINE__);
-
-            /* Cleanup if we are still communicating with this window. */
-            if (source_window == xclient->window) {
-                awt_dnd_cleanup();
-            }
-        }
-    }
-}
-
-static void
-dt_send_response(XClientMessageEvent* xclient, jint eventID, jint action) {
-    Display* dpy = xclient->display;
-    XClientMessageEvent response;
-
-    if (xclient->message_type == XA_XdndPosition) {
-        long* event_data = xclient->data.l;
-
-        if (eventID == java_awt_event_MouseEvent_MOUSE_EXITED) {
-            action = java_awt_dnd_DnDConstants_ACTION_NONE;
-        }
-
-        response.display = dpy;
-        response.type = ClientMessage;
-        response.window = event_data[0];
-        response.format = 32;
-        response.message_type = XA_XdndStatus;
-        /* target window */
-        response.data.l[0] = xclient->window;
-        /* flags */
-        response.data.l[1] = 0;
-        if (action != java_awt_dnd_DnDConstants_ACTION_NONE) {
-            response.data.l[1] |= XDND_ACCEPT_DROP_FLAG;
-        }
-        /* specify an empty rectangle */
-        response.data.l[2] = 0; /* x, y */
-        response.data.l[3] = 0; /* w, h */
-        /* action accepted by the target */
-        response.data.l[4] = java_to_xdnd_action(action);
-    } else if (xclient->message_type == _XA_MOTIF_DRAG_AND_DROP_MESSAGE) {
-        int reason = (int)(xclient->data.b[0] & MOTIF_MESSAGE_REASON_MASK);
-        int origin = (int)(xclient->data.b[0] & MOTIF_MESSAGE_SENDER_MASK);
-        unsigned char byte_order = xclient->data.b[1];
-        CARD16 response_flags = 0;
-        CARD8 response_reason = 0;
-        void* p = &response.data.b;
-
-        /* Only initiator messages should be handled. */
-        if (origin != MOTIF_MESSAGE_FROM_INITIATOR) {
-            DTRACE_PRINTLN2("%s:%d Receiver message.", __FILE__, __LINE__);
-            return;
-        }
-
-        switch (reason) {
-        case DRAG_MOTION:
-            switch (eventID) {
-            case java_awt_event_MouseEvent_MOUSE_ENTERED:
-                response_reason = DROP_SITE_ENTER;
-                break;
-            case java_awt_event_MouseEvent_MOUSE_DRAGGED:
-                response_reason = DRAG_MOTION;
-                break;
-            case java_awt_event_MouseEvent_MOUSE_EXITED:
-                response_reason = DROP_SITE_LEAVE;
-                break;
-            }
-        }
-
-        response.display = dpy;
-        response.type = ClientMessage;
-        response.window = read_card32(xclient->data.b, 12, byte_order);
-        response.format = 8;
-        response.message_type = _XA_MOTIF_DRAG_AND_DROP_MESSAGE;
-
-        write_card8(&p, response_reason | MOTIF_MESSAGE_FROM_RECEIVER);
-        write_card8(&p, MOTIF_BYTE_ORDER);
-
-        if (response_reason != DROP_SITE_LEAVE) {
-            CARD16 flags = read_card16(xclient->data.b, 2, byte_order);
-            unsigned char drop_site_status =
-                (action == java_awt_dnd_DnDConstants_ACTION_NONE) ?
-                MOTIF_INVALID_DROP_SITE : MOTIF_VALID_DROP_SITE;
-
-            /* Clear action and drop site status bits. */
-            response_flags =
-                flags & ~MOTIF_DND_ACTION_MASK & ~MOTIF_DND_STATUS_MASK;
-
-            /* Fill in new action and drop site status. */
-            response_flags |=
-                java_to_motif_actions(action) << MOTIF_DND_ACTION_SHIFT;
-            response_flags |=
-                drop_site_status << MOTIF_DND_STATUS_SHIFT;
-        } else {
-            response_flags = 0;
-        }
-
-        write_card16(&p, response_flags);
-
-        /* Write time stamp. */
-        write_card32(&p, read_card32(xclient->data.b, 4, byte_order));
-
-        /* Write coordinates. */
-        if (response_reason != DROP_SITE_LEAVE) {
-            write_card16(&p, read_card16(xclient->data.b, 8, byte_order));
-            write_card16(&p, read_card16(xclient->data.b, 10, byte_order));
-        } else {
-            write_card16(&p, 0);
-            write_card16(&p, 0);
-        }
-    } else {
-        return;
-    }
-
-    dt_send_event_to_source(&response);
-}
-
-static void
-dummy_selection_callback(Widget w, XtPointer client_data, Atom* selection,
-                         Atom* type, XtPointer value, unsigned long *length,
-                         int32_t *format) {
-    /* The selection callback is responsible for freeing the data. */
-    if (value != NULL) {
-        XtFree(value);
-        value = NULL;
-    }
-}
-
-static void
-dt_notify_drop_done(JNIEnv* env, XClientMessageEvent* xclient, jboolean success,
-                    jint action) {
-    if (xclient->message_type == XA_XdndDrop) {
-        Display* dpy = xclient->display;
-        XClientMessageEvent finished;
-        long* event_data = xclient->data.l;
-
-        /*
-         * The XDnD protocol recommends that the target requests the special
-         * target DELETE in case if the drop action is XdndActionMove.
-         */
-        if (action == java_awt_dnd_DnDConstants_ACTION_MOVE &&
-            success == JNI_TRUE) {
-
-            Time time_stamp = event_data[2];
-
-            XtGetSelectionValue(awt_root_shell, XA_XdndSelection, XA_DELETE,
-                                dummy_selection_callback, NULL, time_stamp);
-        }
-
-        finished.display = dpy;
-        finished.type = ClientMessage;
-        finished.window = event_data[0];
-        finished.format = 32;
-        finished.message_type = XA_XdndFinished;
-        finished.data.l[0] = xclient->window;
-        finished.data.l[1] = 0; /* flags */
-        finished.data.l[2] = None;
-        if (source_protocol_version >= 5) {
-            if (success == JNI_TRUE) {
-                finished.data.l[1] |= XDND_ACCEPT_DROP_FLAG;
-            }
-            finished.data.l[2] = java_to_xdnd_action(action);
-        }
-
-        dt_send_event_to_source(&finished);
-    } else if (xclient->message_type == _XA_MOTIF_DRAG_AND_DROP_MESSAGE) {
-        char* event_data = xclient->data.b;
-        unsigned char event_byte_order = read_card8(event_data, 1);
-        unsigned char first_byte = read_card8(event_data, 0);
-        unsigned char reason = first_byte & MOTIF_MESSAGE_REASON_MASK;
-        unsigned char origin = first_byte & MOTIF_MESSAGE_SENDER_MASK;
-        Atom selection = None;
-        Time time_stamp = CurrentTime;
-        Atom status_atom = None;
-
-        if (origin != MOTIF_MESSAGE_FROM_INITIATOR) {
-            DTRACE_PRINTLN2("%s:%d Invalid origin.", __FILE__, __LINE__);
-            return;
-        }
-
-        if (reason != DROP_START) {
-            DTRACE_PRINTLN2("%s:%d Invalid reason.", __FILE__, __LINE__);
-            return;
-        }
-
-        selection = read_card32(event_data, 12, event_byte_order);
-        time_stamp = read_card32(event_data, 4, event_byte_order);
-
-        if (success == JNI_TRUE) {
-            status_atom = XA_XmTRANSFER_SUCCESS;
-        } else {
-            status_atom = XA_XmTRANSFER_FAILURE;
-        }
-
-        /*
-         * This is just the way to communicate the drop completion status back
-         * to the initiator as prescribed by the Motif DnD protocol.
-         */
-        XtGetSelectionValue(awt_root_shell, selection, status_atom,
-                            dummy_selection_callback, NULL, time_stamp);
-    }
-
-    /*
-     * Flush the buffer to guarantee that the drop completion event is sent
-     * to the source before the method returns.
-     */
-    XFlush(awt_display);
-
-    /* Trick to prevent awt_dnd_cleanup() from posting dragExit */
-    target_component = NULL;
-    /* Cannot do cleanup before the drop finishes as we need source protocol
-       version to send XdndFinished message. */
-    awt_dnd_cleanup();
-}
-
-/*
- * Class:     sun_awt_motif_X11DropTargetContextPeer
- * Method:    sendResponse
- * Signature: (IIJZ)V
- */
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_X11DropTargetContextPeer_sendResponse(JNIEnv *env,
-                                                         jobject this,
-                                                         jint eventID,
-                                                         jint action,
-                                                         jlong nativeCtxt,
-                                                         jboolean dispatcherDone,
-                                                         jboolean consumed) {
-    XClientMessageEvent* xclient =
-        (XClientMessageEvent*)jlong_to_ptr(nativeCtxt);
-
-    AWT_LOCK();
-
-    if (consumed == JNI_FALSE) {
-        dt_send_response(xclient, eventID, action);
-    }
-
-    /*
-     * Free the native context only if all copies of the original event are
-     * processed.
-     */
-    if (dispatcherDone == JNI_TRUE) {
-        XtFree((char*)xclient);
-    }
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_X11DropTargetContextPeer
- * Method:    dropDone
- * Signature: (JZI)V
- */
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_X11DropTargetContextPeer_dropDone(JNIEnv *env,
-                                                     jobject this,
-                                                     jlong nativeCtxt,
-                                                     jboolean success,
-                                                     jint action) {
-    XClientMessageEvent* xclient =
-        (XClientMessageEvent*)jlong_to_ptr(nativeCtxt);
-
-    AWT_LOCK();
-
-    dt_notify_drop_done(env, xclient, success, action);
-
-    XtFree((char*)xclient);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_X11DropTargetContextPeer
- * Method:    getData
- * Signature: (IJ)Ljava/lang/Object;
- */
-
-JNIEXPORT jobject JNICALL
-Java_sun_awt_motif_X11DropTargetContextPeer_getData(JNIEnv *env,
-                                                    jobject this,
-                                                    jlong nativeCtxt,
-                                                    jlong formatAtom) {
-    XClientMessageEvent* xclient =
-        (XClientMessageEvent*)jlong_to_ptr(nativeCtxt);
-
-    Atom selection    = None;
-    Time time_stamp   = CurrentTime;
-    Atom target       = (Atom)formatAtom;
-
-    if (xclient->message_type == XA_XdndDrop ||
-        xclient->message_type == XA_XdndPosition) {
-        Display* dpy = xclient->display;
-        Window source_win = xclient->data.l[0];
-        Atom protocol_version = 0;
-
-        int            status;
-
-        Atom           type;
-        int            format;
-        unsigned long  nitems;
-        unsigned long  after;
-        unsigned char  *data;
-
-        AWT_LOCK();
-
-        data = NULL;
-        status = XGetWindowProperty(dpy, source_win, XA_XdndAware, 0, 0xFFFF,
-                                    False, XA_ATOM, &type, &format, &nitems,
-                                    &after, &data);
-
-        if (status == Success && data != NULL && type == XA_ATOM && format == 32
-            && nitems > 0) {
-            protocol_version = (protocol_version > XDND_PROTOCOL_VERSION) ?
-                XDND_PROTOCOL_VERSION : protocol_version;
-
-            if (protocol_version > 0) {
-                if (xclient->message_type == XA_XdndDrop) {
-                    time_stamp = xclient->data.l[2];
-                } else if (xclient->message_type == XA_XdndPosition) {
-                    time_stamp = xclient->data.l[3];
-                }
-            }
-        }
-
-        if (status == Success) {
-            XFree(data);
-            data = NULL;
-        }
-
-        AWT_FLUSH_UNLOCK();
-
-        selection = XA_XdndSelection;
-        if (time_stamp == CurrentTime) {
-            time_stamp = awt_util_getCurrentServerTime();
-        }
-
-    } else if (xclient->message_type == _XA_MOTIF_DRAG_AND_DROP_MESSAGE) {
-        char* event_data = xclient->data.b;
-        unsigned char event_byte_order = read_card8(event_data, 1);
-        unsigned char first_byte = read_card8(event_data, 0);
-        unsigned char reason = first_byte & MOTIF_MESSAGE_REASON_MASK;
-        unsigned char origin = first_byte & MOTIF_MESSAGE_SENDER_MASK;
-
-        if (origin != MOTIF_MESSAGE_FROM_INITIATOR) {
-            DTRACE_PRINTLN2("%s:%d Invalid origin.", __FILE__, __LINE__);
-            return NULL;
-        }
-
-        switch (reason) {
-        case DROP_START:
-            selection = read_card32(event_data, 12, event_byte_order);
-            break;
-        case DRAG_MOTION:
-        case OPERATION_CHANGED:
-            selection = source_atom;
-            break;
-        default:
-            DTRACE_PRINTLN2("%s:%d Invalid reason.", __FILE__, __LINE__);
-            return NULL;
-        }
-
-        if (selection == None) {
-            return NULL;
-        }
-
-        time_stamp = read_card32(event_data, 4, event_byte_order);
-    } else {
-        return NULL;
-    }
-
-    return get_selection_data(env, selection, target, time_stamp);
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_dnd.h openjdk/jdk/src/solaris/native/sun/awt/awt_dnd.h
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_dnd.h	2014-04-08 05:27:03.454875147 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_dnd.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,242 +0,0 @@
-/*
- * Copyright (c) 2003, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include <X11/Intrinsic.h>
-
-#include "awt_p.h"
-
-/* For definition of MComponentPeerIDs */
-#include "awt_Component.h"
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-
-/* DnD protocols */
-
-typedef enum {
-    NO_PROTOCOL,
-    XDND_PROTOCOL,
-    MOTIF_DND_PROTOCOL
-} Protocol;
-
-/* XDnD constants */
-
-#define XDND_PROTOCOL_VERSION          5
-/* XDnD compliance only requires supporting version 3 and up. */
-#define XDND_MIN_PROTOCOL_VERSION      3
-
-#define XDND_PROTOCOL_MASK    0xFF000000
-#define XDND_PROTOCOL_SHIFT           24
-#define XDND_DATA_TYPES_BIT          0x1
-#define XDND_ACCEPT_DROP_FLAG        0x1
-
-/* Motif DnD constants */
-
-#define MOTIF_DND_PROTOCOL_VERSION 0
-
-/* Suuported protocol styles */
-#define MOTIF_PREFER_PREREGISTER_STYLE    2
-#define MOTIF_PREFER_DYNAMIC_STYLE        4
-#define MOTIF_DYNAMIC_STYLE               5
-#define MOTIF_PREFER_RECEIVER_STYLE       6
-
-#define MOTIF_MESSAGE_REASON_MASK      0x7F
-#define MOTIF_MESSAGE_SENDER_MASK      0x80
-#define MOTIF_MESSAGE_FROM_RECEIVER    0x80
-#define MOTIF_MESSAGE_FROM_INITIATOR      0
-
-/* Info structure sizes */
-#define MOTIF_INITIATOR_INFO_SIZE         8
-#define MOTIF_RECEIVER_INFO_SIZE         16
-
-/* Message flags masks and shifts */
-#define MOTIF_DND_ACTION_MASK        0x000F
-#define MOTIF_DND_ACTION_SHIFT            0
-#define MOTIF_DND_STATUS_MASK        0x00F0
-#define MOTIF_DND_STATUS_SHIFT            4
-#define MOTIF_DND_ACTIONS_MASK       0x0F00
-#define MOTIF_DND_ACTIONS_SHIFT           8
-
-/* message type constants */
-#define TOP_LEVEL_ENTER    0
-#define TOP_LEVEL_LEAVE    1
-#define DRAG_MOTION        2
-#define DROP_SITE_ENTER    3
-#define DROP_SITE_LEAVE    4
-#define DROP_START         5
-#define DROP_FINISH        6
-#define DRAG_DROP_FINISH   7
-#define OPERATION_CHANGED  8
-
-/* drop action constants */
-#define MOTIF_DND_NOOP  0L
-#define MOTIF_DND_MOVE  (1L << 0)
-#define MOTIF_DND_COPY  (1L << 1)
-#define MOTIF_DND_LINK  (1L << 2)
-
-/* drop site status constants */
-#define MOTIF_NO_DROP_SITE      1
-#define MOTIF_INVALID_DROP_SITE 2
-#define MOTIF_VALID_DROP_SITE   3
-
-/* Shared atoms */
-
-extern Atom XA_WM_STATE;
-extern Atom XA_DELETE;
-
-/* XDnD atoms */
-
-extern Atom XA_XdndAware;
-extern Atom XA_XdndProxy;
-
-extern Atom XA_XdndEnter;
-extern Atom XA_XdndPosition;
-extern Atom XA_XdndLeave;
-extern Atom XA_XdndDrop;
-extern Atom XA_XdndStatus;
-extern Atom XA_XdndFinished;
-
-extern Atom XA_XdndTypeList;
-extern Atom XA_XdndSelection;
-
-extern Atom XA_XdndActionCopy;
-extern Atom XA_XdndActionMove;
-extern Atom XA_XdndActionLink;
-extern Atom XA_XdndActionAsk;
-extern Atom XA_XdndActionPrivate;
-extern Atom XA_XdndActionList;
-
-/* Motif DnD atoms */
-
-extern Atom _XA_MOTIF_DRAG_WINDOW;
-extern Atom _XA_MOTIF_DRAG_TARGETS;
-extern Atom _XA_MOTIF_DRAG_INITIATOR_INFO;
-extern Atom _XA_MOTIF_DRAG_RECEIVER_INFO;
-extern Atom _XA_MOTIF_DRAG_AND_DROP_MESSAGE;
-extern Atom XA_XmTRANSFER_SUCCESS;
-extern Atom XA_XmTRANSFER_FAILURE;
-extern Atom _XA_MOTIF_ATOM_0;
-
-extern unsigned char MOTIF_BYTE_ORDER;
-
-/* Motif DnD macros */
-
-#define SWAP4BYTES(l) {\
-        struct {\
-          unsigned t :32;\
-        } bit32;\
-        char n, *tp = (char *) &bit32;\
-        bit32.t = l;\
-        n = tp[0]; tp[0] = tp[3]; tp[3] = n;\
-        n = tp[1]; tp[1] = tp[2]; tp[2] = n;\
-        l = bit32.t;\
-}
-
-#define SWAP2BYTES(s) {\
-        struct {\
-          unsigned t :16;\
-        } bit16;\
-        char n, *tp = (char *) &bit16;\
-        bit16.t = s;\
-        n = tp[0]; tp[0] = tp[1]; tp[1] = n;\
-        s = bit16.t;\
-}
-
-typedef struct DropSiteInfo {
-        Widget                  tlw;
-        jobject                 component;
-        Boolean                 isComposite;
-        uint32_t                dsCnt;
-} DropSiteInfo;
-
-Boolean awt_dnd_init(Display* display);
-Boolean awt_dnd_ds_init(Display* display);
-
-Window get_awt_root_window();
-
-/**************** checked_X* wrappers *****************************************/
-unsigned char
-checked_XChangeProperty(Display* display, Window w, Atom property, Atom type,
-                        int format, int mode, unsigned char* data,
-                        int nelements);
-
-unsigned char
-checked_XGetWindowProperty(Display* display, Window w, Atom property,
-                           long long_offset, long long_length, Bool delete,
-                           Atom req_type, Atom* actual_type_return,
-                           int* actual_format_return,
-                           unsigned long* nitems_return,
-                           unsigned long* bytes_after_return,
-                           unsigned char** prop_return);
-
-unsigned char
-checked_XSendEvent(Display* display, Window w, Bool propagate, long event_mask,
-                   XEvent* event_send);
-
-unsigned char
-checked_XTranslateCoordinates(Display* display, Window src_w, Window dest_w,
-                              int src_x, int src_y, int* dest_x_return,
-                              int* dest_y_return, Window* child_return);
-
-unsigned char
-checked_XSelectInput(Display* display, Window w, long event_mask);
-/******************************************************************************/
-
-jint xdnd_to_java_action(Atom action);
-Atom java_to_xdnd_action(jint action);
-
-jint motif_to_java_actions(unsigned char action);
-unsigned char java_to_motif_actions(jint action);
-
-void write_card8(void** p, CARD8 value);
-void write_card16(void** p, CARD16 value);
-void write_card32(void** p, CARD32 value);
-
-CARD8 read_card8(char* data, size_t offset);
-CARD16 read_card16(char* data, size_t offset, char byte_order);
-CARD32 read_card32(char* data, size_t offset, char byte_order);
-
-Window get_motif_window(Display* dpy);
-
-/*************************** TARGET LIST SUPPORT ***************************************/
-
-int get_index_for_target_list(Display* dpy, Atom* targets, unsigned int num_targets);
-void get_target_list_for_index(Display* dpy, int index, Atom** targets, unsigned
-                               int* num_targets);
-
-/***************************************************************************************/
-
-Boolean awt_dnd_process_event(XEvent* event);
-Boolean awt_dnd_ds_process_event(XEvent* event);
-Boolean awt_dnd_dt_process_event(XEvent* event);
-
-Window awt_dnd_ds_get_source_window();
-
-/**************************** XEmbed server DnD support ***********************/
-void set_proxy_mode_source_window(Window window);
-/******************************************************************************/
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_DrawingSurface.c openjdk/jdk/src/solaris/native/sun/awt/awt_DrawingSurface.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_DrawingSurface.c	2014-04-08 05:27:03.434874852 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_DrawingSurface.c	2014-04-10 02:56:51.366479247 +0100
@@ -29,7 +29,7 @@
 
 #include "awt_p.h"
 #include "java_awt_Component.h"
-#include "sun_awt_motif_MComponentPeer.h"
+//#include "sun_awt_motif_MComponentPeer.h"
 
 #include "awt_Component.h"
 
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_FileDialog.c openjdk/jdk/src/solaris/native/sun/awt/awt_FileDialog.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_FileDialog.c	2014-04-08 05:27:03.434874852 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_FileDialog.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,925 +0,0 @@
-/*
- * Copyright (c) 1995, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include <Xm/AtomMgr.h>
-#include <Xm/Protocols.h>
-#include <sys/param.h>
-#include <string.h>
-#include <stdlib.h>
-#include "awt_p.h"
-#include "java_awt_FileDialog.h"
-#include "java_awt_event_MouseWheelEvent.h"
-#include "sun_awt_motif_MFileDialogPeer.h"
-#include "sun_awt_motif_MComponentPeer.h"
-#include "multi_font.h"
-
-#include "awt_Component.h"
-
-#include <jni.h>
-#include <jni_util.h>
-#include <Xm/FileSB.h>
-
-#define MAX_DIR_PATH_LEN    1024
-
-extern void Text_handlePaste(Widget w, XtPointer client_data, XEvent * event,
-                             Boolean * cont);
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-
-extern AwtGraphicsConfigDataPtr
-    copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-
-/* fieldIDs for FileDialog fields and methods that may be accessed from C */
-static struct FileDialogIDs {
-    jfieldID mode;
-    jfieldID file;
-} fileDialogIDs;
-
-/* the field to store the default search procedure */
-static XmSearchProc DefaultSearchProc = NULL;
-
-/* mouse wheel handler for scrolling */
-void File_handleWheel(Widget w, XtPointer client_data, XEvent* event, Boolean* cont);
-
-/*
- * Class:     java_awt_FileDialog
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for FileDialog.java
-   to initialize the fieldIDs for fields that may be accessed from C */
-
-JNIEXPORT void JNICALL
-Java_java_awt_FileDialog_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    fileDialogIDs.mode = (*env)->GetFieldID(env, cls, "mode", "I");
-    fileDialogIDs.file =
-      (*env)->GetFieldID(env, cls, "file", "Ljava/lang/String;");
-
-    DASSERT(fileDialogIDs.mode != NULL);
-    DASSERT(fileDialogIDs.file != NULL);
-}
-
-/*
- * client_data is MFileDialogPeer instance pointer
- */
-static void
-FileDialog_OK(Widget w,
-              void *client_data,
-              XmFileSelectionBoxCallbackStruct * call_data)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject this = (jobject) client_data;
-    struct FrameData *fdata;
-    char *file;
-    jstring jstr;
-    XmStringContext   stringContext;
-    XmStringDirection direction;
-    XmStringCharSet   charset;
-    Boolean           separator;
-
-    fdata = (struct FrameData *)JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if ((*env)->EnsureLocalCapacity(env, 1) < 0)
-        return;
-
-    if (!XmStringInitContext(&stringContext, call_data->value))
-        return;
-
-    if (!XmStringGetNextSegment(stringContext, &file, &charset,
-                                &direction, &separator))
-        file = NULL;
-
-    if (file == NULL)
-        jstr = NULL;
-    else
-        jstr = JNU_NewStringPlatform(env, (const char *) file);
-
-    if (jstr != 0) {
-        JNU_CallMethodByName(env, NULL, this, "handleSelected",
-                             "(Ljava/lang/String;)V", jstr);
-        (*env)->DeleteLocalRef(env, jstr);
-    }
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-
-    XmStringFreeContext(stringContext);
-    if (file != NULL)
-        XtFree(file);
-}
-
-/*
- * client_data is MFileDialogPeer instance pointer
- */
-static void
-FileDialog_CANCEL(Widget w,
-                  void *client_data,
-                  XmFileSelectionBoxCallbackStruct * call_data)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject this = (jobject) client_data;
-    struct FrameData *fdata;
-
-    fdata = (struct FrameData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    JNU_CallMethodByName(env, NULL, (jobject) client_data, "handleCancel", "()V");
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-
-/*
- * client_data is MFileDialogPeer instance pointer
- */
-static void
-FileDialog_quit(Widget w,
-                XtPointer client_data,
-                XtPointer call_data)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-    JNU_CallMethodByName(env, NULL, (jobject) client_data, "handleQuit", "()V");
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-static void
-setDeleteCallback(jobject this, struct FrameData *wdata)
-{
-    Atom xa_WM_DELETE_WINDOW;
-    Atom xa_WM_PROTOCOLS;
-
-    XtVaSetValues(wdata->winData.shell,
-                  XmNdeleteResponse, XmDO_NOTHING,
-                  NULL);
-    xa_WM_DELETE_WINDOW = XmInternAtom(XtDisplay(wdata->winData.shell),
-                                       "WM_DELETE_WINDOW", False);
-    xa_WM_PROTOCOLS = XmInternAtom(XtDisplay(wdata->winData.shell),
-                                   "WM_PROTOCOLS", False);
-
-    XmAddProtocolCallback(wdata->winData.shell,
-                          xa_WM_PROTOCOLS,
-                          xa_WM_DELETE_WINDOW,
-                          FileDialog_quit, (XtPointer) this);
-}
-
-void
-setFSBDirAndFile(Widget w, char *dir, char *file,
-                 XmString *ffiles, int count)
-{
-    Widget textField, list;
-    char dirbuf[MAX_DIR_PATH_LEN];
-    XmString xim, item;
-    size_t lastSelect;
-
-    dirbuf[0] = (char) '\0';
-
-    if (dir != NULL && strlen(dir) < MAX_DIR_PATH_LEN)
-        strcpy(dirbuf, dir);
-
-    /* -----> make sure dir ends in '/' */
-    if (dirbuf[0] != (char) '\0') {
-        if (dirbuf[strlen(dirbuf) - 1] != (char) '/')
-            strcat(dirbuf, "/");
-    } else {
-        getcwd(dirbuf, MAX_DIR_PATH_LEN - 16);
-        strcat(dirbuf, "/");
-    }
-
-    strcat(dirbuf, "[^.]*");
-    xim = XmStringCreate(dirbuf, XmSTRING_DEFAULT_CHARSET);
-    XtVaSetValues(w, XmNdirMask, xim, NULL);
-
-    if (ffiles != NULL)
-      XtVaSetValues(w,
-                    XmNfileListItems, (count > 0) ? ffiles : NULL,
-                    XmNfileListItemCount, count,
-                    XmNlistUpdated, True, NULL);
-
-    XmStringFree(xim);
-
-    /*
-     * Select the filename from the filelist if it exists.
-     */
-
-    textField = XmFileSelectionBoxGetChild(w, XmDIALOG_TEXT);
-    list = XmFileSelectionBoxGetChild(w, XmDIALOG_LIST);
-
-    if (textField != 0 && file != 0) {
-        lastSelect = strlen(file);
-        XtVaSetValues(textField, XmNvalue, file, NULL);
-        XmTextFieldSetSelection(textField, 0, lastSelect, CurrentTime);
-
-        item = XmStringCreateLocalized(file);
-        XmListSelectItem(list, item, NULL);
-        XmStringFree(item);
-    }
-}
-
-static void
-changeBackground(Widget w, void *bg)
-{
-    /*
-    ** This is a work-around for bug 4325443, caused by motif bug 4345559,
-    ** XmCombobox dosn't return all children, so give it some help ...
-    */
-    Widget grabShell;
-    grabShell = XtNameToWidget(w, "GrabShell");
-    if (grabShell != NULL) {
-        awt_util_mapChildren(grabShell, changeBackground, 0, (void *) bg);
-    }
-
-    XmChangeColor(w, (Pixel) bg);
-}
-
-void
-ourSearchProc(Widget w, XtPointer p) {
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    struct FrameData *wdata;
-    XtPointer peer;
-    jobject this;
-    jboolean res;
-    char * dir = NULL;
-    jstring dir_o;
-    int32_t i, filecount = 0;
-    XmString * filelist = NULL;
-    jobjectArray nffiles = NULL;
-    jclass clazz = NULL;
-    jstring jfilename = NULL;
-    char * cfilename = NULL;
-    XmFileSelectionBoxCallbackStruct * vals = (XmFileSelectionBoxCallbackStruct *)p;
-
-    XtVaGetValues(w, XmNuserData, &peer, NULL);
-    this = (jobject)peer;
-    if (JNU_IsNull(env, this) ) {
-        return;
-    }
-    wdata = (struct FrameData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (wdata == 0 ||
-        wdata->winData.comp.widget == 0 ||
-        wdata->winData.shell == 0 || p == NULL ) {
-        return;
-    }
-
-    if ((*env)->EnsureLocalCapacity(env, 1) < 0) {
-        return;
-    }
-
-    if (DefaultSearchProc != NULL) {
-        /* Unmap the widget temporary. If it takes a long time to generate
-           the list items some visual artifacts may be caused. However,
-           we need to do this to have the widget that works as we expect.
-         */
-        XtSetMappedWhenManaged(w, False);
-        /* Call the default Motif search procedure to take the
-           native filtered file list.
-         */
-        DefaultSearchProc(w, vals);
-        XtSetMappedWhenManaged(w, True);
-        XtVaGetValues(w,
-                      XmNlistItemCount, &filecount,
-                      XmNlistItems, &filelist,
-                      NULL);
-        /* We need to construct the new String array to pass it to
-           the Java code.
-         */
-        clazz = (*env)->FindClass(env, "java/lang/String");
-        /* It is ok if filecount is 0. */
-        nffiles = (*env)->NewObjectArray(env, filecount, clazz, NULL);
-        if (JNU_IsNull(env, nffiles)) {
-            nffiles = NULL;
-            JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        } else {
-            for (i = 0; i < filecount; i++) {
-                DASSERT(filelist[i] != NULL);
-
-                XmStringGetLtoR(filelist[i], XmFONTLIST_DEFAULT_TAG, &cfilename);
-                jfilename = JNU_NewStringPlatform(env, cfilename);
-
-                if (JNU_IsNull(env, jfilename)) {
-                    XtFree(cfilename);
-                    nffiles = NULL;
-                    JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-                    break;
-                }
-
-                (*env)->SetObjectArrayElement(env, nffiles, i, jfilename);
-
-                (*env)->DeleteLocalRef(env, jfilename);
-                XtFree(cfilename);
-            }
-        }
-    }
-
-    XmStringGetLtoR(vals->dir, XmFONTLIST_DEFAULT_TAG, &dir);
-    dir_o = JNU_NewStringPlatform(env, dir);
-    res = JNU_CallMethodByName(env, NULL, this,
-                               "proceedFiltering",
-                               "(Ljava/lang/String;[Ljava/lang/String;Z)Z",
-                               dir_o, nffiles,
-                               awt_currentThreadIsPrivileged(env)).z;
-
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-
-    XtVaSetValues(w,
-                  XmNlistUpdated, res,
-                  NULL);
-    (*env)->DeleteLocalRef(env, dir_o);
-    free(dir);
-}
-
-/*
- * Class:     sun_awt_motif_MFileDialogPeer
- * Method:    create
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MFileDialogPeer_create
-  (JNIEnv *env, jobject this, jobject parent)
-{
-    struct FrameData *fdata;
-    struct CanvasData *wdata;
-    int32_t argc;
-#define MAX_ARGC 20
-    Arg args[MAX_ARGC];
-    Widget child, textField, dirList, fileList;
-    XmString xim;
-    Pixel bg;
-    jobject target;
-    jstring file;
-    jobject globalRef = awtJNI_CreateAndSetGlobalRef(env, this);
-    AwtGraphicsConfigDataPtr adata;
-#ifndef NOMODALFIX
-    extern void awt_shellPoppedUp(Widget shell, XtPointer c, XtPointer d);
-    extern void awt_shellPoppedDown(Widget shell, XtPointer c, XtPointer d);
-#endif NOMODALFIX
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    if (JNU_IsNull(env, parent) || JNU_IsNull(env, target)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-
-    adata = copyGraphicsConfigToPeer(env, this);
-
-    wdata = (struct CanvasData *) JNU_GetLongFieldAsPtr(env,parent,mComponentPeerIDs.pData);
-
-    fdata = ZALLOC(FrameData);
-    JNU_SetLongFieldFromPtr(env,this,mComponentPeerIDs.pData,fdata);
-
-    if (fdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaGetValues(wdata->comp.widget, XmNbackground, &bg, NULL);
-
-    /*
-     * XXX: this code uses FrameData but doesn't bother to init a lot
-     * of its memebers.  This confuses the hell out of the code in
-     * awt_TopLevel.c that gets passes such half-inited FrameData.
-     */
-    fdata->decor = MWM_DECOR_ALL;
-
-    argc = 0;
-    XtSetArg(args[argc], XmNmustMatch, False);
-    argc++;
-    XtSetArg(args[argc], XmNautoUnmanage, False);
-    argc++;
-    XtSetArg(args[argc], XmNbackground, bg);
-    argc++;
-    XtSetArg(args[argc], XmNvisual, adata->awt_visInfo.visual);
-    argc++;
-    XtSetArg(args[argc], XmNdialogStyle, XmDIALOG_FULL_APPLICATION_MODAL);
-    argc++;
-    XtSetArg (args[argc], XmNscreen,
-              ScreenOfDisplay(awt_display, adata->awt_visInfo.screen));
-    argc++;
-    XtSetArg(args[argc], XmNuserData, (XtPointer)globalRef);
-    argc++;
-    XtSetArg(args[argc], XmNresizePolicy, XmRESIZE_NONE);
-    argc++;
-
-    XtSetArg(args[argc], XmNbuttonFontList,  getMotifFontList());
-    argc++;
-    XtSetArg(args[argc], XmNlabelFontList,   getMotifFontList());
-    argc++;
-    XtSetArg(args[argc], XmNtextFontList,    getMotifFontList());
-    argc++;
-
-    DASSERT(!(argc > MAX_ARGC));
-
-    fdata->winData.comp.widget = XmCreateFileSelectionDialog(wdata->shell,
-                                                             "",
-                                                             args,
-                                                             argc);
-    fdata->winData.shell = XtParent(fdata->winData.comp.widget);
-    awt_util_mapChildren(fdata->winData.shell, changeBackground, 0,
-                         (void *) bg);
-    child = XmFileSelectionBoxGetChild(fdata->winData.comp.widget,
-                                       XmDIALOG_HELP_BUTTON);
-
-    /* We should save a pointer to the default search procedure
-       to do some things that we cannot do else. For instance,
-       apply the native pattern.
-     */
-    XtVaGetValues(fdata->winData.comp.widget,
-                  XmNfileSearchProc, &DefaultSearchProc,
-                  NULL);
-    XtVaSetValues(fdata->winData.comp.widget,
-                  XmNfileSearchProc, ourSearchProc,
-                  NULL);
-
-    /*
-     * Get textfield in FileDialog.
-     */
-    textField = XmFileSelectionBoxGetChild(fdata->winData.comp.widget,
-                                           XmDIALOG_TEXT);
-    if (child != NULL) {
-        /*
-         * Workaround for Bug Id 4415659.
-         * If the dialog child is unmanaged before the dialog is managed,
-         * the Motif drop site hierarchy may be broken if we associate
-         * a drop target with the dialog before it is shown.
-         */
-        XtSetMappedWhenManaged(fdata->winData.shell, False);
-        XtManageChild(fdata->winData.comp.widget);
-        XtUnmanageChild(fdata->winData.comp.widget);
-        XtSetMappedWhenManaged(fdata->winData.shell, True);
-        XtUnmanageChild(child);
-    }
-    if (!awtJNI_IsMultiFont(env, awtJNI_GetFont(env, this))) {
-        /* This process should not be done other than English language
-           locale. */
-        child = XmFileSelectionBoxGetChild(fdata->winData.comp.widget,
-                                           XmDIALOG_DEFAULT_BUTTON);
-        if (child != NULL) {
-            XmString xim;
-
-            switch ((*env)->GetIntField(env, target, fileDialogIDs.mode)) {
-                case java_awt_FileDialog_LOAD:
-                    xim = XmStringCreate("Open", "labelFont");
-                    XtVaSetValues(child, XmNlabelString, xim, NULL);
-                    XmStringFree(xim);
-                    break;
-
-                case java_awt_FileDialog_SAVE:
-                    xim = XmStringCreate("Save", "labelFont");
-                    XtVaSetValues(child, XmNlabelString, xim, NULL);
-                    XmStringFree(xim);
-                    break;
-
-                default:
-                    break;
-            }
-        }
-    }
-    XtAddCallback(fdata->winData.comp.widget,
-                  XmNokCallback,
-                  (XtCallbackProc) FileDialog_OK,
-                  (XtPointer) globalRef);
-    XtAddCallback(fdata->winData.comp.widget,
-                  XmNcancelCallback,
-                  (XtCallbackProc) FileDialog_CANCEL,
-                  (XtPointer) globalRef);
-
-#ifndef NOMODALFIX
-    XtAddCallback(fdata->winData.shell,
-                      XtNpopupCallback,
-                      awt_shellPoppedUp,
-                      NULL);
-    XtAddCallback(fdata->winData.shell,
-                      XtNpopdownCallback,
-                      awt_shellPoppedDown,
-                      NULL);
-#endif NOMODALFIX
-
-    setDeleteCallback(globalRef, fdata);
-
-    if (textField != NULL)  {
-        /*
-         * Insert event handler to correctly process cut/copy/paste keys
-         * such that interaction with our own clipboard mechanism will work
-         * properly.
-         *
-         * The Text_handlePaste() event handler is also used by both
-         * TextField/TextArea.
-         */
-        XtInsertEventHandler(textField,
-                         KeyPressMask,
-                         False, Text_handlePaste, (XtPointer) globalRef,
-                         XtListHead);
-    }
-
-    /* To get wheel scrolling, we add an event handler to the directory list and
-     * file list widgets to handle mouse wheels */
-    dirList = XmFileSelectionBoxGetChild(fdata->winData.comp.widget, XmDIALOG_DIR_LIST);
-    if (dirList != NULL) {
-        XtAddEventHandler(dirList, ButtonPressMask, False, File_handleWheel,
-                          (XtPointer) globalRef);
-    }
-
-    fileList = XmFileSelectionBoxGetChild(fdata->winData.comp.widget, XmDIALOG_LIST);
-    if (fileList != NULL) {
-        XtAddEventHandler(fileList, ButtonPressMask, False, File_handleWheel,
-                          (XtPointer) globalRef);
-    }
-
-    file = (*env)->GetObjectField(env, target, fileDialogIDs.file);
-    if (JNU_IsNull(env, file)) {
-        setFSBDirAndFile(fdata->winData.comp.widget, ".", "", NULL, -1);
-    } else {
-        char *fileString;
-
-        fileString = (char *) JNU_GetStringPlatformChars(env, file, NULL);
-        setFSBDirAndFile(fdata->winData.comp.widget, ".", fileString, NULL, -1);
-        JNU_ReleaseStringPlatformChars(env, file, (const char *) fileString);
-    }
-    AWT_UNLOCK();
-}
-
-/* Event handler for making scrolling happen when the mouse wheel is rotated */
-void File_handleWheel(Widget w, XtPointer client_data, XEvent* event, Boolean* cont) {
-    unsigned int btn;
-    Widget scrolledWindow = NULL;
-
-    /* only registered for ButtonPress, so don't need to check event type  */
-    btn = event->xbutton.button;
-    /* wheel up and wheel down show up as button 4 and 5, respectively */
-    if (btn == 4 || btn == 5) {
-        scrolledWindow = XtParent(w);
-        if (scrolledWindow == NULL) {
-            return;
-        }
-        awt_util_do_wheel_scroll(scrolledWindow,
-                             java_awt_event_MouseWheelEvent_WHEEL_UNIT_SCROLL,
-                             3,
-                             btn == 4 ? -1 : 1);
-    }
-}
-
-
-/*
- * Class:     sun_awt_motif_MFileDialogPeer
- * Method:    pReshape
- * Signature: (IIII)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MFileDialogPeer_pReshape
-  (JNIEnv *env, jobject this, jint x, jint y, jint w, jint h)
-{
-    struct FrameData *wdata;
-
-    AWT_LOCK();
-    wdata = (struct FrameData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (wdata == NULL || wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    /* GES: AVH's hack from awt_util.c:
-     * Motif ignores attempts to move a toplevel window to 0,0.
-     * Instead we set the position to 1,1. The expected value is
-     * returned by Frame.getBounds() since it uses the internally
-     * held rectangle rather than querying the peer.
-     */
-
-    if ((x == 0) && (y == 0)) {
-        XtVaSetValues(wdata->winData.shell, XmNx, 1, XmNy, 1, NULL);
-    }
-    XtVaSetValues(wdata->winData.shell,
-                  XtNx, (XtArgVal) x,
-                  XtNy, (XtArgVal) y,
-                  NULL);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MFileDialogPeer
- * Method:    pDispose
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MFileDialogPeer_pDispose
-  (JNIEnv *env, jobject this)
-{
-    struct FrameData *wdata;
-
-    AWT_LOCK();
-    wdata = (struct FrameData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (wdata == NULL ||
-        wdata->winData.comp.widget == NULL ||
-        wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtUnmanageChild(wdata->winData.shell);
-    awt_util_consumeAllXEvents(wdata->winData.shell);
-    XtDestroyWidget(wdata->winData.shell);
-    free((void *) wdata);
-    JNU_SetLongFieldFromPtr(env,this,mComponentPeerIDs.pData,NULL);
-    awtJNI_DeleteGlobalRef(env, this);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MFileDialogPeer
- * Method:    pShow
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MFileDialogPeer_pShow
-  (JNIEnv *env, jobject this)
-{
-    struct FrameData *wdata;
-    XmString dirMask = NULL;
-
-    AWT_LOCK();
-    wdata = (struct FrameData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (wdata == NULL ||
-        wdata->winData.comp.widget == NULL ||
-        wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtManageChild(wdata->winData.comp.widget);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MFileDialogPeer
- * Method:    pHide
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MFileDialogPeer_pHide
-  (JNIEnv *env, jobject this)
-{
-    struct FrameData *wdata;
-
-    AWT_LOCK();
-    wdata = (struct FrameData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (wdata == NULL ||
-        wdata->winData.comp.widget == NULL ||
-        wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (XtIsManaged(wdata->winData.comp.widget)) {
-        XtUnmanageChild(wdata->winData.comp.widget);
-    }
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MFileDialogPeer
- * Method:    setFileEntry
- * Signature: (Ljava/lang/String;Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MFileDialogPeer_setFileEntry
-  (JNIEnv *env, jobject this, jstring dir, jstring file, jobjectArray ffiles)
-{
-    struct ComponentData *cdata;
-    char *cdir;
-    char *cfile;
-    char *cf;
-    struct FrameData *wdata;
-    int32_t length, i;
-    XmString * files = NULL;
-    jstring jf;
-
-    AWT_LOCK();
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (wdata == NULL || wdata->winData.comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-
-    cdir = (JNU_IsNull(env, dir))
-               ? NULL
-               : (char *) JNU_GetStringPlatformChars(env, dir, NULL);
-
-    cfile = (JNU_IsNull(env, file))
-               ? NULL
-               : (char *) JNU_GetStringPlatformChars(env, file, NULL);
-
-    if (ffiles != NULL) {
-        length = (*env)->GetArrayLength(env, ffiles);
-        files = (XmString*)calloc(length, sizeof(XmString));
-
-        for (i = 0; i < length; i++) {
-            jf = (jstring)(*env)->GetObjectArrayElement(env, ffiles, i);
-            cf = (char *) JNU_GetStringPlatformChars(env, jf, NULL);
-
-            if ((*env)->GetStringLength(env, jf) == 0 && length == 1) {
-              length = 0;
-              files[0] = NULL;
-            }
-            else
-              files[i] = XmStringCreateLocalized(cf);
-
-            if (cf)
-                JNU_ReleaseStringPlatformChars(env, jf, (const char *) cf);
-        }
-
-        setFSBDirAndFile(wdata->winData.comp.widget, (cdir) ? cdir : "",
-                         (cfile) ? cfile : "", files, length);
-        while(i > 0) {
-            XmStringFree(files[--i]);
-        }
-        if (files != NULL) {
-            free(files);
-        }
-    }
-    else
-      setFSBDirAndFile(wdata->winData.comp.widget, (cdir) ? cdir : "",
-                       (cfile) ? cfile : "", NULL, -1);
-
-    if (cdir) {
-        JNU_ReleaseStringPlatformChars(env, dir, (const char *) cdir);
-    }
-
-    if (cfile) {
-        JNU_ReleaseStringPlatformChars(env, file, (const char *) cfile);
-    }
-
-    AWT_FLUSH_UNLOCK();
-}
-
-static void
-changeFont(Widget w, void *fontList)
-{
-    XtVaSetValues(w, XmNfontList, fontList, NULL);
-}
-
-/*
- * Class:     sun_awt_motif_MFileDialogPeer
- * Method:    setFont
- * Signature: (Ljava/awt/Font;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MFileDialogPeer_setFont
-  (JNIEnv *env, jobject this, jobject f)
-{
-    struct ComponentData *tdata;
-    struct FontData *fdata;
-    XmFontListEntry fontentry;
-    XmFontList fontlist;
-    char *err;
-
-    if (JNU_IsNull(env, f)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-    fdata = awtJNI_GetFontData(env, f, &err);
-    if (fdata == NULL) {
-        JNU_ThrowInternalError(env, err);
-        AWT_UNLOCK();
-        return;
-    }
-    tdata = (struct ComponentData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (awtJNI_IsMultiFont(env, f)) {
-        if (fdata->xfs == NULL) {
-            fdata->xfs = awtJNI_MakeFontSet(env, f);
-        }
-        if (fdata->xfs != NULL) {
-            fontentry = XmFontListEntryCreate("labelFont",
-                                              XmFONT_IS_FONTSET,
-                                              (XtPointer) (fdata->xfs));
-            fontlist = XmFontListAppendEntry(NULL, fontentry);
-            /*
-             * Some versions of motif have a bug in
-             * XmFontListEntryFree() which causes it to free more than it
-             * should.  Use XtFree() instead.  See O'Reilly's
-             * Motif Reference Manual for more information.
-             */
-            XmFontListEntryFree(&fontentry);
-        } else {
-            fontlist = XmFontListCreate(fdata->xfont, "labelFont");
-        }
-    } else {
-        fontlist = XmFontListCreate(fdata->xfont, "labelFont");
-    }
-
-    if (fontlist != NULL) {
-     /* setting the fontlist in the FileSelectionBox is not good enough --
-        you have to set the resource for all the descendants individually */
-        awt_util_mapChildren(tdata->widget, changeFont, 1, (void *)fontlist);
-        XmFontListFree(fontlist);
-    } else {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-    }
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MFileDialogPeer
- * Method:    insertReplaceFileDialogText
- * Signature: (Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MFileDialogPeer_insertReplaceFileDialogText
-  (JNIEnv *env, jobject this, jstring l)
-{
-    struct ComponentData *cdata;
-    char *cl;
-    XmTextPosition start, end;
-    Widget textField;
-    jobject font;
-
-    /*
-     * Replaces the text in the FileDialog's textfield with the passed
-     * string.
-     */
-
-    AWT_LOCK();
-    cdata = (struct ComponentData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    textField = XmFileSelectionBoxGetChild(cdata->widget, XmDIALOG_TEXT);
-
-    if (textField == NULL)  {
-        JNU_ThrowNullPointerException(env, "Null TextField in FileDialog");
-        AWT_UNLOCK();
-        return;
-    }
-
-    font = awtJNI_GetFont(env, this);
-
-    if (JNU_IsNull(env, l)) {
-        cl = NULL;
-    } else {
-        /*
-         * We use makePlatformCString() to convert unicode to EUC here,
-         * although output only components (Label/Button/Menu..)
-         * is not using make/allocCString() functions anymore.
-         * Because Motif TextFiled widget does not support multi-font
-         * compound string.
-         */
-
-        cl = (char *) JNU_GetStringPlatformChars(env, l, NULL);
-    }
-
-    if (!XmTextGetSelectionPosition(textField, &start, &end)) {
-        start = end = XmTextGetInsertionPosition(textField);
-    }
-    XmTextReplace(textField, start, end, cl);
-
-    if (cl != NULL && cl !="") {
-        JNU_ReleaseStringPlatformChars(env, l, cl);
-    }
-    AWT_FLUSH_UNLOCK();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_GlobalCursorManager.c openjdk/jdk/src/solaris/native/sun/awt/awt_GlobalCursorManager.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_GlobalCursorManager.c	2014-04-08 05:27:03.434874852 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_GlobalCursorManager.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,127 +0,0 @@
-/*
- * Copyright (c) 1999, 2001, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "awt_Component.h"
-#include "sun_awt_motif_MComponentPeer.h"
-
-#include "jni.h"
-#include "jni_util.h"
-
-static jfieldID xID;
-static jfieldID yID;
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern struct ComponentIDs componentIDs;
-extern struct ContainerIDs containerIDs;
-extern jobject getCurComponent();
-
-/*
- * Class:     sun_awt_motif_MGlobalCursorManager
- * Method:    cacheInit
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MGlobalCursorManager_cacheInit
-  (JNIEnv *env, jclass cls)
-{
-    jclass clsDimension = (*env)->FindClass(env, "java/awt/Point");
-    xID = (*env)->GetFieldID(env, clsDimension, "x", "I");
-    yID = (*env)->GetFieldID(env, clsDimension, "y", "I");
-}
-
-/*
- * Class:     sun_awt_motif_MGlobalCursorManager
- * Method:    getCursorPos
- * Signature: (Ljava/awt/Point;)Ljava/awt/Component
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MGlobalCursorManager_getCursorPos
-  (JNIEnv *env, jobject this, jobject point)
-{
-    Window root, rw, cw;
-    int32_t rx, ry, x, y;
-    uint32_t kbs;
-
-    AWT_LOCK();
-    root = RootWindow(awt_display, DefaultScreen(awt_display));
-    XQueryPointer(awt_display, root, &rw, &cw, &rx, &ry, &x, &y, &kbs);
-
-    (*env)->SetIntField(env, point, xID, rx);
-    (*env)->SetIntField(env, point, yID, ry);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MGlobalCursorManager
- * Method:    getCursorPos
- * Signature: ()Ljava/awt/Component
- */
-JNIEXPORT jobject JNICALL Java_sun_awt_motif_MGlobalCursorManager_findHeavyweightUnderCursor
-  (JNIEnv *env, jobject this)
-{
-        jobject target;
-
-    AWT_LOCK();
-        target = getCurComponent();
-    AWT_FLUSH_UNLOCK();
-        return target;
-}
-
-/*
- * Class:     sun_awt_motif_MGlobalCursorManager
- * Method:    getLocationOnScreen
- * Signature: (Ljava/awt/Component;)Ljava/awt/Point
- */
-JNIEXPORT jobject JNICALL Java_sun_awt_motif_MGlobalCursorManager_getLocationOnScreen
-  (JNIEnv *env, jobject this, jobject component)
-{
-    jobject point =
-        (*env)->CallObjectMethod(env, component,
-                                 componentIDs.getLocationOnScreen);
-    return point;
-}
-
-/*
- * Class:     sun_awt_motif_MGlobalCursorManager
- * Method:    findComponentAt
- * Signature: (Ljava/awt/Container;II)Ljava/awt/Component
- */
-JNIEXPORT jobject JNICALL
-Java_sun_awt_motif_MGlobalCursorManager_findComponentAt
-    (JNIEnv *env, jobject this, jobject container, jint x, jint y)
-{
-    /*
-     * Call private version of Container.findComponentAt with the following
-     * flag set: ignoreEnabled = false (i.e., don't return or recurse into
-     * disabled Components).
-     * NOTE: it may return a JRootPane's glass pane as the target Component.
-     */
-    jobject component =
-        (*env)->CallObjectMethod(env, container, containerIDs.findComponentAt,
-                                 x, y, JNI_FALSE);
-    return component;
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_KeyboardFocusManager.c openjdk/jdk/src/solaris/native/sun/awt/awt_KeyboardFocusManager.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_KeyboardFocusManager.c	2014-04-08 05:27:03.438874910 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_KeyboardFocusManager.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,175 +0,0 @@
-/*
- * Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "jni.h"
-#include "jni_util.h"
-
-#include "awt_KeyboardFocusManager.h"
-#include "java_awt_KeyboardFocusManager.h"
-#include "java_awt_event_FocusEvent.h"
-#include "awt_Component.h"
-#include "canvas.h"
-#include "awt_MToolkit.h"
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-
-struct KeyboardFocusManagerIDs keyboardFocusManagerIDs;
-
-/*
- * Class:     java_awt_KeyboardFocusManager
- * Method:    initIDs
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_java_awt_KeyboardFocusManager_initIDs
-    (JNIEnv *env, jclass cls)
-{
-    jclass keyclass = NULL;
-
-    keyboardFocusManagerIDs.keyboardFocusManagerCls = (jclass)
-        (*env)->NewGlobalRef(env, cls);
-    keyboardFocusManagerIDs.shouldNativelyFocusHeavyweightMID =
-        (*env)->GetStaticMethodID(env, cls, "shouldNativelyFocusHeavyweight",
-            "(Ljava/awt/Component;Ljava/awt/Component;ZZJLsun/awt/CausedFocusEvent$Cause;)I");
-    keyboardFocusManagerIDs.heavyweightButtonDownMID =
-        (*env)->GetStaticMethodID(env, cls, "heavyweightButtonDown",
-            "(Ljava/awt/Component;J)V");
-    keyboardFocusManagerIDs.heavyweightButtonDownZMID =
-        (*env)->GetStaticMethodID(env, cls, "heavyweightButtonDown",
-            "(Ljava/awt/Component;JZ)V");
-    keyboardFocusManagerIDs.markClearGlobalFocusOwnerMID =
-        (*env)->GetStaticMethodID(env, cls, "markClearGlobalFocusOwner",
-                                  "()Ljava/awt/Window;");
-
-    keyboardFocusManagerIDs.processSynchronousTransferMID =
-        (*env)->GetStaticMethodID(env, cls, "processSynchronousLightweightTransfer",
-                                  "(Ljava/awt/Component;Ljava/awt/Component;ZZJ)Z");
-
-    keyclass = (*env)->FindClass(env, "java/awt/event/KeyEvent");
-    DASSERT (keyclass != NULL);
-
-    keyboardFocusManagerIDs.isProxyActive =
-        (*env)->GetFieldID(env, keyclass, "isProxyActive",
-                           "Z");
-
-    (*env)->DeleteLocalRef(env, keyclass);
-
-    DASSERT(keyboardFocusManagerIDs.keyboardFocusManagerCls != NULL);
-    DASSERT(keyboardFocusManagerIDs.shouldNativelyFocusHeavyweightMID !=
-            NULL);
-    DASSERT(keyboardFocusManagerIDs.heavyweightButtonDownMID != NULL);
-    DASSERT(keyboardFocusManagerIDs.heavyweightButtonDownZMID != NULL);
-    DASSERT(keyboardFocusManagerIDs.markClearGlobalFocusOwnerMID != NULL);
-    DASSERT(keyboardFocusManagerIDs.processSynchronousTransferMID != NULL);
-}
-
-/*
- * Class:     java_awt_KeyboardFocusManager
- * Method:    getNativeFocusOwner
- * Signature: ()Ljava/awt/Component;
- */
-JNIEXPORT jobject JNICALL
-Java_sun_awt_KeyboardFocusManagerPeerImpl_getNativeFocusOwner
-    (JNIEnv *env, jclass cls)
-{
-    jobject l_peer;
-
-    AWT_LOCK();
-    l_peer = awt_canvas_getFocusOwnerPeer();
-    AWT_UNLOCK();
-
-    return (l_peer != NULL)
-        ? (*env)->GetObjectField(env, l_peer, mComponentPeerIDs.target)
-        : NULL;
-}
-
-/*
- * Class:     java_awt_KeyboardFocusManager
- * Method:    getNativeFocusedWindow
- * Signature: ()Ljava/awt/Window;
- */
-JNIEXPORT jobject JNICALL
-Java_sun_awt_KeyboardFocusManagerPeerImpl_getNativeFocusedWindow
-    (JNIEnv *env, jclass cls)
-{
-    jobject l_peer;
-
-    AWT_LOCK();
-    l_peer = awt_canvas_getFocusedWindowPeer();
-    AWT_UNLOCK();
-
-    return (l_peer != NULL)
-        ? (*env)->GetObjectField(env, l_peer, mComponentPeerIDs.target)
-        : NULL;
-}
-
-/*
- * Class:     java_awt_KeyboardFocusManager
- * Method:    clearGlobalFocusOwner
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_KeyboardFocusManagerPeerImpl_clearNativeGlobalFocusOwner
-    (JNIEnv *env, jobject self, jobject activeWindow)
-{
-  /* Redirect focus to the focus proxy of the active Window. The effect
-     we want is for the active Window to remain active, but for none of
-     its children to be the focus owner. AWT maintains state to know
-     that any key events delivered after this call (but before focus is
-     re-established elsewhere) get ignored. */
-
-    Widget proxy;
-
-    if ((*env)->EnsureLocalCapacity(env, 1) < 0) {
-        return;
-    }
-
-    AWT_LOCK();
-
-    if (activeWindow != NULL) {
-        // Setting focus owner to proxy will be equivalent to having
-        // null focus owner in Java layer while we will still be
-        // able to receive key events.
-        proxy = findWindowsProxy(activeWindow, env);
-
-        if (proxy != NULL) {
-            Widget curFocusWidget = XmGetFocusWidget(proxy);
-            if (curFocusWidget != NULL) {
-                callFocusHandler(curFocusWidget, FocusOut, NULL);
-            }
-
-            // Disable all but proxy widgets
-            processTree(curFocusWidget, proxy, False);
-
-            XmProcessTraversal(proxy, XmTRAVERSE_CURRENT);
-        }
-    }
-
-    AWT_UNLOCK();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Label.c openjdk/jdk/src/solaris/native/sun/awt/awt_Label.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Label.c	2014-04-08 05:27:03.438874910 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Label.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,212 +0,0 @@
-/*
- * Copyright (c) 1995, 2001, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "java_awt_Color.h"
-#include "java_awt_Font.h"
-#include "java_awt_Label.h"
-#include "sun_awt_motif_MLabelPeer.h"
-#include "sun_awt_motif_MComponentPeer.h"
-
-#include "awt_Component.h"
-
-#include "multi_font.h"
-#include <jni.h>
-#include <jni_util.h>
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern AwtGraphicsConfigDataPtr
-    copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-
-static char emptyString[] = "";
-
-
-/*
- * Class:     sun_awt_motif_MLabelPeer
- * Method:    create
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MLabelPeer_create
-  (JNIEnv *env, jobject this, jobject parent)
-{
-    struct ComponentData *cdata;
-    struct ComponentData *wdata;
-    jobject target;
-    jobject globalRef = awtJNI_CreateAndSetGlobalRef(env, this);
-    AwtGraphicsConfigDataPtr adata;
-    AWT_LOCK();
-
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-
-        return;
-    }
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-    wdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, parent, mComponentPeerIDs.pData);
-
-    if (JNU_IsNull(env, target) || wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-
-        return;
-    }
-    cdata = ZALLOC(ComponentData);
-    if (cdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-    JNU_SetLongFieldFromPtr(env, this, mComponentPeerIDs.pData,cdata);
-
-    adata = copyGraphicsConfigToPeer(env, this);
-
-    cdata->widget = XtVaCreateManagedWidget("",
-                                            xmLabelWidgetClass, wdata->widget,
-                                            XmNhighlightThickness, 0,
-                                            XmNalignment, XmALIGNMENT_BEGINNING,
-                                            XmNrecomputeSize, False,
-                                            XmNuserData, (XtPointer) globalRef,
-                                            XmNtraversalOn, True,
-                                            XmNscreen,
-                                            ScreenOfDisplay(awt_display,
-                                               adata->awt_visInfo.screen),
-                                            XmNfontList, getMotifFontList(),
-                                            NULL);
-    XtSetMappedWhenManaged(cdata->widget, False);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MLabelPeer
- * Method:    setText
- * Signature: (Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MLabelPeer_setText
-  (JNIEnv *env, jobject this, jstring label)
-{
-    char *clabel = NULL;
-    char *clabelEnd;
-    struct ComponentData *cdata;
-    XmString xim = NULL;
-    jobject font;
-    Boolean isMultiFont;
-
-    AWT_LOCK();
-
-    font = awtJNI_GetFont(env, this);
-    isMultiFont = awtJNI_IsMultiFont(env, font);
-
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (JNU_IsNull(env, label)) {
-        clabel = emptyString;
-    } else {
-        if (isMultiFont) {
-            if ((*env)->GetStringLength(env, label) <= 0) {
-                xim = XmStringCreateLocalized("");
-            } else {
-                xim = awtJNI_MakeMultiFontString(env, label, font);
-            }
-        } else {
-            clabel = (char *) JNU_GetStringPlatformChars(env, label, NULL);
-
-            /* scan for any \n's and terminate the string at that point */
-            clabelEnd = strchr(clabel, '\n');
-            if (clabelEnd != NULL) {
-                *clabelEnd = '\0';
-            }
-        }
-    }
-
-    if (!isMultiFont) {
-        xim = XmStringCreate(clabel, "labelFont");
-    }
-    XtVaSetValues(cdata->widget, XmNlabelString, xim, NULL);
-
-    if (!isMultiFont) {
-        /* Must test for "" too! */
-        if (clabel != NULL && (*clabel != '\0')) {
-            JNU_ReleaseStringPlatformChars(env, label, (const char *) clabel);
-        }
-    }
-    XmStringFree(xim);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MLabelPeer
- * Method:    setAlignment
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MLabelPeer_setAlignment
-  (JNIEnv *env, jobject this, jint alignment)
-{
-    struct ComponentData *cdata;
-
-    AWT_LOCK();
-
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    switch (alignment) {
-        case java_awt_Label_LEFT:
-            XtVaSetValues(cdata->widget,
-                          XmNalignment, XmALIGNMENT_BEGINNING,
-                          NULL);
-            break;
-
-        case java_awt_Label_CENTER:
-            XtVaSetValues(cdata->widget,
-                          XmNalignment, XmALIGNMENT_CENTER,
-                          NULL);
-            break;
-
-        case java_awt_Label_RIGHT:
-            XtVaSetValues(cdata->widget,
-                          XmNalignment, XmALIGNMENT_END,
-                          NULL);
-            break;
-
-        default:
-            break;
-    }
-
-    AWT_FLUSH_UNLOCK();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_List.c openjdk/jdk/src/solaris/native/sun/awt/awt_List.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_List.c	2014-04-08 05:27:03.438874910 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_List.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,600 +0,0 @@
-/*
- * Copyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "java_awt_List.h"
-#include "java_awt_AWTEvent.h"
-#include "sun_awt_motif_MListPeer.h"
-#include "sun_awt_motif_MComponentPeer.h"
-#include "java_awt_event_MouseWheelEvent.h"
-#include "canvas.h"
-
-#include "awt_Component.h"
-
-#include "multi_font.h"
-#include <jni.h>
-#include <jni_util.h>
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern struct ComponentIDs componentIDs;
-extern AwtGraphicsConfigDataPtr
-    copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-
-
-/*
- * client_data = MListPeer instance
- */
-static void
-Slist_callback(Widget w, XtPointer client_data, XtPointer call_data)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    XmListCallbackStruct *cbs = (XmListCallbackStruct *) call_data;
-
-    switch (cbs->reason) {
-        case XmCR_DEFAULT_ACTION: {
-            ConvertEventTimeAndModifiers converted;
-
-            awt_util_convertEventTimeAndModifiers(cbs->event, &converted);
-
-            if (cbs->event->type == KeyPress) {
-                /* When Default action comes from keyboard, no notification
-                 * is given by motif that a selection has been made, even
-                 * though, internally, the item will now be selected regardless
-                 * of whether or not it was previously selected.  ( on mouse
-                 * generated DEFAULT ACTIONS the XmCR_BROWSE_SELECT is
-                 * generated first ).
-                 */
-                JNU_CallMethodByName(env, NULL, (jobject) client_data
-                                     ,"handleListChanged"
-                                     ,"(I)V"
-                                     ,(cbs->item_position - 1));
-                if ((*env)->ExceptionOccurred(env)) {
-                    (*env)->ExceptionDescribe(env);
-                    (*env)->ExceptionClear(env);
-                }
-            }
-
-            JNU_CallMethodByName(env, NULL, (jobject) client_data
-                                 ,"action"
-                                 ,"(IJI)V"
-                                 ,(cbs->item_position - 1)
-                                 ,converted.when
-                                 ,converted.modifiers);
-            if ((*env)->ExceptionOccurred(env)) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-            }
-            break;
-        }
-        case XmCR_BROWSE_SELECT:
-            JNU_CallMethodByName(env, NULL, (jobject) client_data
-                                 ,"handleListChanged"
-                                 ,"(I)V"
-                                 ,(cbs->item_position - 1));
-            if ((*env)->ExceptionOccurred(env)) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-            }
-            break;
-
-        case XmCR_MULTIPLE_SELECT:
-            JNU_CallMethodByName(env, NULL, (jobject) client_data
-                                 ,"handleListChanged"
-                                 ,"(I)V"
-                                 ,(cbs->item_position - 1));
-            if ((*env)->ExceptionOccurred(env)) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-            }
-            break;
-
-        default:
-            break;
-    }
-}
-
-/*
- * Class:     sun_awt_motif_MListPeer
- * Method:    create
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MListPeer_create
-  (JNIEnv *env, jobject this, jobject parent)
-{
-    Cardinal argc;
-#define MAX_ARGC 40
-    Arg args[MAX_ARGC];
-    struct ComponentData *wdata;
-    struct ListData *sdata;
-    Pixel bg;
-    jobject globalRef = awtJNI_CreateAndSetGlobalRef(env, this);
-    AwtGraphicsConfigDataPtr adata;
-
-    AWT_LOCK();
-
-    adata = copyGraphicsConfigToPeer(env, this);
-
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-
-        return;
-    }
-    wdata = (struct ComponentData *) JNU_GetLongFieldAsPtr(env,parent,mComponentPeerIDs.pData);
-
-    if (wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    sdata = (struct ListData *) calloc(1, sizeof(struct ListData));
-
-    JNU_SetLongFieldFromPtr(env,this,mComponentPeerIDs.pData,sdata);
-    if (sdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaGetValues(wdata->widget, XmNbackground, &bg, NULL);
-    argc = 0;
-    XtSetArg(args[argc], XmNrecomputeSize, False);
-    argc++;
-    XtSetArg(args[argc], XmNbackground, bg);
-    argc++;
-    XtSetArg(args[argc], XmNlistSizePolicy, XmCONSTANT);
-    argc++;
-    XtSetArg(args[argc], XmNx, 0);
-    argc++;
-    XtSetArg(args[argc], XmNy, 0);
-    argc++;
-    XtSetArg(args[argc], XmNmarginTop, 0);
-    argc++;
-    XtSetArg(args[argc], XmNmarginBottom, 0);
-    argc++;
-    XtSetArg(args[argc], XmNmarginLeft, 0);
-    argc++;
-    XtSetArg(args[argc], XmNmarginRight, 0);
-    argc++;
-    XtSetArg(args[argc], XmNmarginHeight, 0);
-    argc++;
-    XtSetArg(args[argc], XmNmarginWidth, 0);
-    argc++;
-    XtSetArg(args[argc], XmNlistMarginHeight, 0);
-    argc++;
-    XtSetArg(args[argc], XmNlistMarginWidth, 0);
-    argc++;
-    XtSetArg(args[argc], XmNscrolledWindowMarginWidth, 0);
-    argc++;
-    XtSetArg(args[argc], XmNscrolledWindowMarginHeight, 0);
-    argc++;
-    XtSetArg(args[argc], XmNuserData, (XtPointer) globalRef);
-    argc++;
-    XtSetArg (args[argc], XmNscreen,
-              ScreenOfDisplay(awt_display,
-                              adata->awt_visInfo.screen));
-    argc++;
-
-    DASSERT(!(argc > MAX_ARGC));
-    sdata->list = XmCreateScrolledList(wdata->widget,
-                                       "slist",
-                                       args,
-                                       argc);
-
-    sdata->comp.widget = XtParent(sdata->list);
-    XtSetMappedWhenManaged(sdata->comp.widget, False);
-    XtAddCallback(sdata->list,
-                  XmNdefaultActionCallback,
-                  Slist_callback,
-                  (XtPointer) globalRef);
-    XtAddEventHandler(sdata->list, FocusChangeMask,
-                      True, awt_canvas_event_handler, globalRef);
-
-    awt_addWidget(sdata->list, sdata->comp.widget, globalRef,
-                  java_awt_AWTEvent_KEY_EVENT_MASK |
-                  java_awt_AWTEvent_MOUSE_EVENT_MASK |
-                  java_awt_AWTEvent_MOUSE_MOTION_EVENT_MASK);
-
-    XtManageChild(sdata->list);
-    XtManageChild(sdata->comp.widget);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MListPeer
- * Method:    setMultipleSelections
- * Signature: (Z)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MListPeer_setMultipleSelections
-  (JNIEnv *env, jobject this, jboolean v)
-{
-    struct ListData *sdata;
-    jobject globalRef;
-    int32_t selPos;
-    Boolean selected;
-
-    AWT_LOCK();
-
-    sdata = (struct ListData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (sdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    globalRef = (jobject)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.jniGlobalRef);
-    if (v == JNI_FALSE) {
-        XtVaSetValues(sdata->list,
-                      XmNselectionPolicy, XmBROWSE_SELECT,
-                      NULL);
-        XtRemoveCallback(sdata->list,
-                         XmNmultipleSelectionCallback,
-                         Slist_callback,
-                         (XtPointer) globalRef);
-        XtAddCallback(sdata->list,
-                      XmNbrowseSelectionCallback,
-                      Slist_callback,
-                      (XtPointer) globalRef);
-
-        // If we change the selection mode from multiple to single
-        // we need to decide what the item should be selected:
-        // If a selected item has the location cursor, only that
-        // item will remain selected.  If no selected item has the
-        // location cursor, all items will be deselected.
-        selPos = XmListGetKbdItemPos(sdata->list);
-        selected = XmListPosSelected(sdata->list, selPos);
-        XmListDeselectAllItems(sdata->list);
-        if (selected) {
-            Java_sun_awt_motif_MListPeer_select(env, this, selPos-1);
-        }
-
-    } else {
-        XtVaSetValues(sdata->list,
-                      XmNselectionPolicy, XmMULTIPLE_SELECT,
-                      NULL);
-        XtRemoveCallback(sdata->list,
-                         XmNbrowseSelectionCallback,
-                         Slist_callback,
-                         (XtPointer) globalRef);
-        XtAddCallback(sdata->list,
-                      XmNmultipleSelectionCallback,
-                      Slist_callback,
-                      (XtPointer) globalRef);
-    }
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MListPeer
- * Method:    setBackground
- * Signature: (Ljava/awt/Color;)V
- */
-
-JNIEXPORT void JNICALL Java_sun_awt_motif_MListPeer_setBackground
-  (JNIEnv *env, jobject this, jobject c)
-{
-    struct ListData *ldata;
-    Pixel color;
-
-    if (JNU_IsNull(env, c)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-    ldata = (struct ListData *)
-        JNU_GetLongFieldAsPtr(env,this, mComponentPeerIDs.pData);
-    if (ldata == NULL || ldata->list == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    color = awtJNI_GetColor(env, c);
-    XtVaSetValues(ldata->list,
-                  XmNbackground, color,
-                  NULL);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MListPeer
- * Method:    isSelected
- * Signature: (I)Z
- */
-JNIEXPORT jboolean JNICALL Java_sun_awt_motif_MListPeer_isSelected
-  (JNIEnv *env, jobject this, jint pos)
-{
-    struct ListData *sdata;
-
-    AWT_LOCK();
-
-    sdata = (struct ListData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (sdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return JNI_FALSE;
-    }
-    pos++;
-    if (XmListPosSelected(sdata->list, pos) == True) {
-        AWT_UNLOCK();
-        return JNI_TRUE;
-    } else {
-        AWT_UNLOCK();
-        return JNI_FALSE;
-    }
-}
-
-/*
- * Class:     sun_awt_motif_MListPeer
- * Method:    addItem
- * Signature: (Ljava/lang/String;I)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MListPeer_addItem
-  (JNIEnv *env, jobject this, jstring item, jint index)
-{
-    XmString im;
-    struct ListData *sdata;
-    jobject font;
-
-    /*
-     * Note:
-     * There used to be code in this function to fix:
-     *  4067355 size of listbox depends on when pack() is called (solaris)
-     * The fix (for jdk1.1.7) involved unmapping the List widget before the add
-     * is done and resizing/remapping it after the add. This causes significant
-     * performance degradation if addItem() is called a lot. A bug was filed
-     * on this performance problem: 4117288
-     * The fix was backed out after testing that:
-     *  - the problem reported in 4067355 was no longer reproducible
-     *  - the performance problem is gone
-     */
-
-    AWT_LOCK();
-    if (JNU_IsNull(env, item)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    sdata = (struct ListData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (sdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    font = awtJNI_GetFont(env, this);
-
-    if (awtJNI_IsMultiFont(env, font)) {
-        im = awtJNI_MakeMultiFontString(env, item, font);
-    } else {
-        char *temp;
-
-        temp = (char *) JNU_GetStringPlatformChars(env, item, NULL);
-        im = XmStringCreateLocalized(temp);
-        JNU_ReleaseStringPlatformChars(env, item, (const char *)temp);
-    }
-
-    /* motif uses 1-based indeces for the list operations with 0 */
-    /* referring to the last item on the list. Thus if index is -1 */
-    /* then we'll get the right effect of adding to the end of the */
-    /* list. */
-    index++;
-
-    XmListAddItemUnselected(sdata->list, im, index);
-    XmStringFree(im);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MListPeer
- * Method:    delItems
- * Signature: (II)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MListPeer_delItems
-  (JNIEnv *env, jobject this, jint start, jint end)
-{
-    struct ListData *sdata;
-    Boolean was_mapped;
-    jobject target;
-    Position width, height;
-    int32_t itemCount;
-
-    AWT_LOCK();
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-    if (JNU_IsNull(env, target)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    sdata = (struct ListData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (sdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    /* [jk] catch bogus indexes (Sun bug) */
-    XtVaGetValues(sdata->list, XmNitemCount, &itemCount, NULL);
-    if (itemCount == 0) {
-        AWT_UNLOCK();
-        return;
-    }
-    if (start > itemCount) {
-        start = itemCount;
-    }
-    if (end > itemCount) {
-        end = itemCount;
-    }
-    start++;
-    end++;
-
-    XtVaGetValues(sdata->comp.widget, XmNmappedWhenManaged, &was_mapped, NULL);
-
-    /* If it was visible, then make it invisible while we update */
-    if (was_mapped) {
-      XtSetMappedWhenManaged(sdata->comp.widget, False);
-    }
-
-    if (start == end) {
-        XmListDeletePos(sdata->list, start);
-    } else {
-        XmListDeleteItemsPos(sdata->list, end - start + 1, start);
-    }
-
-    width = (*env)->GetIntField(env, target, componentIDs.width);
-    height = (*env)->GetIntField(env, target, componentIDs.height);
-    XtVaSetValues(sdata->comp.widget,
-                  XmNwidth, (width > 1) ? width-1 : 1,
-                  XmNheight, (height > 1) ? height-1 : 1,
-                  NULL);
-    XtVaSetValues(sdata->comp.widget,
-                  XmNwidth, (width > 0) ? width : 1,
-                  XmNheight, (height > 0) ? height : 1,
-                  NULL);
-    /* If it was visible, then make it visible again once updated */
-    if (was_mapped) {
-        XtSetMappedWhenManaged(sdata->comp.widget, True);
-    }
-
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MListPeer
- * Method:    pSelect
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MListPeer_select
-  (JNIEnv *env, jobject this, jint pos)
-{
-    struct ListData *sdata;
-
-    AWT_LOCK();
-    sdata = (struct ListData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (sdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    pos++;
-    XmListSelectPos(sdata->list, pos, False);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MListPeer
- * Method:    pDeselect
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MListPeer_deselect
-  (JNIEnv *env, jobject this, jint pos)
-{
-    struct ListData *sdata;
-
-    AWT_LOCK();
-    sdata = (struct ListData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (sdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    pos++;
-    XmListDeselectPos(sdata->list, pos);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MListPeer
- * Method:    makeVisible
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MListPeer_makeVisible
-  (JNIEnv *env, jobject this, jint pos)
-{
-    int32_t top, visible;
-    struct ListData *sdata;
-
-    AWT_LOCK();
-    sdata = (struct ListData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (sdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaGetValues(sdata->list,
-                  XmNtopItemPosition, &top,
-                  XmNvisibleItemCount, &visible,
-                  NULL);
-    pos++;
-    if (pos < top) {
-        XmListSetPos(sdata->list, pos);
-    } else {
-        XmListSetBottomPos(sdata->list, pos);
-    }
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MListPeer
- * Method:    nativeHandleMouseWheel
- * Signature: (III)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MListPeer_nativeHandleMouseWheel
-  (JNIEnv *env, jobject this, jint scrollType, jint scrollAmt, jint wheelAmt)
-{
-    struct ListData *ldata;
-    Widget list = NULL;
-    Widget scroll = NULL;
-
-    AWT_LOCK();
-    ldata = (struct ListData *)
-      JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (ldata == NULL || ldata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    // get the List widget
-    list = ldata->list;
-    if (list == NULL) {
-        AWT_UNLOCK();
-        return;
-    }
-
-    // get the ScrolledWindow
-    scroll = XtParent(list);
-    if (scroll == NULL) {
-        AWT_UNLOCK();
-        return;
-    }
-
-    awt_util_do_wheel_scroll(scroll, scrollType, scrollAmt, wheelAmt);
-    AWT_UNLOCK();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_MenuBar.c openjdk/jdk/src/solaris/native/sun/awt/awt_MenuBar.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_MenuBar.c	2014-04-08 05:27:03.442874969 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_MenuBar.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,198 +0,0 @@
-/*
- * Copyright (c) 1995, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "java_awt_MenuBar.h"
-#include "sun_awt_motif_MMenuBarPeer.h"
-#include "java_awt_Menu.h"
-#include "java_awt_Frame.h"
-#include "sun_awt_motif_MFramePeer.h"
-
-#include "awt_GraphicsEnv.h"
-#include "awt_MenuBar.h"
-#include "awt_Component.h"
-
-#include <jni.h>
-#include <jni_util.h>
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern struct X11GraphicsConfigIDs x11GraphicsConfigIDs;
-struct MMenuBarPeerIDs mMenuBarPeerIDs;
-
-/*
- * Class:     sun_awt_motif_MMenuBarPeer
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for MMenuBarPeer.java
-   to initialize the fieldIDs fields that may be accessed from C */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MMenuBarPeer_initIDs
-  (JNIEnv *env, jclass cls)
-{
-  mMenuBarPeerIDs.pData = (*env)->GetFieldID(env, cls, "pData", "J");
-  mMenuBarPeerIDs.graphicsConfig =
-      (*env)->GetFieldID(env, cls, "graphicsConfig",
-                         "Lsun/awt/X11GraphicsConfig;");
-}
-
-static AwtGraphicsConfigDataPtr
-copyGraphicsConfigToMenuBarPeer(
-JNIEnv *env, jobject frame, jobject thisMenuBar) {
-
-    jobject gc_object;
-    AwtGraphicsConfigDataPtr adata;
-
-    /* GraphicsConfiguration object of Component */
-    gc_object = (*env)->GetObjectField(env, frame,
-                                       mComponentPeerIDs.graphicsConfig);
-
-    if (gc_object != NULL) {
-        /* Set graphicsConfig field of MComponentPeer */
-        (*env)->SetObjectField (env, thisMenuBar,
-                                mMenuBarPeerIDs.graphicsConfig,
-                                gc_object);
-        adata = (AwtGraphicsConfigDataPtr)
-            JNU_GetLongFieldAsPtr(env, gc_object,
-                                  x11GraphicsConfigIDs.aData);
-    } else {
-        /* Component was not constructed with a GraphicsConfiguration
-           object */
-        adata = getDefaultConfig(DefaultScreen(awt_display));
-    }
-
-    return adata;
-}
-
-AwtGraphicsConfigDataPtr
-getGraphicsConfigFromMenuBarPeer(JNIEnv *env, jobject menubarPeer) {
-
-    jobject gc_object;
-    AwtGraphicsConfigDataPtr adata;
-
-    /* GraphicsConfiguration object of Component */
-    gc_object = (*env)->GetObjectField(env, menubarPeer,
-                                       mMenuBarPeerIDs.graphicsConfig);
-
-    if (gc_object != NULL) {
-        adata = (AwtGraphicsConfigDataPtr)
-            JNU_GetLongFieldAsPtr(env, gc_object,
-                                  x11GraphicsConfigIDs.aData);
-    } else {
-        adata = getDefaultConfig(DefaultScreen(awt_display));
-    }
-
-    return adata;
-}
-
-/*
- * Class:     sun_awt_motif_MMenuBarPeer
- * Method:    create
- * Signature: (Lsun/awt/motif/MFramePeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MMenuBarPeer_create
-  (JNIEnv * env, jobject this, jobject frame)
-{
-#define MAX_ARGC 20
-    Arg args[MAX_ARGC];
-    int32_t argc;
-    struct ComponentData *mdata;
-    struct FrameData *wdata;
-    Pixel bg;
-    Pixel fg;
-    AwtGraphicsConfigDataPtr adata;
-
-    if (JNU_IsNull(env, frame)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, frame, mComponentPeerIDs.pData);
-    mdata = ZALLOC(ComponentData);
-
-    if (wdata == NULL || mdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    JNU_SetLongFieldFromPtr(env, this, mMenuBarPeerIDs.pData, mdata);
-
-    adata = copyGraphicsConfigToMenuBarPeer(env, frame, this);
-
-    XtVaGetValues(wdata->winData.comp.widget,
-                  XmNbackground, &bg,
-                  XmNforeground, &fg,
-                  NULL);
-
-    argc = 0;
-    XtSetArg(args[argc], XmNbackground, bg);
-    argc++;
-    XtSetArg(args[argc], XmNforeground, fg);
-    argc++;
-    XtSetArg (args[argc], XmNscreen,
-              ScreenOfDisplay(awt_display,
-                              adata->awt_visInfo.screen));
-    argc++;
-
-    DASSERT(!(argc > MAX_ARGC));
-    mdata->widget = XmCreateMenuBar(wdata->mainWindow, "menu_bar", args, argc);
-    awt_addMenuWidget(mdata->widget);
-    XtSetMappedWhenManaged(mdata->widget, False);
-    XtManageChild(mdata->widget);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MMenuBarPeer
- * Method:    dispose
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MMenuBarPeer_pDispose
-  (JNIEnv * env, jobject this)
-{
-    struct ComponentData *mdata;
-
-    AWT_LOCK();
-
-    /*hania LOOK HERE does this make sense? look at original code */
-    mdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mMenuBarPeerIDs.pData);
-    if (mdata == NULL) {
-        AWT_UNLOCK();
-        return;
-    }
-    awt_delMenuWidget(mdata->widget);
-    XtUnmanageChild(mdata->widget);
-    awt_util_consumeAllXEvents(mdata->widget);
-    XtDestroyWidget(mdata->widget);
-    free((void *) mdata);
-    (*env)->SetLongField(env, this, mMenuBarPeerIDs.pData, (jlong)0);
-    AWT_UNLOCK();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_MenuBar.h openjdk/jdk/src/solaris/native/sun/awt/awt_MenuBar.h
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_MenuBar.h	2014-04-08 05:27:03.442874969 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_MenuBar.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/*
- * Copyright (c) 1998, 1999, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/* fieldIDs for MMenuBarPeer fields that may be accessed from C */
-struct MMenuBarPeerIDs {
-  jfieldID pData;
-  jfieldID graphicsConfig;
-};
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Menu.c openjdk/jdk/src/solaris/native/sun/awt/awt_Menu.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Menu.c	2014-04-08 05:27:03.442874969 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Menu.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,407 +0,0 @@
-/*
- * Copyright (c) 1995, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "color.h"
-#include "java_awt_Menu.h"
-#include "sun_awt_motif_MMenuPeer.h"
-#include "java_awt_MenuBar.h"
-#include "sun_awt_motif_MMenuBarPeer.h"
-
-#include "awt_MenuBar.h"
-#include "awt_MenuComponent.h"
-#include "awt_MenuItem.h"
-#include "awt_Menu.h"
-
-#include "multi_font.h"
-#include <jni.h>
-#include <jni_util.h>
-#include <Xm/CascadeBP.h>
-
-extern struct MenuComponentIDs menuComponentIDs;
-extern struct MenuItemIDs menuItemIDs;
-extern struct MMenuItemPeerIDs mMenuItemPeerIDs;
-extern struct MMenuBarPeerIDs mMenuBarPeerIDs;
-
-struct MenuIDs menuIDs;
-
-/*
- * Class:     java_awt_Menu
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for
-   Menu.java to initialize the fieldIDs for fields that may
-   be accessed from C */
-
-JNIEXPORT void JNICALL Java_java_awt_Menu_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    menuIDs.tearOff = (*env)->GetFieldID(env, cls, "tearOff", "Z");
-    menuIDs.isHelpMenu = (*env)->GetFieldID(env, cls, "isHelpMenu", "Z");
-}
-
-/*
- * Fix for Bug Traq 4251941 - segfault after double tear-off and close
- * Removes the lost callback from menu item on tear-off control re-creation.
- * Only for internal use, to be used from awtTearOffActivatedCallback
- */
-static void awtTearOffShellDestroy(Widget widget, XtPointer closure, XtPointer data) {
-    if (widget != NULL ) {
-        XtSetKeyboardFocus(widget, NULL);
-    }
-}
-
-/*
- * Fix for Bug Traq 4251941 - segfault after double tear-off and close
- * This callback is added to menu after the creation.
- * It adds the destroy callback awtTearOffShellDestroy to remove the lost focus callback on destroy
- */
-static void awtTearOffActivatedCallback(Widget widget, XtPointer closure, XtPointer data) {
-    Widget shell;
-    shell = XtParent(widget);
-    if (shell != NULL && XtClass(shell) == transientShellWidgetClass) {
-        XtAddCallback(shell, XtNdestroyCallback, awtTearOffShellDestroy, widget);
-    }
-}
-
-extern Boolean skipNextNotifyWhileGrabbed;
-
-static void
-Menu_popDownCB(Widget w, XtPointer client_data, XtPointer calldata)
-{
-    skipNextNotifyWhileGrabbed = True;
-}
-
-
-
-/*
- * this is a MMenuPeer instance
- */
-static void
-awtJNI_CreateMenu(JNIEnv * env, jobject this, Widget menuParent)
-{
-    int32_t argc;
-#define MAX_ARGC 10
-    Arg args[MAX_ARGC];
-    char *ctitle = NULL;
-    struct MenuData *mdata;
-    struct FontData *fdata;
-    Pixel bg;
-    Pixel fg;
-    XmFontList fontlist = NULL;
-    Widget tearOff;
-    XmString mfstr = NULL;
-    XmString str = NULL;
-    jobject target;
-    jobject targetFont;
-    jobject label;
-    jobject font;
-    jboolean IsMultiFont;
-    jboolean isTearOff;
-
-    /* perhaps this is unncessary, if awtJNI_CreateMenu is only called
-     * from a native method.
-     */
-    if ((*env)->PushLocalFrame(env, (jint)16) < (jint)0) {
-        return;
-    }
-
-    fdata = NULL;
-
-    target = (*env)->GetObjectField(env, this, mMenuItemPeerIDs.target);
-    if (JNU_IsNull(env, target)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        (*env)->PopLocalFrame(env, NULL);
-        return;
-    }
-    font = JNU_CallMethodByName(env, NULL, target, "getFont_NoClientCode",
-                                "()Ljava/awt/Font;").l;
-
-    mdata = ZALLOC(MenuData);
-    JNU_SetLongFieldFromPtr(env, this, mMenuItemPeerIDs.pData, mdata);
-    if (mdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        (*env)->PopLocalFrame(env, NULL);
-        return;
-    }
-    targetFont = (*env)->GetObjectField(env, target, menuComponentIDs.font);
-    if (!JNU_IsNull(env, targetFont) &&
-        (fdata = awtJNI_GetFontData(env, targetFont, NULL)) != NULL) {
-        IsMultiFont = awtJNI_IsMultiFont(env, targetFont);
-    } else {
-        IsMultiFont = awtJNI_IsMultiFont(env, font);
-    }
-
-    label = (*env)->GetObjectField(env, target, menuItemIDs.label);
-    if (JNU_IsNull(env, label)) {
-        mfstr = XmStringCreateLocalized("");
-        ctitle = "";
-    } else {
-        if (IsMultiFont) {
-            mfstr = awtJNI_MakeMultiFontString(env, label, font);
-        } else {
-            ctitle = (char *) JNU_GetStringPlatformChars(env, label, NULL);
-        }
-    }
-
-    XtVaGetValues(menuParent, XmNbackground, &bg, NULL);
-    XtVaGetValues(menuParent, XmNforeground, &fg, NULL);
-
-    argc = 0;
-    XtSetArg(args[argc], XmNbackground, bg);
-    argc++;
-    XtSetArg(args[argc], XmNforeground, fg);
-    argc++;
-
-    XtSetArg(args[argc], XmNlabelFontList,   getMotifFontList());
-    argc++;
-    XtSetArg(args[argc], XmNbuttonFontList,  getMotifFontList());
-    argc++;
-
-    isTearOff = (*env)->GetBooleanField(env, target, menuIDs.tearOff);
-
-    if (isTearOff) {
-        XtSetArg(args[argc], XmNtearOffModel, XmTEAR_OFF_ENABLED);
-        argc++;
-    }
-
-    if (IsMultiFont) {
-        DASSERT(!(argc > MAX_ARGC));
-        mdata->itemData.comp.widget = XmCreatePulldownMenu(menuParent,
-                                                           "",
-                                                           args,
-                                                           argc);
-    } else {
-        DASSERT(!(argc > MAX_ARGC));
-        mdata->itemData.comp.widget = XmCreatePulldownMenu(menuParent,
-                                                           ctitle,
-                                                           args,
-                                                           argc);
-    }
-    awt_addMenuWidget(mdata->itemData.comp.widget);
-
-    if (isTearOff) {
-        tearOff = XmGetTearOffControl(mdata->itemData.comp.widget);
-        XtVaSetValues(tearOff,
-                      XmNbackground, bg,
-                      XmNforeground, fg,
-                      XmNhighlightColor, fg,
-                      NULL);
-        XtAddCallback(mdata->itemData.comp.widget, XmNtearOffMenuActivateCallback,
-                      awtTearOffActivatedCallback, NULL);
-    }
-    argc = 0;
-    XtSetArg(args[argc], XmNsubMenuId, mdata->itemData.comp.widget);
-    argc++;
-
-    if (IsMultiFont) {
-        XtSetArg(args[argc], XmNlabelString, mfstr);
-    } else {
-        str = XmStringCreate(ctitle, XmSTRING_DEFAULT_CHARSET);
-        XtSetArg(args[argc], XmNlabelString, str);
-    }
-    argc++;
-    XtSetArg(args[argc], XmNbackground, bg);
-    argc++;
-    XtSetArg(args[argc], XmNforeground, fg);
-    argc++;
-
-    if (!JNU_IsNull(env, targetFont) && (fdata != NULL)) {
-        if (IsMultiFont) {
-            fontlist = awtJNI_GetFontList(env, targetFont);
-        } else {
-            fontlist = XmFontListCreate(fdata->xfont, "labelFont");
-        }
-        XtSetArg(args[argc], XmNfontList, fontlist);
-        argc++;
-    } else {
-        if (IsMultiFont) {
-            fontlist = awtJNI_GetFontList(env, font);
-            XtSetArg(args[argc], XmNfontList, fontlist);
-            argc++;
-        }
-    }
-
-    if (IsMultiFont) {
-        DASSERT(!(argc > MAX_ARGC));
-        mdata->comp.widget = XmCreateCascadeButton(menuParent, "", args, argc);
-    } else {
-        DASSERT(!(argc > MAX_ARGC));
-        mdata->comp.widget = XmCreateCascadeButton(menuParent, ctitle, args, argc);
-    }
-
-    if ((*env)->GetBooleanField(env, target, menuIDs.isHelpMenu)) {
-        XtVaSetValues(menuParent,
-                      XmNmenuHelpWidget, mdata->comp.widget,
-                      NULL);
-    }
-
-    /**
-     * Add callback to MenuShell of the menu so we know when
-     * menu pops down. mdata->itemData.comp.widget is RowColumn,
-     * its parent - MenuShell.
-     */
-    XtAddCallback(XtParent(mdata->itemData.comp.widget), XtNpopdownCallback,
-                  Menu_popDownCB,
-                  (XtPointer)
-                  JNU_GetLongFieldAsPtr(env, this,
-                                        mMenuItemPeerIDs.jniGlobalRef));
-
-    /*
-     * Free resources
-     */
-    if (!JNU_IsNull(env, targetFont)) {
-        XmFontListFree(fontlist);
-    }
-
-    if (mfstr != NULL) {
-      XmStringFree(mfstr);
-      mfstr = NULL;
-    }
-
-    if (str) {
-      XmStringFree(str);
-      str = NULL;
-    }
-
-    XtManageChild(mdata->comp.widget);
-    XtSetSensitive(mdata->comp.widget,
-                   (*env)->GetBooleanField(env, target, menuItemIDs.enabled) ?
-                   True : False);
-
-    if (ctitle != NULL && ctitle != "") {
-        JNU_ReleaseStringPlatformChars(env, label, (const char *) ctitle);
-    }
-    (*env)->PopLocalFrame(env, NULL);
-}
-
-
-/*
- * Class:     sun_awt_motif_MMenuPeer
- * Method:    createMenu
- * Signature: (Lsun/awt/motif/MMenuBarPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MMenuPeer_createMenu
-  (JNIEnv *env, jobject this, jobject parent)
-{
-    struct ComponentData *mbdata;
-    AwtGraphicsConfigDataPtr adata;
-
-    AWT_LOCK();
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    mbdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, parent, mMenuBarPeerIDs.pData);
-    if (mbdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    awtJNI_CreateMenu(env, this, mbdata->widget);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MMenuPeer
- * Method:    createSubMenu
- * Signature: (Lsun/awt/motif/MMenuPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MMenuPeer_createSubMenu
-(JNIEnv *env, jobject this, jobject parent)
-{
-    struct MenuData *mpdata;
-    AwtGraphicsConfigDataPtr adata;
-
-    AWT_LOCK();
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    mpdata = (struct MenuData *)
-        JNU_GetLongFieldAsPtr(env, parent, mMenuItemPeerIDs.pData);
-    if (mpdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    awtJNI_CreateMenu(env, this, mpdata->itemData.comp.widget);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MMenuPeer
- * Method:    pDispose
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MMenuPeer_pDispose
-  (JNIEnv *env, jobject this)
-{
-    struct MenuData *mdata;
-    Widget parent;
-    Boolean isParentManaged = False;
-
-    AWT_LOCK();
-
-    mdata = (struct MenuData *)
-        JNU_GetLongFieldAsPtr(env, this, mMenuItemPeerIDs.pData);
-    if (mdata == NULL) {
-        AWT_UNLOCK();
-        return;
-    }
-    awt_delMenuWidget(mdata->itemData.comp.widget);
-    XtUnmanageChild(mdata->comp.widget);
-    awt_util_consumeAllXEvents(mdata->itemData.comp.widget);
-    awt_util_consumeAllXEvents(mdata->comp.widget);
-
-    parent = XtParent(mdata->itemData.comp.widget);
-    if (parent != NULL && XtIsManaged(parent)) {
-        isParentManaged = True;
-        XtUnmanageChild(parent);
-    }
-
-    XtDestroyWidget(mdata->itemData.comp.widget);
-
-    if (isParentManaged) {
-        XtManageChild(parent);
-    }
-
-    XtDestroyWidget(mdata->comp.widget);
-    free((void *) mdata);
-    AWT_UNLOCK();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_MenuComponent.c openjdk/jdk/src/solaris/native/sun/awt/awt_MenuComponent.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_MenuComponent.c	2014-04-08 05:27:03.442874969 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_MenuComponent.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "java_awt_MenuComponent.h"
-#include "jni_util.h"
-
-#include "awt_MenuComponent.h"
-
-struct MenuComponentIDs menuComponentIDs;
-
-
-JNIEXPORT void JNICALL
-Java_java_awt_MenuComponent_initIDs(JNIEnv *env, jclass cls)
-{
-    menuComponentIDs.font =
-      (*env)->GetFieldID(env, cls, "font", "Ljava/awt/Font;");
-    menuComponentIDs.appContext =
-      (*env)->GetFieldID(env, cls, "appContext", "Lsun/awt/AppContext;");
-    menuComponentIDs.getParent =
-      (*env)->GetMethodID(
-          env, cls, "getParent_NoClientCode", "()Ljava/awt/MenuContainer;");
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Menu.h openjdk/jdk/src/solaris/native/sun/awt/awt_Menu.h
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Menu.h	2014-04-08 05:27:03.442874969 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Menu.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-/*
- * Copyright (c) 1998, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include <jni_util.h>
-
-/* fieldIDs for Menu fields that may be accessed from C */
-struct MenuIDs {
-    jfieldID tearOff;
-    jfieldID isHelpMenu;
-};
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_MenuItem.c openjdk/jdk/src/solaris/native/sun/awt/awt_MenuItem.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_MenuItem.c	2014-04-08 05:27:03.446875029 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_MenuItem.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,654 +0,0 @@
-/*
- * Copyright (c) 1995, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include <Xm/Separator.h>
-#include "java_awt_MenuItem.h"
-#include "sun_awt_motif_MMenuItemPeer.h"
-#include "sun_awt_motif_MCheckboxMenuItemPeer.h"
-#include "java_awt_Menu.h"
-#include "sun_awt_motif_MMenuPeer.h"
-
-#include "awt_MenuComponent.h"
-#include "awt_MenuItem.h"
-
-#include "multi_font.h"
-#include <jni.h>
-#include <jni_util.h>
-#include <jlong.h>
-
-extern struct MenuComponentIDs menuComponentIDs;
-
-/* fieldIDs for MenuItem fields that may be accessed from C */
-struct MenuItemIDs menuItemIDs;
-
-/*
- * Class:     java_awt_MenuItem
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for
-   MenuItem.java to initialize the fieldIDs for fields that may
-   be accessed from C */
-
-JNIEXPORT void JNICALL Java_java_awt_MenuItem_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    menuItemIDs.label =
-      (*env)->GetFieldID(env, cls, "label", "Ljava/lang/String;");
-    menuItemIDs.enabled =
-      (*env)->GetFieldID(env, cls, "enabled", "Z");
-    menuItemIDs.shortcut =
-      (*env)->GetFieldID(env, cls, "shortcut", "Ljava/awt/MenuShortcut;");
-}
-
-/* fieldIDs for MMenuItemPeer fields that may be accessed from C */
-struct MMenuItemPeerIDs mMenuItemPeerIDs;
-
-/*
- * Class:     sun_awt_motif_MMenuItemPeer
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for
-   MMenuItemPeer.java to initialize the fieldIDs for fields that may
-   be accessed from C */
-
-JNIEXPORT void JNICALL Java_sun_awt_motif_MMenuItemPeer_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    mMenuItemPeerIDs.target =
-      (*env)->GetFieldID(env, cls, "target", "Ljava/awt/MenuItem;");
-    mMenuItemPeerIDs.pData = (*env)->GetFieldID(env, cls, "pData", "J");
-    mMenuItemPeerIDs.isCheckbox =
-      (*env)->GetFieldID(env, cls, "isCheckbox", "Z");
-    mMenuItemPeerIDs.jniGlobalRef =
-      (*env)->GetFieldID(env, cls, "jniGlobalRef", "J");
-}
-
-/*
- * Class:     sun_awt_motif_MMenuItemPeer
- * Method:    getParent_NoClientCode
- * Signature: (Ljava/awt/MenuComponent;)Ljava/awt/MenuContainer;
- *
- * Gets the MenuContainer parent of this object, without executing client
- * code (e.g., no code in subclasses will be executed).
- */
-JNIEXPORT jobject JNICALL Java_sun_awt_motif_MMenuItemPeer_getParent_1NoClientCode
-  (JNIEnv *env, jclass thisClass, jobject menuComponent)
-{
-    jobject parent = NULL;
-
-    /* getParent is actually getParent_NoClientCode() */
-    parent = (*env)->CallObjectMethod(
-                        env,menuComponent,menuComponentIDs.getParent);
-    DASSERT(!((*env)->ExceptionOccurred(env)));
-    return parent;
-}
-
-/*
- *  client_data is MMenuItemPeer instance pointer
- */
-static void
-MenuItem_selected(Widget w, XtPointer client_data, XmAnyCallbackStruct * s)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject this = (jobject) client_data;
-    ConvertEventTimeAndModifiers converted;
-
-    awt_util_convertEventTimeAndModifiers(s->event, &converted);
-
-    if ((*env)->GetBooleanField(env, this, mMenuItemPeerIDs.isCheckbox)) {
-        jboolean state;
-        struct MenuItemData *mdata;
-
-        mdata = (struct MenuItemData *)
-          JNU_GetLongFieldAsPtr(env, this, mMenuItemPeerIDs.pData);
-
-        if (mdata != NULL) {
-            XtVaGetValues(mdata->comp.widget, XmNset, &state, NULL);
-
-            JNU_CallMethodByName(env, NULL, this
-                                 ,"action"
-                                 ,"(JIZ)V"
-                                 ,converted.when, converted.modifiers,
-                                 state);
-            if ((*env)->ExceptionOccurred(env)) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-            }
-        }
-    } else {
-        JNU_CallMethodByName(env, NULL, this, "action", "(JI)V",
-                             converted.when, converted.modifiers);
-        if ((*env)->ExceptionOccurred(env)) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-    }
-}
-
-/*
- * Class:     sun_awt_motif_MMenuItemPeer
- * Method:    createMenuItem
- * Signature: (Lsun/awt/motif/MMenuPeer;)V
- *
- * ASSUMES: This function is never called by a privileged thread
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MMenuItemPeer_createMenuItem(
-JNIEnv *env, jobject this, jobject parent)
-{
-    int32_t argc;
-#define MAX_ARGC 20
-    Arg args[MAX_ARGC];
-    char *clabel;
-    struct MenuData *menuData;
-    struct MenuItemData *mdata;
-    struct FontData *fdata;
-    Pixel bg;
-    Pixel fg;
-    XmFontList fontlist = NULL;
-    jobject target;
-    jobject targetFont;
-    XmString mfstr = NULL;
-    XmString shortcut_str = NULL;
-    XmString str = NULL;
-    jobject font;
-    jobject shortcut;
-    jboolean IsMultiFont;
-    jboolean isCheckbox;
-    jstring label;
-    jobject globalRef = (*env)->NewGlobalRef(env, this);
-    const jchar *unicodeLabel = NULL;
-    jsize unicodeLabelLen = 0;
-    jboolean isCopy = JNI_FALSE;
-
-    // We call client code on this thread, so it must *NOT* be privileged
-    DASSERT(!awt_currentThreadIsPrivileged(env));
-
-    JNU_SetLongFieldFromPtr(env, this, mMenuItemPeerIDs.jniGlobalRef,
-                            globalRef);
-
-    fdata = NULL;
-
-    fflush(stderr);
-    target =
-      (*env)->GetObjectField(env, this, mMenuItemPeerIDs.target);
-    if (JNU_IsNull(env, target)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    font = JNU_CallMethodByName(env, NULL, target, "getFont_NoClientCode",
-                                "()Ljava/awt/Font;").l;
-
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-    menuData = (struct MenuData *)
-      JNU_GetLongFieldAsPtr(env, parent, mMenuItemPeerIDs.pData);
-
-    targetFont =
-      (*env)->GetObjectField(env, target, menuComponentIDs.font);
-    if (!JNU_IsNull(env, targetFont) &&
-        (fdata = awtJNI_GetFontData(env, targetFont, NULL)) != NULL) {
-        IsMultiFont = awtJNI_IsMultiFont(env, targetFont);
-    } else {
-        IsMultiFont = awtJNI_IsMultiFont(env, font);
-    }
-
-    label = (*env)->GetObjectField(env, target, menuItemIDs.label);
-    if (JNU_IsNull(env, label) || ((*env)->GetStringLength (env, label) == 0)) {
-        mfstr = XmStringCreateLocalized("");
-        clabel = "";
-    } else {
-        if (IsMultiFont) {
-            mfstr = awtJNI_MakeMultiFontString(env, label, font);
-        } else {
-            mfstr = XmStringCreateLocalized("");
-        }
-        clabel = (char *) JNU_GetStringPlatformChars(env, label, NULL);
-    }
-
-    mdata = ZALLOC(MenuItemData);
-    JNU_SetLongFieldFromPtr(env, this, mMenuItemPeerIDs.pData, mdata);
-
-    argc = 0;
-    XtSetArg(args[argc], XmNbackground, &bg);
-    argc++;
-    XtSetArg(args[argc], XmNforeground, &fg);
-    argc++;
-    XtGetValues(menuData->itemData.comp.widget, args, argc);
-
-    argc = 0;
-    XtSetArg(args[argc], XmNbackground, bg);
-    argc++;
-    XtSetArg(args[argc], XmNforeground, fg);
-    argc++;
-
-    /* check if the label is "-" but don't use strcmp(clabel, "-") because
-     * the high-order bytes in the unicode characters are not present in
-     * the C string (bugid 4099695)
-     */
-    if (!JNU_IsNull(env, label)) {
-        unicodeLabel = (*env)->GetStringChars(env, label, &isCopy);
-        unicodeLabelLen = (*env)->GetStringLength(env, label);
-    }
-    if ((unicodeLabel != NULL) && (unicodeLabel[0] == '-') &&
-        (unicodeLabelLen == 1)) {
-        DASSERT(!(argc > MAX_ARGC));
-        mdata->comp.widget = XmCreateSeparator(menuData->itemData.comp.widget,
-                                               "", args, argc);
-    } else {
-        if (IsMultiFont) {
-            XtSetArg(args[argc], XmNlabelString, mfstr);
-        } else {
-            str = XmStringCreate(clabel, XmSTRING_DEFAULT_CHARSET);
-            XtSetArg(args[argc], XmNlabelString, str);
-        }
-        argc++;
-
-        shortcut =
-          (*env)->GetObjectField(env, target, menuItemIDs.shortcut);
-        if (!JNU_IsNull(env, shortcut)) {
-            jstring shortcutText;
-            char *text = "";
-
-            shortcutText = JNU_CallMethodByName(env, NULL, shortcut,
-                                                "toString",
-                                                "()Ljava/lang/String;").l;
-
-            if (!JNU_IsNull(env, shortcutText)) {
-                text = (char *) JNU_GetStringPlatformChars(env, shortcutText, NULL);
-            }
-            shortcut_str = XmStringCreate(text, XmSTRING_DEFAULT_CHARSET);
-            XtSetArg(args[argc], XmNacceleratorText, shortcut_str);
-
-            argc++;
-
-            if (!JNU_IsNull(env, shortcutText)) {
-                JNU_ReleaseStringPlatformChars(env, shortcutText, (const char *) text);
-            }
-        }
-        if (!JNU_IsNull(env, targetFont) && (fdata != NULL)) {
-            if (IsMultiFont) {
-                fontlist = awtJNI_GetFontList(env, targetFont);
-            } else {
-                fontlist = XmFontListCreate(fdata->xfont, "labelFont");
-            }
-            XtSetArg(args[argc], XmNfontList, fontlist);
-            argc++;
-        } else {
-            if (IsMultiFont) {
-                fontlist = awtJNI_GetFontList(env, font);
-                XtSetArg(args[argc], XmNfontList, fontlist);
-                argc++;
-            }
-        }
-
-        isCheckbox =
-          (*env)->GetBooleanField(env, this, mMenuItemPeerIDs.isCheckbox);
-        if (isCheckbox) {
-            /* Fix for 4090493 */
-            if (IsMultiFont) {
-                /* FontData that correspond to XmNfontList we just set */
-                struct FontData *fdataForIndSize;
-                Dimension indSize;
-                if (!JNU_IsNull(env, targetFont) && (fdata != NULL)) {
-                    fdataForIndSize = fdata;
-                }
-                else {
-                fdataForIndSize = awtJNI_GetFontData(env, font, NULL);
-                }
-                indSize = awt_adjustIndicatorSizeForMenu(awt_computeIndicatorSize(fdataForIndSize));
-                if (indSize != MOTIF_XmINVALID_DIMENSION) {
-                    XtSetArg(args[argc], XmNindicatorSize, indSize); argc++;
-                }
-            }
-            /* End of fix for 4090493 */
-            XtSetArg(args[argc], XmNset, False);
-            argc++;
-            XtSetArg(args[argc], XmNvisibleWhenOff, True);
-            argc++;
-
-            DASSERT(!(argc > MAX_ARGC));
-            mdata->comp.widget = XmCreateToggleButton(menuData->itemData.comp.widget,
-                                                      clabel,
-                                                      args,
-                                                      argc);
-        } else {
-            DASSERT(!(argc > MAX_ARGC));
-            mdata->comp.widget = XmCreatePushButton(menuData->itemData.comp.widget,
-                                                    clabel,
-                                                    args,
-                                                    argc);
-        }
-        XtAddCallback(mdata->comp.widget,
-                      ((isCheckbox) ? XmNvalueChangedCallback : XmNactivateCallback),
-                      (XtCallbackProc) MenuItem_selected,
-                      (XtPointer) globalRef);
-
-        XtSetSensitive(mdata->comp.widget,
-          (*env)->GetBooleanField(env, target, menuItemIDs.enabled) ?
-                       True : False);
-
-
-        if (!JNU_IsNull(env, targetFont)) {
-            XmFontListFree(fontlist);
-        }
-    }
-
-    if (clabel && (clabel != "")) {
-        JNU_ReleaseStringPlatformChars(env, label, clabel);
-    }
-
-    /*
-     * Free up resources after we have created the widget
-     */
-    if (mfstr != NULL) {
-      XmStringFree(mfstr);
-      mfstr = NULL;
-    }
-    if (str) {
-      XmStringFree(str);
-      str = NULL;
-    }
-    if (shortcut_str) {
-      XmStringFree(shortcut_str);
-      shortcut_str = NULL;
-    }
-    if (isCopy == JNI_TRUE) {
-        (*env)->ReleaseStringChars(env, label, unicodeLabel);
-    }
-
-    XtManageChild(mdata->comp.widget);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MMenuItemPeer
- * Method:    pSetLabel
- * Signature: (Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MMenuItemPeer_pSetLabel
-(JNIEnv *env, jobject this, jstring label)
-{
-    struct ComponentData *wdata;
-    char *clabel;
-    XmString xim;
-
-    AWT_LOCK();
-    wdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mMenuItemPeerIDs.pData);
-    if (wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (JNU_IsNull(env, label) || ((*env)->GetStringLength (env, label) == 0)) {
-        xim = XmStringCreateLocalized("");
-    } else {
-        jobject font;
-        jobject target;
-
-        target = (*env)->GetObjectField(env, this, mMenuItemPeerIDs.target);
-        if (JNU_IsNull(env, target)) {
-            JNU_ThrowNullPointerException(env, "NullPointerException");
-            AWT_UNLOCK();
-            return;
-        }
-        font = JNU_CallMethodByName(env, NULL, target, "getFont_NoClientCode",
-                                    "()Ljava/awt/Font;").l;
-
-        if (awtJNI_IsMultiFont(env, font)) {
-            xim = awtJNI_MakeMultiFontString(env, label, font);
-        } else {
-            clabel = (char *) JNU_GetStringPlatformChars(env, label, NULL);
-            xim = XmStringCreate(clabel, "labelFont");
-            JNU_ReleaseStringPlatformChars(env, label, clabel);
-        }
-    }
-    XtUnmanageChild(wdata->widget);
-    XtVaSetValues(wdata->widget, XmNlabelString, xim, NULL);
-    XtManageChild(wdata->widget);
-    XmStringFree(xim);
-    AWT_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_MMenuItemPeer
- * Method:    pSetShortCut
- * Signature: (Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MMenuItemPeer_pSetShortcut
-(JNIEnv *env, jobject this, jstring shortcut)
-{
-    struct ComponentData *wdata;
-    char *cshortcut;
-    XmString xim;
-
-
-    AWT_LOCK();
-    wdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mMenuItemPeerIDs.pData);
-    if (wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (JNU_IsNull(env, shortcut)) {
-        xim = XmStringCreateLocalized("");
-    } else {
-        jobject font;
-        jobject target;
-
-        target = (*env)->GetObjectField(env, this, mMenuItemPeerIDs.target);
-        if (JNU_IsNull(env, target)) {
-            JNU_ThrowNullPointerException(env, "NullPointerException");
-            AWT_UNLOCK();
-            return;
-        }
-        font = JNU_CallMethodByName(env, NULL, target, "getFont_NoClientCode",
-                                    "()Ljava/awt/Font;").l;
-
-        if (awtJNI_IsMultiFont(env, font)) {
-            xim = awtJNI_MakeMultiFontString(env, shortcut, font);
-        } else {
-            cshortcut = (char *) JNU_GetStringPlatformChars(env, shortcut, NULL);
-            xim = XmStringCreate(cshortcut, "labelFont");
-            JNU_ReleaseStringPlatformChars(env, shortcut, cshortcut);
-        }
-    }
-
-    XtUnmanageChild(wdata->widget);
-    XtVaSetValues(wdata->widget, XmNacceleratorText, xim, NULL);
-    XtManageChild(wdata->widget);
-    XmStringFree(xim);
-    AWT_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_MMenuItemPeer
- * Method:    pEnable
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MMenuItemPeer_pEnable
-(JNIEnv *env, jobject this)
-{
-    struct MenuItemData *mdata;
-
-    AWT_LOCK();
-
-    mdata = (struct MenuItemData *)
-        JNU_GetLongFieldAsPtr(env, this, mMenuItemPeerIDs.pData);
-
-    if (mdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtSetSensitive(mdata->comp.widget, True);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MMenuItemPeer
- * Method:    pDisable
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MMenuItemPeer_pDisable
-(JNIEnv *env, jobject this)
-{
-    struct MenuItemData *mdata;
-
-    AWT_LOCK();
-
-    mdata = (struct MenuItemData *)
-        JNU_GetLongFieldAsPtr(env, this, mMenuItemPeerIDs.pData);
-
-    if (mdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtSetSensitive(mdata->comp.widget, False);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MMenuItemPeer
- * Method:    pDispose
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MMenuItemPeer_pDispose
-(JNIEnv *env, jobject this)
-{
-    struct MenuItemData *mdata;
-    Widget parent;
-    Boolean isParentManaged = False;
-
-    AWT_LOCK();
-
-    mdata = (struct MenuItemData *)
-        JNU_GetLongFieldAsPtr(env, this, mMenuItemPeerIDs.pData);
-
-    if (mdata != NULL) {
-        /* Fix for 4280561:Workspace freezes, does not respond to mouse clicks
-        **
-        ** this really helps a lot of Fujitsu problems, take down a popup
-        ** menu when removing items, on windows you could never get here, since
-        ** the show() of a popup menu puts it in a menu loop where further
-        ** events are processed in that loop, its like a modal dialog show,
-        ** in that it dosn't return till it comes down.
-        ** in X - future xevents will be dispatched immeadiatly, but some
-        ** may be still waiting on the java queue - which can cause them to be
-        ** dispatched out of order (sometimes hanging system !)
-        */
-        /* note: should realy only take down if XtParent(mdata->comp.widget)
-        ** is the activePopup (in awt_PopupMenu.c) but ...
-        */
-        {
-            removePopupMenus();
-        }
-        XtUnmanageChild(mdata->comp.widget);
-        awt_util_consumeAllXEvents(mdata->comp.widget);
-
-        parent = XtParent(mdata->comp.widget);
-        if (parent != NULL && XtIsManaged(parent)) {
-            isParentManaged = True;
-            XtUnmanageChild(parent);
-        }
-
-        XtDestroyWidget(mdata->comp.widget);
-
-        if (isParentManaged) {
-            XtManageChild(parent);
-        }
-
-        free((void *) mdata);
-        (*env)->SetLongField(env, this, mMenuItemPeerIDs.pData, (jlong)0);
-        awtJNI_DeleteGlobalMenuRef(env, this);
-    }
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MCheckboxMenuItemPeer
- * Method:    pSetState
- * Signature: (Z)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MCheckboxMenuItemPeer_pSetState
-  (JNIEnv *env, jobject this, jboolean state)
-{
-    struct MenuItemData *mdata;
-
-    AWT_LOCK();
-
-    mdata = (struct MenuItemData *)
-        JNU_GetLongFieldAsPtr(env, this, mMenuItemPeerIDs.pData);
-
-    if (mdata == NULL) {
-        JNU_ThrowNullPointerException(env, "menuitem data is null");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaSetValues(mdata->comp.widget, XmNset, (Boolean)state, NULL);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MCheckboxMenuItemPeer
- * Method:    getState
- * Signature: ()Z
- */
-JNIEXPORT jboolean JNICALL Java_sun_awt_motif_MCheckboxMenuItemPeer_getState
-  (JNIEnv *env, jobject this)
-{
-    struct MenuItemData *mdata;
-    Boolean             state;
-
-    AWT_LOCK();
-
-    mdata = (struct MenuItemData *)
-      (*env)->GetLongField(env, this, mMenuItemPeerIDs.pData);
-
-    if (mdata == NULL) {
-        JNU_ThrowNullPointerException(env, "menuitem data is null");
-        AWT_UNLOCK();
-        return JNI_FALSE;
-    }
-    XtVaGetValues(mdata->comp.widget, XmNset, &state, NULL);
-    AWT_UNLOCK();
-    return ((state) ? JNI_TRUE : JNI_FALSE);
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_motif12.c openjdk/jdk/src/solaris/native/sun/awt/awt_motif12.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_motif12.c	2014-04-08 05:27:03.462875264 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_motif12.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,435 +0,0 @@
-/*
- * Copyright (c) 2000, 2001, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#if MOTIF_VERSION!=1
-    #error This file should only be compiled with motif 1.2
-#endif
-
-#include "awt_motif.h"
-#include <Xm/VendorSEP.h>
-#include <Xm/DragCP.h>
-#include "debug_util.h"
-#include "awt.h"
-
-/*
- * awt_motif_getIMStatusHeight is a cut and paste of the ImGetGeo() function
- * found in CDE Motif's Xm/XmIm.c.  It returns the height of the Input Method
- * Status region attached to the given VendorShell.  This is needed in order
- * to calculate geometry for Frames and Dialogs that contain TextField or
- * TextArea widgets.
- *
- * BCB: Copying this function out of the Motif source is a horrible
- * hack. Unfortunately, Motif tries to hide the existence of the IM Status
- * region from us so it does not provide any public way to get this info.
- * Clearly a better long term solution needs to be found.
- */
-
-typedef struct _XmICStruct {
-    struct _XmICStruct *next;
-    Widget icw;
-    Window focus_window;
-    XtArgVal foreground;
-    XtArgVal background;
-    XtArgVal background_pixmap;
-    XtArgVal font_list;
-    XtArgVal line_space;
-    int32_t status_width;
-    int32_t status_height;
-    int32_t preedit_width;
-    int32_t preedit_height;
-    Boolean has_focus;
-    Boolean need_reset;
-}   XmICStruct;
-
-typedef struct {
-    Widget im_widget;
-    XIMStyle input_style;
-    XIC xic;
-    int32_t status_width;
-    int32_t status_height;
-    int32_t preedit_width;
-    int32_t preedit_height;
-    XmICStruct *iclist;
-    XmICStruct *current;
-}   XmImInfo;
-
-static XFontSet extract_fontset(XmFontList);
-static XmICStruct *get_iclist(Widget);
-
-#define MAXARGS 10
-static Arg xic_vlist[MAXARGS];
-static Arg status_vlist[MAXARGS];
-static Arg preedit_vlist[MAXARGS];
-
-#define NO_ARG_VAL -1
-#define SEPARATOR_HEIGHT 2
-
-
-#ifdef MOTIF_2_1_HACK
-/* To shut up warning messages from "cc -v"
- *   Copied from Solaris 2.6 /usr/dt/include/Xm/BaseClassP.h and not
- *     there in Solaris 7.
- */
-#if defined(__SunOS_5_7) || defined(__SunOS_5_8)
-extern XmWidgetExtData _XmGetWidgetExtData(Widget, unsigned char);
-#endif
-
-#else
-
-/*
-   The following defines are to make the XmImGetXIC to compile on systems
-   lower than SunOS 5.7, so therefore the following is a copy of the
-   defines on SunOS 5.7/Motif2.1 header files.
-*/
-/*#if defined (__SunOS_5_5_1) || defined (__SunOS_5_6)*/
-#define XmPER_SHELL 0
-
-extern XIC XmImGetXIC(
-                        Widget          w,
-                        unsigned int    input_policy,
-                        ArgList         args,
-                        Cardinal        num_args) ;
-#endif
-
-static XmICStruct *
-get_iclist(Widget w)
-{
-    Widget p;
-    XmVendorShellExtObject ve;
-    XmWidgetExtData extData;
-    XmImInfo *im_info;
-
-    p = w;
-    while (!XtIsShell(p))
-        p = XtParent(p);
-
-    extData = (XmWidgetExtData)_XmGetWidgetExtData((Widget) p, XmSHELL_EXTENSION);
-    if (extData == NULL)
-        return NULL;
-
-    ve = (XmVendorShellExtObject) extData->widget;
-    if ((im_info = (XmImInfo *) ve->vendor.im_info) == NULL)
-        return NULL;
-    else
-        return im_info->iclist;
-}
-
-int32_t
-awt_motif_getIMStatusHeight(Widget vw, jobject tc)
-{
-    XmICStruct *icp;
-    XmVendorShellExtObject ve;
-    XmWidgetExtData extData;
-    XmImInfo *im_info;
-    int32_t width = 0;
-    int32_t height = 0;
-    XRectangle rect;
-    XRectangle *rp;
-    int32_t old_height;
-    Arg args[1];
-    int32_t base_height;
-    XFontSet fs;
-    XFontSet fss = NULL;
-    XFontSet fsp = NULL;
-
-    extData = (XmWidgetExtData)_XmGetWidgetExtData((Widget) vw, XmSHELL_EXTENSION);
-    ve = (XmVendorShellExtObject) extData->widget;
-
-    if ((icp = get_iclist(vw)) == NULL) {
-        ve->vendor.im_height = 0;
-        return 0;
-    }
-    im_info = (XmImInfo *) ve->vendor.im_info;
-    if (im_info->xic == NULL) {
-        ve->vendor.im_height = 0;
-        return 0;
-    }
-    status_vlist[0].name = XNFontSet;
-    status_vlist[1].name = NULL;
-    preedit_vlist[0].name = XNFontSet;
-    preedit_vlist[1].name = NULL;
-
-    xic_vlist[0].name = XNAreaNeeded;
-    xic_vlist[1].name = NULL;
-
-    im_info->status_width = 0;
-    im_info->status_height = 0;
-    im_info->preedit_width = 0;
-    im_info->preedit_height = 0;
-    for (; icp != NULL; icp = icp->next) {
-        if (im_info->input_style & XIMStatusArea) {
-            if (icp->status_height == 0) {
-                char *ret;
-
-                if (icp->font_list == NO_ARG_VAL ||
-                    (fss = extract_fontset((XmFontList) icp->font_list)) == NULL)
-                    continue;
-
-                status_vlist[0].value = (XtArgVal) fss;
-                XSetICValues(im_info->xic,
-                             XNStatusAttributes, &status_vlist[0],
-                             NULL);
-
-                xic_vlist[0].value = (XtArgVal) & rp;
-                ret = XGetICValues(im_info->xic,
-                                   XNStatusAttributes, &xic_vlist[0],
-                                   NULL);
-
-                if (ret) {
-                    /* Cannot obtain XIC value. IM server may be gone. */
-                    ve->vendor.im_height = 0;
-                    return 0;
-                } else {
-                    icp->status_width = rp->width;
-                    icp->status_height = rp->height;
-                    XFree(rp);
-                }
-            }
-            if (icp->status_width > im_info->status_width)
-                im_info->status_width = icp->status_width;
-            if (icp->status_height > im_info->status_height)
-                im_info->status_height = icp->status_height;
-        }
-        if (im_info->input_style & XIMPreeditArea) {
-            if (icp->preedit_height == 0) {
-                if (icp->font_list == NO_ARG_VAL ||
-                    (fsp = extract_fontset((XmFontList) icp->font_list)) == NULL)
-                    continue;
-
-                preedit_vlist[0].value = (XtArgVal) fsp;
-                XSetICValues(im_info->xic,
-                             XNPreeditAttributes, &preedit_vlist[0],
-                             NULL);
-
-                xic_vlist[0].value = (XtArgVal) & rp;
-                XGetICValues(im_info->xic,
-                             XNPreeditAttributes, &xic_vlist[0],
-                             NULL);
-
-                icp->preedit_width = rp->width;
-                icp->preedit_height = rp->height;
-                XFree(rp);
-            }
-            if (icp->preedit_width > im_info->preedit_width)
-                im_info->preedit_width = icp->preedit_width;
-            if (icp->preedit_height > im_info->preedit_height)
-                im_info->preedit_height = icp->preedit_height;
-        }
-    }
-
-    if (im_info->current != NULL && (fss != NULL || fsp != NULL)) {
-        if (im_info->current->font_list != NO_ARG_VAL &&
-            (fs = extract_fontset((XmFontList) im_info->current->font_list))
-            != NULL) {
-            if (fss != NULL)
-                status_vlist[0].value = (XtArgVal) fs;
-            else
-                status_vlist[0].name = NULL;
-            if (fsp != NULL)
-                preedit_vlist[0].value = (XtArgVal) fs;
-            else
-                preedit_vlist[0].name = NULL;
-            XSetICValues(im_info->xic,
-                         XNStatusAttributes, &status_vlist[0],
-                         XNPreeditAttributes, &preedit_vlist[0],
-                         NULL);
-        }
-    }
-    if (im_info->status_height > im_info->preedit_height)
-        height = im_info->status_height;
-    else
-        height = im_info->preedit_height;
-    old_height = ve->vendor.im_height;
-    if (height)
-        height += SEPARATOR_HEIGHT;
-
-    ve->vendor.im_height = height;
-
-    XtSetArg(args[0], XtNbaseHeight, &base_height);
-    XtGetValues(vw, args, 1);
-    if (base_height < 0)
-        base_height = 0;
-    XtSetArg(args[0], XtNbaseHeight, base_height);
-    XtSetValues(vw, args, 1);
-    return height;
-}
-static XRectangle geometryRect;
-XVaNestedList awt_motif_getXICStatusAreaList(Widget w, jobject tc)
-{
-    Widget p;
-    XmVendorShellExtObject ve;
-    XmWidgetExtData extData;
-    XmImInfo *im_info;
-    XmICStruct *icp;
-
-    XVaNestedList list = NULL;
-    XRectangle  *ssgeometry = &geometryRect;
-    Pixel  bg;
-    Pixel  fg;
-    Pixmap bpm;
-    Dimension height,width;
-    Position  x,y;
-
-    p = w;
-    while (!XtIsShell(p)){
-        p = XtParent(p);
-    }
-
-    XtVaGetValues(p,
-                  XmNx, &x,
-                  XmNy, &y,
-                  XmNwidth, &width,
-                  XmNheight, &height,
-                  NULL);
-
-    extData = (XmWidgetExtData)_XmGetWidgetExtData((Widget) p, XmSHELL_EXTENSION);
-    if (extData == NULL) {
-        return NULL;
-    }
-
-    ve = (XmVendorShellExtObject) extData->widget;
-    if ((im_info = (XmImInfo *) ve->vendor.im_info) == NULL) {
-        return NULL;
-    } else
-        icp = im_info->iclist;
-
-
-    if (icp) {
-        /*
-         * We hava at least a textfield/textarea in the frame, use the
-         * first one.
-         */
-        ssgeometry->x = 0;
-        ssgeometry->y = height - icp->status_height;
-        ssgeometry->width = icp->status_width;
-        ssgeometry->height = icp->status_height;
-
-        /*
-         * use motif TextComponent's resource
-         */
-        fg = icp->foreground;
-        bg = icp->background;
-        bpm = icp->background_pixmap;
-
-        list = XVaCreateNestedList(0,
-                        XNFontSet, extract_fontset((XmFontList)icp->font_list),
-                        XNArea, ssgeometry,
-                        XNBackground, bg,
-                        XNForeground, fg,
-                        XNBackgroundPixmap, bpm,
-                        NULL);
-   }
-    return list ;
-}
-
-static XFontSet
-extract_fontset(XmFontList fl)
-{
-    XmFontContext context;
-    XmFontListEntry next_entry;
-    XmFontType type_return;
-    XtPointer tmp_font;
-    XFontSet first_fs = NULL;
-    char *font_tag;
-
-    if (!XmFontListInitFontContext(&context, fl))
-        return NULL;
-
-    do {
-        next_entry = XmFontListNextEntry(context);
-        if (next_entry) {
-            tmp_font = XmFontListEntryGetFont(next_entry, &type_return);
-            if (type_return == XmFONT_IS_FONTSET) {
-                font_tag = XmFontListEntryGetTag(next_entry);
-                if (!strcmp(font_tag, XmFONTLIST_DEFAULT_TAG)) {
-                    XmFontListFreeFontContext(context);
-                    XtFree(font_tag);
-                    return (XFontSet) tmp_font;
-                }
-                XtFree(font_tag);
-                if (first_fs == NULL)
-                    first_fs = (XFontSet) tmp_font;
-            }
-        }
-    } while (next_entry);
-
-    XmFontListFreeFontContext(context);
-    return first_fs;
-}
-
-/*
- * Motif 1.2 requires that an X event passed to XmDragStart is of
- * ButtonPress type. In Motif 2.1 the restriction is relaxed to allow
- * ButtonPress, ButtonRelease, KeyRelease, KeyPress, MotionNotify events
- * as drag initiators. Actually the code in Motif 1.2 works okay for these
- * events as well, since it uses only the fields that have the same values
- * in all five event types. To bypass the initial sanity check in
- * XmDragStart we forcibly change event type to ButtonPress.
- *
- * This function causes an UnsatisfiedLinkError on Linux.
- * Since Linux only links against Motif 2.1, we can safely remove
- * this function altogether from the Linux build.
- * bchristi 1/22/2001
- */
-
-#ifdef __solaris__
-void
-awt_motif_adjustDragTriggerEvent(XEvent* xevent) {
-    xevent->type = ButtonPress;
-}
-#endif /* __solaris__ */
-
-static XmDragStartProc do_drag_start = NULL;
-static Widget drag_initiator = NULL;
-
-static void
-CheckedDragStart(XmDragContext dc, Widget src, XEvent *event) {
-    DASSERT(do_drag_start != NULL);
-    DASSERT(drag_initiator != NULL);
-    /*
-     * Fix for BugTraq ID 4407057.
-     * Enable the drag operation only if it is registered on the specific widget.
-     * We use this check to disable Motif default drag support.
-     */
-    if (src == drag_initiator) {
-        do_drag_start(dc, src, event);
-    } else {
-        /*
-         * This is the last chance to destroy the XmDragContext widget.
-         * NOTE: We rely on the fact that Motif 1.2 never uses the pointer
-         * to XmDragContext object returned from XmDragStart.
-         */
-        XtDestroyWidget(dc);
-    }
-}
-
-void
-awt_motif_enableSingleDragInitiator(Widget w) {
-    DASSERT(drag_initiator == NULL && do_drag_start == NULL && w != NULL);
-    drag_initiator = w;
-    do_drag_start = xmDragContextClassRec.drag_class.start;
-    DASSERT(do_drag_start != NULL);
-    xmDragContextClassRec.drag_class.start = (XmDragStartProc)CheckedDragStart;
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_motif21.c openjdk/jdk/src/solaris/native/sun/awt/awt_motif21.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_motif21.c	2014-04-08 05:27:03.462875264 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_motif21.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,234 +0,0 @@
-/*
- * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#if MOTIF_VERSION!=2
-    #error This file should only be compiled with motif 2.1
-#endif
-
-#include "awt_motif.h"
-#include <Xm/Xm.h>
-#include "awt.h"
-#include "awt_p.h"
-#include "awt_Component.h"
-
-#define XmPER_SHELL 0
-extern int32_t _XmImGetGeo(
-                        Widget vw) ;
-
-#define MAXARGS 10
-static Arg xic_vlist[MAXARGS];
-
-#define SEPARATOR_HEIGHT        2
-#define MTEXTAREAPEER_CLASS_NAME        "sun/awt/motif/MTextAreaPeer"
-extern struct MComponentPeerIDs mComponentPeerIDs;
-static jobject  mTextAreaClass = NULL;
-
-/*
- * Get the Motif text widget from the text component peer.  XmImGetXIC()
- * function should be issued on Motif text widgets.
- */
-static Widget getTextWidget(jobject tc) {
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-    if (mTextAreaClass == NULL) {
-        jclass localClass = (*env)->FindClass(env, MTEXTAREAPEER_CLASS_NAME);
-        mTextAreaClass = (jclass)(*env)->NewGlobalRef(env, localClass);
-        (*env)->DeleteLocalRef(env, localClass);
-    }
-
-    if ((*env)->IsInstanceOf(env, tc, mTextAreaClass)) {
-        struct TextAreaData * tdata = (struct TextAreaData *)
-        JNU_GetLongFieldAsPtr(env, tc, mComponentPeerIDs.pData);
-        return tdata->txt;
-    } else {
-        struct ComponentData * tdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, tc, mComponentPeerIDs.pData);
-        return tdata->widget;
-    }
-}
-
-/* get_im_height: returns height of the input method status area in pixels.
- *
- * This function assumes that if any XIM related information cannot be
- * queried then the app must not have an input method status area in the
- * current locale and returns zero as the status area height
- */
-int32_t
-awt_motif_getIMStatusHeight(Widget w, jobject tc)
-{
-    XIC xic = NULL;
-    XRectangle *im_rect=NULL;
-    int32_t im_height = 0;
-    char *ret;
-
-    xic = XmImGetXIC(getTextWidget(tc), XmPER_SHELL, NULL, 0);
-
-    if(xic != NULL) {
-        /* finally query the server for the status area geometry */
-        xic_vlist[0].name = XNArea;
-        xic_vlist[0].value = (XtArgVal)&im_rect;
-        xic_vlist[1].name = NULL;
-        ret=XGetICValues(xic, XNStatusAttributes, &xic_vlist[0], NULL);
-        if (ret == NULL && im_rect != NULL) {
-            im_height = im_rect->height;
-            if (im_height > 0) {
-                im_height += SEPARATOR_HEIGHT;
-            }
-            XFree(im_rect);
-        } else {
-            im_height = 0;
-        }
-    }
-
-    if (im_height == 0) {
-        im_height = _XmImGetGeo(w);
-    }
-
-#if defined(DEBUG)
-    jio_fprintf(stderr,"awt_motif_getIMStatusHeight: Height = %d",im_height);
-#endif
-    return im_height;
-}
-
-
-static XRectangle geomRect;
-static Pixmap bpm;
-XVaNestedList awt_motif_getXICStatusAreaList(Widget w, jobject tc)
-{
-    XIC xic;
-
-    XRectangle *im_rect;
-    XFontSet   *im_font;
-
-    Pixel bg ;
-    Pixel fg ;
-    Dimension height, width ;
-    Position x,y ;
-
-    XVaNestedList list = NULL;
-
-    char *ret;
-    Widget p=w;
-
-    while (!XtIsShell(p)) {
-        p = XtParent(p);
-    }
-
-    XtVaGetValues(p,
-        XmNx, &x,
-        XmNy, &y,
-        XmNwidth, &width,
-        XmNheight, &height,
-        XmNbackgroundPixmap, &bpm,
-        NULL);
-
-
-
-    xic = XmImGetXIC(getTextWidget(tc), XmPER_SHELL, NULL, 0);
-    if(xic == NULL)
-    {
-#if defined DEBUG
-        jio_fprintf(stderr,"Could not get XIC");
-#endif
-        return list ;
-    }
-
-   /* finally query the server for the required attributes area geometry */
-    xic_vlist[0].name = XNFontSet ;
-    xic_vlist[0].value =  (XtArgVal) &im_font ;
-    xic_vlist[1].name = XNArea;
-    xic_vlist[1].value = (XtArgVal) &im_rect;
-    xic_vlist[2].name = XNBackground ;
-    xic_vlist[2].value = (XtArgVal) &bg ;
-    xic_vlist[3].name = XNForeground ;
-    xic_vlist[3].value = (XtArgVal) &fg ;
-    xic_vlist[4].name = NULL;
-
-
-    if(ret=XGetICValues(xic, XNStatusAttributes, &xic_vlist[0], NULL))
-    {
-        return list ;
-    } else {
-        geomRect.x = 0 ;
-        geomRect.y = height - im_rect->height ;
-        geomRect.width = im_rect->width ;
-        geomRect.height = im_rect->height ;
-        XFree(im_rect) ;
-
-        list = XVaCreateNestedList(0 ,
-                        XNFontSet, im_font ,
-                        XNArea, &geomRect ,
-                        XNBackground, bg ,
-                        XNForeground, fg ,
-                        XNBackgroundPixmap, &bpm ,
-                        NULL );
-    }
-#if defined(DEBUG)
-    jio_fprintf(stderr,"awt_motif_getXICStatusAreaList:\n");
-    jio_fprintf(stderr,"XNArea:x=%d,y=%d,width=%d,height=%d\n", \
-         geomRect.x,geomRect.y,geomRect.width,geomRect.height);
-    jio_fprintf(stderr,"XNBackground=0x%x\n",bg);
-    jio_fprintf(stderr,"XNForeground=0x%x\n",fg);
-    jio_fprintf(stderr,"XNBackgroundPixmap=0x%x\n",bpm);
-#endif
-    return list ;
-
-}
-
-    /* This function causes an UnsatisfiedLinkError on Linux.
-     * Since Linux only links against Motif 2.1 and under 2.1 this function
-     * is a no-op, we can safely remove
-     * this function altogether from the Linux build.
-     * bchristi 1/22/2001
-     */
-
-#ifdef __solaris__
-void
-awt_motif_adjustDragTriggerEvent(XEvent* xevent) {
-    /* Do nothing. In Motif 2.1 the sanity check is corrected
-       to allow any imput event as a drag trigger event. */
-}
-#endif /* __solaris__ */
-
-static void
-CheckDragInitiator(Widget w, XtPointer client_data,
-                   XmDragStartCallbackStruct* cbstruct) {
-    Widget drag_initiator = (Widget)client_data;
-    /*
-     * Fix for BugTraq ID 4407057.
-     * Enable the drag operation only if it is registered on the specific
-     * widget. We use this check to disable Motif default drag support.
-     */
-    if (drag_initiator != cbstruct->widget) {
-        cbstruct->doit = False;
-    }
-}
-
-void
-awt_motif_enableSingleDragInitiator(Widget w) {
-    XtAddCallback(XmGetXmDisplay(XtDisplay(w)),
-                  XmNdragStartCallback, (XtCallbackProc)CheckDragInitiator,
-                  (XtPointer)w);
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_motif.c openjdk/jdk/src/solaris/native/sun/awt/awt_motif.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_motif.c	2014-04-08 05:27:03.458875205 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_motif.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-/*
- * Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_motif.h"
-
-#include <jvm.h>
-
-/* Common routines required for both Motif 2.1 and Motif 1.2 */
-#include <Xm/ScrollBarP.h>
-
-/* Remove the ScrollBar widget's continuous scrolling timeout handler
-   on a ButtonRelease to prevent the continuous scrolling that would
-   occur if a timeout expired after the ButtonRelease.
-*/
-/*
- * Note: RFE:4263104 is filed when the API is available these needs to removed
- */
-void
-awt_motif_Scrollbar_ButtonReleaseHandler(Widget w,
-                                         XtPointer data,
-                                         XEvent *event,
-                                         Boolean *cont)
-{
-  /* Remove the timeout handler. */
-#define END_TIMER         (1<<2)
-  XmScrollBarWidget sbw = (XmScrollBarWidget) w;
-  if (sbw->scrollBar.timer != NULL) {
-    XtRemoveTimeOut( sbw->scrollBar.timer );
-    sbw->scrollBar.timer = (XtIntervalId)NULL;
-    sbw->scrollBar.flags |= END_TIMER;
-  }
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_MToolkit.c openjdk/jdk/src/solaris/native/sun/awt/awt_MToolkit.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_MToolkit.c	2014-04-08 05:27:03.442874969 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_MToolkit.c	2014-04-10 02:56:51.382479482 +0100
@@ -48,7 +48,7 @@
 
 /* JNI field and method ids */
 #include "awt_Component.h"
-#include "awt_Cursor.h"
+//#include "awt_Cursor.h"
 #include "awt_MenuComponent.h"
 #include "awt_TopLevel.h"
 #include "canvas.h"
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_p.h openjdk/jdk/src/solaris/native/sun/awt/awt_p.h
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_p.h	2014-04-08 13:33:32.074668722 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_p.h	2014-04-10 02:56:51.386479541 +0100
@@ -79,7 +79,7 @@
 
 #ifndef XAWT
 #include "GLXGraphicsConfig.h"
-#include <sun_awt_motif_MComponentPeer.h>
+//#include <sun_awt_motif_MComponentPeer.h>
 #endif
 
 #ifndef HEADLESS
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_PopupMenu.c openjdk/jdk/src/solaris/native/sun/awt/awt_PopupMenu.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_PopupMenu.c	2014-04-08 05:27:03.446875029 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_PopupMenu.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,491 +0,0 @@
-/*
- * Copyright (c) 1996, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include <Xm/Separator.h>
-#include <Xm/MenuShell.h>
-#include <Xm/RowColumn.h>
-#include "color.h"
-#include "java_awt_PopupMenu.h"
-#include "java_awt_Component.h"
-#include "java_awt_Event.h"
-#include "sun_awt_motif_MPopupMenuPeer.h"
-#include "sun_awt_motif_MComponentPeer.h"
-
-#include "awt_PopupMenu.h"
-#include "awt_MenuItem.h"
-#include "awt_Component.h"
-#include "awt_MenuComponent.h"
-#include "awt_Menu.h"
-#include "awt_Event.h"
-
-#include "multi_font.h"
-#include <jni.h>
-#include <jni_util.h>
-
-extern struct MMenuItemPeerIDs mMenuItemPeerIDs;
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern struct MenuComponentIDs menuComponentIDs;
-extern struct MenuItemIDs menuItemIDs;
-extern struct MenuIDs menuIDs;
-extern AwtGraphicsConfigDataPtr
-getGraphicsConfigFromComponentPeer(JNIEnv *env, jobject parentPeer);
-extern Boolean keyboardGrabbed;
-Boolean poppingDown = False;
-
-struct MPopupMenuPeerIDs mPopupMenuPeerIDs;
-
-static Widget activePopup;
-
-void removePopupMenus() {
-    if (activePopup != NULL &&
-        XtIsManaged(activePopup))
-    {
-            XtUnmanageChild(activePopup);
-            activePopup = NULL;
-    }
-}
-
-Boolean awtMenuIsActive() {
-    return ((activePopup != NULL) || (awt_util_focusIsOnMenu(awt_display)));
-}
-
-struct ClientDataStruct {
-    struct ComponentData *wdata;
-    jobject mMenuItemPeerIDs;
-};
-
-/*
- * Class:     sun_awt_motif_MPopupMenuPeer
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for
-   MPopupMenuPeer.java to initialize the methodIDs for methods that may
-   be accessed from C */
-
-JNIEXPORT void JNICALL Java_sun_awt_motif_MPopupMenuPeer_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    mPopupMenuPeerIDs.destroyNativeWidgetAfterGettingTreeLock =
-        (*env)->GetMethodID(env, cls,
-                            "destroyNativeWidgetAfterGettingTreeLock", "()V");
-}
-
-extern Boolean skipNextNotifyWhileGrabbed;
-
-static void
-Popup_popUpCB(Widget w, XtPointer client_data, XtPointer calldata)
-{
-    skipNextNotifyWhileGrabbed = True;
-}
-/*
- * client_data is MPopupMenuPeer instance
- */
-static void
-Popup_popdownCB(Widget w, XtPointer client_data, XtPointer calldata)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject target = NULL;
-
-    /*
-     * Fix for 4394847. Due to the race keyboard remains grabbed after menu
-     * was disposed. Clear the grab status here instead of processOneEvent.
-     */
-    poppingDown = True;
-    keyboardGrabbed = False;
-    skipNextNotifyWhileGrabbed = True;
-
-    XtRemoveCallback(w, XtNpopdownCallback,
-                     Popup_popdownCB, (XtPointer) client_data);
-
-    (*env)->CallVoidMethod(env, (jobject) client_data,
-        mPopupMenuPeerIDs.destroyNativeWidgetAfterGettingTreeLock);
-
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-/*
- * Class:     sun_awt_motif_MPopupMenuPeer
- * Method:    createMenu
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MPopupMenuPeer_createMenu
-  (JNIEnv *env, jobject this, jobject parent)
-{
-    struct ComponentData *wdata;
-    struct MenuData *mdata;
-    struct FontData *fdata;
-    char *ctitle = NULL;
-    int32_t argc;
-#define MAX_ARGC 10
-    Arg args[MAX_ARGC];
-    Pixel bg;
-    Pixel fg;
-    XmFontList fontlist = NULL;
-    XmString mfstr = NULL;
-    jobject font;
-    jobject target;
-    jobject targetFont;
-    jobject label;
-    jboolean IsMultiFont;
-    jboolean tearOff;
-    jobject globalRef = (*env)->NewGlobalRef(env, this);
-    AwtGraphicsConfigDataPtr adata;
-
-    JNU_SetLongFieldFromPtr(env, this,
-                            mMenuItemPeerIDs.jniGlobalRef, globalRef);
-
-
-    AWT_LOCK();
-
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    target =
-      (*env)->GetObjectField(env, this, mMenuItemPeerIDs.target);
-    wdata = (struct ComponentData *)
-      JNU_GetLongFieldAsPtr(env, parent, mComponentPeerIDs.pData);
-
-    if (wdata == NULL || JNU_IsNull(env, target)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    mdata = ZALLOC(MenuData);
-    if (mdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-    JNU_SetLongFieldFromPtr(env, this, mMenuItemPeerIDs.pData, mdata);
-
-    adata = getGraphicsConfigFromComponentPeer(env, parent);
-
-    /*
-     * Why are these different?
-     */
-    font = JNU_CallMethodByName(env, NULL, target, "getFont_NoClientCode",
-                                "()Ljava/awt/Font;").l;
-    targetFont =
-      (*env)->GetObjectField(env, target, menuComponentIDs.font);
-    if (!JNU_IsNull(env, targetFont) &&
-        (fdata = awtJNI_GetFontData(env, targetFont, NULL)) != NULL) {
-        IsMultiFont = awtJNI_IsMultiFont(env, targetFont);
-    } else {
-        IsMultiFont = awtJNI_IsMultiFont(env, font);
-    }
-
-    label = (*env)->GetObjectField(env, target, menuItemIDs.label);
-    if (JNU_IsNull(env, label)) {
-        mfstr = XmStringCreateLocalized("");
-        ctitle = "";
-    } else {
-        if (IsMultiFont) {
-            mfstr = awtJNI_MakeMultiFontString(env, label, font);
-        } else {
-            ctitle = (char *) JNU_GetStringPlatformChars(env, label, NULL);
-        }
-    }
-
-    XtVaGetValues(wdata->widget, XmNbackground, &bg, NULL);
-    XtVaGetValues(wdata->widget, XmNforeground, &fg, NULL);
-
-    argc = 0;
-    XtSetArg(args[argc], XmNbackground, bg);
-    argc++;
-    XtSetArg(args[argc], XmNforeground, fg);
-    argc++;
-    tearOff = (*env)->GetBooleanField(env, target, menuIDs.tearOff);
-    if (tearOff) {
-        XtSetArg(args[argc], XmNtearOffModel, XmTEAR_OFF_ENABLED);
-        argc++;
-    }
-    if (!JNU_IsNull(env, targetFont)
-        && (fdata = awtJNI_GetFontData(env, targetFont, NULL)) != NULL) {
-        if (IsMultiFont) {
-            fontlist = awtJNI_GetFontList(env, targetFont);
-        } else {
-            fontlist = XmFontListCreate(fdata->xfont, "labelFont");
-        }
-
-        XtSetArg(args[argc], XmNfontList, fontlist);
-        argc++;
-    } else {
-        if (IsMultiFont) {
-            fontlist = awtJNI_GetFontList(env, font);
-            XtSetArg(args[argc], XmNfontList, fontlist);
-            argc++;
-        }
-    }
-
-    XtSetArg(args[argc], XmNvisual, adata->awt_visInfo.visual);
-    argc++;
-    XtSetArg (args[argc], XmNscreen,
-              ScreenOfDisplay(awt_display,
-                              adata->awt_visInfo.screen));
-    argc++;
-
-    if (IsMultiFont) {
-        DASSERT(!(argc > MAX_ARGC));
-        mdata->itemData.comp.widget = XmCreatePopupMenu(wdata->widget,
-                                                        "",
-                                                        args,
-                                                        argc);
-    } else {
-        DASSERT(!(argc > MAX_ARGC));
-        mdata->itemData.comp.widget = XmCreatePopupMenu(wdata->widget,
-                                                        ctitle,
-                                                        args,
-                                                        argc);
-    }
-    awt_addMenuWidget(mdata->itemData.comp.widget);
-
-    /*
-     * Fix for bug 4180147 -
-     * screen can be frozen when interacting with MB3 using AWT on Motif
-     */
-    XtUngrabButton(wdata->widget, AnyButton, AnyModifier);
-    XtUngrabPointer(wdata->widget, CurrentTime);
-
-    /* fix for bug #4169155: Popup menus get a leading separator on Motif
-       system.
-       Additional check that title string is not empty*/
-    if (!JNU_IsNull(env, label) &&
-        (*env)->GetStringUTFLength( env, label) != (jsize)0 ) {
-        if (IsMultiFont) {
-            XtVaCreateManagedWidget("",
-                                    xmLabelWidgetClass,
-                                    mdata->itemData.comp.widget,
-                                    XmNfontList, fontlist,
-                                    XmNlabelString, mfstr,
-                                    XmNbackground, bg,
-                                    XmNforeground, fg,
-                                    XmNhighlightColor, fg,
-                                    NULL);
-            XmStringFree(mfstr);
-        } else {
-            XmString xmstr = XmStringCreateLocalized(ctitle);
-
-            XtVaCreateManagedWidget(ctitle,
-                                    xmLabelWidgetClass,
-                                    mdata->itemData.comp.widget,
-                                    XmNlabelString, xmstr,
-                                    XmNbackground, bg,
-                                    XmNforeground, fg,
-                                    XmNhighlightColor, fg,
-                                    NULL);
-            XmStringFree(xmstr);
-            JNU_ReleaseStringPlatformChars(env, label, (const char *) ctitle);
-        }
-        /* Create separator */
-        XtVaCreateManagedWidget("",
-                                xmSeparatorWidgetClass,
-                                mdata->itemData.comp.widget,
-                                XmNbackground, bg,
-                                XmNforeground, fg,
-                                NULL);
-    }
-    if (tearOff) {
-        Widget tearOffWidget = XmGetTearOffControl(mdata->itemData.comp.widget);
-
-        XtVaSetValues(tearOffWidget,
-                      XmNbackground, bg,
-                      XmNforeground, fg,
-                      XmNhighlightColor, fg,
-                      NULL);
-    }
-    mdata->comp.widget = mdata->itemData.comp.widget;
-
-    if (!JNU_IsNull(env, targetFont)) {
-        XmFontListFree(fontlist);
-    }
-    XtSetSensitive(mdata->comp.widget,
-      ((*env)->GetBooleanField(env, target, menuItemIDs.enabled) ?
-       True : False));
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MPopupMenuPeer
- * Method:    pShow
- * Signature: (Ljava/awt/Event;IILsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MPopupMenuPeer_pShow
-  (JNIEnv *env, jobject this, jobject event, jint x, jint y, jobject origin)
-{
-    struct MenuData *mdata;
-    struct ComponentData *wdata;
-    XButtonEvent *bevent;
-    XButtonEvent *newEvent = NULL;
-    void *data;
-
-    AWT_LOCK();
-
-    mdata = (struct MenuData *)
-      JNU_GetLongFieldAsPtr(env, this, mMenuItemPeerIDs.pData);
-    if (mdata == NULL || JNU_IsNull(env, event)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    wdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, origin, mComponentPeerIDs.pData);
-
-    if ( wdata == NULL || wdata->widget == NULL ) { /* 425598 */
-        JNU_ThrowNullPointerException(env, "NullPointerException"); /* 425598 */
-        AWT_UNLOCK(); /* 425598 */
-        return; /* 425598 */
-    } /* 425598 */
-
-    if (!XtIsRealized(wdata->widget)) {
-        JNU_ThrowInternalError(env, "widget not visible on screen");
-        AWT_UNLOCK();
-        return;
-    }
-
-    /*
-     * Fix for BugTraq ID 4186663 - Pural PopupMenus appear at the same time.
-     * If another popup is currently visible hide it.
-     */
-    if (activePopup != NULL &&
-        activePopup != mdata->comp.widget &&
-        XtIsObject(activePopup) &&
-        XtIsManaged(activePopup)) {
-            removePopupMenus();
-    }
-
-    /* If the raw x event is not available, then we must use an unfortunate
-     * round-trip call to XTranslateCoordiates to get the root coordinates.
-     */
-    data = JNU_GetLongFieldAsPtr(env, event, eventIDs.data);
-    if (data == NULL || ((XEvent *) data)->type != ButtonPress) {
-        int32_t rx, ry;
-        Window root, win;
-
-        root = RootWindowOfScreen(XtScreen(wdata->widget));
-        XTranslateCoordinates(awt_display,
-                              XtWindow(wdata->widget),
-                              root,
-                              (int32_t) x, (int32_t) y,
-                              &rx, &ry,
-                              &win);
-        /*
-                printf("translated coords %d,%d to root %d,%d\n", x, y, rx, ry);
-        */
-
-        newEvent = (XButtonEvent *) malloc(sizeof(XButtonEvent));
-        newEvent->type = ButtonPress;
-        newEvent->display = awt_display;
-        newEvent->window = XtWindow(wdata->widget);
-        newEvent->time = awt_util_getCurrentServerTime();
-        newEvent->x = (int32_t) x;
-        newEvent->y = (int32_t) y;
-        newEvent->x_root = rx;
-        newEvent->y_root = ry;
-        bevent = newEvent;
-
-    } else {
-        bevent = (XButtonEvent *) data;
-    }
-
-    XtAddCallback(XtParent(mdata->comp.widget), XtNpopdownCallback,
-                  Popup_popdownCB,
-                  (XtPointer)
-                  JNU_GetLongFieldAsPtr(env, this,
-                                        mMenuItemPeerIDs.jniGlobalRef));
-
-    XtAddCallback(XtParent(mdata->comp.widget), XtNpopupCallback,
-                  Popup_popUpCB,
-                  (XtPointer)
-                  JNU_GetLongFieldAsPtr(env, this,
-                                        mMenuItemPeerIDs.jniGlobalRef));
-
-
-    XmMenuPosition(mdata->comp.widget, bevent);
-    XtManageChild(mdata->comp.widget);
-
-    /*
-     * Fix for BugTraq ID 4186663 - Pural PopupMenus appear at the same time.
-     * Store the pointer to the currently showing popup.
-     */
-    activePopup = mdata->comp.widget;
-
-    if (newEvent) {
-        free((void *) newEvent);
-    }
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MPopupMenuPeer
- * Method:    pDispose
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MPopupMenuPeer_pDispose
-  (JNIEnv *env, jobject this)
-{
-    struct MenuData *mdata;
-
-    AWT_LOCK();
-
-    mdata = (struct MenuData *)
-      JNU_GetLongFieldAsPtr(env, this, mMenuItemPeerIDs.pData);
-
-    if (mdata == NULL) {
-        AWT_UNLOCK();
-        return;
-    }
-    /*
-     * Fix for BugTraq ID 4186663 - Pural PopupMenus appear at the same time.
-     * Clear the pointer to the currently showing popup.
-     */
-    if (activePopup == mdata->comp.widget) {
-        activePopup = NULL;
-    }
-    awt_delMenuWidget(mdata->itemData.comp.widget);
-    XtUnmanageChild(mdata->comp.widget);
-    awt_util_consumeAllXEvents(mdata->comp.widget);
-    XtDestroyWidget(mdata->comp.widget);
-    free((void *) mdata);
-    (*env)->SetLongField(env, this, mMenuItemPeerIDs.pData, (jlong)0);
-
-    awtJNI_DeleteGlobalMenuRef(env, this);
-
-    poppingDown = False;
-    AWT_UNLOCK();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Robot.c openjdk/jdk/src/solaris/native/sun/awt/awt_Robot.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Robot.c	2014-04-10 02:28:17.828675796 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Robot.c	2014-04-10 02:56:51.398479716 +0100
@@ -205,14 +205,8 @@
 
 /*********************************************************************************************/
 
-#ifdef XAWT
-#define FUNC_NAME(name) Java_sun_awt_X11_XRobotPeer_ ## name
-#else
-#define FUNC_NAME(name) Java_sun_awt_motif_MRobotPeer_ ## name
-#endif
-
 JNIEXPORT void JNICALL
-FUNC_NAME(setup) (JNIEnv * env, jclass cls) {
+Java_sun_awt_X11_XRobotPeer_setup (JNIEnv * env, jclass cls) {
     int32_t xtestAvailable;
 
     DTRACE_PRINTLN("RobotPeer: setup()");
@@ -233,7 +227,7 @@
 }
 
 JNIEXPORT void JNICALL
-FUNC_NAME(getRGBPixelsImpl)( JNIEnv *env,
+Java_sun_awt_X11_XRobotPeer_getRGBPixelsImpl( JNIEnv *env,
                              jclass cls,
                              jobject xgc,
                              jint x,
@@ -297,7 +291,7 @@
 }
 
 JNIEXPORT void JNICALL
-FUNC_NAME(keyPressImpl) (JNIEnv *env,
+Java_sun_awt_X11_XRobotPeer_keyPressImpl (JNIEnv *env,
                          jclass cls,
                          jint keycode) {
 
@@ -317,7 +311,7 @@
 }
 
 JNIEXPORT void JNICALL
-FUNC_NAME(keyReleaseImpl) (JNIEnv *env,
+Java_sun_awt_X11_XRobotPeer_keyReleaseImpl (JNIEnv *env,
                            jclass cls,
                            jint keycode) {
     AWT_LOCK();
@@ -335,7 +329,7 @@
 }
 
 JNIEXPORT void JNICALL
-FUNC_NAME(mouseMoveImpl) (JNIEnv *env,
+Java_sun_awt_X11_XRobotPeer_mouseMoveImpl (JNIEnv *env,
                           jclass cls,
                           jobject xgc,
                           jint root_x,
@@ -357,7 +351,7 @@
 }
 
 JNIEXPORT void JNICALL
-FUNC_NAME(mousePressImpl) (JNIEnv *env,
+Java_sun_awt_X11_XRobotPeer_mousePressImpl (JNIEnv *env,
                            jclass cls,
                            jint buttonMask) {
     AWT_LOCK();
@@ -381,7 +375,7 @@
 }
 
 JNIEXPORT void JNICALL
-FUNC_NAME(mouseReleaseImpl) (JNIEnv *env,
+Java_sun_awt_X11_XRobotPeer_mouseReleaseImpl (JNIEnv *env,
                              jclass cls,
                              jint buttonMask) {
     AWT_LOCK();
@@ -405,7 +399,7 @@
 }
 
 JNIEXPORT void JNICALL
-FUNC_NAME(mouseWheelImpl) (JNIEnv *env,
+Java_sun_awt_X11_XRobotPeer_mouseWheelImpl (JNIEnv *env,
                            jclass cls,
                            jint wheelAmt) {
 /* Mouse wheel is implemented as a button press of button 4 and 5, so it */
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Scrollbar.c openjdk/jdk/src/solaris/native/sun/awt/awt_Scrollbar.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Scrollbar.c	2014-04-08 05:27:03.450875088 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Scrollbar.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,440 +0,0 @@
-/*
- * Copyright (c) 1995, 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "java_awt_Scrollbar.h"
-#include "java_awt_event_MouseEvent.h"
-#include "sun_awt_motif_MScrollbarPeer.h"
-#include "sun_awt_motif_MComponentPeer.h"
-
-#include "awt_Component.h"
-#include "canvas.h"
-
-#include <jni.h>
-#include <jni_util.h>
-#include "multi_font.h"
-
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern AwtGraphicsConfigDataPtr
-    copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-
-/* fieldIDs for java.awt.Scrollbar fields that may be accessed from C */
-static struct ScrollbarIDs {
-    jfieldID orientation;
-    jfieldID visibleAmount;
-    jfieldID lineIncrement;
-    jfieldID pageIncrement;
-    jfieldID value;
-    jfieldID minimum;
-    jfieldID maximum;
-} targetIDs;
-
-/* MScrollbarPeer callback methods */
-static struct {
-    jmethodID lineUp;
-    jmethodID lineDown;
-    jmethodID pageUp;
-    jmethodID pageDown;
-    jmethodID drag;
-    jmethodID dragEnd;
-    jmethodID warp;
-} peerIDs;
-
-
-
-/*
- * Class:     java_awt_ScrollBar
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for
-   Scrollbar.java to initialize the fieldIDs for fields that may
-   be accessed from C */
-
-JNIEXPORT void JNICALL
-Java_java_awt_Scrollbar_initIDs(JNIEnv *env, jclass cls)
-{
-    targetIDs.orientation =
-      (*env)->GetFieldID(env, cls, "orientation", "I");
-    targetIDs.visibleAmount =
-      (*env)->GetFieldID(env, cls, "visibleAmount", "I");
-    targetIDs.lineIncrement =
-      (*env)->GetFieldID(env, cls, "lineIncrement", "I");
-    targetIDs.pageIncrement =
-      (*env)->GetFieldID(env, cls, "pageIncrement", "I");
-    targetIDs.value =
-      (*env)->GetFieldID(env, cls, "value", "I");
-    targetIDs.minimum =
-      (*env)->GetFieldID(env, cls, "minimum", "I");
-    targetIDs.maximum =
-      (*env)->GetFieldID(env, cls, "maximum", "I");
-}
-
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for
-   MScrollbarPeer to initialize the JNI ids for fields and methods
-   that may be accessed from C */
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MScrollbarPeer_initIDs(JNIEnv *env, jclass cls)
-{
-    peerIDs.lineUp =
-        (*env)->GetMethodID(env, cls, "lineUp",   "(I)V");
-    peerIDs.lineDown =
-        (*env)->GetMethodID(env, cls, "lineDown", "(I)V");
-    peerIDs.pageUp =
-        (*env)->GetMethodID(env, cls, "pageUp",   "(I)V");
-    peerIDs.pageDown =
-        (*env)->GetMethodID(env, cls, "pageDown", "(I)V");
-    peerIDs.drag =
-        (*env)->GetMethodID(env, cls, "drag",     "(I)V");
-    peerIDs.dragEnd =
-        (*env)->GetMethodID(env, cls, "dragEnd",  "(I)V");
-    peerIDs.warp =
-        (*env)->GetMethodID(env, cls, "warp",     "(I)V");
-}
-
-/*
- * Call peer.jcallback(value)
- */
-static void
-DoJavaCallback(jobject peer, jmethodID jcallback, jint value)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    (*env)->CallVoidMethod(env, peer, jcallback, value);
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-
-static void /* XtCallbackProc */
-decrementCallback(Widget w, jobject peer,
-    XmScrollBarCallbackStruct *scroll)
-{
-    DASSERT(scroll->reason == XmCR_DECREMENT);
-    DoJavaCallback(peer, peerIDs.lineUp, scroll->value);
-}
-
-static void /* XtCallbackProc */
-incrementCallback(Widget w, jobject peer,
-    XmScrollBarCallbackStruct *scroll)
-{
-    DASSERT(scroll->reason == XmCR_INCREMENT);
-    DoJavaCallback(peer, peerIDs.lineDown, scroll->value);
-}
-
-static void /* XtCallbackProc */
-pageDecrementCallback(Widget w, jobject peer,
-    XmScrollBarCallbackStruct *scroll)
-{
-    DASSERT(scroll->reason == XmCR_PAGE_DECREMENT);
-    DoJavaCallback(peer, peerIDs.pageUp, scroll->value);
-}
-
-static void /* XtCallbackProc */
-pageIncrementCallback(Widget w, jobject peer,
-    XmScrollBarCallbackStruct *scroll)
-{
-    DASSERT(scroll->reason == XmCR_PAGE_INCREMENT);
-    DoJavaCallback(peer, peerIDs.pageDown, scroll->value);
-}
-
-static void /* XtCallbackProc */
-dragCallback(Widget w, jobject peer,
-    XmScrollBarCallbackStruct *scroll)
-{
-    DASSERT(scroll->reason == XmCR_DRAG);
-    DoJavaCallback(peer, peerIDs.drag, scroll->value);
-}
-
-static void /* XtCallbackProc */
-dragEndCallback(Widget w, jobject peer,
-    XmScrollBarCallbackStruct *scroll)
-{
-    DASSERT(scroll->reason == XmCR_VALUE_CHANGED);
-    DoJavaCallback(peer, peerIDs.dragEnd, scroll->value);
-}
-
-static void /* XtCallbackProc */
-toTopCallback(Widget w, jobject peer,
-    XmScrollBarCallbackStruct *scroll)
-{
-    DASSERT(scroll->reason == XmCR_TO_TOP);
-    DoJavaCallback(peer, peerIDs.warp, scroll->value);
-}
-
-static void /* XtCallbackProc */
-toBottomCallback(Widget w, jobject peer,
-    XmScrollBarCallbackStruct *scroll)
-{
-    DASSERT(scroll->reason == XmCR_TO_BOTTOM);
-    DoJavaCallback(peer, peerIDs.warp, scroll->value);
-}
-
-
-/*
- * Class:     sun_awt_motif_MScrollbarPeer
- * Method:    create
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MScrollbarPeer_create(JNIEnv *env, jobject this,
-    jobject parent)
-{
-    Widget w;
-
-    jobject target;
-    XtPointer globalRef = (XtPointer) /* jobject */
-        awtJNI_CreateAndSetGlobalRef(env, this);
-
-    struct ComponentData *pdata; /* for parent     */
-    struct ComponentData *sdata; /* for scrollbar */
-    AwtGraphicsConfigDataPtr adata;
-
-    int32_t value, visible, minimum, maximum;
-    int32_t lineIncrement, pageIncrement;
-    Pixel bg;
-
-#define MAX_ARGC 20
-    Arg args[MAX_ARGC];
-    int32_t argc = 0;
-
-
-    AWT_LOCK();
-
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    pdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, parent, mComponentPeerIDs.pData);
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    if (JNU_IsNull(env, target) || pdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-
-    switch ((*env)->GetIntField(env, target, targetIDs.orientation)) {
-      case java_awt_Scrollbar_HORIZONTAL:
-          XtSetArg(args[argc], XmNorientation, XmHORIZONTAL);
-          argc++;
-          break;
-
-      case java_awt_Scrollbar_VERTICAL:
-          XtSetArg(args[argc], XmNorientation, XmVERTICAL);
-          argc++;
-          break;
-
-      default:
-          JNU_ThrowIllegalArgumentException(env, "bad scrollbar orientation");
-          AWT_UNLOCK();
-          return;
-    }
-
-    adata = copyGraphicsConfigToPeer(env, this);
-    XtVaGetValues(pdata->widget, XmNbackground, &bg, NULL);
-
-    visible = (int32_t) (*env)->GetIntField(env, target, targetIDs.visibleAmount);
-    value   = (int32_t) (*env)->GetIntField(env, target, targetIDs.value);
-    minimum = (int32_t) (*env)->GetIntField(env, target, targetIDs.minimum);
-    maximum = (int32_t) (*env)->GetIntField(env, target, targetIDs.maximum);
-    lineIncrement =
-              (int32_t) (*env)->GetIntField(env, target, targetIDs.lineIncrement);
-    pageIncrement =
-              (int32_t) (*env)->GetIntField(env, target, targetIDs.pageIncrement);
-
-    /*
-     * Sanity check.  Scrollbar.setValues should have taken care.
-     */
-    DASSERT(maximum > minimum);
-    DASSERT(visible <= maximum - minimum);
-    DASSERT(visible >= 1);
-    DASSERT(value >= minimum);
-    DASSERT(value <= maximum - visible);
-
-    XtSetArg(args[argc], XmNx,             0);                  argc++;
-    XtSetArg(args[argc], XmNy,             0);                  argc++;
-    XtSetArg(args[argc], XmNvalue,         value);              argc++;
-    XtSetArg(args[argc], XmNsliderSize,    visible);            argc++;
-    XtSetArg(args[argc], XmNminimum,       minimum);            argc++;
-    XtSetArg(args[argc], XmNmaximum,       maximum);            argc++;
-    XtSetArg(args[argc], XmNincrement,     lineIncrement);      argc++;
-    XtSetArg(args[argc], XmNpageIncrement, pageIncrement);      argc++;
-    XtSetArg(args[argc], XmNbackground,    bg);                 argc++;
-    XtSetArg(args[argc], XmNrecomputeSize, False);              argc++;
-    XtSetArg(args[argc], XmNuserData,      globalRef);          argc++;
-    XtSetArg(args[argc], XmNscreen,
-                             ScreenOfDisplay(awt_display,
-                                 adata->awt_visInfo.screen));   argc++;
-
-    DASSERT(argc <= MAX_ARGC);  /* sanity check */
-
-    sdata = ZALLOC(ComponentData);
-    if (sdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-
-    JNU_SetLongFieldFromPtr(env, this, mComponentPeerIDs.pData, sdata);
-
-    sdata->widget = w =
-        XmCreateScrollBar(pdata->widget, "scrollbar", args, argc);
-
-    XtAddCallback(w, XmNdecrementCallback,
-        (XtCallbackProc)decrementCallback, globalRef);
-    XtAddCallback(w, XmNincrementCallback,
-        (XtCallbackProc)incrementCallback, globalRef);
-    XtAddCallback(w, XmNpageDecrementCallback,
-        (XtCallbackProc)pageDecrementCallback, globalRef);
-    XtAddCallback(w, XmNpageIncrementCallback,
-        (XtCallbackProc)pageIncrementCallback, globalRef);
-    XtAddCallback(w, XmNtoTopCallback,
-        (XtCallbackProc)toTopCallback, globalRef);
-    XtAddCallback(w, XmNtoBottomCallback,
-        (XtCallbackProc)toBottomCallback, globalRef);
-    XtAddCallback(w, XmNdragCallback,
-        (XtCallbackProc)dragCallback, globalRef);
-    XtAddCallback(w, XmNvalueChangedCallback,
-        (XtCallbackProc)dragEndCallback, globalRef);
-
-    /* Set up workaround for the continuous scrolling bug */
-    XtAddEventHandler(w, ButtonReleaseMask, False,
-        awt_motif_Scrollbar_ButtonReleaseHandler, NULL);
-
-    /* Fix for 4955950. ButtonRelease & MotionNotify should be handled as well */
-    XtAddEventHandler(w, ButtonPressMask | ButtonReleaseMask | PointerMotionMask,
-                      False, awt_canvas_event_handler, globalRef);
-
-    XtSetMappedWhenManaged(w, False);
-    XtManageChild(w);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MScrollbarPeer
- * Method:    pSetValues
- * Signature: (IIII)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MScrollbarPeer_pSetValues(JNIEnv *env, jobject this,
-    jint value, jint visible, jint minimum, jint maximum)
-{
-    struct ComponentData *sdata;
-
-    AWT_LOCK();
-
-    sdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (sdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    /* pass in visible for sliderSize since Motif will calculate the */
-    /* slider's size for us. */
-    XtVaSetValues(sdata->widget,
-                  XmNminimum, minimum,
-                  XmNmaximum, maximum,
-                  XmNvalue, value,
-                  XmNsliderSize, visible,
-                  NULL);
-    AWT_FLUSH_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_MScrollbarPeer
- * Method:    setLineIncrement
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MScrollbarPeer_setLineIncrement(JNIEnv *env, jobject this,
-    jint value)
-{
-    struct ComponentData *sdata;
-
-    AWT_LOCK();
-
-    sdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (sdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaSetValues(sdata->widget,
-                  XmNincrement, value,
-                  NULL);
-    AWT_FLUSH_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_MScrollbarPeer
- * Method:    setPageIncrement
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MScrollbarPeer_setPageIncrement(JNIEnv *env, jobject this,
-    jint value)
-{
-    struct ComponentData *sdata;
-
-    AWT_LOCK();
-
-    sdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (sdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaSetValues(sdata->widget,
-                  XmNpageIncrement, value,
-                  NULL);
-    AWT_FLUSH_UNLOCK();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_ScrollPane.c openjdk/jdk/src/solaris/native/sun/awt/awt_ScrollPane.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_ScrollPane.c	2014-04-08 05:27:03.446875029 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_ScrollPane.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,927 +0,0 @@
-/*
- * Copyright (c) 1996, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-
-#include "java_awt_Adjustable.h"
-#include "java_awt_Insets.h"
-#include "java_awt_ScrollPane.h"
-#include "java_awt_event_AdjustmentEvent.h"
-#include "sun_awt_motif_MComponentPeer.h"
-#include "sun_awt_motif_MScrollPanePeer.h"
-#include "java_awt_AWTEvent.h"
-
-#include "awt_Component.h"
-#include "canvas.h"
-
-#include <jni.h>
-#include <jni_util.h>
-#include <Xm/ScrolledWP.h>
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern AwtGraphicsConfigDataPtr
-    copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-
-/* fieldIDs for ScrollPane fields that may be accessed from C */
-static struct ScrollPaneIDs {
-    jfieldID scrollbarDisplayPolicy;
-} scrollPaneIDs;
-
-/*
- * Class:     java_awt_ScrollPane
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for
-   ScrollPane.java to initialize the fieldIDs for fields that may
-   be accessed from C */
-
-JNIEXPORT void JNICALL Java_java_awt_ScrollPane_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    scrollPaneIDs.scrollbarDisplayPolicy =
-      (*env)->GetFieldID(env, cls, "scrollbarDisplayPolicy", "I");
-}
-
-/* fieldIDs for MScrollPanePeer fields that may be accessed from C */
-static struct MScrollPanePeerIDs {
-    jmethodID postScrollEventID;
-} mScrollPanePeerIDs;
-
-/*
- * Class:     sun_awt_motif_MScrollPanePeer
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for
-   MScrollPanePeer.java to initialize the fieldIDs for fields that may
-   be accessed from C */
-
-JNIEXPORT void JNICALL Java_sun_awt_motif_MScrollPanePeer_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    mScrollPanePeerIDs.postScrollEventID =
-        (*env)->GetMethodID(env, cls, "postScrollEvent", "(IIIZ)V");
-}
-
-static void
-dump_scroll_attrs(Widget scrollbar)
-{
-    unsigned char orient;
-    int32_t value, size, incr, pIncr, max, min;
-
-    XtVaGetValues(scrollbar,
-                  XmNvalue, &value,
-                  XmNincrement, &incr,
-                  XmNpageIncrement, &pIncr,
-                  XmNsliderSize, &size,
-                  XmNmaximum, &max,
-                  XmNminimum, &min,
-                  XmNorientation, &orient,
-                  NULL);
-
-    jio_fprintf(stdout, "%s: min=%d max=%d slider-size=%d incr=%d pageIncr=%d value = %d\n",
-                orient == XmVERTICAL ? "VSB" : "HSB", min, max, size,
-                incr, pIncr, value);
-}
-
-
-/*
- * client_data is MScrollPanePeer instance
- */
-static void
-postScrollEvent(jint jorient, jobject peer, XmScrollBarCallbackStruct *scroll)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-    jint jscrollcode;
-    jboolean jadjusting = JNI_FALSE;
-
-    switch (scroll->reason) {
-      case XmCR_DECREMENT:
-          jscrollcode = java_awt_event_AdjustmentEvent_UNIT_DECREMENT;
-          break;
-      case XmCR_INCREMENT:
-          jscrollcode = java_awt_event_AdjustmentEvent_UNIT_INCREMENT;
-          break;
-      case XmCR_PAGE_DECREMENT:
-          jscrollcode = java_awt_event_AdjustmentEvent_BLOCK_DECREMENT;
-          break;
-      case XmCR_PAGE_INCREMENT:
-          jscrollcode = java_awt_event_AdjustmentEvent_BLOCK_INCREMENT;
-          break;
-      case XmCR_DRAG:
-          jscrollcode = java_awt_event_AdjustmentEvent_TRACK;
-          jadjusting = JNI_TRUE;
-          break;
-      case XmCR_VALUE_CHANGED:  /* drag finished */
-      case XmCR_TO_TOP:
-      case XmCR_TO_BOTTOM:
-          jscrollcode = java_awt_event_AdjustmentEvent_TRACK;
-          break;
-      default:
-          DASSERT(FALSE);
-          return;
-    }
-
-    (*env)->CallVoidMethod(env, peer,  mScrollPanePeerIDs.postScrollEventID,
-        jorient, jscrollcode, (jint)scroll->value, jadjusting);
-
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-/*
- * client_data is MScrollPanePeer instance
- */
-static void
-ScrollPane_scrollV(Widget w, XtPointer client_data, XtPointer call_data)
-{
-    postScrollEvent(java_awt_Adjustable_VERTICAL, (jobject)client_data,
-                    (XmScrollBarCallbackStruct *)call_data);
-}
-
-/*
- * client_data is MScrollPanePeer instance
- */
-static void
-ScrollPane_scrollH(Widget w, XtPointer client_data, XtPointer call_data)
-{
-    postScrollEvent(java_awt_Adjustable_HORIZONTAL, (jobject)client_data,
-                    (XmScrollBarCallbackStruct *)call_data);
-}
-
-
-typedef XmNavigability (*NavigableCallback) (Widget);
-
-NavigableCallback oldClipNavigable = NULL;
-Boolean clipCallbackInitialized = False;
-XmNavigability MyClipNavigable(Widget wid) {
-    // We've installed this function for ClipWindow
-    if (XmIsClipWindow(wid)) {
-        // To be able to request focus on ClipWindow by call
-        // XmProcessTraversal(, XmTRAVERSE_CURRENT) we need to make
-        // it return XmCONTROL_NAVIGABLE. Default implementation returns
-        // DESCENDANTS_TAB_NAVIGABLE which doesn't allow this.
-        return XmCONTROL_NAVIGABLE;
-    }
-    if (oldClipNavigable) {
-        return oldClipNavigable(wid);
-    }
-    // this will never happen
-    return XmCONTROL_NAVIGABLE;
-}
-
-const char * ScrollPaneManagerName = "ScrolledWindowClipWindow";
-NavigableCallback oldManagerNavigable = NULL;
-Boolean managerCallbackInitialized = False;
-XmNavigability MyManagerNavigable(Widget wid) {
-    // We've installed this function for Manager
-    // with the name ScrollPaneManagerName
-    if (XmIsManager(wid)
-        && ( XtName(wid) != NULL && strcmp(XtName(wid), ScrollPaneManagerName) == 0) )
-    {
-        // To be able to request focus on Manager by call
-        // XmProcessTraversal(, XmTRAVERSE_CURRENT) we need to make
-        // it return XmCONTROL_NAVIGABLE. Default implementation returns
-        // DESCENDANTS_TAB_NAVIGABLE which doesn't allow this.
-        return XmCONTROL_NAVIGABLE;
-    }
-    if (oldManagerNavigable) {
-        return oldManagerNavigable(wid);
-    }
-    // this will never happen
-    return XmCONTROL_NAVIGABLE;
-}
-
-/*
- * Class:     sun_awt_motif_MScrollPanePeer
- * Method:    create
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MScrollPanePeer_create
-  (JNIEnv *env, jobject this, jobject parent)
-{
-    int32_t argc;
-#define MAX_ARGC 40
-    Arg args[MAX_ARGC];
-    struct ComponentData *wdata;
-    struct ComponentData *sdata;
-    jobject target;
-    Pixel bg;
-    Widget vsb, hsb;
-    jint sbDisplay;
-    jobject globalRef = awtJNI_CreateAndSetGlobalRef(env, this);
-    AwtGraphicsConfigDataPtr adata;
-
-    AWT_LOCK();
-
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-
-        return;
-    }
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-    wdata = (struct ComponentData *)
-      JNU_GetLongFieldAsPtr(env,parent,mComponentPeerIDs.pData);
-
-    if (JNU_IsNull(env, target) || wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-
-        return;
-    }
-    sdata = ZALLOC(ComponentData);
-    JNU_SetLongFieldFromPtr(env,this,mComponentPeerIDs.pData,sdata);
-
-    if (sdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaGetValues(wdata->widget, XmNbackground, &bg, NULL);
-
-    adata = copyGraphicsConfigToPeer(env, this);
-
-    argc = 0;
-
-    sbDisplay =
-      (*env)->GetIntField(env, target, scrollPaneIDs.scrollbarDisplayPolicy);
-
-    XtSetArg(args[argc], XmNuserData, (XtPointer) globalRef);
-    argc++;
-
-
-    if (sbDisplay == java_awt_ScrollPane_SCROLLBARS_NEVER) {
-        DASSERT(!(argc > MAX_ARGC));
-        sdata->widget = XtCreateWidget(ScrollPaneManagerName,
-                                       xmManagerWidgetClass, wdata->widget,
-                                       args, argc);
-
-        {
-            // To be able to request focus on Manager by call
-            // XmProcessTraversal(, XmTRAVERSE_CURRENT) we need to make
-            // it return XmCONTROL_NAVIGABLE from widgetNavigable callback.
-            // Default implementation returns DESCENDANTS_TAB_NAVIGABLE
-            // which doesn't allow this.
-            if (!managerCallbackInitialized) {
-                XmBaseClassExt *er;
-                WidgetClass wc;
-                managerCallbackInitialized = True;
-                wc = (WidgetClass) &xmManagerClassRec;
-                er = _XmGetBaseClassExtPtr(wc, XmQmotif);
-                oldManagerNavigable = (*er)->widgetNavigable;
-                (*er)->widgetNavigable = MyManagerNavigable;
-            }
-        }
-    }
-    else
-    {
-        XtSetArg(args[argc], XmNscrollingPolicy, XmAUTOMATIC);
-        argc++;
-        XtSetArg(args[argc], XmNvisualPolicy, XmCONSTANT);
-        argc++;
-        if (sbDisplay == java_awt_ScrollPane_SCROLLBARS_ALWAYS) {
-            DASSERT(!(argc > MAX_ARGC));
-            XtSetArg(args[argc], XmNscrollBarDisplayPolicy, XmSTATIC);
-            argc++;
-        } else {
-            XtSetArg(args[argc], XmNscrollBarDisplayPolicy, XmAS_NEEDED);
-            argc++;
-        }
-
-        XtSetArg(args[argc], XmNspacing, 0);
-        argc++;
-        XtSetArg (args[argc], XmNscreen,
-                  ScreenOfDisplay(awt_display,
-                                  adata->awt_visInfo.screen));
-        argc++;
-
-        DASSERT(!(argc > MAX_ARGC));
-        sdata->widget = XmCreateScrolledWindow(wdata->widget, "scroller", args, argc);
-
-        XtVaGetValues(sdata->widget,
-                      XmNverticalScrollBar, &vsb,
-                      XmNhorizontalScrollBar, &hsb,
-                      NULL);
-
-        if (vsb != NULL) {
-            XtAddCallback(vsb, XmNincrementCallback, ScrollPane_scrollV, (XtPointer) globalRef);
-            XtAddCallback(vsb, XmNdecrementCallback, ScrollPane_scrollV, (XtPointer) globalRef);
-            XtAddCallback(vsb, XmNpageIncrementCallback, ScrollPane_scrollV, (XtPointer) globalRef);
-            XtAddCallback(vsb, XmNpageDecrementCallback, ScrollPane_scrollV, (XtPointer) globalRef);
-            XtAddCallback(vsb, XmNtoTopCallback, ScrollPane_scrollV, (XtPointer) globalRef);
-            XtAddCallback(vsb, XmNtoBottomCallback, ScrollPane_scrollV, (XtPointer) globalRef);
-            XtAddCallback(vsb, XmNvalueChangedCallback, ScrollPane_scrollV, (XtPointer) globalRef);
-            XtAddCallback(vsb, XmNdragCallback, ScrollPane_scrollV, (XtPointer) globalRef);
-
-            XtVaSetValues(vsb, XmNhighlightThickness, 0, NULL);
-        }
-        if (hsb != NULL) {
-            XtAddCallback(hsb, XmNincrementCallback, ScrollPane_scrollH, (XtPointer) globalRef);
-            XtAddCallback(hsb, XmNdecrementCallback, ScrollPane_scrollH, (XtPointer) globalRef);
-            XtAddCallback(hsb, XmNpageIncrementCallback, ScrollPane_scrollH, (XtPointer) globalRef);
-            XtAddCallback(hsb, XmNpageDecrementCallback, ScrollPane_scrollH, (XtPointer) globalRef);
-            XtAddCallback(hsb, XmNtoTopCallback, ScrollPane_scrollH, (XtPointer) globalRef);
-            XtAddCallback(hsb, XmNtoBottomCallback, ScrollPane_scrollH, (XtPointer) globalRef);
-            XtAddCallback(hsb, XmNvalueChangedCallback, ScrollPane_scrollH, (XtPointer) globalRef);
-            XtAddCallback(hsb, XmNdragCallback, ScrollPane_scrollH, (XtPointer) globalRef);
-
-            XtVaSetValues(hsb, XmNhighlightThickness, 0, NULL);
-        }
-        {
-            /**
-             * Fix for 4033837 - ScrollPane doesn't generate mouse, focus, key events
-             * If ScrollPane created with ALWAYS or AS_NEEDED scrollbars policy then
-             * the upper widget is ClipWindow. We should install callbacks on it to
-             * receive event notifications.
-             */
-            Widget clip = XtNameToWidget(sdata->widget, "*ClipWindow");
-            if (clip != NULL) {
-                // To be able to request focus on Manager by call
-                // XmProcessTraversal(, XmTRAVERSE_CURRENT) we need to make
-                // it return XmCONTROL_NAVIGABLE from widgetNavigable callback.
-                // Default implementation returns DESCENDANTS_TAB_NAVIGABLE
-                // which doesn't allow this.
-                if (!clipCallbackInitialized) {
-                    XmBaseClassExt *er;
-                    clipCallbackInitialized = True;
-                    er = _XmGetBaseClassExtPtr(XtClass(clip), XmQmotif);
-                    oldClipNavigable = (*er)->widgetNavigable;
-                    (*er)->widgetNavigable = MyClipNavigable;
-                }
-                awt_addWidget(clip, sdata->widget, globalRef, java_awt_AWTEvent_MOUSE_EVENT_MASK |
-                              java_awt_AWTEvent_MOUSE_MOTION_EVENT_MASK | java_awt_AWTEvent_KEY_EVENT_MASK);
-            }
-        }
-        {
-            /**
-             * Fix for 4033837 - ScrollPane with ALWAYS doesn't have scrollbars visible
-             * It seems to be the bug in Motif, the workaround is to add empty child.
-             * User child will replace it when needed. This doesn't work if child had been
-             * removed.
-             */
-            if (sbDisplay == java_awt_ScrollPane_SCROLLBARS_ALWAYS) {
-                Widget darea = NULL;
-                argc = 0;
-                XtSetArg(args[argc], XmNwidth, 1);
-                argc++;
-                XtSetArg(args[argc], XmNheight, 1);
-                argc++;
-                XtSetArg(args[argc], XmNmarginWidth, 0);
-                argc++;
-                XtSetArg(args[argc], XmNmarginHeight, 0);
-                argc++;
-                XtSetArg(args[argc], XmNspacing, 0);
-                argc++;
-                XtSetArg(args[argc], XmNresizePolicy, XmRESIZE_NONE);
-                argc++;
-                darea = XmCreateDrawingArea(sdata->widget, "null_child", args, argc);
-
-                XmScrolledWindowSetAreas(sdata->widget, NULL, NULL, darea);
-                XtSetMappedWhenManaged(darea, False);
-                XtManageChild(darea);
-            }
-        }
-
-    }
-
-    XtSetMappedWhenManaged(sdata->widget, False);
-    XtManageChild(sdata->widget);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MScrollPanePeer
- * Method:    pSetScrollChild
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MScrollPanePeer_pSetScrollChild
-  (JNIEnv *env, jobject this, jobject child)
-{
-    struct ComponentData *cdata;
-    struct ComponentData *sdata;
-    jobject target;
-
-    AWT_LOCK();
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    if (JNU_IsNull(env, child) || JNU_IsNull(env, target)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-
-        return;
-    }
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,child,mComponentPeerIDs.pData);
-    sdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (sdata == NULL || cdata == NULL || sdata->widget == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-
-        return;
-    }
-    if ((*env)->GetIntField(env, target, scrollPaneIDs.scrollbarDisplayPolicy)
-        == java_awt_ScrollPane_SCROLLBARS_NEVER) {
-        /* Do Nothing */
-    } else {
-        XmScrolledWindowSetAreas(sdata->widget, NULL, NULL, cdata->widget);
-        /*
-          XtInsertEventHandler(cdata->widget, StructureNotifyMask, FALSE,
-          child_event_handler, sdata->widget, XtListHead);
-        */
-    }
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MScrollPanePeer
- * Method:    pSetIncrement
- * Signature: (III)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MScrollPanePeer_pSetIncrement
-  (JNIEnv *env, jobject this, jint orient, jint incrType, jint incr)
-{
-    struct ComponentData *sdata;
-    Widget scrollbar = NULL;
-
-    AWT_LOCK();
-
-    sdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (sdata == NULL || sdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (!XtIsSubclass(sdata->widget, xmScrolledWindowWidgetClass)) {
-        AWT_UNLOCK();
-        return;
-    }
-    if (orient == java_awt_Adjustable_VERTICAL) {
-        XtVaGetValues(sdata->widget,
-                      XmNverticalScrollBar, &scrollbar,
-                      NULL);
-    } else {
-        XtVaGetValues(sdata->widget,
-                      XmNhorizontalScrollBar, &scrollbar,
-                      NULL);
-    }
-
-    if (scrollbar != NULL) {
-        if (incrType == sun_awt_motif_MScrollPanePeer_UNIT_INCREMENT) {
-            XtVaSetValues(scrollbar,
-                          XmNincrement, (XtArgVal) incr,
-                          NULL);
-
-        } else {
-            /* BLOCK_INCREMENT */
-            XtVaSetValues(scrollbar,
-                          XmNpageIncrement, (XtArgVal) incr,
-                          NULL);
-        }
-    }
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MScrollPanePeer
- * Method:    pGetScrollbarSpace
- * Signature: (I)I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MScrollPanePeer_pGetScrollbarSpace
-  (JNIEnv *env, jobject this, jint orient)
-{
-    struct ComponentData *sdata;
-    Widget scrollbar;
-    Dimension thickness = 0;
-    Dimension space = 0;
-    Dimension highlight = 0;
-
-    AWT_LOCK();
-
-    sdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (sdata == NULL || sdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return 0;
-    }
-    if (orient == java_awt_Adjustable_VERTICAL) {
-        XtVaGetValues(sdata->widget,
-                      XmNverticalScrollBar, &scrollbar,
-                      XmNspacing, &space,
-                      NULL);
-        XtVaGetValues(scrollbar,
-                      XmNwidth, &thickness,
-                      XmNhighlightThickness, &highlight,
-                      NULL);
-    } else {
-        XtVaGetValues(sdata->widget,
-                      XmNhorizontalScrollBar, &scrollbar,
-                      XmNspacing, &space,
-                      NULL);
-        XtVaGetValues(scrollbar,
-                      XmNheight, &thickness,
-                      XmNhighlightThickness, &highlight,
-                      NULL);
-    }
-
-    AWT_UNLOCK();
-    return (jint) (thickness + space + 2 * highlight);
-}
-
-/*
- * Class:     sun_awt_motif_MScrollPanePeer
- * Method:    pGetBlockIncrement
- * Signature: (I)I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MScrollPanePeer_pGetBlockIncrement
-  (JNIEnv *env, jobject this, jint orient)
-{
-    int32_t pageIncr = 0;
-    struct ComponentData *sdata;
-    Widget scrollbar;
-
-    AWT_LOCK();
-
-    sdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (sdata == NULL || sdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return 0;
-    }
-    if (orient == java_awt_Adjustable_VERTICAL) {
-
-        XtVaGetValues(sdata->widget,
-                      XmNverticalScrollBar, &scrollbar,
-                      NULL);
-        XtVaGetValues(scrollbar,
-                      XmNpageIncrement, &pageIncr,
-                      NULL);
-    } else {
-
-        XtVaGetValues(sdata->widget,
-                      XmNhorizontalScrollBar, &scrollbar,
-                      NULL);
-        XtVaGetValues(scrollbar,
-                      XmNpageIncrement, &pageIncr,
-                      NULL);
-    }
-
-    AWT_UNLOCK();
-    return (jint) (pageIncr);
-}
-
-/*
- * Class:     sun_awt_motif_MScrollPanePeer
- * Method:    pInsets
- * Signature: (IIII)Ljava/awt/Insets;
- */
-JNIEXPORT jobject JNICALL Java_sun_awt_motif_MScrollPanePeer_pInsets
-  (JNIEnv *env, jobject this, jint width, jint height, jint childWidth, jint childHeight)
-{
-    struct ComponentData *sdata;
-    jobject target;
-    jobject insets = NULL;
-    Widget hsb, vsb;
-    Dimension hsbThickness, hsbHighlight, hsbSpace = 0,
-              vsbThickness, vsbHighlight, vsbSpace = 0,
-              space, border, shadow, hMargin, vMargin;
-    unsigned char placement;
-    Boolean hsbVisible, vsbVisible;
-    jint sbDisplay;
-    int32_t top, left, right, bottom;
-    jclass clazz;
-    jmethodID mid;
-
-    AWT_LOCK();
-
-    sdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    if (JNU_IsNull(env, target) || sdata == NULL || sdata->widget == NULL)
-    {
-        JNU_ThrowNullPointerException(env, "sdata is NULL");
-        AWT_UNLOCK();
-        return 0;
-    }
-    sbDisplay =
-      (*env)->GetIntField(env, target, scrollPaneIDs.scrollbarDisplayPolicy);
-
-    /* REMIND: investigate caching these values rather than querying for
-     * them each time.
-     */
-
-    if (sbDisplay == java_awt_ScrollPane_SCROLLBARS_NEVER) {
-        XtVaGetValues(sdata->widget,
-                      XmNshadowThickness, &shadow,
-                      NULL);
-        space = border = hMargin = vMargin = 0;
-
-    } else {
-        XtVaGetValues(sdata->widget,
-                      XmNverticalScrollBar, &vsb,
-                      XmNhorizontalScrollBar, &hsb,
-                      XmNscrollBarPlacement, &placement,
-                      XmNspacing, &space,
-                      XmNshadowThickness, &shadow,
-                      XmNscrolledWindowMarginHeight, &vMargin,
-                      XmNscrolledWindowMarginWidth, &hMargin,
-                      XmNborderWidth, &border,
-                      NULL);
-
-        XtVaGetValues(vsb,
-                      XmNwidth, &vsbThickness,
-                      XmNhighlightThickness, &vsbHighlight,
-                      NULL);
-
-        XtVaGetValues(hsb,
-                      XmNheight, &hsbThickness,
-                      XmNhighlightThickness, &hsbHighlight,
-                      NULL);
-
-        hsbSpace = hsbThickness + space + hsbHighlight;
-        vsbSpace = vsbThickness + space + vsbHighlight;
-
-/*
-  XtVaGetValues(clip,
-  XmNwidth, &clipw, XmNheight, &cliph,
-  XmNx, &clipx, XmNy, &clipy,
-  NULL);
-  printf("insets: spacing=%d shadow=%d swMarginH=%d swMarginW=%d border=%d ; \
-  vsb=%d vsbHL=%d ; hsb=%d hsbHL=%d ; %dx%d ->clip=%d,%d %dx%d\n",
-  space, shadow, vMargin, hMargin, border,
-  vsbThickness, vsbHighlight, hsbThickness, hsbHighlight,
-  w, h, clipx, clipy, clipw, cliph);
-*/
-    }
-
-    /* We unfortunately have to use the size parameters to determine
-     * whether or not "as needed" scrollbars are currently present or
-     * not because we can't necessarily rely on getting valid geometry
-     * values straight from the Motif widgets until they are mapped. :(
-     */
-    switch (sbDisplay) {
-        case java_awt_ScrollPane_SCROLLBARS_NEVER:
-            vsbVisible = hsbVisible = FALSE;
-            break;
-
-        case java_awt_ScrollPane_SCROLLBARS_ALWAYS:
-            vsbVisible = hsbVisible = TRUE;
-            break;
-
-        case java_awt_ScrollPane_SCROLLBARS_AS_NEEDED:
-        default:
-            vsbVisible = hsbVisible = FALSE;
-            if (childWidth > width - 2 * shadow) {
-                hsbVisible = TRUE;
-            }
-            if (childHeight > height - 2 * shadow) {
-                vsbVisible = TRUE;
-            }
-            if (!hsbVisible && vsbVisible && childWidth > width - 2 * shadow - vsbSpace) {
-                hsbVisible = TRUE;
-            } else if (!vsbVisible && hsbVisible && childHeight > height - 2 * shadow - hsbSpace) {
-                vsbVisible = TRUE;
-            }
-    }
-
-    top = bottom = shadow + vMargin;
-    left = right = shadow + hMargin;
-
-    if (sbDisplay != java_awt_ScrollPane_SCROLLBARS_NEVER) {
-        switch (placement) {
-            case XmBOTTOM_RIGHT:
-                bottom += (hsbVisible ? hsbSpace : (vsbVisible ? vsbHighlight : 0));
-                right += (vsbVisible ? vsbSpace : (hsbVisible ? hsbHighlight : 0));
-                top += (vsbVisible ? vsbHighlight : 0);
-                left += (hsbVisible ? hsbHighlight : 0);
-                break;
-
-            case XmBOTTOM_LEFT:
-                bottom += (hsbVisible ? hsbSpace : (vsbVisible ? vsbHighlight : 0));
-                left += (vsbVisible ? hsbSpace : (hsbVisible ? hsbHighlight : 0));
-                top += (vsbVisible ? vsbHighlight : 0);
-                right += (hsbVisible ? hsbHighlight : 0);
-                break;
-
-            case XmTOP_RIGHT:
-                top += (hsbVisible ? hsbSpace : (vsbVisible ? vsbHighlight : 0));
-                right += (vsbVisible ? vsbSpace : (hsbVisible ? hsbHighlight : 0));
-                bottom += (vsbVisible ? vsbHighlight : 0);
-                left += (hsbVisible ? hsbHighlight : 0);
-                break;
-
-            case XmTOP_LEFT:
-                top += (hsbVisible ? hsbSpace : (vsbVisible ? vsbHighlight : 0));
-                left += (vsbVisible ? vsbSpace : (hsbVisible ? hsbHighlight : 0));
-                bottom += (vsbVisible ? vsbHighlight : 0);
-                right += (hsbVisible ? hsbHighlight : 0);
-        }
-    }
-    /* Deadlock prevention:
-     * don't hold the toolkit lock while invoking constructor.
-     */
-    AWT_UNLOCK();
-
-    clazz = (*env)->FindClass(env, "java/awt/Insets");
-    mid = (*env)->GetMethodID(env, clazz, "<init>", "(IIII)V");
-    if (mid != NULL) {
-        insets = (*env)->NewObject(env, clazz, mid,
-                                   (jint) top,
-                                   (jint) left,
-                                   (jint) bottom,
-                                   (jint) right);
-
-    }
-    /* This should catch both method not found and error exceptions */
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-    if (JNU_IsNull(env, insets)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException: insets constructor failed");
-    }
-    return insets;
-}
-
-/*
- * Class:     sun_awt_motif_MScrollPanePeer
- * Method:    setScrollPosition
- * Signature: (II)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MScrollPanePeer_setScrollPosition
-  (JNIEnv *env, jobject this, jint x, jint y)
-{
-    struct ComponentData *sdata;
-    jobject target;
-    Widget hsb, vsb;
-    int32_t size, incr, pIncr;
-
-    AWT_LOCK();
-
-    sdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    if (JNU_IsNull(env, target) || sdata == NULL || sdata->widget == NULL)
-    {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if ((*env)->GetIntField(env, target, scrollPaneIDs.scrollbarDisplayPolicy)
-        == java_awt_ScrollPane_SCROLLBARS_NEVER) {
-        WidgetList children;
-        Cardinal numChildren;
-
-        XtVaGetValues(sdata->widget,
-                      XmNchildren, &children,
-                      XmNnumChildren, &numChildren,
-                      NULL);
-
-        if (numChildren < 1) {
-            JNU_ThrowNullPointerException(env, "NullPointerException");
-            AWT_UNLOCK();
-            return;
-        }
-        XtMoveWidget(children[0], (Position) -x, (Position) -y);
-    } else {
-        int32_t sb_min = 0;
-        int32_t sb_max = 0;
-        XtVaGetValues(sdata->widget,
-                      XmNhorizontalScrollBar, &hsb,
-                      XmNverticalScrollBar, &vsb,
-                      NULL);
-
-        if (vsb) {
-            XtVaGetValues(vsb,
-                          XmNincrement, &incr,
-                          XmNpageIncrement, &pIncr,
-                          XmNsliderSize, &size,
-                          XmNminimum, &sb_min,
-                          XmNmaximum, &sb_max,
-                          NULL);
-            /* Bug 4208972, 4275934 : Do range checking for scroll bar value. */
-            if (y < sb_min)
-                y = sb_min;
-            if (y > (sb_max - size))
-                y = sb_max - size;
-            XmScrollBarSetValues(vsb, (int32_t) y, size, incr, pIncr, TRUE);
-        }
-        if (hsb) {
-            XtVaGetValues(hsb,
-                          XmNincrement, &incr,
-                          XmNpageIncrement, &pIncr,
-                          XmNsliderSize, &size,
-                          XmNminimum, &sb_min,
-                          XmNmaximum, &sb_max,
-                          NULL);
-            /* Bug 4208972, 4275934 : Do range checking for scroll bar value. */
-            if (x < sb_min)
-                x = sb_min;
-            if (x > (sb_max - size))
-                x = sb_max - size;
-            XmScrollBarSetValues(hsb, (int32_t) x, size, incr, pIncr, TRUE);
-        }
-    }
-    AWT_FLUSH_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_MScrollPanePeer
- * Method:    pGetShadow
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MScrollPanePeer_pGetShadow(
-                       JNIEnv *env, jobject this) {
-    struct ComponentData *sdata;
-    jobject target;
-    Dimension shadow=0 ;
-
-    AWT_LOCK() ;
-    sdata = (struct ComponentData *)
-    (*env)->GetLongField(env,this,mComponentPeerIDs.pData);
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    if (JNU_IsNull(env, target) || sdata == NULL || sdata->widget == NULL)
-    {
-        JNU_ThrowNullPointerException(env, "sdata is NULL");
-        AWT_UNLOCK();
-        return 0;
-    }
-
-    XtVaGetValues(sdata->widget,
-        XmNshadowThickness,
-        &shadow,
-        NULL);
-
-    AWT_UNLOCK() ;
-
-    return((jint)shadow) ;
-}
-
-/*
- * Class:     sun_awt_motif_MScrollPanePeer
- * Method:    setTypedValue
- * Signature: (Ljava/awt/ScrollPaneAdjustable;II)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MScrollPanePeer_setTypedValue(JNIEnv *env, jobject peer, jobject adjustable, jint value, jint type)
-{
-    static jmethodID setTypedValueMID = 0;
-    if (setTypedValueMID == NULL) {
-        jclass clazz = (*env)->FindClass(env, "java/awt/ScrollPaneAdjustable");
-        if ((*env)->ExceptionOccurred(env)) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-            return;
-        }
-        setTypedValueMID = (*env)->GetMethodID(env, clazz, "setTypedValue", "(II)V");
-        (*env)->DeleteLocalRef(env, clazz);
-
-        DASSERT(setTypedValueMID != NULL);
-    }
-    (*env)->CallVoidMethod(env, adjustable, setTypedValueMID, value, type);
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Selection.c openjdk/jdk/src/solaris/native/sun/awt/awt_Selection.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_Selection.c	2014-04-08 05:27:03.450875088 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_Selection.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,508 +0,0 @@
-/*
- * Copyright (c) 1996, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "awt_DataTransferer.h"
-#include "java_awt_datatransfer_Transferable.h"
-#include "java_awt_datatransfer_DataFlavor.h"
-#include "sun_awt_motif_X11Selection.h"
-#include "sun_awt_motif_X11Clipboard.h"
-#include <X11/Intrinsic.h>
-#include <X11/Xatom.h>
-#include <inttypes.h>
-
-#include <jni.h>
-#include <jni_util.h>
-
-/* fieldIDs for X11Selection fields that may be accessed from C */
-static struct X11SelectionIDs {
-    jfieldID holder;
-    jfieldID atom;
-    jfieldID contents;
-    jfieldID selections;
-} x11SelectionIDs;
-
-DECLARE_JAVA_CLASS(selectionClazz, "sun/awt/motif/X11Selection")
-
-static jobject
-call_getSelectionsArray(JNIEnv* env) {
-    DECLARE_STATIC_OBJECT_JAVA_METHOD(getSelectionsArray, selectionClazz,
-                                    "getSelectionsArray", "()[Ljava/lang/Object;")
-    DASSERT(!JNU_IsNull(env, getSelectionsArray));
-    return (*env)->CallStaticObjectMethod(env, clazz, getSelectionsArray);
-}
-
-static void
-call_checkChange(JNIEnv* env, jobject jselection, jlongArray targetArray)
-{
-    DECLARE_VOID_JAVA_METHOD(checkChangeMID, selectionClazz,
-                             "checkChange", "([J)V")
-    DASSERT(!JNU_IsNull(env, jselection));
-
-    (*env)->CallVoidMethod(env, jselection, checkChangeMID, targetArray);
-}
-
-static jlongArray
-call_getSelectionAtomsToCheckChange(JNIEnv* env)
-{
-    DECLARE_STATIC_OBJECT_JAVA_METHOD(getSelectionAtomsToCheckChangeMID,
-            selectionClazz, "getSelectionAtomsToCheckChange", "()[J")
-
-    return (jlongArray)(*env)->CallStaticObjectMethod(env,
-            get_selectionClazz(env), getSelectionAtomsToCheckChangeMID);
-
-}
-
-
-/*
- * Class:     sun_awt_motif_X11Selection
- * Method:    initIDs
- * Signature: ()V
- */
-/* This function gets called from the static initializer for
-   X11Selection.java to initialize the fieldIDs for fields that may
-   be accessed from C */
-JNIEXPORT void JNICALL Java_sun_awt_motif_X11Selection_initIDs
-    (JNIEnv *env, jclass cls)
-{
-    x11SelectionIDs.holder = (*env)->
-        GetFieldID(env, cls, "holder","Lsun/awt/motif/X11SelectionHolder;");
-    x11SelectionIDs.atom = (*env)->GetFieldID(env, cls, "atom", "J");
-    x11SelectionIDs.contents = (*env)->
-        GetFieldID(env, cls, "contents",
-                   "Ljava/awt/datatransfer/Transferable;");
-    x11SelectionIDs.selections = (*env)->
-        GetStaticFieldID(env, cls, "selections", "Ljava/util/Vector;");
-}
-
-/*
- * Class:     sun_awt_motif_X11Selection
- * Method:    init
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_X11Selection_init
-    (JNIEnv *env, jclass this)
-{
-    AWT_LOCK();
-
-    AWT_UNLOCK();
-}
-
-static jobject
-getX11Selection(JNIEnv * env, Atom atom)
-{
-    jobjectArray selections;
-    jsize selectionCount, i;
-    jobject selection;
-    jobject returnSelection = NULL;
-
-    selections = (jobjectArray)call_getSelectionsArray(env);
-
-    if (JNU_IsNull(env, selections)) {
-        return NULL;
-    }
-
-    selectionCount = (*env)->GetArrayLength(env, selections);
-
-    for (i = 0; i < selectionCount; i++) {
-        selection = (*env)->GetObjectArrayElement(env, selections, i);
-        if ((*env)->ExceptionCheck(env)) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-            break;
-        }
-        if (JNU_IsNull(env, selection)) {
-            break;
-        }
-        if ((*env)->GetLongField(env, selection, x11SelectionIDs.atom) == atom) {
-            returnSelection = selection;
-        } else {
-            (*env)->DeleteLocalRef(env, selection);
-        }
-    }
-
-    (*env)->DeleteLocalRef(env, selections);
-
-    return returnSelection;
-}
-
-Boolean
-awtJNI_isSelectionOwner(JNIEnv * env, char *sel_str)
-{
-    Atom selection;
-    jobject x11sel;
-
-    selection = XInternAtom(awt_display, sel_str, False);
-
-    x11sel = getX11Selection(env, selection);
-    if (!JNU_IsNull(env, x11sel)) {
-        jobject holder;
-
-        holder = (*env)->GetObjectField(env, x11sel, x11SelectionIDs.holder);
-        if (!JNU_IsNull(env, holder)) {
-            return TRUE;
-        }
-    }
-    return FALSE;
-}
-
-static void losingSelectionOwnership(Widget w, Atom * selection);
-
-void
-awtJNI_notifySelectionLost(JNIEnv * env, char *sel_str)
-{
-    Atom selection;
-
-    selection = XInternAtom(awt_display, sel_str, False);
-    losingSelectionOwnership(NULL, &selection);
-}
-
-static void
-losingSelectionOwnership(Widget w, Atom * selection)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject this = getX11Selection(env, *selection);
-
-    /*
-     * SECURITY: OK to call this on privileged thread - peer does
-     *         not call into client code
-     */
-    JNU_CallMethodByName(env, NULL, this, "lostSelectionOwnership", "()V");
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-    /*
-     * Fix for 4692059.
-     * The native context is cleaned up on the event dispatch thread after the
-     * references to the current contents and owner are cleared.
-     */
-}
-
-/*
- * Class:     sun_awt_motif_X11Selection
- * Method:    pGetSelectionOwnership
- * Signature: (Ljava/lang/Object;Ljava/awt/datatransfer/Transferable;[JLjava/util/Map;Lsun/awt/motif/X11SelectionHolder;)Z
- */
-JNIEXPORT jboolean JNICALL
-Java_sun_awt_motif_X11Selection_pGetSelectionOwnership(JNIEnv *env,
-                                                       jobject this,
-                                                       jobject source,
-                                                       jobject transferable,
-                                                       jlongArray formats,
-                                                       jobject formatMap,
-                                                       jobject holder)
-{
-    Boolean gotit = False;
-    Atom selection = (Atom)(*env)->GetLongField(env, this,
-                                                x11SelectionIDs.atom);
-    awt_convertDataCallbackStruct* structPtr = NULL;
-    Time time = CurrentTime;
-
-    AWT_LOCK();
-
-    time = awt_util_getCurrentServerTime();
-
-    (*env)->SetObjectField(env, this, x11SelectionIDs.holder, NULL);
-    (*env)->SetObjectField(env, this, x11SelectionIDs.contents, NULL);
-
-    gotit = XtOwnSelection(awt_root_shell, selection, time, awt_convertData,
-                           losingSelectionOwnership, NULL);
-
-    if (gotit) {
-        if (XFindContext(awt_display, selection, awt_convertDataContext,
-                         (XPointer*)&structPtr) == 0 && structPtr != NULL) {
-            (*env)->DeleteGlobalRef(env, structPtr->source);
-            (*env)->DeleteGlobalRef(env, structPtr->transferable);
-            (*env)->DeleteGlobalRef(env, structPtr->formatMap);
-            (*env)->DeleteGlobalRef(env, structPtr->formats);
-            memset(structPtr, 0, sizeof(awt_convertDataCallbackStruct));
-        } else {
-            XDeleteContext(awt_display, selection, awt_convertDataContext);
-
-            structPtr = calloc(1, sizeof(awt_convertDataCallbackStruct));
-
-            if (structPtr == NULL) {
-                XtDisownSelection(awt_root_shell, selection, time);
-                AWT_UNLOCK();
-                JNU_ThrowOutOfMemoryError(env, "");
-                return JNI_FALSE;
-            }
-
-            if (XSaveContext(awt_display, selection, awt_convertDataContext,
-                             (XPointer)structPtr) == XCNOMEM) {
-                XtDisownSelection(awt_root_shell, selection, time);
-                free(structPtr);
-                AWT_UNLOCK();
-                JNU_ThrowInternalError(env, "Failed to save context data for selection.");
-                return JNI_FALSE;
-            }
-        }
-
-        structPtr->source = (*env)->NewGlobalRef(env, source);
-        structPtr->transferable = (*env)->NewGlobalRef(env, transferable);
-        structPtr->formatMap = (*env)->NewGlobalRef(env, formatMap);
-        structPtr->formats = (*env)->NewGlobalRef(env, formats);
-
-        if (JNU_IsNull(env, structPtr->source) ||
-            JNU_IsNull(env, structPtr->transferable) ||
-            JNU_IsNull(env, structPtr->formatMap) ||
-            JNU_IsNull(env, structPtr->formats)) {
-
-            if (!JNU_IsNull(env, structPtr->source)) {
-                (*env)->DeleteGlobalRef(env, structPtr->source);
-            }
-            if (!JNU_IsNull(env, structPtr->transferable)) {
-                (*env)->DeleteGlobalRef(env, structPtr->transferable);
-            }
-            if (!JNU_IsNull(env, structPtr->formatMap)) {
-                (*env)->DeleteGlobalRef(env, structPtr->formatMap);
-            }
-            if (!JNU_IsNull(env, structPtr->formats)) {
-                (*env)->DeleteGlobalRef(env, structPtr->formats);
-            }
-            XtDisownSelection(awt_root_shell, selection, time);
-            XDeleteContext(awt_display, selection, awt_convertDataContext);
-            free(structPtr);
-            AWT_UNLOCK();
-            JNU_ThrowOutOfMemoryError(env, "");
-            return JNI_FALSE;
-        }
-
-        (*env)->SetObjectField(env, this, x11SelectionIDs.holder, holder);
-        (*env)->SetObjectField(env, this, x11SelectionIDs.contents, transferable);
-    }
-    AWT_UNLOCK();
-
-    return (gotit ? JNI_TRUE : JNI_FALSE);
-}
-
-/*
- * Class:     sun_awt_motif_X11Selection
- * Method:    clearNativeContext
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_X11Selection_clearNativeContext(JNIEnv *env, jobject this) {
-    Atom selection = (Atom)(*env)->GetLongField(env, this,
-                                                x11SelectionIDs.atom);
-
-    AWT_LOCK();
-
-    XtDisownSelection(awt_root_shell, selection, CurrentTime);
-    awt_cleanupConvertDataContext(env, selection);
-
-    AWT_UNLOCK();
-}
-
-
-static void
-getSelectionTargetsToCheckChange(Widget w, XtPointer client_data,
-        Atom * selection, Atom * type, XtPointer value, unsigned long *length,
-        int32_t *format)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    size_t count = 0, i = 0, j = 0;
-    jlongArray targetArray = NULL;
-
-    // Should keep this in sync with getSelectionTargets() so that
-    // this function yields non-null targetArray iff
-    // getSelectionTargets() yields SelectionSuccess.
-    if (*type == XA_TARGETS || *type == XA_ATOM) {
-        targetArray = getSelectionTargetsHelper(env, value, *length);
-    } else if (*type != XT_CONVERT_FAIL) {
-        targetArray = (*env)->NewLongArray(env, 0);
-    }
-
-    if (value != NULL) {
-        XtFree(value);
-        value = NULL;
-    }
-
-    {
-        jobject jselection = getX11Selection(env, *selection);
-        call_checkChange(env, jselection, targetArray);
-        if ((*env)->ExceptionCheck(env)) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-        (*env)->DeleteLocalRef(env, targetArray);
-        (*env)->DeleteLocalRef(env, jselection);
-    }
-}
-
-
-static Atom _XA_JAVA_TIME_PROPERTY_ATOM_CHECK_SELECTION_CHANGE_ON_TIMEOUT = 0;
-
-static void
-checkSelectionChangeOnTimeout(XtPointer client_data, XtIntervalId* id)
-{
-    // We don't call XtGetSelectionValue(..., TARGETS, ..., awt_util_getCurrentServerTime())
-    // here because awt_util_getCurrentServerTime() may block toolkit therad for a while
-    // whereas the current function is called very often at regular intervals.
-    // Instead we call XtGetSelectionValue(..., XtLastTimestampProcessed(awt_display))
-    // in the property change event handler wherein we have got an up-to-date timestamp.
-
-    XChangeProperty(awt_display, XtWindow(awt_root_shell),
-                    _XA_JAVA_TIME_PROPERTY_ATOM_CHECK_SELECTION_CHANGE_ON_TIMEOUT,
-                    XA_ATOM, 32, PropModeAppend, (unsigned char *)"", 0);
-    XFlush(awt_display);
-}
-
-
-static unsigned long selectionPollInterval;
-
-static void
-propertyChangeEventHandlerToSelectionCheck
-(Widget w, XtPointer client_data, XEvent* event, Boolean* continue_to_dispatch)
-{
-    JNIEnv *env;
-    jlongArray jselectionAtoms;
-
-    if (event->type != PropertyNotify || event->xproperty.atom !=
-            _XA_JAVA_TIME_PROPERTY_ATOM_CHECK_SELECTION_CHANGE_ON_TIMEOUT) {
-        return;
-    }
-
-    env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jselectionAtoms = call_getSelectionAtomsToCheckChange(env);
-
-    DASSERT(!JNU_IsNull(env, jselectionAtoms));
-    if ((*env)->ExceptionCheck(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    } else {
-        jsize len = (*env)->GetArrayLength(env, jselectionAtoms);
-        jlong* selectionAtomsNative =
-                (*env)->GetLongArrayElements(env, jselectionAtoms, NULL);
-        if (!JNU_IsNull(env, selectionAtomsNative)) {
-            jsize i = 0;
-            for (i = 0; i < len; i++) {
-                XtGetSelectionValue(awt_root_shell, (Atom)selectionAtomsNative[i], XA_TARGETS,
-                                    getSelectionTargetsToCheckChange, (XtPointer)NULL,
-                                    XtLastTimestampProcessed(awt_display));
-            }
-            (*env)->ReleaseLongArrayElements(env, jselectionAtoms,
-                                             selectionAtomsNative, JNI_ABORT);
-        }
-    }
-
-    // Reschedule the timer callback.
-    XtAppAddTimeOut(awt_appContext, selectionPollInterval,
-                    checkSelectionChangeOnTimeout, client_data);
-}
-
-
-static BOOL isClipboardViewerRegistered = FALSE;
-
-/*
- * Class:     sun_awt_motif_X11Clipboard
- * Method:    registerClipboardViewer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_X11Clipboard_registerClipboardViewer(JNIEnv *env, jobject self,
-                                                        jint pollInterval)
-{
-    AWT_LOCK();
-
-    if (isClipboardViewerRegistered) {
-        AWT_UNLOCK();
-        return;
-    }
-
-    if (_XA_JAVA_TIME_PROPERTY_ATOM_CHECK_SELECTION_CHANGE_ON_TIMEOUT == 0) {
-        _XA_JAVA_TIME_PROPERTY_ATOM_CHECK_SELECTION_CHANGE_ON_TIMEOUT =
-                XInternAtom(awt_display,
-                            "_SUNW_JAVA_AWT_TIME_CHECK_SELECTION_CHANGE_ON_TIMEOUT",
-                            False);
-    }
-
-    XtAddEventHandler(awt_root_shell, PropertyChangeMask, False,
-                      propertyChangeEventHandlerToSelectionCheck, NULL);
-
-    selectionPollInterval = pollInterval;
-
-    XtAppAddTimeOut(awt_appContext, selectionPollInterval,
-                    checkSelectionChangeOnTimeout, (XtPointer)NULL);
-
-    isClipboardViewerRegistered = TRUE;
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_X11Clipboard
- * Method:    unregisterClipboardViewer
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_X11Clipboard_unregisterClipboardViewer(JNIEnv *env, jobject self)
-{
-    AWT_LOCK();
-
-    if (!isClipboardViewerRegistered) {
-        AWT_UNLOCK();
-        return;
-    }
-
-    XtRemoveEventHandler(awt_root_shell, PropertyChangeMask, False,
-                         propertyChangeEventHandlerToSelectionCheck, NULL);
-
-    isClipboardViewerRegistered = FALSE;
-
-    AWT_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_X11Clipboard
- * Method:    getClipboardFormats
- * Signature: (J)[J
- */
-JNIEXPORT jlongArray JNICALL
-Java_sun_awt_motif_X11Clipboard_getClipboardFormats
-    (JNIEnv *env, jclass cls, jlong selectionAtom)
-{
-    Time time_stamp = awt_util_getCurrentServerTime();
-    return get_selection_targets(env, selectionAtom, time_stamp);
-}
-
-/*
- * Class:     sun_awt_motif_X11Clipboard
- * Method:    getClipboardData
- * Signature: (JJ)[B
- */
-JNIEXPORT jbyteArray JNICALL
-Java_sun_awt_motif_X11Clipboard_getClipboardData
-    (JNIEnv *env, jclass cls, jlong selectionAtom, jlong format)
-{
-    Time time_stamp = awt_util_getCurrentServerTime();
-    return get_selection_data(env, selectionAtom, format, time_stamp);
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_TextArea.c openjdk/jdk/src/solaris/native/sun/awt/awt_TextArea.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_TextArea.c	2014-04-08 05:27:03.450875088 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_TextArea.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1003 +0,0 @@
-/*
- * Copyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "canvas.h"
-#include "java_awt_TextArea.h"
-#include "java_awt_Cursor.h"
-#include "java_awt_Component.h"
-#include "java_awt_Color.h"
-#include "java_awt_AWTEvent.h"
-#include "java_awt_Font.h"
-#include "java_awt_event_MouseWheelEvent.h"
-#include "sun_awt_motif_MTextAreaPeer.h"
-#include "sun_awt_motif_MComponentPeer.h"
-
-#include "awt_Component.h"
-#include "awt_Cursor.h"
-#include "awt_TextArea.h"
-
-#include <jni.h>
-#include <jni_util.h>
-#include "multi_font.h"
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern struct CursorIDs cursorIDs;
-extern AwtGraphicsConfigDataPtr
-    copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-struct TextAreaIDs textAreaIDs;
-struct MTextAreaPeerIDs mTextAreaPeerIDs;
-
-/*
- * Class:     java_awt_TextArea
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for TextArea.java
-   to initialize the fieldIDs for fields that may be accessed from C */
-
-JNIEXPORT void JNICALL
-Java_java_awt_TextArea_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    textAreaIDs.scrollbarVisibility =
-      (*env)->GetFieldID(env, cls, "scrollbarVisibility", "I");
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for
-   MTextAreaPeer.java to initialize the fieldIDs for fields that may
-   be accessed from C */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MTextAreaPeer_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    mTextAreaPeerIDs.firstChangeSkipped =
-      (*env)->GetFieldID(env, cls, "firstChangeSkipped", "Z");
-}
-
-/*
- * client_data is MTextAreaPeer instance
- */
-void
-TextArea_valueChanged(Widget w, XtPointer client_data, XtPointer call_data)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jboolean skipped;
-
-    skipped = (*env)->GetBooleanField(env, (jobject) client_data,
-                                      mTextAreaPeerIDs.firstChangeSkipped);
-    if (!(*env)->ExceptionOccurred(env)) {
-        if (skipped == JNI_FALSE) {
-            (*env)->SetBooleanField(env, (jobject) client_data,
-                                    mTextAreaPeerIDs.firstChangeSkipped,
-                                    JNI_TRUE);
-        } else {
-            JNU_CallMethodByName(env, NULL, (jobject) client_data,
-                                 "valueChanged", "()V");
-        }
-    }
-
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-extern void Text_handlePaste(Widget w, XtPointer client_data, XEvent * event,
-                             Boolean * cont);
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    pCreate
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_pCreate
-  (JNIEnv *env, jobject this, jobject parent)
-{
-    struct TextAreaData *tdata;
-#define MAX_ARGC 30
-    Arg args[MAX_ARGC];
-    int32_t argc;
-    struct ComponentData *wdata;
-    jobject target;
-    Pixel bg;
-    int32_t sbVisibility;
-    Boolean wordWrap = False, hsb = False, vsb = False;
-    jobject globalRef = awtJNI_CreateAndSetGlobalRef(env, this);
-    AwtGraphicsConfigDataPtr adata;
-    char *nonEmptyText = "* will never be shown *";
-
-    AWT_LOCK();
-
-    adata = copyGraphicsConfigToPeer(env, this);
-
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    wdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,parent,mComponentPeerIDs.pData);
-    if (wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    tdata = ZALLOC(TextAreaData);
-    JNU_SetLongFieldFromPtr(env,this,mComponentPeerIDs.pData,tdata);
-
-    if (tdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaGetValues(wdata->widget, XmNbackground, &bg, NULL);
-
-    sbVisibility = (*env)->GetIntField(env, target,
-                                       textAreaIDs.scrollbarVisibility);
-    switch (sbVisibility) {
-        case java_awt_TextArea_SCROLLBARS_NONE:
-            wordWrap = True;
-            hsb = False;
-            vsb = False;
-            break;
-
-        case java_awt_TextArea_SCROLLBARS_VERTICAL_ONLY:
-            wordWrap = True;
-            hsb = False;
-            vsb = True;
-            break;
-
-        case java_awt_TextArea_SCROLLBARS_HORIZONTAL_ONLY:
-            wordWrap = False;
-            hsb = True;
-            vsb = False;
-            break;
-
-        default:
-        case java_awt_TextArea_SCROLLBARS_BOTH:
-            wordWrap = False;
-            hsb = True;
-            vsb = True;
-            break;
-    }
-
-    argc = 0;
-    XtSetArg(args[argc], XmNrecomputeSize, False);
-    argc++;
-    XtSetArg(args[argc], XmNx, 0);
-    argc++;
-    XtSetArg(args[argc], XmNy, 0);
-    argc++;
-    XtSetArg(args[argc], XmNbackground, bg);
-    argc++;
-    XtSetArg(args[argc], XmNeditMode, XmMULTI_LINE_EDIT);
-    argc++;
-    XtSetArg(args[argc], XmNwordWrap, wordWrap);
-    argc++;
-    XtSetArg(args[argc], XmNscrollHorizontal, hsb);
-    argc++;
-    XtSetArg(args[argc], XmNscrollVertical, vsb);
-    argc++;
-    XtSetArg(args[argc], XmNmarginHeight, 2);
-    argc++;
-    XtSetArg(args[argc], XmNmarginWidth, 2);
-    argc++;
-    XtSetArg(args[argc], XmNuserData, (XtPointer) globalRef);
-    argc++;
-    XtSetArg (args[argc], XmNscreen,
-              ScreenOfDisplay(awt_display,
-                              adata->awt_visInfo.screen));
-    argc++;
-    XtSetArg(args[argc], XmNfontList, getMotifFontList());
-    argc++;
-
-    /* Initialize with a non-empty text, so the
-     * TextArea_valueChanged callback will be called
-     * even if the following conditions are true:
-     * 1. TextArea constructed with an empty initial text.
-     * 2. setText() with an empty argument is called
-     *    immediately after the TextArea component is created.
-     * For more details please see #4028580.
-     */
-    XtSetArg(args[argc], XmNvalue, nonEmptyText);
-    argc++;
-
-    DASSERT(!(argc > MAX_ARGC));
-    tdata->txt = XmCreateScrolledText(wdata->widget, "textA",
-                                      args, argc);
-    tdata->comp.widget = XtParent(tdata->txt);
-
-    /* Bug 4208972. Give the ScrolledWindow a minimum size. */
-    XtVaSetValues(tdata->comp.widget,
-        XmNwidth,  1,
-        XmNheight, 1, NULL);
-
-    XtSetMappedWhenManaged(tdata->comp.widget, False);
-    XtManageChild(tdata->txt);
-    XtManageChild(tdata->comp.widget);
-
-    XtAddCallback(tdata->txt,
-                  XmNvalueChangedCallback,
-                  TextArea_valueChanged,
-                  (XtPointer) globalRef);
-
-    XtAddEventHandler(tdata->txt, FocusChangeMask,
-                      True, awt_canvas_event_handler, globalRef);
-
-    XtInsertEventHandler(tdata->txt,
-                         KeyPressMask,
-                         False, Text_handlePaste, (XtPointer) globalRef,
-                         XtListHead);
-
-    awt_addWidget(tdata->txt, tdata->comp.widget, globalRef,
-                  java_awt_AWTEvent_KEY_EVENT_MASK |
-                  java_awt_AWTEvent_MOUSE_EVENT_MASK |
-                  java_awt_AWTEvent_MOUSE_MOTION_EVENT_MASK);
-    /*
-     * Fix for BugTraq ID 4349615.
-     * Unregister Motif drop site to prevent it from crash
-     * when dropping java objects.
-     */
-    XmDropSiteUnregister(tdata->txt);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    getExtraWidth
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MTextAreaPeer_getExtraWidth
-  (JNIEnv *env, jobject this)
-{
-    struct TextAreaData *tdata;
-    Dimension spacing, shadowThickness, textMarginWidth, sbWidth;
-    Widget verticalScrollBar;
-
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return 0;
-    }
-    XtVaGetValues(tdata->txt, XmNmarginWidth, &textMarginWidth, NULL);
-    XtVaGetValues(tdata->comp.widget,
-                  XmNspacing, &spacing,
-                  XmNverticalScrollBar, &verticalScrollBar,
-                  NULL);
-    if (verticalScrollBar != NULL) {
-        /* Assumption:  shadowThickness same for scrollbars and text area */
-        XtVaGetValues(verticalScrollBar,
-                      XmNwidth, &sbWidth,
-                      XmNshadowThickness, &shadowThickness,
-                      NULL);
-    } else {
-        sbWidth = 0;
-        shadowThickness = 0;
-    }
-
-    AWT_UNLOCK();
-
-    return (jint) (sbWidth + spacing + 2 * textMarginWidth + 4 * shadowThickness);
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    getExtraHeight
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MTextAreaPeer_getExtraHeight
-  (JNIEnv *env, jobject this)
-{
-    struct TextAreaData *tdata;
-    Dimension spacing, shadowThickness, textMarginHeight, sbHeight;
-    Dimension sbShadowThickness, highlightThickness, sbHighlightThickness;
-    int32_t height;
-    Widget horizontalScrollBar;
-
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return 0;
-    }
-
-    XtVaGetValues(tdata->txt, XmNmarginHeight, &textMarginHeight,
-                              XmNshadowThickness, &shadowThickness,
-                              XmNhighlightThickness, &highlightThickness, NULL);
-    height = 2 * (textMarginHeight + shadowThickness + highlightThickness);
-
-    XtVaGetValues(tdata->comp.widget,
-                  XmNspacing, &spacing,
-                  XmNhorizontalScrollBar, &horizontalScrollBar,
-                  NULL);
-
-    if (horizontalScrollBar != NULL) {
-        XtVaGetValues(horizontalScrollBar,
-                      XmNshadowThickness, &sbShadowThickness,
-                      XmNhighlightThickness, &sbHighlightThickness,
-                      XmNheight, &sbHeight,
-                      NULL);
-        height += sbHeight + spacing
-                + 2 * (sbShadowThickness + sbHighlightThickness);
-    }
-
-    AWT_UNLOCK();
-
-    return (jint)height;
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    setTextBackground
- * Signature: (Ljava/awt/Color;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_setTextBackground
-  (JNIEnv *env, jobject this, jobject c)
-{
-    struct TextAreaData *tdata;
-    Pixel color;
-
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->txt == NULL || JNU_IsNull(env, c)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    color = awtJNI_GetColor(env, c);
-    XtVaSetValues(tdata->txt,
-                  XmNbackground, color,
-                  NULL);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    pSetEditable
- * Signature: (Z)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_pSetEditable
-  (JNIEnv *env, jobject this, jboolean editable)
-{
-    struct TextAreaData *tdata;
-
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaSetValues(tdata->txt,
-                  XmNeditable, (editable ? True : False),
-                  XmNcursorPositionVisible, (editable ? True : False),
-                  NULL);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    select
- * Signature: (II)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_select
-  (JNIEnv *env, jobject this, jint start, jint end)
-{
-    struct TextAreaData *tdata;
-
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XmTextSetSelection(tdata->txt, (XmTextPosition) start, (XmTextPosition) end, 0);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    getSelectionStart
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MTextAreaPeer_getSelectionStart
-  (JNIEnv *env, jobject this)
-{
-    struct TextAreaData *tdata;
-    XmTextPosition start, end, pos;
-
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return 0;
-    }
-    if (XmTextGetSelectionPosition(tdata->txt, &start, &end) &&
-                                             (start != end)) {
-        pos = start;
-    } else {
-        pos = XmTextGetInsertionPosition(tdata->txt);
-    }
-    AWT_UNLOCK();
-
-    return (jint) pos;
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    getSelectionEnd
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MTextAreaPeer_getSelectionEnd
-  (JNIEnv *env, jobject this)
-{
-    struct TextAreaData *tdata;
-    XmTextPosition start, end, pos;
-
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return 0;
-    }
-    if (XmTextGetSelectionPosition(tdata->txt, &start, &end) &&
-                                             (start != end)) {
-        pos = end;
-    } else {
-        pos = XmTextGetInsertionPosition(tdata->txt);
-    }
-    AWT_UNLOCK();
-
-    return (jint) pos;
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    setText
- * Signature: (Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_setText
-  (JNIEnv *env, jobject this, jstring txt)
-{
-    struct TextAreaData *tdata;
-    char *cTxt;
-    jobject font = awtJNI_GetFont(env, this);
-
-    if (JNU_IsNull(env, txt)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *)
-      JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    cTxt = (char *) JNU_GetStringPlatformChars(env, txt, NULL);
-
-    if (cTxt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaSetValues(tdata->txt, XmNvalue, cTxt, NULL);
-
-    if (cTxt != NULL) {
-        JNU_ReleaseStringPlatformChars(env, txt, cTxt);
-    }
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    getText
- * Signature: ()Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_sun_awt_motif_MTextAreaPeer_getText
-  (JNIEnv *env, jobject this)
-{
-    struct TextAreaData *tdata;
-    char *cTxt;
-    jstring rval;
-    jobject font = awtJNI_GetFont(env, this);
-
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *)
-      JNU_GetLongFieldAsPtr(env,this, mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return NULL;
-    }
-    cTxt = XmTextGetString(tdata->txt);
-
-    rval = JNU_NewStringPlatform(env, (const char *) cTxt);
-
-    XtFree(cTxt);
-
-    AWT_UNLOCK();
-
-    return rval;
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    insert
- * Signature: (Ljava/lang/String;I)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_insert
-  (JNIEnv *env, jobject this, jstring txt, jint pos)
-{
-    struct TextAreaData *tdata;
-    char *cTxt;
-    jobject font = awtJNI_GetFont(env, this);
-
-    if (JNU_IsNull(env, txt)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-    tdata = (struct TextAreaData *)
-      JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    cTxt = (char *) JNU_GetStringPlatformChars(env, txt, NULL);
-
-    if (cTxt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XmTextInsert(tdata->txt, (XmTextPosition) pos, cTxt);
-
-    if (cTxt != NULL) {
-        JNU_ReleaseStringPlatformChars(env, txt, cTxt);
-    }
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    replaceRange
- * Signature: (Ljava/lang/String;II)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_replaceRange
-  (JNIEnv *env, jobject this, jstring txt, jint start, jint end)
-{
-    struct TextAreaData *tdata;
-    char *cTxt;
-    jobject font = awtJNI_GetFont(env, this);
-
-    if (JNU_IsNull(env, txt)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-    tdata = (struct TextAreaData *)
-      JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    cTxt = (char *) JNU_GetStringPlatformChars(env, txt, NULL);
-
-    if (cTxt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XmTextReplace(tdata->txt,
-                  (XmTextPosition) start,
-                  (XmTextPosition) end,
-                  cTxt);
-
-    if (cTxt != NULL) {
-        JNU_ReleaseStringPlatformChars(env, txt, cTxt);
-    }
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    setFont
- * Signature: (Ljava/awt/Font;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_setFont
-  (JNIEnv *env, jobject this, jobject f)
-{
-    struct TextAreaData *tdata;
-    struct FontData *fdata;
-    XmFontList fontlist;
-    char *err;
-    XmFontListEntry fontentry;
-
-    if (JNU_IsNull(env, f)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-    AWT_LOCK();
-
-    fdata = awtJNI_GetFontData(env, f, &err);
-    if (fdata == NULL) {
-        JNU_ThrowInternalError(env, err);
-        AWT_UNLOCK();
-        return;
-    }
-    tdata = (struct TextAreaData *)
-      JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (awtJNI_IsMultiFont(env, f)) {
-        if (fdata->xfs == NULL) {
-            fdata->xfs = awtJNI_MakeFontSet(env, f);
-        }
-        if (fdata->xfs != NULL) {
-            fontentry = XmFontListEntryCreate("labelFont",
-                                              XmFONT_IS_FONTSET,
-                                              (XtPointer) (fdata->xfs));
-            fontlist = XmFontListAppendEntry(NULL, fontentry);
-            /*
-             * Some versions of motif have a bug in
-             * XmFontListEntryFree() which causes it to free more than it
-             * should.  Use XtFree() instead.  See O'Reilly's
-             * Motif Reference Manual for more information.
-             */
-            XmFontListEntryFree(&fontentry);
-
-        } else {
-            fontlist = XmFontListCreate(fdata->xfont, "labelFont");
-        }
-    } else {
-        fontlist = XmFontListCreate(fdata->xfont, "labelFont");
-    }
-
-    if (fontlist != NULL) {
-        Dimension textw, texth;
-        Dimension w, h;
-
-        XtVaGetValues(tdata->txt,
-                      XmNwidth, &textw,
-                      XmNheight, &texth,
-                      NULL);
-        XtVaGetValues(tdata->comp.widget,
-                      XmNwidth, &w,
-                      XmNheight, &h,
-                      NULL);
-
-        /* Must set width/height when we set the font, else
-         * Motif resets the text to a single row.
-         */
-        XtVaSetValues(tdata->txt,
-                      XmNfontList, fontlist,
-                      XmNwidth, textw,
-                      XmNheight, texth,
-                      NULL);
-        XtVaSetValues(tdata->comp.widget,
-                      XmNwidth, w,
-                      XmNheight, h,
-                      NULL);
-
-        XmFontListFree(fontlist);
-    } else {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-    }
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    setCaretPosition
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_setCaretPosition
-  (JNIEnv *env, jobject this, jint pos)
-{
-    struct TextAreaData *tdata;
-
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *)
-      JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XmTextSetInsertionPosition(tdata->txt, (XmTextPosition) pos);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    getCaretPosition
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MTextAreaPeer_getCaretPosition
-  (JNIEnv *env, jobject this)
-{
-    struct TextAreaData *tdata;
-    XmTextPosition pos;
-
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *)
-      JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return 0;
-    }
-    pos = XmTextGetInsertionPosition(tdata->txt);
-
-    AWT_UNLOCK();
-
-    return (jint) pos;
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    pShow
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_pShow2
-  (JNIEnv *env, jobject this)
-{
-    struct TextAreaData *tdata;
-
-    AWT_LOCK();
-    tdata = (struct TextAreaData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    awt_util_show(tdata->comp.widget);
-    AWT_FLUSH_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    pMakeCursorVisible
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_pMakeCursorVisible
-  (JNIEnv *env, jobject this)
-{
-    struct TextAreaData *tdata;
-
-    AWT_LOCK();
-    tdata = (struct TextAreaData *) JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    pSetCursor
- * Signature: (L/java/awt/Cursor;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_pSetCursor
-  (JNIEnv *env, jobject this, jobject cursor)
-{
-    Cursor xcursor;
-    struct TextAreaData         *tdata;
-
-    AWT_LOCK();
-    tdata = (struct TextAreaData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->comp.widget == NULL || JNU_IsNull(env, cursor)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    awt_util_setCursor(tdata->txt, getCursor(env, cursor));
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextAreaPeer
- * Method:    nativeHandleMouseWheel
- * Signature: (III)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextAreaPeer_nativeHandleMouseWheel
-  (JNIEnv *env, jobject this, jint scrollType, jint scrollAmt, jint wheelAmt)
-{
-    struct TextAreaData         *tdata;
-    Widget text = NULL;
-    Widget scroll = NULL;
-
-    AWT_LOCK();
-    tdata = (struct TextAreaData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    // get the Text widget
-    text = tdata->txt;
-    if (text == NULL) {
-        AWT_UNLOCK();
-        return;
-    }
-
-    // get the ScrolledWindow
-    scroll = XtParent(text);
-    if (scroll == NULL) {
-        AWT_UNLOCK();
-        return;
-    }
-
-    awt_util_do_wheel_scroll(scroll, scrollType, scrollAmt, wheelAmt);
-    AWT_UNLOCK();
-}
-
-
-
-/*  To be fully implemented in a future release
- *
- * Class:     sun_awt_windows_MTextAreaPeer
- * Method:    getIndexAtPoint
- * Signature: (II)I
- *
-JNIEXPORT jint JNICALL
-Java_sun_awt_motif_MTextAreaPeer_getIndexAtPoint(JNIEnv *env, jobject self,
- jint x, jint y)
-{
-    struct TextAreaData *tdata;
-    XmTextPosition pos;
-
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *)
-        JNU_GetLongFieldAsPtr(env,self,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return -1;
-    }
-    pos = XmTextXYToPos(tdata->txt, x, y);
-    AWT_UNLOCK();
-
-    return (jint) pos;
-}
-*/
-
-/*  To be fully implemented in a future release
- *
- * Class:     sun_awt_windows_MTextAreaPeer
- * Method:    getCharacterBounds
- * Signature: (I)Ljava/awt/Rectangle;
- *
-JNIEXPORT jobject JNICALL
-Java_sun_awt_motif_MTextAreaPeer_getCharacterBounds(JNIEnv *env, jobject self, jint i)
-{
-#define Text_FontAscent(tfg)                   (((XmTextWidget)(tfg)) -> \
-                                           text.output->data->font_ascent)
-#define Text_FontDescent(tfg)                  (((XmTextWidget)(tfg)) -> \
-                                           text.output->data->font_descent)
-
-    struct TextAreaData *tdata;
-    jobject rect=NULL;
-    Position x=0, y=0;
-    Position next_x=0, next_y=0;
-    int32_t w=0, h=0;
-
-    AWT_LOCK();
-
-    tdata = (struct TextAreaData *)
-        JNU_GetLongFieldAsPtr(env,self,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->txt == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return (jobject) NULL;
-    }
-
-    XmTextPosToXY(tdata->txt, i, &x, &y);
-    y -= Text_FontAscent(tdata->txt);
-    XmTextPosToXY(tdata->txt, i+1, &next_x, &next_y);
-    w = next_x - x;
-    h = Text_FontAscent(tdata->txt) + Text_FontDescent(tdata->txt);
-
-    AWT_UNLOCK();
-
-    if (w>0) {
-        jclass clazz;
-        jmethodID mid;
-
-        clazz = (*env)->FindClass(env, "java/awt/Rectangle");
-        mid = (*env)->GetMethodID(env, clazz, "<init>", "(IIII)V");
-        if (mid != NULL) {
-            rect = (*env)->NewObject(env, clazz, mid, x, y, w, h);
-            if ((*env)->ExceptionOccurred(env)) {
-                return (jobject) NULL;
-            }
-        }
-    }
-    return rect;
-}
-*/
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_TextArea.h openjdk/jdk/src/solaris/native/sun/awt/awt_TextArea.h
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_TextArea.h	2014-04-08 05:27:03.450875088 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_TextArea.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include "jni_util.h"
-
-/* fieldIDs for TextArea fields that may be accessed from C */
-static struct TextAreaIDs {
-    jfieldID scrollbarVisibility;
-};
-
-/* fieldIDs for MTextAreaPeer fields that may be accessed from C */
-struct MTextAreaPeerIDs {
-    jfieldID firstChangeSkipped;
-};
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_TextField.c openjdk/jdk/src/solaris/native/sun/awt/awt_TextField.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_TextField.c	2014-04-08 05:27:03.450875088 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_TextField.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,989 +0,0 @@
-/*
- * Copyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include <Xm/VirtKeys.h>
-
-#include "awt_p.h"
-#include "java_awt_TextField.h"
-#include "java_awt_Color.h"
-#include "java_awt_AWTEvent.h"
-#include "java_awt_Font.h"
-#include "java_awt_Canvas.h"
-#include "sun_awt_motif_MComponentPeer.h"
-#include "sun_awt_motif_MCanvasPeer.h"
-#include "sun_awt_motif_MTextFieldPeer.h"
-
-#include "awt_Component.h"
-#include "awt_TextField.h"
-
-#include "multi_font.h"
-#include <jni.h>
-#include <jni_util.h>
-#include <Xm/DropSMgr.h>
-#include <Xm/TextFP.h>  /* Motif TextField private header. */
-
-
-#define ECHO_BUFFER_LEN 1024
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern AwtGraphicsConfigDataPtr
-    copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-struct TextFieldIDs textFieldIDs;
-struct MTextFieldPeerIDs mTextFieldPeerIDs;
-
-/*
- * Class:     java_awt_TextField
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for TextField.java
-   to initialize the fieldIDs for fields that may be accessed from C */
-
-JNIEXPORT void JNICALL
-Java_java_awt_TextField_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    textFieldIDs.echoChar =
-      (*env)->GetFieldID(env, cls, "echoChar", "C");
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for
-   MTextFieldPeer.java to initialize the fieldIDs for fields that may
-   be accessed from C */
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MTextFieldPeer_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    mTextFieldPeerIDs.firstChangeSkipped =
-      (*env)->GetFieldID(env, cls, "firstChangeSkipped", "Z");
-}
-
-static void
-echoChar(Widget text_w, XtPointer unused, XmTextVerifyCallbackStruct * cbs)
-{
-    size_t len;
-    int32_t c;
-    char *val;
-    struct DPos *dp;
-    int32_t ret;
-    jobject globalRef;
-    int32_t i, numbytes;
-
-    struct TextFieldData *tdata;
-
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-    /*
-     * Get the echoContextID from the globalRef which is stored in
-     * the XmNuserData resource for the widget.
-     */
-    XtVaGetValues(text_w,XmNuserData,&globalRef,NULL);
-
-    tdata = (struct TextFieldData *)
-      (*env)->GetLongField(env,globalRef,mComponentPeerIDs.pData);
-
-    ret = XFindContext(XtDisplay(text_w), (XID)text_w, tdata->echoContextID,
-                       (XPointer *)&dp);
-    if ((ret != 0) || (dp == NULL)) {
-        /* no context found or DPos is NULL - shouldn't happen */
-        return;
-    }
-
-    c = dp->echoC;
-    val = (char *) (dp->data);
-
-    len = strlen(val);
-    if (cbs->text->ptr == NULL) {
-        if (cbs->text->length == 0 && cbs->startPos == 0) {
-            val[0] = '\0';
-            return;
-        } else if (cbs->startPos == (len - 1)) {
-            /* handle deletion */
-            cbs->endPos = strlen(val);
-            val[cbs->startPos] = '\0';
-            return;
-        } else {
-            /* disable deletes anywhere but at the end */
-            cbs->doit = False;
-            return;
-        }
-    }
-    if (cbs->startPos != len) {
-        /* disable "paste" or inserts into the middle */
-        cbs->doit = False;
-        return;
-    }
-    /* append the value typed in */
-    if ((cbs->endPos + cbs->text->length) > ECHO_BUFFER_LEN) {
-        val = realloc(val, cbs->endPos + cbs->text->length + 10);
-    }
-    strncat(val, cbs->text->ptr, cbs->text->length);
-    val[cbs->endPos + cbs->text->length] = '\0';
-
-    /* modify the output to be the echo character */
-    for (len = 0, i = 0; len < cbs->text->length; i++) {
-        /* Write one echo character for each multibyte character. */
-        numbytes = mblen(cbs->text->ptr + len, cbs->text->length - len);
-        cbs->text->ptr[i] = (char) c;
-        len += numbytes;
-    }
-    cbs->text->length = i;
-}
-
-/*
- * Event handler used by both TextField/TextArea to correctly process
- * cut/copy/paste keys such that interaction with our own
- * clipboard mechanism will work properly.
- *
- * client_data is MTextFieldPeer instance
- */
-void
-Text_handlePaste(Widget w, XtPointer client_data, XEvent * event, Boolean * cont)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    KeySym keysym;
-    Modifiers mods;
-
-    /* Any event handlers which take peer instance pointers as
-     * client_data should check to ensure the widget has not been
-     * marked as destroyed as a result of a dispose() call on the peer
-     * (which can result in the peer instance pointer already haven
-     * been gc'd by the time this event is processed)
-     */
-    if (event->type != KeyPress || w->core.being_destroyed) {
-        return;
-    }
-
-    XtTranslateKeycode(event->xkey.display, (KeyCode) event->xkey.keycode,
-                       event->xkey.state, &mods, &keysym);
-
-    /* Should be a temporary fix for 4052132 if a cleaner fix is found later */
-    if ((event->xkey.state & ControlMask) && (keysym == 'v' || keysym == 'V'))
-        keysym = osfXK_Paste;
-    if ((event->xkey.state & ShiftMask) && (keysym == osfXK_Insert))
-        keysym = osfXK_Paste;
-
-    switch (keysym) {
-        case osfXK_Paste:
-            /* If we own the selection, then paste the data directly */
-            if (awtJNI_isSelectionOwner(env, "CLIPBOARD")) {
-                JNU_CallMethodByName(env, NULL, (jobject) client_data,
-                                     "pasteFromClipboard", "()V");
-                if ((*env)->ExceptionOccurred(env)) {
-                    (*env)->ExceptionDescribe(env);
-                    (*env)->ExceptionClear(env);
-                }
-                *cont = FALSE;
-            }
-            break;
-
-        case osfXK_Cut:
-        case osfXK_Copy:
-            /* For some reason if we own the selection, our loseSelection
-             * callback is not automatically called on cut/paste from
-             * text widgets.
-             */
-            if (awtJNI_isSelectionOwner(env, "CLIPBOARD")) {
-                awtJNI_notifySelectionLost(env, "CLIPBOARD");
-            }
-            break;
-        default:
-            break;
-    }
-}
-
-/*
- * client_data is MTextFieldPeer instance
- */
-void
-TextField_valueChanged(Widget w, XtPointer client_data, XtPointer call_data)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jboolean skipped;
-
-    skipped = (*env)->GetBooleanField(env, (jobject) client_data,
-                                      mTextFieldPeerIDs.firstChangeSkipped);
-    if (!(*env)->ExceptionOccurred(env)) {
-        if (skipped == JNI_FALSE) {
-            (*env)->SetBooleanField(env, (jobject) client_data,
-                                    mTextFieldPeerIDs.firstChangeSkipped,
-                                    JNI_TRUE);
-        } else {
-            JNU_CallMethodByName(env, NULL, (jobject) client_data,
-                                 "valueChanged", "()V");
-        }
-    }
-
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-/*
- * client_data is MTextFieldPeer instance
- */
-static void
-TextField_action(Widget w, XtPointer client_data, XmAnyCallbackStruct * s)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    ConvertEventTimeAndModifiers converted;
-
-    awt_util_convertEventTimeAndModifiers(s->event, &converted);
-
-    JNU_CallMethodByName(env, NULL, (jobject) client_data, "action", "(JI)V",
-                         converted.when, converted.modifiers);
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    pCreate
- * Signature: (Lsun/awt/motif/MComponentPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextFieldPeer_pCreate
-  (JNIEnv *env, jobject this, jobject parent)
-{
-    struct ComponentData *wdata;
-    struct TextFieldData *tdata;
-
-    jobject globalRef = awtJNI_CreateAndSetGlobalRef(env, this);
-    AwtGraphicsConfigDataPtr adata;
-
-    AWT_LOCK();
-
-    adata = copyGraphicsConfigToPeer(env, this);
-
-    if (JNU_IsNull(env, parent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    wdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,parent,mComponentPeerIDs.pData);
-    if (wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    tdata = ZALLOC(TextFieldData);
-    if (tdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-    JNU_SetLongFieldFromPtr(env,this,mComponentPeerIDs.pData,tdata);
-
-    tdata->comp.widget = XtVaCreateManagedWidget("textfield",
-                                                 xmTextFieldWidgetClass,
-                                                 wdata->widget,
-                                                 XmNrecomputeSize, False,
-                                                 XmNhighlightThickness, 1,
-                                                 XmNshadowThickness, 2,
-                                                 XmNuserData, (XtPointer) globalRef,
-                                                 XmNscreen,
-                                                 ScreenOfDisplay(awt_display,
-                                                   adata->awt_visInfo.screen),
-                                                 XmNfontList, getMotifFontList(),
-                                                 NULL);
-    tdata->echoContextIDInit = FALSE;
-
-    XtSetMappedWhenManaged(tdata->comp.widget, False);
-    XtAddCallback(tdata->comp.widget,
-                  XmNactivateCallback,
-                  (XtCallbackProc) TextField_action,
-                  (XtPointer) globalRef);
-    XtAddCallback(tdata->comp.widget,
-                  XmNvalueChangedCallback,
-                  (XtCallbackProc) TextField_valueChanged,
-                  (XtPointer) globalRef);
-    XtInsertEventHandler(tdata->comp.widget,
-                         KeyPressMask,
-                         False, Text_handlePaste, (XtPointer) globalRef,
-                         XtListHead);
-    /*
-     * Fix for BugTraq ID 4349615.
-     * Unregister Motif drop site to prevent it from crash
-     * when dropping java objects.
-     */
-    XmDropSiteUnregister(tdata->comp.widget);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class     sun_awt_motif_MTextFieldPeer
- * Method:    pSetEditable
- * Signature: (Z)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextFieldPeer_pSetEditable
-  (JNIEnv *env, jobject this, jboolean editable)
-{
-    struct TextFieldData *tdata;
-
-    AWT_LOCK();
-    tdata = (struct TextFieldData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaSetValues(tdata->comp.widget,
-                  XmNeditable, (editable ? True : False),
-                  XmNcursorPositionVisible, (editable ? True : False),
-                  NULL);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    select
- * Signature: (II)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextFieldPeer_select
-  (JNIEnv *env, jobject this, jint start, jint end)
-{
-    struct TextFieldData *tdata;
-
-    AWT_LOCK();
-
-    tdata = (struct TextFieldData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XmTextSetSelection(tdata->comp.widget, (XmTextPosition) start, (XmTextPosition) end, 0);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    getSelectionStart
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MTextFieldPeer_getSelectionStart
-  (JNIEnv *env, jobject this)
-{
-    struct TextFieldData *tdata;
-    XmTextPosition start, end, pos;
-
-    AWT_LOCK();
-
-    tdata = (struct TextFieldData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return 0;
-    }
-    if (XmTextGetSelectionPosition(tdata->comp.widget, &start, &end) &&
-                                                (start != end)) {
-        pos = start;
-    } else {
-        pos = XmTextGetInsertionPosition(tdata->comp.widget);
-    }
-    AWT_UNLOCK();
-
-    return (jint) pos;
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    getSelectionEnd
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MTextFieldPeer_getSelectionEnd
-  (JNIEnv *env, jobject this)
-{
-    struct TextFieldData *tdata;
-    XmTextPosition start, end, pos;
-
-    AWT_LOCK();
-
-    tdata = (struct TextFieldData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return 0;
-    }
-    if (XmTextGetSelectionPosition(tdata->comp.widget, &start, &end) &&
-                                                 (start != end)) {
-        pos = end;
-    } else {
-        pos = XmTextGetInsertionPosition(tdata->comp.widget);
-    }
-    AWT_UNLOCK();
-
-    return (jint) pos;
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    setText
- * Signature: (Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextFieldPeer_setText
-  (JNIEnv *env, jobject this, jstring l)
-{
-    struct TextFieldData *tdata;
-    char *cl;
-    jobject target;
-
-    AWT_LOCK();
-
-    tdata = (struct TextFieldData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (JNU_IsNull(env, l)) {
-        cl = "";
-    } else {
-        /*
-         * Note: Motif TextField widgets do not support multi-font
-         * compound strings.
-         */
-        cl = (char *) JNU_GetStringPlatformChars(env, l, NULL);
-    }
-
-    /* Fix for bug 4084454 : setText appears in clear */
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-    if ((*env)->GetCharField(env, target, textFieldIDs.echoChar) != 0) {
-        XtVaSetValues(tdata->comp.widget,
-                      XmNvalue, "", NULL);
-        XmTextFieldInsert(tdata->comp.widget,0,cl);
-        XmTextSetInsertionPosition(tdata->comp.widget,
-                                   (XmTextPosition) strlen(cl));
-    }
-    else {
-        XtVaSetValues(tdata->comp.widget,
-                      XmNvalue, cl,
-                      NULL);
-    }
-    /*
-     * Fix for BugTraq Id 4185654 - TextField.setText(<String>) incorrect justification
-     * Comment out the next line.
-     */
-    /* XmTextSetInsertionPosition(tdata->comp.widget,
-     *                            (XmTextPosition) strlen(cl));
-     */
-
-    if (cl != NULL && cl != "") {
-        JNU_ReleaseStringPlatformChars(env, l, cl);
-    }
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    insertReplaceText
- * Signature: (Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextFieldPeer_insertReplaceText
-  (JNIEnv *env, jobject this, jstring l)
-{
-    struct TextFieldData *tdata;
-    char *cl;
-    XmTextPosition start, end;
-
-    AWT_LOCK();
-
-    tdata = (struct TextFieldData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    if (JNU_IsNull(env, l)) {
-        cl = "";
-    } else {
-        /*
-         * Note: Motif TextField widgets do not support multi-font
-         * compound strings.
-         */
-        cl = (char *) JNU_GetStringPlatformChars(env, l, NULL);
-    }
-
-    if (!XmTextGetSelectionPosition(tdata->comp.widget, &start, &end)) {
-        start = end = XmTextGetInsertionPosition(tdata->comp.widget);
-    }
-    XmTextReplace(tdata->comp.widget, start, end, cl);
-
-    if (cl != NULL && cl != "") {
-        JNU_ReleaseStringPlatformChars(env, l, cl);
-    }
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    preDispose
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextFieldPeer_preDispose
-  (JNIEnv *env, jobject this)
-{
-    struct TextFieldData *tdata;
-    struct DPos *dp;
-    jobject target;
-    int32_t ret;
-
-    AWT_LOCK();
-
-    tdata = (struct TextFieldData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    if ((*env)->GetCharField(env, target, textFieldIDs.echoChar) != 0) {
-        ret = XFindContext(XtDisplay(tdata->comp.widget), (XID)(tdata->comp.widget),
-                           tdata->echoContextID, (XPointer *)&dp);
-        if ((ret == 0) && dp != NULL) {
-
-            /* Remove the X context associated with this textfield's
-             * echo character. BugId #4225734
-             */
-            XDeleteContext(XtDisplay(tdata->comp.widget),
-                           (XID)(tdata->comp.widget),
-                           tdata->echoContextID);
-
-            tdata->echoContextIDInit = FALSE;
-
-            /* Free up the space allocated for the echo character data. */
-            if (dp->data) {
-                free(dp->data);
-            }
-            free(dp);
-        }
-    }
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    getText
- * Signature: ()Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_sun_awt_motif_MTextFieldPeer_getText
-  (JNIEnv *env, jobject this)
-{
-    struct TextFieldData *tdata;
-    char *val;
-    struct DPos *dp;
-    jobject target;
-    int32_t ret;
-    jstring returnVal;
-
-    AWT_LOCK();
-    tdata = (struct TextFieldData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return NULL;
-    }
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    if ((*env)->GetCharField(env, target, textFieldIDs.echoChar) != 0) {
-        ret = XFindContext(XtDisplay(tdata->comp.widget), (XID)tdata->comp.widget,
-                           tdata->echoContextID, (XPointer *)&dp);
-        if ((ret == 0) && (dp != NULL)) {
-            val = (char *)(dp->data);
-        } else {
-            val = "";
-        }
-    } else {
-        XtVaGetValues(tdata->comp.widget, XmNvalue, &val, NULL);
-    }
-    AWT_UNLOCK();
-
-    returnVal = JNU_NewStringPlatform(env, (const char *) val);
-    if ((*env)->GetCharField(env, target, textFieldIDs.echoChar) == 0) {
-        free(val);
-    }
-    return returnVal;
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    setEchoChar
- * Signature: (C)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextFieldPeer_setEchoChar
-  (JNIEnv *env, jobject this, jchar c)
-{
-    char *val;
-    char *cval;
-    struct TextFieldData *tdata;
-    struct DPos *dp;
-    int32_t i;
-    size_t len;
-    int32_t ret;
-
-    AWT_LOCK();
-    tdata = (struct TextFieldData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    XtVaGetValues(tdata->comp.widget,
-                  XmNvalue, &cval,
-                  NULL);
-
-    DASSERT(c != 0 || tdata->echoContextIDInit);
-
-    if (!tdata->echoContextIDInit) {
-        tdata->echoContextID = XUniqueContext();
-        tdata->echoContextIDInit = TRUE;
-    }
-    ret = XFindContext(XtDisplay(tdata->comp.widget), (XID)(tdata->comp.widget),
-                       tdata->echoContextID, (XPointer *)&dp);
-    /*
-     * Fix for BugTraq ID 4307281.
-     * Special case for setting echo char to 0:
-     *  - remove the callback and X context associated with echo character;
-     *  - restore the original text.
-     */
-    if (c == 0) {
-        XtRemoveCallback(tdata->comp.widget, XmNmodifyVerifyCallback,
-                         (XtCallbackProc) echoChar, NULL);
-        if (ret == 0 && dp != NULL) {
-
-            /* Remove the X context associated with echo character. */
-            XDeleteContext(XtDisplay(tdata->comp.widget),
-                           (XID)(tdata->comp.widget),
-                           tdata->echoContextID);
-
-            tdata->echoContextIDInit = FALSE;
-
-            /* Restore the original text. */
-            if (dp->data != NULL) {
-                val = (char *)(dp->data);
-            } else {
-                val = "";
-            }
-            XtVaSetValues(tdata->comp.widget,
-                          XmNvalue, val,
-                          NULL);
-
-            /* Free up the space allocated for the echo character data. */
-            if (dp->data) {
-                free(dp->data);
-            }
-            free(dp);
-        }
-        AWT_UNLOCK();
-        return;
-    }
-    if (ret != 0) {
-        dp = NULL;
-    }
-
-    if (dp != NULL) {
-        /* Fix bug 4124697: cannot change setEchoChar twice on Motif */
-        XtRemoveCallback(tdata->comp.widget, XmNmodifyVerifyCallback,
-                        (XtCallbackProc) echoChar, NULL);
-    } else {
-        if ((int32_t) strlen(cval) > ECHO_BUFFER_LEN) {
-            val = (char *) malloc(strlen(cval) + 1);
-        } else {
-            val = (char *) malloc(ECHO_BUFFER_LEN + 1);
-        }
-        if (val == NULL) {
-            JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-            AWT_UNLOCK();
-            return;
-        }
-        if (cval != NULL) {
-            strcpy(val, cval);
-        } else {
-            *val = '\0';
-        }
-        dp = (struct DPos *) malloc(sizeof(struct DPos));
-
-        dp->x = -1;
-        dp->data = (void *) val;
-    }
-
-    dp->echoC = c;
-    len = strlen(cval);
-    for (i = 0; i < len; i++) {
-        cval[i] = (char) (c);
-    }
-    XtVaSetValues(tdata->comp.widget,
-                  XmNvalue, cval,
-                  NULL);
-
-    ret = XSaveContext(XtDisplay(tdata->comp.widget), (XID)tdata->comp.widget,
-                       tdata->echoContextID, (XPointer)dp);
-    if (ret == 0) {
-        XtAddCallback(tdata->comp.widget, XmNmodifyVerifyCallback,
-                      (XtCallbackProc) echoChar, NULL);
-    }
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    setFont
- * Signature: (Ljava/awt/Font;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextFieldPeer_setFont
-  (JNIEnv *env, jobject this, jobject f)
-{
-    struct TextFieldData *tdata;
-    struct FontData *fdata;
-    XmFontListEntry fontentry;
-    XmFontList fontlist;
-    char *err;
-
-    AWT_LOCK();
-    if (JNU_IsNull(env, f)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    fdata = awtJNI_GetFontData(env, f, &err);
-    if (fdata == NULL) {
-        JNU_ThrowInternalError(env, err);
-        AWT_UNLOCK();
-        return;
-    }
-    tdata = (struct TextFieldData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (awtJNI_IsMultiFont(env, f)) {
-        if (fdata->xfs == NULL) {
-            fdata->xfs = awtJNI_MakeFontSet(env, f);
-        }
-        if (fdata->xfs != NULL) {
-            fontentry = XmFontListEntryCreate("labelFont",
-                                              XmFONT_IS_FONTSET,
-                                              (XtPointer) (fdata->xfs));
-            fontlist = XmFontListAppendEntry(NULL, fontentry);
-            /*
-             * Some versions of motif have a bug in
-             * XmFontListEntryFree() which causes it to free more than it
-             * should.  Use XtFree() instead.  See O'Reilly's
-             * Motif Reference Manual for more information.
-             */
-            XmFontListEntryFree(&fontentry);
-        } else {
-            fontlist = XmFontListCreate(fdata->xfont, "labelFont");
-        }
-    } else {
-        fontlist = XmFontListCreate(fdata->xfont, "labelFont");
-    }
-
-    if (fontlist != NULL) {
-        XtVaSetValues(tdata->comp.widget, XmNfontList, fontlist, NULL);
-        XmFontListFree(fontlist);
-    } else {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-    }
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    setCaretPosition
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MTextFieldPeer_setCaretPosition
-  (JNIEnv *env, jobject this, jint pos)
-{
-    struct TextFieldData *tdata;
-
-    AWT_LOCK();
-
-    tdata = (struct TextFieldData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XmTextSetInsertionPosition(tdata->comp.widget, (XmTextPosition) pos);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MTextFieldPeer
- * Method:    getCaretPosition
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_sun_awt_motif_MTextFieldPeer_getCaretPosition
-  (JNIEnv *env, jobject this)
-{
-    struct TextFieldData *tdata;
-    XmTextPosition pos;
-
-    AWT_LOCK();
-
-    tdata = (struct TextFieldData *)
-        JNU_GetLongFieldAsPtr(env,this,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return 0;
-    }
-    pos = XmTextGetInsertionPosition(tdata->comp.widget);
-    AWT_UNLOCK();
-
-    return (jint) pos;
-}
-
-
-/*  To be fully implemented in a future release
- *
- * Class:     sun_awt_windows_MTextFieldPeer
- * Method:    getIndexAtPoint
- * Signature: (Ljava/awt/Point;)I
- *
-JNIEXPORT jint JNICALL
-Java_sun_awt_motif_MTextFieldPeer_getIndexAtPoint(JNIEnv *env, jobject self,
- jint x, jint y)
-{
-    struct ComponentData *tdata;
-    XmTextPosition pos;
-
-    AWT_LOCK();
-
-    tdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,self,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->comp.widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return -1;
-    }
-    pos = XmTextFieldXYToPos(tdata->widget, x, y);
-    AWT_UNLOCK();
-
-    return (jint) pos;
-}
-*/
-
-/*  To be fully implemented in a future release
- *
- * Class:     sun_awt_windows_MTextFieldPeer
- * Method:    getCharacterBounds
- * Signature: (I)Ljava/awt/Rectangle;
- *
-JNIEXPORT jobject JNICALL
-Java_sun_awt_motif_MTextFieldPeer_getCharacterBounds(JNIEnv *env, jobject self, jint i)
-{
-#define TextF_FontAscent(tfg)                   (((XmTextFieldWidget)(tfg)) -> \
-                                           text.font_ascent)
-#define TextF_FontDescent(tfg)                  (((XmTextFieldWidget)(tfg)) -> \
-                                           text.font_descent)
-
-    struct ComponentData *tdata;
-    jobject rect=NULL;
-    Position x=0, y=0;
-    Position next_x=0, next_y=0;
-    int32_t w=0, h=0;
-
-    AWT_LOCK();
-
-    tdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env,self,mComponentPeerIDs.pData);
-
-    if (tdata == NULL || tdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return (jobject) NULL;
-    }
-
-    XmTextFieldPosToXY(tdata->widget, i, &x, &y);
-    y -= TextF_FontAscent(tdata->widget);
-    XmTextFieldPosToXY(tdata->widget, i+1, &next_x, &next_y);
-    w = next_x - x;
-    h = TextF_FontAscent(tdata->widget) + TextF_FontDescent(tdata->widget);
-
-    AWT_UNLOCK();
-
-    if (w>0) {
-        jclass clazz;
-        jmethodID mid;
-
-        clazz = (*env)->FindClass(env, "java/awt/Rectangle");
-        mid = (*env)->GetMethodID(env, clazz, "<init>", "(IIII)V");
-        if (mid != NULL) {
-            rect = (*env)->NewObject(env, clazz, mid, x, y, w, h);
-            if ((*env)->ExceptionOccurred(env)) {
-                return NULL;
-            }
-        }
-    }
-    return rect;
-}
-*/
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_TextField.h openjdk/jdk/src/solaris/native/sun/awt/awt_TextField.h
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_TextField.h	2014-04-08 05:27:03.450875088 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_TextField.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include "jni_util.h"
-
-/* fieldIDs for TextField fields that may be accessed from C */
-static struct TextFieldIDs {
-    jfieldID echoChar;
-};
-
-/* fieldIDs for MTextFieldPeer fields that may be accessed from C */
-struct MTextFieldPeerIDs {
-    jfieldID firstChangeSkipped;
-};
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_TopLevel.c openjdk/jdk/src/solaris/native/sun/awt/awt_TopLevel.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_TopLevel.c	2014-04-08 05:27:03.454875147 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_TopLevel.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,5095 +0,0 @@
-/*
- * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-
-#include <X11/Shell.h>
-#include <Xm/VendorS.h>
-#include <Xm/Form.h>
-#include <Xm/DialogS.h>
-#include <Xm/AtomMgr.h>
-#include <Xm/Protocols.h>
-#include <Xm/MenuShell.h>
-#include <Xm/MwmUtil.h>
-#include "VDrawingArea.h"
-
-#ifdef DEBUG
-#  include <X11/Xmu/Editres.h>
-#endif
-
-#include <jni.h>
-#include <jni_util.h>
-
-/* JNI headers */
-#include "java_awt_Color.h"
-#include "java_awt_Component.h"
-#include "java_awt_Dialog.h"
-#include "java_awt_Font.h"
-#include "java_awt_Frame.h"
-#include "java_awt_Image.h"
-#include "java_awt_Insets.h"
-#include "java_awt_Insets.h"
-#include "java_awt_MenuBar.h"
-#include "java_awt_Window.h"
-#include "java_awt_event_FocusEvent.h"
-#include "java_awt_TrayIcon.h"
-#include "sun_awt_EmbeddedFrame.h"
-#include "sun_awt_motif_MComponentPeer.h"
-#include "sun_awt_motif_MDialogPeer.h"
-#include "sun_awt_motif_MEmbeddedFramePeer.h"
-#include "sun_awt_motif_MFramePeer.h"
-#include "sun_awt_motif_MMenuBarPeer.h"
-#include "sun_awt_motif_MWindowPeer.h"
-
-/* JNI field and method ids */
-#include "awt_Component.h"
-#include "awt_GraphicsEnv.h"
-#include "awt_Insets.h"
-#include "awt_MenuBar.h"
-#include "awt_Window.h"
-#include "awt_KeyboardFocusManager.h"
-#include "awt_MToolkit.h"
-#include "awt_Plugin.h"
-
-#include "color.h"
-#include "canvas.h"
-#include "awt_util.h"
-#include "img_util.h"
-#include "awt_wm.h"
-#include "awt_util.h"
-#include "awt_xembed.h"
-
-
-#ifdef __linux__
-void adjustStatusWindow(Widget shell);
-#endif
-/* For the moment only InputMethodWindow is taking advantage of
-** the posibility for different decor styles
-** values could be passed are the MWM_DECOR defines
-** for the moment we are full on or full off.
-*/
-#define AWT_NO_DECOR    0x0
-#define AWT_FULL_DECOR  MWM_DECOR_ALL
-
-static void reshape(JNIEnv *env, jobject this, struct FrameData *wdata,
-                    jint x, jint y, jint w, jint h, Boolean setXY);
-Widget findTopLevelByShell(Widget widget);
-
-extern EmbeddedFrame *theEmbeddedFrameList;
-extern struct ComponentIDs componentIDs;
-extern struct MMenuBarPeerIDs mMenuBarPeerIDs;
-extern struct MComponentPeerIDs mComponentPeerIDs;
-struct WindowIDs windowIDs;
-struct MWindowPeerIDs mWindowPeerIDs;
-extern struct InsetsIDs insetsIDs;
-extern struct X11GraphicsConfigIDs x11GraphicsConfigIDs;
-extern struct KeyboardFocusManagerIDs keyboardFocusManagerIDs;
-extern struct X11GraphicsDeviceIDs x11GraphicsDeviceIDs;
-
-#ifndef NOMODALFIX
-extern Boolean awt_isModal();
-extern Boolean awt_isWidgetModal(Widget w);
-extern void awt_shellPoppedUp(Widget shell, XtPointer c, XtPointer d);
-extern void awt_shellPoppedDown(Widget shell, XtPointer c, XtPointer d);
-#endif //NOMODALFIX
-
-static jclass inputMethodWindowClass = NULL;
-
-static int32_t globalTopGuess    = 0;
-static int32_t globalLeftGuess   = 0;
-static int32_t globalBottomGuess = 0;
-static int32_t globalRightGuess  = 0;
-
-
-// Atom used for otlogenniy top-level disposal
-static Atom _XA_JAVA_DISPOSE_PROPERTY_ATOM = 0;
-
-/*
- * Fix for bug 4141361
- *
- * We keep a linked list of the FrameData information for
- * every top level window.
- */
-struct FrameDataList {
-    struct FrameData* wdata;
-    struct FrameDataList* next;
-};
-
-static struct FrameDataList* allTopLevel = NULL;
-
-extern void checkNewXineramaScreen(JNIEnv* env, jobject peer,
-                                   struct FrameData* wdata,
-                                   int32_t newX, int32_t newY,
-                                   int32_t newWidth, int32_t newHeight);
-
-// Returns false if this Window is non-focusable
-// or its nearest decorated parent is non-focusable.
-Boolean isFocusableWindowByPeer(JNIEnv * env, jobject peer) {
-    jobject target, decoratedParent;
-    struct FrameData *wdata;
-    Boolean focusable;
-
-    wdata = (struct FrameData *)JNU_GetLongFieldAsPtr(env, peer, mComponentPeerIDs.pData);
-    DASSERT(wdata != NULL);
-
-    target = (*env)->GetObjectField(env, peer, mComponentPeerIDs.target);
-    DASSERT(target != NULL);
-
-    decoratedParent = getOwningFrameOrDialog(target, env);
-    (*env)->DeleteLocalRef(env, target);
-
-    if (decoratedParent == NULL) {
-        return wdata->isFocusableWindow;
-    } else {
-        jobject parentPeer = (*env)->GetObjectField(env, decoratedParent, componentIDs.peer);
-        DASSERT(parentPeer != NULL);
-        focusable = wdata->isFocusableWindow && isFocusableWindowByPeer(env, parentPeer);
-
-        (*env)->DeleteLocalRef(env, decoratedParent);
-        (*env)->DeleteLocalRef(env, parentPeer);
-    }
-    return focusable;
-}
-
-// Returns false if this shell's Java Window is non-focusable
-// or its nearest decorated parent is non-focusable.
-// Returns true otherwise or if any of parameters is NULL
-Boolean isFocusableWindowByShell(JNIEnv* env, Widget shell) {
-    Widget toplevel;
-    jobject peer;
-    Boolean focusable;
-
-    DASSERT(shell != NULL && XtIsShell(shell));
-    if (shell == NULL) return True;
-    if (!XtIsShell(shell)) return True;
-
-    toplevel = findTopLevelByShell(shell);
-    if (toplevel == NULL) {
-        return True;
-    }
-    peer = findPeer(&toplevel);
-    DASSERT(peer != NULL);
-
-    if (env == NULL) {
-        env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    }
-    return isFocusableWindowByPeer(env, peer);
-}
-
-
-// Returns Shell widget - the parent of this child
-Widget getShellWidget(Widget child) {
-
-    while (child != NULL && !XtIsShell(child)) {
-        child = XtParent(child);
-    }
-    return child;
-}
-
-// Returns false if the parent shell of this widget is non-focusable Java Window.
-// Returns false otherwise.
-// Doesn't accept NULL parameters.
-Boolean isFocusableComponentTopLevelByWidget(JNIEnv * env, Widget child) {
-    Widget shell = NULL;
-    shell = getShellWidget(child);
-    DASSERT(shell);
-    return isFocusableWindowByShell(env, shell);
-}
-
-
-/*
- * Add a new element into the top level window list
- */
-void addTopLevel(struct FrameData* wdata) {
-    struct FrameDataList* newNode;
-    newNode = (struct FrameDataList*)
-        malloc(sizeof(struct FrameDataList));
-    newNode->wdata = wdata;
-    newNode->next = allTopLevel;
-    allTopLevel = newNode;
-}
-
-/*
- * Remove an element from the top level window list
- * (recursive)
- */
-Boolean removeTopLevelR(struct FrameDataList** ptr,
-    struct FrameData* wdata) {
-    struct FrameDataList* node = *ptr;
-    if (node == NULL) {
-        return False;
-    }
-    if (node->wdata == wdata) {
-        *ptr = node->next;
-        free(node);
-        return True;
-    }
-    return removeTopLevelR(&(node->next), wdata);
-}
-
-Boolean removeTopLevel(struct FrameData* wdata) {
-    return removeTopLevelR(&allTopLevel, wdata);
-}
-
-/*
- * Return the Widget ID of the top level window underneath the
- * mouse pointer.
- */
-Widget awt_GetWidgetAtPointer() {
-    struct FrameDataList* ptr = allTopLevel;
-    Window rootWindow, childWindow, mainWindow;
-    int32_t xw, yw, xr, yr;
-    uint32_t keys;
-    while (ptr != NULL) {
-        mainWindow = XtWindow(ptr->wdata->mainWindow);
-        XQueryPointer(awt_display, mainWindow,
-            &rootWindow, &childWindow, &xr, &yr, &xw, &yw, &keys);
-        if (childWindow != None) {
-            return ptr->wdata->winData.comp.widget;
-        }
-        ptr = ptr->next;
-    }
-    return NULL;
-}
-
-Widget findFocusProxy(Widget widget) {
-  struct FrameDataList* ptr = allTopLevel;
-  for (ptr = allTopLevel; ptr != NULL; ptr = ptr->next) {
-    if (ptr->wdata->winData.comp.widget == widget) {
-      return ptr->wdata->focusProxy;
-    }
-  }
-  return NULL;
-}
-
-Widget findTopLevelByShell(Widget widget) {
-  struct FrameDataList* ptr;
-  for (ptr = allTopLevel; ptr != NULL; ptr = ptr->next) {
-      if (ptr->wdata->winData.shell == widget) {
-          return ptr->wdata->winData.comp.widget;
-      }
-  }
-  return NULL;
-}
-
-void
-awt_Frame_guessInsets(struct FrameData *wdata)
-{
-    if (wdata->decor == AWT_NO_DECOR ) {
-        wdata->top    = wdata->topGuess    = 0;
-        wdata->left   = wdata->leftGuess   = 0;
-        wdata->bottom = wdata->bottomGuess = 0;
-        wdata->right  = wdata->rightGuess  = 0;
-        return;
-    }
-
-    if (globalTopGuess == 0) {
-        char *insets_env;
-
-        if (wdata->top >= 0) {
-            /* insets were set on wdata by System Properties */
-            globalTopGuess    = wdata->top;
-            globalLeftGuess   = wdata->left;
-            globalBottomGuess = wdata->bottom;
-            globalRightGuess  = wdata->right;
-        }
-        else switch (awt_wm_getRunningWM()) {
-        case ENLIGHTEN_WM:
-            globalTopGuess    = 19;
-            globalLeftGuess   =  4;
-            globalBottomGuess =  4;
-            globalRightGuess  =  4;
-            break;
-
-        case CDE_WM:
-            globalTopGuess    = 28;
-            globalLeftGuess   =  6;
-            globalBottomGuess =  6;
-            globalRightGuess  =  6;
-            break;
-
-        case MOTIF_WM:
-        case OPENLOOK_WM:
-        default:
-            globalTopGuess    = 25;
-            globalLeftGuess   =  5;
-            globalBottomGuess =  5;
-            globalRightGuess  =  5;
-            break;
-        }
-
-        if ((insets_env = getenv("AWT_INSETS")) != NULL) {
-            int guess = atoi(insets_env);
-            globalTopGuess    = (guess & 0xff00) >> 8;
-            globalLeftGuess   = guess & 0x00ff;
-            globalBottomGuess = wdata->leftGuess;
-            globalRightGuess  = wdata->leftGuess;
-        }
-
-        /* don't allow bizarly large insets */
-        if ((globalTopGuess > 64) || (globalTopGuess < 0))
-            globalTopGuess = 28;
-        if ((globalLeftGuess > 32) || (globalLeftGuess < 0))
-            globalLeftGuess = 6;
-        if ((globalBottomGuess > 32) || (globalBottomGuess < 0))
-            globalBottomGuess = 6;
-        if ((globalRightGuess > 32) || (globalRightGuess < 0))
-            globalRightGuess = 6;
-    }
-
-    wdata->top    = wdata->topGuess    = globalTopGuess;
-    wdata->left   = wdata->leftGuess   = globalLeftGuess;
-    wdata->bottom = wdata->bottomGuess = globalBottomGuess;
-    wdata->right  = wdata->rightGuess  = globalRightGuess;
-}
-
-/*
- * To keep input method windows floating, maintain a list of all
- * input method windows here.  When some top level window gets
- * activated, moved, or resized, these input method windows need
- * to be brought on top.
- */
-static struct FrameDataList* allInputMethodWindow = NULL;
-
-/*
- * Add a new element into the input method window list
- */
-void addInputMethodWindow(struct FrameData* wdata) {
-    struct FrameDataList* newNode;
-    newNode = (struct FrameDataList*)
-        malloc(sizeof(struct FrameDataList));
-    newNode->wdata = wdata;
-    newNode->next = allInputMethodWindow;
-    allInputMethodWindow = newNode;
-}
-
-/*
- * Remove an element from the top level window list
- * (recursive)
- */
-Boolean removeInputMethodWindowR(struct FrameDataList** ptr,
-    struct FrameData* wdata) {
-    struct FrameDataList* node = *ptr;
-    if (node == NULL) {
-        return False;
-    }
-    if (node->wdata == wdata) {
-        *ptr = node->next;
-        free(node);
-        return True;
-    }
-    return removeInputMethodWindowR(&(node->next), wdata);
-}
-
-Boolean removeInputMethodWindow(struct FrameData* wdata) {
-    return removeInputMethodWindowR(&allInputMethodWindow, wdata);
-}
-
-/*
- * Raise input method windows
- */
-void raiseInputMethodWindow(struct FrameData* wdata) {
-    struct FrameDataList* node = allInputMethodWindow;
-
-    if (wdata->isInputMethodWindow) {
-        return;
-    }
-
-    while (node != NULL) {
-        XRaiseWindow(awt_display, XtWindow(node->wdata->winData.shell));
-        node = node->next;
-    }
-}
-
-/* fieldIDs for Frame fields that may be accessed from C */
-static struct FrameIDs {
-    jfieldID resizable;
-    jfieldID state;
-} frameIDs;
-
-/*
- * Class:     java_awt_Frame
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for Frame.java
-   to initialize the fieldIDs for fields that may be accessed from C */
-JNIEXPORT void JNICALL
-Java_java_awt_Frame_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    frameIDs.resizable = (*env)->GetFieldID(env, cls, "resizable", "Z");
-    frameIDs.state = (*env)->GetFieldID(env, cls, "state", "I");
-}
-
-/* ******* */
-/* Dialogs */
-/* ******* */
-/* No longer have a need for unique fields for query */
-static struct DialogIDs {
-    jfieldID modal;
-    jfieldID resizable;
-} dialogIDs;
-
-JNIEXPORT void JNICALL
-Java_java_awt_Dialog_initIDs
-  (JNIEnv *env, jclass cls)
-{
-#if 0
-    dialogIDs.modal = (*env)->GetFieldID(env, cls, "modal", "Z");
-    dialogIDs.resizable = (*env)->GetFieldID(env, cls, "resizable", "Z");
-#endif
-}
-
-/* ******* */
-/* Windows */
-/* ******* */
-
-JNIEXPORT void JNICALL
-Java_java_awt_Window_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    windowIDs.warningString = (*env)->GetFieldID(env, cls, "warningString",
-                                                 "Ljava/lang/String;");
-    windowIDs.resetGCMID = (*env)->GetMethodID(env, cls, "resetGC",
-                                                 "()V");
-
-    windowIDs.locationByPlatform = (*env)->GetFieldID(env, cls, "locationByPlatform",
-                                                        "Z");
-    windowIDs.isAutoRequestFocus = (*env)->GetFieldID(env, cls, "autoRequestFocus", "Z");
-
-    DASSERT(windowIDs.resetGCMID);
-}
-
-/*
- * Class:     sun_motif_awt_WindowAttributes
- * Method:    initIDs
- * Signature: ()V
- */
-
-static struct MWindowAttributeIDs {
-    jfieldID nativeDecor;
-    jfieldID initialFocus;
-    jfieldID isResizable;
-    jfieldID initialState;
-    jfieldID visibilityState;
-    jfieldID decorations;
-} mWindowAttributeIDs;
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowAttributes_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    mWindowAttributeIDs.nativeDecor =
-        (*env)->GetFieldID(env, cls, "nativeDecor", "Z");
-    mWindowAttributeIDs.initialFocus =
-        (*env)->GetFieldID(env, cls, "initialFocus", "Z");
-    mWindowAttributeIDs.isResizable =
-        (*env)->GetFieldID(env, cls, "isResizable", "Z");
-    mWindowAttributeIDs.initialState =
-        (*env)->GetFieldID(env, cls, "initialState", "I");
-    mWindowAttributeIDs.visibilityState =
-        (*env)->GetFieldID(env, cls, "visibilityState", "I");
-    mWindowAttributeIDs.decorations =
-        (*env)->GetFieldID(env, cls, "decorations", "I");
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    initIDs
- * Signature: ()V
- */
-
-/* This function gets called from the static initializer for MWindowPeer.java
-   to initialize the fieldIDs for fields that may be accessed from C */
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowPeer_initIDs
-  (JNIEnv *env, jclass cls)
-{
-    mWindowPeerIDs.insets =
-        (*env)->GetFieldID(env, cls, "insets", "Ljava/awt/Insets;");
-    mWindowPeerIDs.winAttr =
-        (*env)->GetFieldID( env,
-                            cls,
-                            "winAttr",
-                            "Lsun/awt/motif/MWindowAttributes;"
-                          );
-    mWindowPeerIDs.iconWidth =
-        (*env)->GetFieldID(env, cls, "iconWidth", "I");
-    mWindowPeerIDs.iconHeight =
-        (*env)->GetFieldID(env, cls, "iconHeight", "I");
-    mWindowPeerIDs.handleWindowFocusOut =
-        (*env)->GetMethodID(env,
-                            cls,
-                            "handleWindowFocusOut",
-                            "(Ljava/awt/Window;)V");
-    mWindowPeerIDs.handleWindowFocusIn =
-        (*env)->GetMethodID(env,
-                            cls,
-                            "handleWindowFocusIn",
-                            "()V");
-    mWindowPeerIDs.handleIconify =
-        (*env)->GetMethodID(env,
-                            cls,
-                            "handleIconify",
-                            "()V");
-    mWindowPeerIDs.handleDeiconify =
-        (*env)->GetMethodID(env,
-                            cls,
-                            "handleDeiconify",
-                            "()V");
-    mWindowPeerIDs.handleStateChange =
-        (*env)->GetMethodID(env,
-                            cls,
-                            "handleStateChange",
-                            "(II)V");
-
-    mWindowPeerIDs.draggedToScreenMID = (*env)->GetMethodID(env, cls,
-                                                           "draggedToNewScreen",
-                                                           "(I)V");
-    DASSERT(mWindowPeerIDs.draggedToScreenMID);
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    wrapInSequenced
- * Signature: (Ljava/awt/AWTEvent;)Ljava/awt/SequencedEvent;
- */
-
-/* This method gets called from MWindowPeer to wrap a FocusEvent in
-   a SequencedEvent. We have to do this in native code, because we
-   don't want to make SequencedEvent a public class. */
-
-JNIEXPORT jobject JNICALL
-Java_sun_awt_motif_MWindowPeer_wrapInSequenced
-  (JNIEnv *env, jobject this, jobject awtevent)
-{
-  jobject global = awt_canvas_wrapInSequenced(awtevent);
-  jobject local = (*env)->NewLocalRef(env, global);
-  (*env)->DeleteGlobalRef(env, global);
-  return local;
-}
-
-extern jobject findTopLevelOpposite();
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    findOpposite
- * Signature: (Ljava/awt/AWTEvent;)Ljava/awt/Window;
- */
-
-JNIEXPORT jobject JNICALL
-Java_sun_awt_motif_MWindowPeer_findOpposite
-    (JNIEnv *env, jobject this, jint eventType)
-{
-#ifdef HEADLESS
-    return NULL;
-#else
-    if ((*env)->EnsureLocalCapacity(env, 1) < 0) {
-        return NULL;
-    }
-
-    return findTopLevelOpposite(env, eventType);
-#endif
-}
-
-/* changeInsets() sets target's insets equal to X/Motif values. */
-
-static void
-awtJNI_ChangeInsets(JNIEnv * env, jobject this, struct FrameData *wdata)
-{
-    jobject insets;
-
-    if ((*env)->EnsureLocalCapacity(env, 1) < 0)
-        return;
-
-    insets = (*env)->GetObjectField(env, this, mWindowPeerIDs.insets);
-
-    if (JNU_IsNull(env, insets)) {
-        return;
-    }
-
-    (*env)->SetIntField(env, insets, insetsIDs.top, wdata->top);
-    (*env)->SetIntField(env, insets, insetsIDs.left, wdata->left);
-    (*env)->SetIntField(env, insets, insetsIDs.bottom, wdata->bottom);
-    (*env)->SetIntField(env, insets, insetsIDs.right, wdata->right);
-
-    /* Fix for 4106068: don't do it, rely on the window */
-    /*   manager maximizing policy instead              */
-#if 0
-    /* when the insets get set, make sure we set the proper */
-    /* max window size (since it's dependent on inset size) */
-    if (wdata->isResizable) {
-        int32_t screenWidth = XWidthOfScreen( XDefaultScreenOfDisplay(awt_display));
-        int32_t screenHeight= XHeightOfScreen(XDefaultScreenOfDisplay(awt_display));
-        XtVaSetValues(wdata->winData.shell,
-                XmNmaxWidth, screenWidth - (wdata->left + wdata->right),
-                XmNmaxHeight, screenHeight - (wdata->top + wdata->bottom),
-                NULL);
-    }
-#endif
-    (*env)->DeleteLocalRef(env, insets);
-}
-
-
-/* setMbAndWwHeightAndOffsets() attempts to establish the heights
-   of frame's menu bar and warning window (if present in frame).
-   setMbAndWwHeightAndOffsets() also adjusts appropriately the
-   X/Motif offsets and calls changeInsets() to set target insets.
-   A warning window, if present, is established during ...create().
-   wdata->warningWindow is set there, wdata->wwHeight is set here.
-   Routine pSetMenuBar() sets value of the wdata->menuBar field.
-   This routine reads that value. If it is not null, a menubar
-   has been added.  In this case, calculate the current height
-   of the menu bar.  This may be a partial (incomplete) menubar
-   because ths routine may be called before the X/Motif menubar
-   is completely realized. In this case, the menubar height may
-   be adjusted incrementally.  This routine may be called from
-   ...pSetMenuBar(), innerCanvasEH(), and ...pReshape(). It is
-   designed to (eventually) obtain the correct menubar height.
-   On the other hand, if wdata->menuBar is NULL and the stored
-   menubar height is not zero, then we subtract off the height. */
-
-static void
-awtJNI_setMbAndWwHeightAndOffsets(JNIEnv * env,
-                                  jobject this,
-                                  struct FrameData *wdata )
-{
-    Dimension   warningHeight,  /* Motif warning window height  */
-                labelHeight;    /* Motif warning label's height */
-
-    WidgetList  warningChildrenWL; /* warning children widgets  */
-
-    Dimension   menuBarWidth,   /* Motif menubar width          */
-                menuBarHeight,  /* Motif menubar height         */
-                menuBarBorderSize, /* Motif menubar border size */
-                marginHeight,   /* Motif menubar margin height  */
-                menuHeight,     /* Motif menubar's menu height  */
-                menuBorderSize, /* Motif menu border size       */
-                actualHeight;   /* height: menu+margins+borders */
-
-    WidgetList  menuBarChildrenWL; /* menubar children widgets  */
-    Cardinal    numberChildren; /* number of menubar children   */
-
-#ifdef _pauly_debug
-    fprintf(stdout," ++ setMenuBar\n");
-    fflush(stdout);
-#endif /* _pauly_debug */
-
-    /* If warning window height not yet known, try to get it now.
-       It will be added to top or bottom (iff NETSCAPE) offset. */
-    if  (wdata->warningWindow != NULL) {
-        XtVaGetValues(wdata->warningWindow,
-                      XmNheight, &warningHeight,
-                      XmNchildren, &warningChildrenWL,
-                      XmNnumChildren, &numberChildren,
-                      NULL);
-
-        /* We may be doing this before warning window is realized ! So,
-           check for a child label in the warning. If its height is not
-           yet accounted for in the warning height, then use it here.   */
-        if  (numberChildren != 0) {
-            XtVaGetValues(warningChildrenWL[0],
-                          XmNheight, &labelHeight,
-                          NULL);
-#ifdef _pauly_debug
-            fprintf(stdout,"    setMenuBar.... warning label found with height: %d\n", labelHeight);
-            fflush(stdout);
-#endif /* _pauly_debug */
-            if  (warningHeight < labelHeight) {
-#ifdef _pauly_debug
-    fprintf(stdout,"    setMenuBar.... !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
-    fflush(stdout);
-#endif /* _pauly_debug */
-                warningHeight = labelHeight;
-            }
-        }
-
-        if  (wdata->wwHeight < warningHeight) {
-#ifdef _pauly_debug
-            fprintf(stdout, "    setMenuBar.... adding warning height: %d\n", warningHeight);
-            fflush(stdout);
-#endif /* _pauly_debug */
-#ifdef NETSCAPE
-            wdata->bottom += (warningHeight - wdata->wwHeight);
-#else
-            wdata->top += (warningHeight - wdata->wwHeight);
-#endif /* NETSCAPE */
-            awtJNI_ChangeInsets(env, this, wdata);
-            wdata->wwHeight = warningHeight;
-        }
-    }
-
-    /* Now we adjust offsets for an added or removed menu bar   */
-    if  (wdata->menuBar != NULL) {
-#ifdef _pauly_debug
-        fprintf(stdout,"    setMenuBar.  menu bar: %x\n", wdata->menuBar);
-        fflush(stdout);
-#endif /* _pauly_debug */
-        XtVaGetValues(wdata->menuBar,
-                      XmNwidth, &menuBarWidth,
-                      XmNheight, &menuBarHeight,
-                      XmNchildren, &menuBarChildrenWL,
-                      XmNnumChildren, &numberChildren,
-                      XmNborderWidth, &menuBarBorderSize,
-                      XmNmarginHeight, &marginHeight,
-                      NULL);
-
-        /* We may be doing this before menu bar is realized ! Hence,
-           check for a menu in the menu bar. If its height is not yet
-           accounted for in the menu bar height, then add it in here.   */
-        if  (numberChildren != 0) {
-            XtVaGetValues(menuBarChildrenWL[0],
-                          XmNheight, &menuHeight,
-                          XmNborderWidth, &menuBorderSize,
-                          NULL);
-#ifdef _pauly_debug
-            fprintf(stdout,"    setMenuBar.... menu found with height: %d, border: %d, margin: %d, bar border: %d\n", menuHeight, menuBorderSize, marginHeight, menuBarBorderSize);
-            fflush(stdout);
-#endif /* _pauly_debug */
-            /* Calculate real height of menu bar by adding height of its
-               child menu and borders, margins, and the menu bar borders*/
-            actualHeight = menuHeight + (2 * menuBorderSize) +
-                           (2 * marginHeight) + (2 * menuBarBorderSize);
-#ifdef __linux__
-#ifdef _pauly_debug
-            fprintf(stdout,"  actual height: %d mb height %d\n", actualHeight, menuBarHeight);
-            fflush(stdout);
-#endif /* _pauly_debug */
-#endif
-            if  (menuBarHeight < actualHeight) {
-#ifdef _pauly_debug
-fprintf(stdout,"    setMenuBar.... ****************************************\n");
-fflush(stdout);
-#endif /* _pauly_debug */
-                menuBarHeight = actualHeight;
-            }
-        }
-
-        if  (wdata->mbHeight < menuBarHeight) {
-            /* Adjust the (partially) added menu bar height, top offset.*/
-#ifdef _pauly_debug
-            fprintf(stdout, "    setMenuBar.... added menuBar height: %d\n", menuBarHeight);
-            fflush(stdout);
-#endif /* _pauly_debug */
-            wdata->top += (menuBarHeight - wdata->mbHeight);
-            awtJNI_ChangeInsets(env, this, wdata);
-            wdata->mbHeight = menuBarHeight;
-        }
-    } else if  ((wdata->menuBar == NULL) && (wdata->mbHeight > 0)) {
-        /* A menu bar has been removed; subtract height from top offset.*/
-        wdata->top -= wdata->mbHeight;
-#ifdef _pauly_debug
-        fprintf(stdout, "    setMenuBar.... removed menuBar height: %d\n", wdata->mbHeight);
-        fflush(stdout);
-#endif /* _pauly_debug */
-        awtJNI_ChangeInsets(env, this, wdata);
-        wdata->mbHeight = 0;
-    }
-}
-
-
-/* outerCanvasResizeCB() is Motif resize callback for outer/child canvas.
-   It reads width, height of Motif widget, sets java target accordingly,
-   and then calls handleResize() to affect any changes.
-   This call is only done for a shell resize or inner/parent resize;
-   i.e., it may not be done for a ...pReshape() to avoid doing a loop.
-
-   client_data is MWindowPeer instance
-*/
-static void
-outerCanvasResizeCB(Widget wd, XtPointer client_data, XtPointer call_data)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject target;
-    struct FrameData *wdata;
-    Position    screenX;        /* x position of the canvas, screen */
-    Position    screenY;        /* y position of the canvas, screen */
-    Dimension   width;          /* width of the canvas, target  */
-    Dimension   height;         /* height of the canvas, target */
-    jint        oldWidth;
-    jint        oldHeight;
-
-#ifdef _pauly_debug
-    fprintf(stdout," ++ WindowResize.\n");
-    fflush(stdout);
-#endif /* _pauly_debug */
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, (jobject) client_data,
-                              mComponentPeerIDs.pData);
-    if (wdata == NULL) {
-        return;
-    }
-
-    if ((*env)->EnsureLocalCapacity(env, 1) < 0)
-        return;
-
-    target = (*env)->GetObjectField(env, (jobject) client_data,
-                                    mComponentPeerIDs.target);
-    XtVaGetValues(wd,
-                  XmNwidth, &width,
-                  XmNheight, &height,
-                  NULL);
-#ifdef _pauly_debug
-    fprintf(stdout,"    outerCanvasResizeCB.  width: %d, height: %d\n", width, height);
-    fflush(stdout);
-#endif /* _pauly_debug */
-
-
-    XtTranslateCoords(wd, 0, 0, &screenX, &screenY);
-
-    if  ((wdata->shellResized) || (wdata->canvasResized)) {
-#ifdef _pauly_debug
-        fprintf(stdout,"    outerCanvasResizeCB\n");
-        fflush(stdout);
-#endif /* _pauly_debug */
-        wdata->shellResized = False;
-        wdata->canvasResized = False;
-        /*
-        ** if you are not yet reparented, don't compute the size based on the
-        ** widgets, as the window manager shell containg the insets is not yet
-        ** there.  Use the size the application has set.
-        ** If not reparented, we got here because the application set the size,
-        ** so just send them Component.RESIZED event with the size they set.
-        **
-        ** If the reparenting causes a resize ( only when inset guess is wrong )        ** the new size will be sent in a Component.RESIZED event at that time.
-        */
-        if (wdata->reparented)
-        {
-            (*env)->SetIntField(env, target, componentIDs.x, (jint) screenX);
-            (*env)->SetIntField(env, target, componentIDs.y, (jint) screenY);
-        }
-
-    oldWidth = (*env)->GetIntField(env, target, componentIDs.width);
-    oldHeight = (*env)->GetIntField(env, target, componentIDs.height);
-
-    if (oldWidth != width || oldHeight != height || wdata->need_reshape)
-    {
-        wdata->need_reshape = False;
-        (*env)->SetIntField(env, target, componentIDs.width, (jint)width);
-        (*env)->SetIntField(env, target, componentIDs.height,
-                (jint)height);
-
-        /* only do this for Windows, not Canvases, btw */
-        checkNewXineramaScreen(env, client_data, wdata, screenX, screenY, width, height);
-
-        JNU_CallMethodByName(env, NULL, (jobject) client_data,
-                 "handleResize", "(II)V", width, height);
-        if  ((*env)->ExceptionOccurred(env)) {
-            (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-        }
-    }
-    }
-
-    (*env)->DeleteLocalRef(env, target);
-
-#ifdef _pauly_debug
-    fprintf(stdout,"    WindowResize. Done.\n");
-    fflush(stdout);
-#endif /* _pauly_debug */
-
-} /* outerCanvasResizeCB() */
-
-static void reconfigureOuterCanvas ( JNIEnv *env, jobject target,
-                                     jobject this, struct FrameData *wdata )
-{
-    Dimension   innerDAWidth,   /* width of inner Motif canvas  */
-                innerDAHeight,  /* height of inner Motif canvas */
-                outerDAWidth,   /* width of outer Motif canvas  */
-                outerDAHeight;  /* height of outer Motif canvas */
-    int32_t     targetWidth,    /* java target object's width   */
-                targetHeight;   /* java target's object height  */
-    Dimension   width;          /* width of the canvas, target  */
-    Dimension   height;         /* height of the canvas, target */
-
-
-    Position    innerX,         /* x loc. of inner Motif canvas */
-                innerY,         /* y loc. of inner Motif canvas */
-                x, y;
-
-    /* canvasW is (visible) inner/parent drawing area (canvas) widget   */
-    XtVaGetValues(XtParent(wdata->winData.comp.widget),
-                  XmNwidth, &innerDAWidth,
-                  XmNheight, &innerDAHeight,
-                  XmNx, &innerX,
-                  XmNy, &innerY,
-                  NULL);
-
-    /* This resize may be due to the insertion or removal of a menu bar.
-       If so, we appropriately adjust the top offset in wdata, insets.  */
-    awtJNI_setMbAndWwHeightAndOffsets(env, this, wdata);
-
-    outerDAWidth = innerDAWidth + wdata->left + wdata->right;
-    outerDAHeight = innerDAHeight + wdata->top + wdata->bottom;
-
-    /* If it's a menu bar reset, do not do resize of outer/child canvas.
-       (Another thread problem; we arrest this now before damage done.) */
-    if  (wdata->menuBarReset)
-    {
-        targetWidth = (*env)->GetIntField(env, target, componentIDs.width);
-        targetHeight = (*env)->GetIntField(env, target, componentIDs.height);
-        if  ((outerDAWidth != targetWidth) || (outerDAHeight != targetHeight))
-        {
-            return;
-        }
-    }
-
-    wdata->canvasResized = True;
-
-    /* The outer/child drawing area (canvas) needs to be configured too.
-       If its size changes, its resize callback will thereby be invoked.*/
-    x = -wdata->left;
-    y = -wdata->top;
-    width = innerDAWidth + wdata->left + wdata->right;
-    height = innerDAHeight + wdata->top + wdata->bottom;
-
-    XtConfigureWidget(wdata->winData.comp.widget, x, y, width, height, 0 );
-}
-
-
-
-/* innerCanvasEH() is event handler for inner/parent canvas. It handles
-   map and configure notify events. It reads width and height, adjusts
-   for menubar insertion / removal and configures outer/child canvas.   */
-
-static void
-innerCanvasEH(Widget canvasW, XtPointer client_data, XEvent *event,
-              Boolean* continueToDispatch)
-{
-    JNIEnv      *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject     this = (jobject) client_data;
-    jobject     target;
-    struct FrameData *wdata;
-
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if  (wdata == NULL) {
-        return;
-    }
-
-    if  ((*env)->EnsureLocalCapacity(env, 1) < 0)
-        return;
-
-    target = (*env)->GetObjectField(env, (jobject) client_data,
-                                    mComponentPeerIDs.target);
-
-    /* While inside ...pSetMenuBar(), don't react to incomplete resizing
-       events supplied by Xt toolkit. Wait for completion of the routine. */
-
-
-    /* For a map or resize, we need to check for the addition or deletion
-       of a menu bar to the form which is the of this drawing area (canvas).
-       We also must then configure the outer/child canvas appropriately.  */
-
-    if  ( (event->xany.type == MapNotify) ||
-          (event->xany.type == ConfigureNotify) )
-    {
-        reconfigureOuterCanvas( env, target, this, wdata );
-    }
-
-    (*env)->DeleteLocalRef(env, target);
-
-}
-
-/* syncTopLevelPos() is necessary to insure that the window manager has in
- * fact moved us to our final position relative to the reParented WM window.
- * We have noted a timing window which our shell has not been moved so we
- * screw up the insets thinking they are 0,0.  Wait (for a limited period of
- * time to let the WM hava a chance to move us
- */
-void syncTopLevelPos( Display *d, Window w, XWindowAttributes *winAttr )
-{
-    int32_t i = 0;
-    memset(winAttr, 0, sizeof(*winAttr));
-
-    do {
-        if (!XGetWindowAttributes(d, w, winAttr)) {
-            memset(winAttr, 0, sizeof(*winAttr));
-            break;
-        }
-        /* Sometimes we get here before the WM has updated the
-        ** window data struct with the correct position.  Loop
-        ** until we get a non-zero position.
-        */
-        if ((winAttr->x != 0) || (winAttr->y != 0)) {
-            break;
-        }
-        else {
-            /* What we really want here is to sync with the WM,
-            ** but there's no explicit way to do this, so we
-            ** call XSync for a delay.
-            */
-            XSync(d, False);
-        }
-    } while (i++ < 50);
-}
-
-typedef struct FocusOutInfo_str {
-    XEvent * eventOut;
-    Window inWin;
-    Window inChild;
-    Widget defChild;
-    jobject childComp;
-} FocusOutInfo_t;
-
-#define IsCanvasTypeWidget(w) \
-        (XtIsSubclass(w, xmDrawingAreaWidgetClass) ||\
-        XtIsSubclass(w, vDrawingAreaClass))
-
-int isTopLevelPartWidget(Widget w) {
-    if (XtIsShell(w)) {
-        return TRUE;
-    }
-    if (XtIsSubclass(w, xmFormWidgetClass)) {
-        return TRUE;
-    }
-    if (IsCanvasTypeWidget(w)) {
-        Widget w1 = XtParent(w);
-        if (w1 != NULL) {
-            if (XtIsSubclass(w1, xmFormWidgetClass)) {
-                return TRUE;
-            }
-            if (IsCanvasTypeWidget(w1)) {
-                Widget w2 = XtParent(w1);
-                if (w2 != NULL) {
-                    if (XtIsSubclass(w2, xmFormWidgetClass)) {
-                        return TRUE;
-                    }
-                }
-            }
-
-        }
-    }
-    return FALSE;
-}
-
-void
-shellFocusEH(Widget w, XtPointer data, XEvent *event, Boolean *continueToDispatch)
-{
-    JNIEnv      *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject     this = (jobject) data;
-    jobject     target;
-    struct FrameData *wdata;
-
-    /* Any event handlers which take peer instance pointers as
-     * client_data should check to ensure the widget has not been
-     * marked as destroyed as a result of a dispose() call on the peer
-     * (which can result in the peer instance pointer already haven
-     * been gc'd by the time this event is processed)
-     */
-    if (w->core.being_destroyed) {
-        return;
-    }
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL) {
-        return;
-    }
-
-    switch (event->xany.type) {
-      case FocusOut:
-          // Will be handled by proxy automaticall since he is focus owner
-        break;
-      case FocusIn:
-        // Forward focus event to the proxy
-        XSetInputFocus(awt_display, XtWindow(wdata->focusProxy), RevertToParent, CurrentTime);
-        break;
-    }
-}
-
-/**
- * Fix for Alt-Tab problem.
- * See coments on use semantics below.
- */
-Boolean skipNextNotifyWhileGrabbed = False;
-Boolean skipNextFocusIn = False;
-
-Boolean focusOnMapNotify = False;
-
-/* shellEH() is event handler for the Motif shell widget. It handles
-   focus change, map notify, configure notify events for the shell.
-   Please see internal comments pertaining to these specific events.
-
-   data is MWindowPeer instance pointer
-*/
-void
-shellEH(Widget w, XtPointer data, XEvent *event, Boolean *continueToDispatch)
-{
-    JNIEnv      *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject     this = (jobject) data;
-    jobject     target;
-    struct FrameData *wdata;
-    int32_t     setTargetX,
-                setTargetY,
-                getTargetX,
-                getTargetY;
-    /* Changed long to int for 64-bit */
-    int32_t     wwHeight;       /* height of any warning window present */
-    int32_t     topAdjust;      /* adjust top offset for menu, warning  */
-    jclass      clazz;
-    int32_t     x, y;
-    int32_t     width, height;
-    enum wmgr_t runningWM;
-    jobject   winAttrObj;
-    static jobject windowClass = NULL;
-    /* Any event handlers which take peer instance pointers as
-     * client_data should check to ensure the widget has not been
-     * marked as destroyed as a result of a dispose() call on the peer
-     * (which can result in the peer instance pointer already haven
-     * been gc'd by the time this event is processed)
-     */
-    if (w->core.being_destroyed) {
-        return;
-    }
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL) {
-        return;
-    }
-
-    switch (event->xany.type) {
-
-    case FocusOut: {
-        int32_t res = 0;
-        int revert_to = 0;
-        Widget defChild = NULL;
-        Window focusOwner = None;
-        jobject oppositeWindow = NULL;
-        Widget oppositeShell = NULL;
-        XEvent inEvent;
-        Widget shell = NULL;
-#ifdef DEBUG_FOCUS
-        fprintf(stderr, "Focusout on proxy; window = %x, mode %d, detail %d\n",
-                event->xfocus.window, event->xfocus.mode, event->xfocus.detail);
-#endif
-        shell = wdata->winData.shell;
-
-        if ((*env)->EnsureLocalCapacity(env, 3) < 0) {
-            break;
-        }
-
-        /**
-         * Fix for Alt-Tab problem. We should process NotifyWhileGrabbed events
-         * only if they are due to the switch between top-levels.
-         * skipNextNotifyWhileGrabbed is set from Menu and PopupMenu code
-         * to prevent generation of focus events when user interact with these
-         * widget.
-         */
-        if (event->xfocus.mode == NotifyWhileGrabbed) {
-            if (skipNextNotifyWhileGrabbed) {
-                skipNextNotifyWhileGrabbed = False;
-                break;
-            }
-        } else if (event->xfocus.mode != NotifyNormal) break;
-
-        /**
-         * Fix for Alt-Tab problem.
-         * skipNextFocusIn is set in Choice code to avoid processing of
-         * next focus-in or focus-out generated by Choice as it is a fake
-         * event.
-         */
-        if (skipNextFocusIn && event->xfocus.detail == NotifyPointer) {
-            break;
-        }
-
-        XGetInputFocus( awt_display, &focusOwner, &revert_to);
-
-        if (focusOwner != None) {
-            Widget inWidget = NULL;
-            jobject wpeer = NULL;
-            inWidget = XtWindowToWidget(awt_display, focusOwner);
-            if (inWidget != NULL && inWidget != shell) {
-                oppositeShell = getShellWidget(inWidget);
-                wpeer = findPeer(&inWidget);
-                if (wpeer == NULL) {
-                    inWidget = findTopLevelByShell(inWidget);
-                    if (inWidget != NULL) {
-                        wpeer = findPeer(&inWidget);
-                    }
-                }
-                if (wpeer != NULL) {
-                    jobject peerComp =
-                        (*env)->GetObjectField(env,
-                                               wpeer,
-                                               mComponentPeerIDs.target);
-                    if (peerComp != NULL) {
-                        // Check that peerComp is top-level
-
-                        // load class
-                        if (windowClass == NULL) {
-                            jobject localWindowClass = (*env)->FindClass(env, "java/awt/Window");
-                            windowClass = (*env)->NewGlobalRef(env, localWindowClass);
-                            (*env)->DeleteLocalRef(env, localWindowClass);
-                        }
-                        if ((*env)->IsInstanceOf(env, peerComp, windowClass)) {
-                            oppositeWindow = peerComp;
-                        } else { // Opposite object is not Window - there is no opposite window.
-                            (*env)->DeleteLocalRef(env, peerComp);
-                            peerComp = NULL;
-                            oppositeShell = NULL;
-                        }
-                    }
-                }
-            }
-        } else {
-            // If there is no opposite shell but we have active popup - this popup is actually
-            // the oppposite. This should mean that this focus out is due to popup - and thus
-            // should be skipped. Fix for 4478780.
-            if (skipNextNotifyWhileGrabbed) {
-                break;
-            }
-        }
-
-        // If current window is not focusable and opposite window is not focusable - do nothing
-        // If current window is focusable and opposite is not - do not clear focus variables like
-        // focus didn't leave this window(but it will in terms of X). When we later switch to either
-        // - back to this window: variables are already here
-        // - another focusable window: variables point to focusable window and "focus lost" events
-        //   will be generated for it
-        // - non-java window: variables point to focusable window and "focus lost" events
-        //   will be generated for it, not for non-focusable.
-        // If current window is non-focusable and opposite is focusable then do not generate anything
-        // as if we didn't leave previous focusable window so Java events will generated for it.
-        //
-        // Fix for 6547951.
-        // Also do cleaning when switching to non-java window (opposite is null).
-        if (isFocusableWindowByShell(env, shell) && shell != oppositeShell &&
-            ((oppositeShell != NULL && isFocusableWindowByShell(env, oppositeShell)) ||
-             oppositeShell == NULL))
-        {
-            // The necessary FOCUS_LOST event will be generated by DKFM.
-            // So we need to process focus list like we received FocusOut
-            // for the desired component - shell's current focus widget
-            defChild = XmGetFocusWidget(shell);
-            if (defChild != NULL) {
-                jobject peer = findPeer(&defChild);
-                if (peer == NULL) {
-                    defChild = findTopLevelByShell(defChild);
-                    if (defChild != NULL) {
-                        peer = findPeer(&defChild);
-                    }
-                }
-                if (peer != NULL) {
-                    jobject comp = (*env)->GetObjectField(env, peer, mComponentPeerIDs.target);
-                    if (focusList != NULL) {
-                        jobject last = (*env)->NewLocalRef(env, focusList->requestor);
-                        if ((*env)->IsSameObject(env, comp, last)) {
-                            FocusListElt * temp = focusList;
-                            forGained = focusList->requestor;
-                            focusList = focusList->next;
-                            free(temp);
-                            if (focusList == NULL) {
-                                focusListEnd = NULL;
-                            }
-                        }
-                        if (!JNU_IsNull(env, last)) {
-                            (*env)->DeleteLocalRef(env, last);
-                        }
-                    }
-                    (*env)->DeleteLocalRef(env, comp);
-                }
-            }
-            target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-            processTree(defChild, findWindowsProxy(target, env), False);
-            XtSetKeyboardFocus(shell, NULL);
-            (*env)->DeleteLocalRef(env, target);
-        }
-#ifndef NOMODALFIX
-        if (!awt_isModal() || awt_isWidgetModal(shell)) {
-#endif //NOMODALFIX
-            if ( oppositeShell != NULL
-                 && isFocusableWindowByShell(env, oppositeShell)
-                 && isFocusableWindowByShell(env, shell)
-                 || (oppositeShell == NULL))
-            {
-                /*
-                 * Fix for 5095117.
-                 * Check if current native focused window is the same as source.
-                 * Sometimes it is not - we must not however clean reference to
-                 * actual native focused window.
-                 */
-                jobject currentFocusedWindow = awt_canvas_getFocusedWindowPeer();
-                if ((*env)->IsSameObject(env, this, currentFocusedWindow)) {
-                    awt_canvas_setFocusedWindowPeer(NULL);
-                }
-                (*env)->DeleteLocalRef(env, currentFocusedWindow);
-
-                JNU_CallMethodByName(env, NULL, this, "handleWindowFocusOut", "(Ljava/awt/Window;)V",
-                                     oppositeWindow);
-                if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-                    (*env)->ExceptionDescribe(env);
-                    (*env)->ExceptionClear(env);
-                }
-            }
-#ifndef NOMODALFIX
-        }
-#endif //NOMODALFIX
-        if (oppositeWindow != NULL) {
-            (*env)->DeleteLocalRef(env, oppositeWindow);
-        }
-
-        break;
-    } /* FocusOut */
-
-    case FocusIn: {
-        Widget shell = wdata->winData.shell;
-#ifdef DEBUG_FOCUS
-        fprintf(stderr, "FocusIn on proxy; window = %x, mode %d, detail %d\n", event->xfocus.window,
-                event->xfocus.mode, event->xfocus.detail);
-#endif
-        if (/*  event->xfocus.mode == NotifyNormal */ 1) {
-
-            /**
-             * Fix for Alt-Tab problem. We should process NotifyWhileGrabbed events to detect
-             * switch between top-levels using alt-tab, but avoid processing these type of event
-             * when they are originated from other sources.
-             */
-            if (event->xfocus.mode == NotifyWhileGrabbed) {
-                /**
-                 * skipNextNotifyWhileGrabbed is set from Menu and PopupMenu code to
-                 * skip next focus-in event with NotifyWhileGrabbed as it is generated
-                 * in result of closing of the Menu's shell.
-                 * Event will also have NotifyInferior if uses clicked on menu bar in the
-                 * space where there is not menu items.
-                 */
-                if (skipNextNotifyWhileGrabbed || event->xfocus.detail == NotifyInferior) {
-                    skipNextNotifyWhileGrabbed = False;
-                    break;
-                }
-            } else if (event->xfocus.mode != NotifyNormal)  {
-                break;
-            }
-
-            /**
-             * Fix for Alt-Tab problem.
-             * skipNextFocusIn is set from Choice code to avoid processing next focus-in
-             * as it is a fake event.
-             */
-            if (skipNextFocusIn == True) {
-                /**
-                 * There could be the set of fake events, the last one
-                 * will have detail == NotifyPointer
-                 */
-                if (event->xfocus.detail != NotifyPointer) {
-                    skipNextFocusIn = False;
-                }
-                break;
-            }
-#ifndef NOMODALFIX
-            if (!awt_isModal() || awt_isWidgetModal(shell)) {
-#endif //NOMODALFIX
-                if (isFocusableWindowByShell(env, shell)) {
-                    jobject currentFocusedWindow = awt_canvas_getFocusedWindowPeer();
-                    // Check if focus variables already point to this window. If so,
-                    // it means there were transfer to non-focusable window and now we
-                    // are back to origianl focusable window. No need to generate Java events
-                    // in this case.
-                    if (!(*env)->IsSameObject(env, this, currentFocusedWindow)) {
-                        awt_canvas_setFocusedWindowPeer(this);
-                        awt_canvas_setFocusOwnerPeer(this);
-
-                        /*
-                         * Fix for 6465038.
-                         * Restore focus on the toplevel widget if it's broken.
-                         */
-                        Widget widgetToFocus = getFocusWidget(findTopLevelByShell(shell));
-                        Widget currentOwner = XmGetFocusWidget(shell);
-
-                        if (widgetToFocus != currentOwner) {
-#ifdef DEBUG_FOCUS
-                            fprintf(stderr, "Wrong Xm focus; resetting Xm focus from %x to toplevel %x...\n",
-                                    currentOwner != NULL ? XtWindow(currentOwner) : 0,
-                                    widgetToFocus != NULL ? XtWindow(widgetToFocus) : 0);
-#endif
-                            if ( !XmProcessTraversal(widgetToFocus, XmTRAVERSE_CURRENT) ) {
-                                XtSetKeyboardFocus(shell, widgetToFocus);
-                            }
-#ifdef DEBUG_FOCUS
-                            Widget _w = XmGetFocusWidget(shell);
-                            fprintf(stderr, "                ...focus resulted on window %x\n", _w != NULL ? XtWindow(_w) : 0);
-#endif
-                        }
-
-                        JNU_CallMethodByName(env, NULL, this, "handleWindowFocusIn", "()V");
-                        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-                            (*env)->ExceptionDescribe(env);
-                            (*env)->ExceptionClear(env);
-                        }
-                    }
-                    (*env)->DeleteLocalRef(env, currentFocusedWindow);
-                }
-#ifndef NOMODALFIX
-            }
-#endif //NOMODALFIX
-        }
-        raiseInputMethodWindow(wdata);
-        break;
-    } /* FocusIn */
-
-    case VisibilityNotify: {
-       winAttrObj = (*env)->GetObjectField(env, this, mWindowPeerIDs.winAttr);
-       (*env)->SetIntField(env, winAttrObj,
-                           mWindowAttributeIDs.visibilityState,
-                           event->xvisibility.state);
-        if (event->xvisibility.state == VisibilityUnobscured) {
-            raiseInputMethodWindow(wdata);
-        }
-        break;
-    } /* VisibilityNotify */
-
-    case MapNotify: {
-        /* Your body seems to unfade */
-        if (wdata->initialFocus == False) {
-            XtVaSetValues(wdata->winData.shell, XmNinput, True, NULL);
-
-            // We have to to evidently move the window to the front here.
-            Window shellWindow;
-            if ((shellWindow = XtWindow(wdata->winData.shell)) != None) {
-                XRaiseWindow(awt_display, shellWindow);
-            }
-        }
-        if (awt_wm_isStateNetHidden(XtWindow(wdata->winData.shell))) {
-            focusOnMapNotify = True;
-        }
-        /*
-         * TODO: perhaps we need this putback only for simple Window.
-         * For Frame/Dialog XmNinput==True would be enough. The native
-         * system will focus it itself.
-         */
-        if (wdata->isFocusableWindow && focusOnMapNotify) {
-            XEvent ev;
-            memset(&ev, 0, sizeof(ev));
-
-            ev.type = FocusIn;
-            ev.xany.send_event = True;
-            ev.xany.display = awt_display;
-            ev.xfocus.mode = NotifyNormal;
-            ev.xfocus.detail = NotifyNonlinear;
-            ev.xfocus.window = XtWindow(wdata->winData.shell);
-            awt_put_back_event(env, &ev);
-        }
-        focusOnMapNotify = False;
-
-        break;
-    }
-
-    case UnmapNotify: {
-        /* Gee!  All of a sudden, you can't see yourself */
-        if (wdata->initialFocus == False) {
-            XtVaSetValues(wdata->winData.shell, XmNinput, False, NULL);
-        }
-        if (awt_wm_isStateNetHidden(XtWindow(wdata->winData.shell))) {
-            focusOnMapNotify = True;
-        }
-        break;
-    }
-
-    case DestroyNotify: {       /* Foul play!  ICCCM forbids WM to do this! */
-        /* Your window is killed by the WM */
-        JNU_CallMethodByName(env, NULL, this, "handleDestroy", "()V");
-        if ((*env)->ExceptionOccurred(env)) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-        break;
-    }
-
-    case PropertyNotify: {
-        jint state, old_state, changed;
-
-        /*
-         * Let's see if this is a window state protocol message, and
-         * if it is - decode a new state in terms of java constants.
-         */
-        if (!awt_wm_isStateChange(wdata, (XPropertyEvent *)event, &state)) {
-            /* Pakka Pakka seems not interested */
-            break;
-        }
-
-        changed = wdata->state ^ state;
-        if (changed == 0) {
-            /* You feel dizzy for a moment, but nothing happens... */
-            DTRACE_PRINTLN("TL: >>> state unchanged");
-            break;
-        }
-
-        old_state = wdata->state;
-        wdata->state = state;
-
-#ifdef DEBUG
-        DTRACE_PRINT("TL: >>> State Changed:");
-        if (changed & java_awt_Frame_ICONIFIED) {
-            if (state & java_awt_Frame_ICONIFIED) {
-                DTRACE_PRINT(" ICON");
-            } else {
-                DTRACE_PRINT(" !icon");
-            }
-        }
-        if (changed & java_awt_Frame_MAXIMIZED_VERT) {
-            if (state & java_awt_Frame_MAXIMIZED_VERT) {
-                DTRACE_PRINT(" MAX_VERT");
-            } else {
-                DTRACE_PRINT(" !max_vert");
-            }
-        }
-        if (changed & java_awt_Frame_MAXIMIZED_HORIZ) {
-            if (state & java_awt_Frame_MAXIMIZED_HORIZ) {
-                DTRACE_PRINT(" MAX_HORIZ");
-            } else {
-                DTRACE_PRINT(" !max_horiz");
-            }
-        }
-        DTRACE_PRINTLN("");
-#endif
-
-        if (changed & java_awt_Frame_ICONIFIED) {
-            /* Generate window de/iconified event for old clients */
-            if (state & java_awt_Frame_ICONIFIED) {
-                DTRACE_PRINTLN("TL: ... handleIconify");
-                JNU_CallMethodByName(env, NULL,
-                                     this, "handleIconify", "()V");
-            }
-            else {
-                DTRACE_PRINTLN("TL: ... handleDeiconify");
-                JNU_CallMethodByName(env, NULL,
-                                     this, "handleDeiconify", "()V");
-            }
-            if ((*env)->ExceptionOccurred(env)) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-            }
-        }
-
-        DTRACE_PRINTLN("TL: ... handleStateChange");
-        JNU_CallMethodByName(env, NULL,
-                             this, "handleStateChange", "(II)V",
-                             old_state, state);
-        if ((*env)->ExceptionOccurred(env)) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-        break;
-    } /* PropertyNotify */
-
-    case ReparentNotify: {
-        Window root = RootWindowOfScreen(XtScreen(wdata->winData.shell));
-
-#ifdef DEBUG
-        DTRACE_PRINT2("TL: ReparentNotify(0x%x/0x%x) to ",
-                      wdata->winData.shell, XtWindow(wdata->winData.shell));
-        if (event->xreparent.parent == root) {
-            DTRACE_PRINTLN("root");
-        } else {
-            DTRACE_PRINTLN1("window 0x%x", event->xreparent.parent);
-        }
-#endif
-
-        if (wdata->winData.flags & W_IS_EMBEDDED) {
-            DTRACE_PRINTLN("TL:   embedded frame - nothing to do");
-            break;
-        }
-
-#ifdef __linux__
-        if (!wdata->fixInsets) {
-            DTRACE_PRINTLN("TL:   insets already fixed");
-            break;
-        }
-        else {
-            wdata->fixInsets = False;
-        }
-#endif
-
-        if ((*env)->EnsureLocalCapacity(env, 1) < 0)
-            break;
-
-        target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-        x      = (*env)->GetIntField(env, target, componentIDs.x);
-        y      = (*env)->GetIntField(env, target, componentIDs.y);
-        width  = (*env)->GetIntField(env, target, componentIDs.width);
-        height = (*env)->GetIntField(env, target, componentIDs.height);
-
-        /* The insets were literally hardcoded in the MWindowPeer.
-           But they are dependent upon both the window manager (WM)
-           and the hardware display.  So, these are usually wrong.
-           This leads to problems with shell positioning and size.
-           Furthermore, there is not a published interface or way
-           to obtain from any given window manager the dimensions
-           of its decoration windows (i.e., borders and title bar).
-           So, given this problem in design, we must workaround.
-           N.B. (0) This works.  But there is one functional caveat:
-           the frame.insets() function will usually return
-           the wrong values until AFTER the frame is shown.
-           It always did this before; it's just that now,
-           the values will become correct after rendering,
-           whereas before the values were never corrected.
-           (I believe this unavoidable given this design.)
-           (1) Note that we must/have to do this exactly once.
-           (2) The hardcoded values of ...create() (25,5)
-           are also utilized here and must be consistent.
-           This of course could be reworked as desired.
-           (3) Assume top border (title bar) is one width,
-           and other three borders are another width.
-           This, however, could be easily reworked below.       */
-
-        /*
-         * The above comment is no longer completely true.
-         * The insets are no longer hardcoded but are retrieved from
-         * guessInsets(), either from a per-window manager default,
-         * set in the awt.properties file, or overwritten by the
-         * actual values determined from a previous frames
-         * reparenting.
-         */
-
-        if (wdata->decor == AWT_NO_DECOR) {
-            if (!wdata->isResizable && !wdata->isFixedSizeSet) {
-                reshape(env, this, wdata, x, y, width, height, False);
-                if (wdata->warningWindow != NULL)
-                    awtJNI_ChangeInsets(env, this, wdata);
-            }
-        }
-        else if (event->xreparent.parent == root) {
-            wdata->reparented = False;
-            wdata->configure_seen = False;
-
-            /*
-             * We can be repareted to root for two reasons:
-             *   . setVisible(false)
-             *   . WM exited
-             */
-            if (wdata->isShowing) { /* WM exited */
-                /* Work around 4775545 */
-                awt_wm_unshadeKludge(wdata);
-            }
-        }
-        else  { /* reparented to WM frame, figure out our insets */
-            XWindowAttributes   winAttr, actualAttr;
-            int32_t             correctWMTop = -1;
-            int32_t             correctWMLeft = -1;
-            int32_t             correctWMBottom;
-            int32_t             correctWMRight;
-            int32_t             topCorrection;
-            int32_t             leftCorrection;
-            int32_t             bottomCorrection = 0;
-            int32_t             rightCorrection = 0;
-            int32_t             screenX, screenY;
-            int32_t             i;
-            int32_t             actualWidth, actualHeight;
-            int32_t             t, l, b, r;
-            Window              containerWindow;
-
-            /* Dummies for XQueryTree */
-            Window              ignore_Window, *ignore_WindowPtr;
-            uint32_t            ignore_uint;
-
-            Boolean             setXY = True;
-            XSizeHints*         hints = XAllocSizeHints();
-
-            wdata->reparented = True;
-
-            if (hints != NULL) {
-                long ignore = 0;
-                XGetWMNormalHints(awt_display, XtWindow(wdata->winData.shell),
-                    hints, &ignore);
-                setXY = (hints->flags & (USPosition|PPosition)) != 0;
-                XFree(hints);
-            }
-
-            /*
-             * Unfortunately the concept of "insets" borrowed to AWT
-             * from Win32 is *absolutely*, *unbelievably* foreign to
-             * X11.  Few WMs provide the size of frame decor
-             * (i.e. insets) in a property they set on the client
-             * window, so we check if we can get away with just
-             * peeking at it.  [Future versions of wm-spec might add a
-             * standardized hint for this].
-             *
-             * Otherwise we do some special casing.  Actually the
-             * fallback code ("default" case) seems to cover most of
-             * the existing WMs (modulo Reparent/Configure order
-             * perhaps?).
-             *
-             * Fallback code tries to account for the two most common cases:
-             *
-             * . single reparenting
-             *       parent window is the WM frame
-             *       [twm, olwm, sawfish]
-             *
-             * . double reparenting
-             *       parent is a lining exactly the size of the client
-             *       grandpa is the WM frame
-             *       [mwm, e!, kwin, fvwm2 ... ]
-             */
-
-            if (awt_wm_getInsetsFromProp(event->xreparent.window,
-                                         &t, &l, &b, &r))
-            {
-                correctWMTop    = t;
-                correctWMLeft   = l;
-                correctWMBottom = b;
-                correctWMRight  = r;
-                setXY = False;
-            }
-            else
-            switch (awt_wm_getRunningWM()) {
-
-            /* should've been done in awt_wm_getInsetsFromProp */
-            case ENLIGHTEN_WM: {
-                DTRACE_PRINTLN("TL:   hmm, E! insets should have been read"
-                               " from _E_FRAME_SIZE");
-                /* enlightenment does double reparenting */
-                syncTopLevelPos(XtDisplay(wdata->winData.shell),
-                                event->xreparent.parent, &winAttr);
-
-                XQueryTree(XtDisplay(wdata->winData.shell),
-                           event->xreparent.parent,
-                           &ignore_Window,
-                           &containerWindow, /* actual WM frame */
-                           &ignore_WindowPtr,
-                           &ignore_uint);
-                if (ignore_WindowPtr)
-                    XFree(ignore_WindowPtr);
-
-                correctWMLeft = winAttr.x;
-                correctWMTop  = winAttr.y;
-
-                /*
-                 * Now get the actual dimensions of the parent window
-                 * resolve the difference.  We can't rely on the left
-                 * to be equal to right or bottom...  Enlightment
-                 * breaks that assumption.
-                 */
-                XGetWindowAttributes(XtDisplay(wdata->winData.shell),
-                                     containerWindow, &actualAttr);
-                correctWMRight  = actualAttr.width
-                    - (winAttr.width + correctWMLeft);
-                correctWMBottom = actualAttr.height
-                    - (winAttr.height + correctWMTop) ;
-                break;
-            }
-
-            case ICE_WM:
-            case KDE2_WM: /* should've been done in awt_wm_getInsetsFromProp */
-            case CDE_WM:
-            case MOTIF_WM: {
-                /* these are double reparenting too */
-                syncTopLevelPos(XtDisplay(wdata->winData.shell),
-                                event->xreparent.parent, &winAttr);
-
-                correctWMTop    = winAttr.y;
-                correctWMLeft   = winAttr.x;
-                correctWMRight  = correctWMLeft;
-                correctWMBottom = correctWMLeft;
-
-                XTranslateCoordinates(awt_display, event->xreparent.window,
-                                      root, 0,0, &screenX, &screenY,
-                                      &containerWindow);
-
-                if ((screenX != x + wdata->leftGuess)
-                    || (screenY != y + wdata->topGuess))
-                {
-                    /*
-                     * looks like the window manager has placed us somewhere
-                     * other than where we asked for, lets respect the window
-                     * and go where he put us, not where we tried to put us
-                     */
-                    x = screenX - correctWMLeft;
-                    y = screenY - correctWMTop;
-                }
-                break;
-            }
-
-            case SAWFISH_WM:
-            case OPENLOOK_WM: {
-                /* single reparenting */
-                syncTopLevelPos(XtDisplay(wdata->winData.shell),
-                                event->xreparent.window, &winAttr);
-
-                correctWMTop    = winAttr.y;
-                correctWMLeft   = winAttr.x;
-                correctWMRight  = correctWMLeft;
-                correctWMBottom = correctWMLeft;
-                break;
-            }
-
-            case OTHER_WM:
-            default: {          /* this is very similar to the E! case above */
-                Display *dpy = event->xreparent.display;
-                Window w = event->xreparent.window;
-                Window parent = event->xreparent.parent;
-                XWindowAttributes wattr, pattr;
-
-                XGetWindowAttributes(dpy, w, &wattr);
-                XGetWindowAttributes(dpy, parent, &pattr);
-
-                DTRACE_PRINTLN5("TL:   window attr +%d+%d+%dx%d (%d)",
-                                wattr.x, wattr.y, wattr.width, wattr.height,
-                                wattr.border_width);
-                DTRACE_PRINTLN5("TL:   parent attr +%d+%d+%dx%d (%d)",
-                                pattr.x, pattr.y, pattr.width, pattr.height,
-                                pattr.border_width);
-
-                /*
-                 * Check for double-reparenting WM.
-                 *
-                 * If the parent is exactly the same size as the
-                 * top-level assume taht it's the "lining" window and
-                 * that the grandparent is the actual frame (NB: we
-                 * have already handled undecorated windows).
-                 *
-                 * XXX: what about timing issues that syncTopLevelPos
-                 * is supposed to work around?
-                 */
-                if (wattr.x == 0 && wattr.y == 0
-                    && wattr.width  + 2*wattr.border_width == pattr.width
-                    && wattr.height + 2*wattr.border_width == pattr.height)
-                {
-                    Window ignore_root, grandparent, *children;
-                    unsigned int ignore_nchildren;
-
-                    DTRACE_PRINTLN("TL:   double reparenting WM detected");
-                    XQueryTree(dpy, parent,
-                               &ignore_root,
-                               &grandparent,
-                               &children,
-                               &ignore_nchildren);
-                    if (children)
-                        XFree(children);
-
-                    /* take lining window into account */
-                    wattr.x = pattr.x;
-                    wattr.y = pattr.y;
-                    wattr.border_width += pattr.border_width;
-
-                    parent = grandparent;
-                    XGetWindowAttributes(dpy, parent, &pattr);
-                    DTRACE_PRINTLN5("TL:   window attr +%d+%d+%dx%d (%d)",
-                                    wattr.x, wattr.y,
-                                    wattr.width, wattr.height,
-                                    wattr.border_width);
-                    DTRACE_PRINTLN5("TL:   parent attr +%d+%d+%dx%d (%d)",
-                                    pattr.x, pattr.y,
-                                    pattr.width, pattr.height,
-                                    pattr.border_width);
-                }
-
-                /*
-                 * XXX: To be absolutely correct, we'd need to take
-                 * parent's border-width into account too, but the
-                 * rest of the code is happily unaware about border
-                 * widths and inner/outer distinction, so for the time
-                 * being, just ignore it.
-                 */
-                correctWMTop = wattr.y + wattr.border_width;
-                correctWMLeft = wattr.x + wattr.border_width;
-                correctWMBottom = pattr.height
-                    - (wattr.y + wattr.height + 2*wattr.border_width);
-                correctWMRight = pattr.width
-                    - (wattr.x + wattr.width + 2*wattr.border_width);
-                DTRACE_PRINTLN4("TL: insets = top %d, left %d, bottom %d, right %d",
-                                correctWMTop, correctWMLeft,
-                                correctWMBottom, correctWMRight);
-                break;
-            } /* default */
-
-            } /* switch (runningWM) */
-
-
-            /*
-             * Ok, now see if we need adjust window size because
-             * initial insets were wrong (most likely they were).
-             */
-            topCorrection    = correctWMTop    - wdata->topGuess;
-            leftCorrection   = correctWMLeft   - wdata->leftGuess;
-            bottomCorrection = correctWMBottom - wdata->bottomGuess;
-            rightCorrection  = correctWMRight  - wdata->rightGuess;
-
-            DTRACE_PRINTLN3("TL: top:    computed=%d, guess=%d, correction=%d",
-                correctWMTop, wdata->topGuess, topCorrection);
-            DTRACE_PRINTLN3("TL: left:   computed=%d, guess=%d, correction=%d",
-                correctWMLeft, wdata->leftGuess, leftCorrection);
-            DTRACE_PRINTLN3("TL: bottom: computed=%d, guess=%d, correction=%d",
-                correctWMBottom, wdata->bottomGuess, bottomCorrection);
-            DTRACE_PRINTLN3("TL: right:  computed=%d, guess=%d, correction=%d",
-                correctWMRight, wdata->rightGuess, rightCorrection);
-
-            if (topCorrection != 0 || leftCorrection != 0
-                || bottomCorrection != 0 || rightCorrection != 0)
-            {
-                jboolean isPacked;
-
-                DTRACE_PRINTLN("TL: insets need correction");
-                wdata->need_reshape = True;
-
-                globalTopGuess    = correctWMTop;
-                globalLeftGuess   = correctWMLeft;
-                globalBottomGuess = correctWMBottom;
-                globalRightGuess  = correctWMRight;
-
-                /* guesses are for WM decor *only* */
-                wdata->topGuess    = correctWMTop;
-                wdata->leftGuess   = correctWMLeft;
-                wdata->bottomGuess = correctWMBottom;
-                wdata->rightGuess  = correctWMRight;
-
-                /*
-                 * Actual insets account for menubar/warning label,
-                 * so we can't assign directly but must adjust them.
-                 */
-                wdata->top    += topCorrection;
-                wdata->left   += leftCorrection;
-                wdata->bottom += bottomCorrection;
-                wdata->right  += rightCorrection;
-
-                awtJNI_ChangeInsets(env, this, wdata);
-
-                /*
-                 * If this window has been sized by a pack() we need
-                 * to keep the interior geometry intact.  Since pack()
-                 * computed width and height with wrong insets, we
-                 * must adjust the target dimensions appropriately.
-                 */
-                isPacked = (*env)->GetBooleanField(env, target,
-                                                   componentIDs.isPacked);
-                if (isPacked) {
-                    int32_t correctTargetW;
-                    int32_t correctTargetH;
-
-                    DTRACE_PRINTLN("TL: window is packed, "
-                                   "adjusting size to preserve layout");
-
-                    correctTargetW = width + (leftCorrection + rightCorrection);
-                    correctTargetH = height +(topCorrection + bottomCorrection);
-
-                    (*env)->SetIntField(env, target, componentIDs.width,
-                                        (jint) correctTargetW);
-                    (*env)->SetIntField(env, target, componentIDs.height,
-                                        (jint) correctTargetH);
-                    /*
-                    **  Normally you only reconfigure the outerCanvas due to
-                    **  handling the ReconfigureNotify on the innerCanvas.
-                    **  However, in this case the innerCanvas may not have
-                    **  changed, but outterCanvas may still need to, since the
-                    **  insets have changed.
-                    */
-                    reshape(env, this, wdata, x, y,
-                            correctTargetW, correctTargetH, setXY);
-                    reconfigureOuterCanvas(env, target, this, wdata);
-                } else {
-                    reshape(env, this, wdata, x, y, width, height, setXY);
-                    JNU_CallMethodByName(env, NULL, this,
-                        "handleResize", "(II)V", width, height);
-                }
-            }
-/* NEW for dialog */ /* XXX: what this comment is supposed to mean? */
-            else {
-                wdata->need_reshape = False;
-                /* fix for 4976337 - son@sparc.spb.su */
-                /* we should find better fix later if needed */
-                if (wdata->isResizable || !wdata->isFixedSizeSet) {
-                    reshape(env, this, wdata, x, y, width, height, setXY);
-                }
-            }
-        }
-        (*env)->DeleteLocalRef(env, target);
-        break;
-    } /* ReparentNotify */
-
-    case ConfigureNotify: {
-        DTRACE_PRINTLN2("TL: ConfigureNotify(0x%x/0x%x)",
-                        wdata->winData.shell, XtWindow(wdata->winData.shell));
-
-        /*
-         * Some window managers configure before we are reparented and
-         * the send event flag is set! ugh... (Enlighetenment for one,
-         * possibly MWM as well).  If we haven't been reparented yet
-         * this is just the WM shuffling us into position.  Ignore
-         * it!!!! or we wind up in a bogus location.
-         */
-        runningWM = awt_wm_getRunningWM();
-        if (!wdata->reparented && wdata->isShowing &&
-            runningWM != NO_WM && wdata->decor != AWT_NO_DECOR) {
-            break;
-        }
-
-        /*
-         * Notice that we have seen a ConfigureNotify after being
-         * reparented.  We should really check for it being a
-         * synthetic event, but metacity doesn't send one.
-         */
-        if (wdata->reparented)
-            wdata->configure_seen = 1;
-
-        if ((*env)->EnsureLocalCapacity(env, 1) < 0) {
-            break;
-        }
-        target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-        /*
-         * We can detect the difference between a move and a resize by
-         * checking the send_event flag on the event; if it's true,
-         * then it's indeed a move, if it's false, then this is a
-         * resize and we do not want to process it as a "move" (for
-         * resizes the x,y values are misleadingly set to 0,0 and so
-         * just checking for an x,y delta won't work).
-         */
-
-        getTargetX = (*env)->GetIntField(env, target, componentIDs.x);
-        getTargetY = (*env)->GetIntField(env, target, componentIDs.y);
-
-        DTRACE_PRINTLN2("TL:   target thinks (%d, %d)",
-                        getTargetX, getTargetY);
-        DTRACE_PRINTLN3("TL:   event is (%d, %d)%s",
-                        event->xconfigure.x, event->xconfigure.y,
-                        (event->xconfigure.send_event ? " synthetic" : ""));
-
-        /*
-         * N.B. The wdata top offset is the offset from the outside of
-         * the entire (bordered window) to the inner/parent drawing
-         * area (canvas), NOT to the shell.  Thus, if a menubar is
-         * present and/or a warning window at the top (not NETSCAPE),
-         * the top offset will also include space for these.  In order
-         * to position the abstract java window relative to the shell,
-         * we must add back in the appropriate space for these when we
-         * subtract off the wdata top field.
-         */
-#ifdef NETSCAPE
-        wwHeight = 0;
-#else /* NETSCAPE */
-        if (wdata->warningWindow != NULL)
-            wwHeight = wdata->wwHeight;
-        else
-            wwHeight = 0;
-#endif /* NETSCAPE */
-        topAdjust = wdata->mbHeight + wwHeight;
-
-        /*
-         * Coordinates in Component.setLocation() are treated as the
-         * upper-left corner of the outer shell.  The x and y in the
-         * ConfigureNotify event, however, are the upper-left corner
-         * of the inset CLIENT window.  Therefore, the coordinates
-         * from the event are massaged using the inset values in order
-         * to determine if the top-level shell has moved.  In the
-         * event of a user- generated move event (i.e. dragging the
-         * window itself), these coordinates are written back into the
-         * Window object.
-         *
-         * Neat X/CDE/Native bug:
-         * If an attempt is made to move the shell in the y direction
-         * by an amount equal to the top inset, the Window isn't
-         * moved.  This can be seen here by examining event->xconfigure.y
-         * before and after such a request is made: the value remains
-         * unchanged.  This wrecks a little havoc here, as the x and y
-         * in the Component have already been set to the new location
-         * (in Component.reshape()), but the Window doesn't end up in
-         * the new location.  What's more, if a second request is
-         * made, the window will be relocated by TWICE the requested
-         * amount, sort of "catching up" it would seem.
-         *
-         * For a test case of this, see bug 4234645.
-         */
-        setTargetX = event->xconfigure.x - wdata->left;
-        setTargetY = event->xconfigure.y - wdata->top + topAdjust;
-
-        width = (*env)->GetIntField(env, target, componentIDs.width);
-        height = (*env)->GetIntField(env, target, componentIDs.height);
-        checkNewXineramaScreen(env, this, wdata, setTargetX, setTargetY,
-                               width, height);
-
-        if ((getTargetX != setTargetX || getTargetY != setTargetY)
-            && (event->xconfigure.send_event || runningWM == NO_WM))
-        {
-            (*env)->SetIntField(env, target, componentIDs.x, (jint)setTargetX);
-            (*env)->SetIntField(env, target, componentIDs.y, (jint)setTargetY);
-#ifdef _pauly_debug
-            fprintf(stdout, " ++ shell move. Xevent x,y: %d, %d.\n",
-                    event->xconfigure.x, event->xconfigure.y);
-            fprintf(stdout, "    shell move. left: %d, top: %d, but offset: %d\n", wdata->left, wdata->top, topAdjust);
-            fprintf(stdout,"    shell move. target x: %d, target y: %d\n", setTargetX, setTargetY);
-            fprintf(stdout,"    shell move. ww height: %d\n", wwHeight);
-            fflush(stdout);
-#endif /* _pauly_debug */
-
-            DTRACE_PRINTLN2("TL:   handleMoved(%d, %d)",
-                            setTargetX, setTargetY);
-            JNU_CallMethodByName(env, NULL,
-                                 this, "handleMoved", "(II)V",
-                                 setTargetX, setTargetY);
-            if ((*env)->ExceptionOccurred(env)) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-            }
-        }
-        else if (event->xconfigure.send_event == False) {
-#ifdef _pauly_debug
-            fprintf(stdout,
-                    " ++ shell resize. Xevent x,y,w,h: %d, %d, %d, %d.\n",
-                    event->xconfigure.x, event->xconfigure.y,
-                    event->xconfigure.width, event->xconfigure.height);
-            fflush(stdout);
-#endif /* _pauly_debug */
-
-            wdata->shellResized = True;
-        }
-
-
-        (*env)->DeleteLocalRef(env, target);
-        raiseInputMethodWindow(wdata);
-#ifdef __linux__
-        adjustStatusWindow(wdata->winData.shell);
-#endif
-        break;
-    } /* ConfigureNotify */
-
-    default:
-        break;
-    }
-}
-
-
-static void
-Frame_quit(Widget w,
-           XtPointer client_data,
-           XtPointer call_data)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-    JNU_CallMethodByName(env, NULL, (jobject) client_data, "handleQuit", "()V");
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-
-static void
-setDeleteCallback(jobject this, struct FrameData *wdata)
-{
-    Atom xa_WM_DELETE_WINDOW;
-    Atom xa_WM_TAKE_FOCUS;
-    Atom xa_WM_PROTOCOLS;
-
-    XtVaSetValues(wdata->winData.shell,
-                  XmNdeleteResponse, XmDO_NOTHING,
-                  NULL);
-    xa_WM_DELETE_WINDOW = XmInternAtom(XtDisplay(wdata->winData.shell),
-                                       "WM_DELETE_WINDOW", False);
-    xa_WM_TAKE_FOCUS = XmInternAtom(XtDisplay(wdata->winData.shell),
-                                    "WM_TAKE_FOCUS", False);
-    xa_WM_PROTOCOLS = XmInternAtom(XtDisplay(wdata->winData.shell),
-                                   "WM_PROTOCOLS", False);
-
-    XmAddProtocolCallback(wdata->winData.shell,
-                          xa_WM_PROTOCOLS,
-                          xa_WM_DELETE_WINDOW,
-                          Frame_quit, (XtPointer) this);
-}
-
-
-extern AwtGraphicsConfigDataPtr
-copyGraphicsConfigToPeer(JNIEnv *env, jobject this);
-
-extern AwtGraphicsConfigDataPtr
-getGraphicsConfigFromComponentPeer(JNIEnv *env, jobject this);
-
-// Returns true if this shell has some transient shell chidlren
-// which are either Dialogs or Windows.
-// Returns false otherwise.
-Boolean hasTransientChildren(Widget shell) {
-    int childIndex;
-
-    // Enumerate through the popups
-    for (childIndex = 0; childIndex < shell->core.num_popups; childIndex++) {
-        Widget childShell = shell->core.popup_list[childIndex];
-        // Find all transient shell which are either Dialog or Window
-        if (XtIsTransientShell(childShell)) {
-            Widget toplevel = findTopLevelByShell(childShell);
-            if (toplevel != NULL) {
-                // It is Dialog or Window - return true.
-                return True;
-            }
-        }
-    }
-    return False;
-}
-
-extern Widget grabbed_widget;
-/**
- * Disposes top-level component and its widgets
- */
-static
-void disposeTopLevel(JNIEnv * env, jobject this) {
-
-    struct FrameData *wdata;
-    Widget parentShell;
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL || wdata->mainWindow == NULL
-        || wdata->winData.shell == NULL)
-    {
-        /* do nothing */
-        return;
-    }
-
-    // Save parent shell for later disposal.
-    parentShell = XtParent(wdata->winData.shell);
-
-    removeTopLevel(wdata);
-    if (wdata->isInputMethodWindow) {
-        removeInputMethodWindow(wdata);
-    }
-
-    XtRemoveEventHandler(wdata->focusProxy, FocusChangeMask,
-                         False, shellEH, this);
-    XtUnmanageChild(wdata->focusProxy);
-    awt_util_consumeAllXEvents(wdata->focusProxy);
-    awt_util_cleanupBeforeDestroyWidget(wdata->focusProxy);
-    XtDestroyWidget(wdata->focusProxy);
-
-    XtUnmanageChild(wdata->winData.comp.widget);
-    awt_delWidget(wdata->winData.comp.widget);
-    awt_util_consumeAllXEvents(wdata->winData.comp.widget);
-    awt_util_cleanupBeforeDestroyWidget(wdata->winData.comp.widget);
-    XtDestroyWidget(wdata->winData.comp.widget);
-
-    XtUnmanageChild(wdata->mainWindow);
-    awt_util_consumeAllXEvents(wdata->mainWindow);
-    awt_util_consumeAllXEvents(wdata->winData.shell);
-    XtDestroyWidget(wdata->mainWindow);
-    XtDestroyWidget(wdata->winData.shell);
-    if (wdata->iconPixmap) {
-        XFreePixmap(awt_display, wdata->iconPixmap);
-    }
-
-    if (grabbed_widget == wdata->winData.shell) {
-        XUngrabPointer(awt_display, CurrentTime);
-        XUngrabKeyboard(awt_display, CurrentTime);
-        grabbed_widget = NULL;
-    }
-
-    free((void *) wdata);
-
-    (*env)->SetLongField(env, this, mComponentPeerIDs.pData, 0);
-    awtJNI_DeleteGlobalRef(env, this);
-
-    // Check if parent shell was scheduled for disposal.
-    // If it doesn't have window then we have to dispose it
-    // by ourselves right now.
-    // We can dispose shell only if it doesn't have "transient" children.
-    {
-        struct FrameData *pdata;
-        struct WidgetInfo* winfo;
-        Widget toplevel = findTopLevelByShell(parentShell);
-        if (toplevel == NULL) {
-            // Has already been deleted or it is top shell
-            return;
-        }
-        winfo = findWidgetInfo(toplevel);
-        DASSERT(winfo != NULL);
-        if (winfo == NULL) {
-            // Huh - has already been deleted?
-            return;
-        }
-        pdata = (struct FrameData *)
-            JNU_GetLongFieldAsPtr(env, winfo->peer, mComponentPeerIDs.pData);
-        DASSERT(pdata != NULL);
-        if (pdata == NULL) {
-            // Huh - has already been deleted?
-            return;
-        }
-        // 1) scheduled 2) no children 3) no window
-        if (pdata->isDisposeScheduled
-            && !hasTransientChildren(parentShell)
-            && XtWindow(parentShell) == None)
-        {
-            disposeTopLevel(env, winfo->peer);
-        }
-    }
-}
-
-
-/**
- * Property change listener. Listens to _XA_JAVA_DISPOSE_PROPERTY_ATOM,
- * disposes the top-level when this property has been changed.
- */
-static void
-shellDisposeNotifyHandler(Widget w, XtPointer client_data,
-                           XEvent* event, Boolean* continue_to_dispatch) {
-    struct FrameData *wdata;
-
-    *continue_to_dispatch = True;
-
-    if (event->type == PropertyNotify &&
-        event->xproperty.atom == _XA_JAVA_DISPOSE_PROPERTY_ATOM)
-    {
-        JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-        wdata = (struct FrameData *)
-            JNU_GetLongFieldAsPtr(env, (jobject)client_data,
-                                  mComponentPeerIDs.pData);
-        if (wdata != NULL && wdata->isDisposeScheduled) {
-            disposeTopLevel(env, (jobject)client_data);
-
-            // We've disposed top-level, no more actions on it
-            *continue_to_dispatch = False;
-        }
-    }
-}
-
-/**
- * Schedules top-level for later dispose - when all events
- * on it will be processed.
- */
-static
-void scheduleDispose(JNIEnv * env, jobject peer) {
-
-    struct FrameData *wdata;
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, peer, mComponentPeerIDs.pData);
-
-    if (wdata->isDisposeScheduled) {
-        return;
-    }
-
-    wdata->isDisposeScheduled = True;
-    if (XtWindow(wdata->winData.shell) != None) {
-        XChangeProperty(awt_display, XtWindow(wdata->winData.shell),
-                        _XA_JAVA_DISPOSE_PROPERTY_ATOM, XA_ATOM, 32, PropModeAppend,
-                        (unsigned char *)"", 0);
-        XFlush(awt_display);
-        XSync(awt_display, False);
-    } else {
-        // If this top-level has children which are still visible then
-        // their disposal could have been scheduled. We shouldn't allow this widget
-// to destroy its children top-levels. For this purpose we postpone the disposal
-        // of this toplevel until after all its children are disposed.
-        if (!hasTransientChildren(wdata->winData.shell)) {
-            disposeTopLevel(env, peer);
-        }
-    }
-}
-
-
-/* sun_awt_motif_MWindowPeer_pCreate() is native (X/Motif) create routine */
-static char* focusProxyName = "FocusProxy";
-
-Widget createFocusProxy(jobject globalRef, Widget parent) {
-    Widget proxy;
-#define MAX_ARGC 20
-    Arg args[MAX_ARGC];
-    int32_t argc;
-
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-    if (parent == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return NULL;
-    }
-    argc = 0;
-    XtSetArg(args[argc], XmNwidth, 1);
-    argc++;
-    XtSetArg(args[argc], XmNheight, 1);
-    argc++;
-    XtSetArg(args[argc], XmNx, -1);
-    argc++;
-    XtSetArg(args[argc], XmNy, -1);
-    argc++;
-    XtSetArg(args[argc], XmNmarginWidth, 0);
-    argc++;
-    XtSetArg(args[argc], XmNmarginHeight, 0);
-    argc++;
-    XtSetArg(args[argc], XmNspacing, 0);
-    argc++;
-    XtSetArg(args[argc], XmNresizePolicy, XmRESIZE_NONE);
-    argc++;
-
-    DASSERT(!(argc > MAX_ARGC));
-    proxy = XmCreateDrawingArea(parent, focusProxyName, args, argc);
-    XtAddEventHandler(proxy,
-                      FocusChangeMask,
-                      False, shellEH, globalRef);
-    XtManageChild(proxy);
-#undef MAX_ARGC
-    return proxy;
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    pCreate
- * Signature: (Lsun/awt/motif/MComponentPeer;Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowPeer_pCreate(JNIEnv *env, jobject this,
-    jobject parent, jstring target_class_name, jboolean isFocusableWindow)
-{
-#define MAX_ARGC 50
-    Arg                 args[MAX_ARGC];
-    int32_t             argc;
-    struct FrameData    *wdata;
-    struct FrameData    *pdata = NULL;
-    char                *shell_name = NULL;
-    WidgetClass         shell_class;
-    Widget              parent_widget;
-    jobject             target;
-    jobject             insets;
-    jobject             winAttr;
-    jstring             warningString;
-    jboolean            resizable;
-    jboolean            isModal;
-    jboolean            initialFocus;
-    jint                state;
-    jclass              clazz;
-    jobject             globalRef = awtJNI_CreateAndSetGlobalRef(env, this);
-
-    uint32_t            runningWM;      /* the running Window Manager   */
-    Widget              innerCanvasW;   /* form's child, parent of the
-                                           outer canvas (drawing area)  */
-    Position            x,y;
-    Dimension           w,h;
-    AwtGraphicsConfigDataPtr adata;
-    AwtGraphicsConfigDataPtr defConfig;
-    jobject gd = NULL;
-    jobject gc = NULL;
-    char *cname = NULL;
-    jstring jname;
-
-    AWT_LOCK();
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    if (JNU_IsNull(env, target)) {
-        JNU_ThrowNullPointerException(env, "null target");
-        AWT_UNLOCK();
-        return;
-    }
-
-    wdata = ZALLOC(FrameData);
-    JNU_SetLongFieldFromPtr(env, this, mComponentPeerIDs.pData, wdata);
-    if (wdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-
-    adata = copyGraphicsConfigToPeer(env, this);
-    defConfig = getDefaultConfig(adata->awt_visInfo.screen);
-
-
-    /* Retrieve the specified characteristics for this window */
-    winAttr = (*env)->GetObjectField(env, this, mWindowPeerIDs.winAttr);
-    resizable = (*env)->GetBooleanField( env,
-                                         winAttr,
-                                         mWindowAttributeIDs.isResizable);
-    state = (*env)->GetIntField( env,
-                                 winAttr,
-                                 mWindowAttributeIDs.initialState);
-    initialFocus = (*env)->GetBooleanField( env,
-                                            winAttr,
-                                            mWindowAttributeIDs.initialFocus);
-
-    /* As of today decor is either on or off... except the InputMethodWindow */
-    if ((*env)->GetBooleanField(env, winAttr, mWindowAttributeIDs.nativeDecor)) {
-        wdata->decor = (*env)->GetIntField(env, winAttr, mWindowAttributeIDs.decorations);
-    } else {
-        wdata->decor = AWT_NO_DECOR;
-    }
-
-    insets = (*env)->GetObjectField(env, this, mWindowPeerIDs.insets);
-
-    /* The insets will be corrected upon the reparent
-           event in shellEH().  For now, use bogus values.      */
-    wdata->top = (*env)->GetIntField(env, insets, insetsIDs.top);
-    wdata->left = (*env)->GetIntField(env, insets, insetsIDs.left);
-    wdata->bottom = (*env)->GetIntField(env, insets, insetsIDs.bottom);
-    wdata->right = (*env)->GetIntField(env, insets, insetsIDs.right);
-    awt_Frame_guessInsets(wdata);
-    awtJNI_ChangeInsets(env, this, wdata);
-    wdata->reparented = False;
-    wdata->configure_seen = False;
-    x = (*env)->GetIntField(env, target, componentIDs.x) + wdata->left;
-    y = (*env)->GetIntField(env, target, componentIDs.y) + wdata->top;
-
-    w = (*env)->GetIntField(env, target, componentIDs.width)
-        - (wdata->left + wdata->right);
-    h = (*env)->GetIntField(env, target, componentIDs.height)
-        - (wdata->top + wdata->bottom);
-    if (w < 0) w = 0;
-    if (h < 0) h = 0;
-
-    DTRACE_PRINTLN1("TL: pCreate: state = 0x%X", state);
-
-    wdata->isModal = 0;
-    wdata->initialFocus = (Boolean)initialFocus;
-    wdata->isShowing = False;
-    wdata->shellResized = False;
-    wdata->canvasResized = False;
-    wdata->menuBarReset = False;
-    wdata->need_reshape = False;
-    wdata->focusProxy = NULL;
-#ifdef __linux__
-    wdata->fixInsets = True;
-#endif
-    wdata->state = state;
-
-    /* initialize screen to screen number in GraphicsConfig's device */
-    /* can the Window's GC ever be null? */
-    gc =  (*env)->GetObjectField(env, target, componentIDs.graphicsConfig);
-    DASSERT(gc);
-
-    gd =  (*env)->GetObjectField(env, gc, x11GraphicsConfigIDs.screen);
-    DASSERT(gd);
-
-    wdata->screenNum = (*env)->GetIntField(env, gd, x11GraphicsDeviceIDs.screen);
-
-    wdata->isFocusableWindow = (Boolean)isFocusableWindow;
-
-    /*
-     * Create a top-level shell widget.
-     */
-    argc = 0;
-    XtSetArg(args[argc], XmNsaveUnder, False); argc++;
-    if (resizable) {
-        XtSetArg(args[argc], XmNallowShellResize, True); argc++;
-    } else {
-        XtSetArg(args[argc], XmNallowShellResize, False); argc++;
-    }
-    XtSetArg(args[argc], XmNvisual, defConfig->awt_visInfo.visual); argc++;
-    XtSetArg(args[argc], XmNcolormap, defConfig->awt_cmap); argc++;
-    XtSetArg(args[argc], XmNdepth, defConfig->awt_depth); argc++;
-    XtSetArg(args[argc], XmNmappedWhenManaged, False); argc++;
-    XtSetArg(args[argc], XmNx, x); argc++;
-    XtSetArg(args[argc], XmNy, y); argc++;
-    XtSetArg(args[argc], XmNwidth, w); argc++;
-    XtSetArg(args[argc], XmNheight, h); argc++;
-
-    XtSetArg(args[argc], XmNbuttonFontList, getMotifFontList()); argc++;
-    XtSetArg(args[argc], XmNlabelFontList, getMotifFontList()); argc++;
-    XtSetArg(args[argc], XmNtextFontList, getMotifFontList()); argc++;
-
-    XtSetArg(args[argc], XmNmwmDecorations, wdata->decor); argc++;
-    XtSetArg(args[argc], XmNscreen,
-             ScreenOfDisplay(awt_display, defConfig->awt_visInfo.screen)); argc++;
-
-    if (wdata->initialFocus == False || !isFocusableWindowByPeer(env, this)) {
-        XtSetArg(args[argc], XmNinput, False); argc++;
-    }
-
-    if (wdata->decor == AWT_NO_DECOR) {
-        /* this is heinous but it can not be avoided for now.
-         ** this is the only known way to eliminate all decorations
-         ** for openlook, which btw, is a bug as ol theoretically
-         ** supports MWM_HINTS
-         */
-#ifndef DO_FULL_DECOR
-        if (awt_wm_getRunningWM() == OPENLOOK_WM) {
-            XtSetArg(args[argc], XmNoverrideRedirect, True);
-            argc++;
-        }
-#endif
-    }
-
-    /* 4334958: Widget name is set to the Java class name */
-    shell_name =
-        (char *)JNU_GetStringPlatformChars(env, target_class_name, NULL);
-
-    if (parent) {
-        pdata = (struct FrameData *)
-            (*env)->GetLongField(env, parent, mComponentPeerIDs.pData);
-    }
-
-    /* Parenting tells us whether we wish to be transient or not */
-    if (pdata == NULL) {
-        if (!shell_name)
-            shell_name = "AWTapp";
-        shell_class =  topLevelShellWidgetClass;
-        parent_widget = awt_root_shell;
-    }
-    else {
-        if (!shell_name)
-            shell_name = "AWTdialog";
-        shell_class = transientShellWidgetClass;
-        parent_widget = pdata->winData.shell;
-        XtSetArg(args[argc], XmNtransient, True); argc++;
-        XtSetArg(args[argc], XmNtransientFor, parent_widget); argc++;
-
-        /* Fix Forte Menu Bug. If Window name is "###overrideRedirect###",
-         * then set XmNoverrideRedirect to prevent Menus from getting focus.
-         * In JDK 1.2.2 we created Windows as xmMenuShellWidgetClass,
-         * so we did not need to do this. Swing DefaultPopupFactory's
-         * createHeavyWeightPopup sets Window name to "###overrideRedirect###".
-        */
-        /**
-         * Fix for 4476629. Allow Swing to create heavyweight popups which will
-         * not steal focus from Frame.
-         */
-        jname = (*env)->GetObjectField(env, target, componentIDs.name);
-        if (!JNU_IsNull(env, jname)) {
-          cname = (char *)JNU_GetStringPlatformChars(env, jname, NULL);
-        }
-        if ( (cname != NULL && strcmp(cname, "###overrideRedirect###") == 0)
-            || (!isFrameOrDialog(target, env)
-                && !isFocusableWindowByPeer(env, this)
-                )
-            )
-        {    /* mbron */
-            XtSetArg(args[argc], XmNoverrideRedirect, True);
-            argc++;
-        }
-        if (cname) {
-            JNU_ReleaseStringPlatformChars(env, jname, (const char *) cname);
-        }
-        (*env)->DeleteLocalRef(env, jname);
-    }
-    DASSERT(!(argc > MAX_ARGC));
-    wdata->winData.shell = XtCreatePopupShell(shell_name, shell_class,
-                                              parent_widget, args, argc);
-    if (shell_name) {
-        JNU_ReleaseStringPlatformChars(env, target_class_name, shell_name);
-    }
-
-#ifdef DEBUG
-    /* Participate in EditRes protocol to facilitate debugging */
-    XtAddEventHandler(wdata->winData.shell, (EventMask)0, True,
-                      _XEditResCheckMessages, NULL);
-#endif
-
-    setDeleteCallback(globalRef, wdata);
-
-    /* Establish resizability.  For the case of not resizable, do not
-       yet set a fixed size here; we must wait until in the routine
-       sun_awt_motif_MWindowPeer_pReshape() after insets have been fixed.
-       This is because correction of the insets may affect shell size.
-       (See comments in shellEH() concerning correction of the insets.  */
-    /*
-     * Fix for BugTraq ID 4313607.
-     * Initial resizability will be set later in MWindowPeer_setResizable()
-     * called from init().
-     */
-    wdata->isResizable = True;
-    wdata->isFixedSizeSet = False;
-
-    XtAddEventHandler(wdata->winData.shell,
-                      (StructureNotifyMask | PropertyChangeMask
-                       | VisibilityChangeMask),
-                      False, shellEH, globalRef);
-
-    XtAddEventHandler(wdata->winData.shell,
-                      FocusChangeMask,
-                      False, shellFocusEH, globalRef);
-
-
-    /**
-     * Installing property change handler for DISPOSE property.
-     * This property will be changed when we need to dispose the whole
-     * top-level. The nature of PropertyNotify will guarantee that it is
-     * the latest event on the top-level so we can freely dispose it.
-     */
-    wdata->isDisposeScheduled = False;
-    if (_XA_JAVA_DISPOSE_PROPERTY_ATOM == 0) {
-        _XA_JAVA_DISPOSE_PROPERTY_ATOM = XInternAtom(awt_display, "_SUNW_JAVA_AWT_DISPOSE", False);
-    }
-    XtAddEventHandler(wdata->winData.shell, PropertyChangeMask, False,
-                      shellDisposeNotifyHandler, globalRef);
-
-    /*
-     * Create "main" form.
-     */
-    argc = 0;
-    XtSetArg(args[argc], XmNmarginWidth, 0); argc++;
-    XtSetArg(args[argc], XmNmarginHeight, 0); argc++;
-    XtSetArg(args[argc], XmNhorizontalSpacing, 0); argc++;
-    XtSetArg(args[argc], XmNverticalSpacing, 0); argc++;
-    XtSetArg(args[argc], XmNresizePolicy, XmRESIZE_NONE); argc++;
-
-    XtSetArg(args[argc], XmNbuttonFontList, getMotifFontList()); argc++;
-    XtSetArg(args[argc], XmNlabelFontList, getMotifFontList()); argc++;
-    XtSetArg(args[argc], XmNtextFontList, getMotifFontList()); argc++;
-
-    DASSERT(!(argc > MAX_ARGC));
-    wdata->mainWindow = XmCreateForm(wdata->winData.shell, "main", args, argc);
-
-    /* The widget returned by awt_canvas_create is a drawing area
-       (i.e., canvas) which is the child of another drawing area
-       parent widget.  The parent is the drawing area within the
-       form just created.  The child is an drawing area layer over
-       the entire frame window, including the form, any menu bar
-       and warning windows present, and also window manager stuff.
-       The top, bottom, left, and right fields in wdata maintain
-       the respective offsets between these two drawing areas.  */
-
-    wdata->winData.comp.widget = awt_canvas_create((XtPointer)globalRef,
-                                                   wdata->mainWindow,
-                                                   "frame_",
-                                                   -1,
-                                                   -1,
-                                                   True,
-                                                   wdata,
-                                                   adata);
-    XtAddCallback(wdata->winData.comp.widget,
-                  XmNresizeCallback, outerCanvasResizeCB,
-                  globalRef);
-
-    innerCanvasW = XtParent(wdata->winData.comp.widget);
-    XtVaSetValues(innerCanvasW,
-                  XmNleftAttachment, XmATTACH_FORM,
-                  XmNrightAttachment, XmATTACH_FORM,
-                  NULL);
-
-    XtAddEventHandler(innerCanvasW, StructureNotifyMask, FALSE,
-                      innerCanvasEH, globalRef);
-
-    wdata->focusProxy = createFocusProxy((XtPointer)globalRef,
-                                         wdata->mainWindow);
-
-    /* No menu bar initially */
-    wdata->menuBar = NULL;
-    wdata->mbHeight = 0;
-
-    /* If a warning window (string) is needed, establish it now.*/
-    warningString =
-        (*env)->GetObjectField(env, target, windowIDs.warningString);
-    if (!JNU_IsNull(env, warningString) ) {
-        char *wString;
-        /* Insert a warning window. It's height can't be set yet;
-           it will later be set in setMbAndWwHeightAndOffsets().*/
-        wString = (char *) JNU_GetStringPlatformChars(env, warningString, NULL);
-        wdata->warningWindow = awt_util_createWarningWindow(wdata->mainWindow, wString);
-        JNU_ReleaseStringPlatformChars(env, warningString, (const char *) wString);
-
-        wdata->wwHeight = 0;
-        XtVaSetValues(wdata->warningWindow,
-                      XmNleftAttachment, XmATTACH_FORM,
-                      XmNrightAttachment, XmATTACH_FORM,
-                      NULL);
-
-#ifdef NETSCAPE
-        /* For NETSCAPE, warning window is at bottom of the form*/
-        XtVaSetValues(innerCanvasW,
-                      XmNtopAttachment, XmATTACH_FORM,
-                      NULL);
-        XtVaSetValues(wdata->warningWindow,
-                      XmNtopAttachment, XmATTACH_WIDGET,
-                      XmNtopWidget, innerCanvasW,
-                      XmNbottomAttachment, XmATTACH_FORM,
-                      NULL);
-#else  /* NETSCAPE */
-        /* Otherwise (not NETSCAPE), warning is at top of form  */
-        XtVaSetValues(wdata->warningWindow,
-                      XmNtopAttachment, XmATTACH_FORM,
-                      NULL);
-        XtVaSetValues(innerCanvasW,
-                      XmNtopAttachment, XmATTACH_WIDGET,
-                      XmNtopWidget, wdata->warningWindow,
-                      XmNbottomAttachment, XmATTACH_FORM,
-                      NULL);
-#endif /* NETSCAPE */
-
-    } else {
-        /* No warning window present */
-        XtVaSetValues(innerCanvasW,
-                      XmNtopAttachment, XmATTACH_FORM,
-                      XmNbottomAttachment, XmATTACH_FORM,
-                      NULL);
-        wdata->warningWindow = NULL;
-        wdata->wwHeight = 0;
-    }
-
-    awt_util_show(wdata->winData.comp.widget);
-
-    AWT_FLUSH_UNLOCK();
-
-    addTopLevel(wdata);
-
-    /* Check whether this is an instance of InputMethodWindow or not */
-    if (inputMethodWindowClass == NULL) {
-        jclass localClass = (*env)->FindClass(env, "sun/awt/im/InputMethodWindow");
-        inputMethodWindowClass = (jclass)(*env)->NewGlobalRef(env, localClass);
-        (*env)->DeleteLocalRef(env, localClass);
-    }
-    if ((*env)->IsInstanceOf(env, target, inputMethodWindowClass)) {
-        wdata->isInputMethodWindow = True;
-        addInputMethodWindow(wdata);
-    }
-} /* MWindowPeer_pCreate() */
-
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    pSetTitle
- * Signature: (Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowPeer_pSetTitle(JNIEnv *env, jobject this,
-    jstring title)
-{
-    char *ctitle;
-    char *empty_string = " ";
-    struct FrameData *wdata;
-    XTextProperty text_prop;
-    char *c[1];
-    int32_t conv_result;
-
-    AWT_LOCK();
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL || wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "null wdata or shell");
-        AWT_UNLOCK();
-        return;
-    }
-
-    /* TODO: uwe: set _NET_WM_NAME property to utf-8 name */
-
-    ctitle = (JNU_IsNull(env, title)) ? empty_string
-        : (char *) JNU_GetStringPlatformChars(env, title, NULL);
-
-    if (strcmp(ctitle, "") == 0)
-        ctitle = empty_string;
-
-    c[0] = ctitle;
-
-    /* need to convert ctitle to CompoundText */
-    conv_result = XmbTextListToTextProperty(awt_display, c, 1,
-                                            XStdICCTextStyle,
-                                            &text_prop);
-
-    /*
-     * XmbTextListToTextProperty returns value that is greater
-     * than Success if the supplied text is not fully convertible
-     * to specified encoding. In this case, the return value is
-     * the number of inconvertible characters. But convertibility
-     * is guaranteed for XCompoundTextStyle, so it will actually
-     * never be greater than Success. Errors handled below are
-     * represented by values that are lower than Success.
-     */
-    if (conv_result >= Success) {
-        XtVaSetValues(wdata->winData.shell,
-                  XmNtitle, text_prop.value,
-                  XmNtitleEncoding, text_prop.encoding,
-                  XmNiconName, text_prop.value,
-                  XmNiconNameEncoding, text_prop.encoding,
-                  XmNname, ctitle,
-                  NULL);
-    }
-
-    if (ctitle != empty_string)
-        JNU_ReleaseStringPlatformChars(env, title, (const char *) ctitle);
-
-    if (conv_result == XNoMemory) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-    if (conv_result == XLocaleNotSupported) {
-        JNU_ThrowInternalError(env, "Current locale is not supported");
-        AWT_UNLOCK();
-        return;
-    }
-
-    XFree(text_prop.value);
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    pToFront
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowPeer_pToFront(JNIEnv *env, jobject this)
-{
-    struct FrameData *wdata;
-    jobject target;
-    Window shellWindow;
-    Boolean autoRequestFocus;
-    Boolean isModal = FALSE;
-
-    AWT_LOCK();
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL
-        || wdata->winData.comp.widget == NULL
-        || wdata->winData.shell == NULL
-        || wdata->mainWindow == NULL
-        || JNU_IsNull(env, target))
-    {
-        JNU_ThrowNullPointerException(env, "null widget/target data");
-        AWT_UNLOCK();
-        return;
-    }
-
-    if ((shellWindow = XtWindow(wdata->winData.shell)) != None) {
-        XRaiseWindow(awt_display, shellWindow);
-
-        autoRequestFocus = (*env)->GetBooleanField(env, target, windowIDs.isAutoRequestFocus);
-
-        if (isDialog(target, env)) {
-            isModal = (*env)->GetBooleanField(env, target, dialogIDs.modal);
-        }
-
-        // In contrast to XToolkit/WToolkit modal dialog can be unfocused.
-        // So we should also ask for modality in addition to 'autoRequestFocus'.
-        if (wdata->isFocusableWindow && (autoRequestFocus || isModal)) {
-            XSetInputFocus(awt_display, XtWindow(wdata->focusProxy), RevertToPointerRoot, CurrentTime);
-        }
-    }
-
-   (*env)->DeleteLocalRef(env, target);
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    pShow
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowPeer_pShow(JNIEnv *env, jobject this)
-{
-    Java_sun_awt_motif_MWindowPeer_pShowModal(env, this, JNI_FALSE);
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    pShowModal
- * Signature: (Z)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowPeer_pShowModal(JNIEnv *env, jobject this,
-    jboolean isModal)
-{
-    struct FrameData *wdata;
-    Boolean iconic;
-    jobject target;
-    Boolean locationByPlatform;
-
-    AWT_LOCK();
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL
-        || wdata->winData.comp.widget == NULL
-        || wdata->winData.shell == NULL
-        || wdata->mainWindow == NULL
-        || (wdata->winData.flags & W_IS_EMBEDDED)
-        || JNU_IsNull(env, target))
-    {
-        JNU_ThrowNullPointerException(env, "null widget/target data");
-        AWT_UNLOCK();
-        return;
-    }
-
-    DTRACE_PRINTLN2("TL: pShowModal(modal = %s) state = 0x%X",
-                    isModal ? "true" : "false",
-                    wdata->state);
-
-    wdata->isModal = isModal;
-
-    /*
-     * A workaround for bug 4062589 that is really a motif problem
-     * (see bug 4064803).  Before popping up a modal dialog, if a
-     * pulldown menu has the input focus (i.e. user has pulled the
-     * menu down), we send a fake click event and make sure the click
-     * event is processed.  With this simulation of user clicking, X
-     * server will not get confused about the modality and a
-     * subsequent click on the popup modal dialog will not cause
-     * system lockup.
-     */
-    if (wdata->isModal && awt_util_focusIsOnMenu(awt_display)
-        && awt_util_sendButtonClick(awt_display, InputFocus))
-    {
-        for (;;) {
-            XEvent ev;
-            XtAppPeekEvent(awt_appContext, &ev);
-            if ((ev.type == ButtonRelease)
-                && (*(XButtonEvent *)&ev).send_event)
-            {
-                XtAppProcessEvent(awt_appContext, XtIMAll);
-                break;
-            } else {
-                XtAppProcessEvent(awt_appContext, XtIMAll);
-            }
-        }
-    }
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    // 4488209: kdm@sparc.spb.su
-    // wdata->isShowing is True when toFront calls pShow.
-    // We do not need to do some things if wdata->isShowing is True.
-    if (!wdata->isShowing) {
-        XtVaSetValues(wdata->winData.comp.widget,
-                      XmNx, -(wdata->left),
-                      XmNy, -(wdata->top),
-                      NULL);
-
-        /* But see below! */
-        iconic = (wdata->state & java_awt_Frame_ICONIFIED) ? True : False;
-        XtVaSetValues(wdata->winData.shell,
-                      XmNinitialState, iconic ? IconicState : NormalState,
-                      NULL);
-
-        if (wdata->menuBar != NULL) {
-            awt_util_show(wdata->menuBar);
-        }
-        XtManageChild(wdata->mainWindow);
-        XtRealizeWidget(wdata->winData.shell); /* but not map it yet */
-
-/*         fprintf(stderr, "*** proxy window %x\n", XtWindow(wdata->focusProxy)); */
-        XStoreName(awt_display, XtWindow(wdata->focusProxy), "FocusProxy");
-        /*
-         * Maximization and other stuff that requires a live Window to set
-         * properties on to communicate with WM.
-         */
-        awt_wm_setExtendedState(wdata, wdata->state);
-        awt_wm_setShellDecor(wdata, wdata->isResizable);
-
-        if (wdata->isModal) {
-            removePopupMenus();
-#ifndef NOMODALFIX
-            /*
-             * Fix for 4078176 Modal dialogs don't act modal
-             * if addNotify() is called before setModal(true).
-             * Moved from Java_sun_awt_motif_MDialogPeer_create.
-             */
-            if (!wdata->callbacksAdded) {
-                XtAddCallback(wdata->winData.shell,
-                              XtNpopupCallback, awt_shellPoppedUp,
-                              NULL);
-                XtAddCallback(wdata->winData.shell,
-                              XtNpopdownCallback, awt_shellPoppedDown,
-                              NULL);
-                wdata->callbacksAdded = True;
-            }
-#endif /* !NOMODALFIX */
-            /*
-             * Set modality on the Shell, not the BB.  The BB expects that
-             * its parent is an xmDialogShell, which as the result of
-             * coalescing is now a transientShell...  This has resulted in
-             * a warning message generated under fvwm.  The shells are
-             * virtually identical and a review of Motif src suggests that
-             * setting dialog style on BB is a convenience not functional
-             * for BB so set Modality on shell, not the BB(form) widget.
-             */
-            XtVaSetValues(wdata->winData.shell,
-                          XmNmwmInputMode, MWM_INPUT_FULL_APPLICATION_MODAL,
-                          NULL);
-            XtManageChild(wdata->winData.comp.widget);
-        }
-        else {                  /* not modal */
-            XtVaSetValues(wdata->winData.shell,
-                          XmNmwmInputMode, MWM_INPUT_MODELESS, NULL);
-            XtManageChild(wdata->winData.comp.widget);
-            XtSetMappedWhenManaged(wdata->winData.shell, True);
-        }
-        if (wdata->isResizable) {
-            /* REMINDER: uwe: will need to revisit for setExtendedStateBounds */
-            awt_wm_removeSizeHints(wdata->winData.shell, PMinSize|PMaxSize);
-        }
-        locationByPlatform =
-            (*env)->GetBooleanField(env, target, windowIDs.locationByPlatform);
-        if (locationByPlatform) {
-            awt_wm_removeSizeHints(wdata->winData.shell, USPosition|PPosition);
-        }
-    }
-
-    /*
-     * 4261047: always pop up with XtGrabNone.  Motif notices the
-     * modal input mode and perform the grab for us, doing its
-     * internal book-keeping as well.
-     */
-    XtPopup(wdata->winData.shell, XtGrabNone);
-    wdata->isShowing = True;
-
-    wdata->initialFocus = (*env)->GetBooleanField(env, target, windowIDs.isAutoRequestFocus);
-
-    if (wdata->isFocusableWindow) {
-        if (wdata->initialFocus || wdata->isModal) {
-            focusOnMapNotify = True;
-        } else {
-            XtVaSetValues(wdata->winData.shell, XmNinput, False, NULL);
-        }
-    }
-
-    (*env)->DeleteLocalRef(env, target);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    getState
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL
-Java_sun_awt_motif_MWindowPeer_getState(JNIEnv *env, jobject this)
-{
-    struct FrameData *wdata;
-    jint state;
-
-    AWT_LOCK();
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL || wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return java_awt_Frame_NORMAL;
-    }
-
-    state = wdata->state;
-
-    AWT_FLUSH_UNLOCK();
-    return state;
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    setState
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowPeer_setState(JNIEnv *env, jobject this,
-    jint state)
-{
-    struct FrameData *wdata;
-    Widget shell;
-    Window shell_win;
-    jint changed;
-    Boolean changeIconic, iconic;
-
-    AWT_LOCK();
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL || wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    shell = wdata->winData.shell;
-    shell_win = XtWindow(shell);
-
-    DTRACE_PRINTLN4("TL: setState(0x%x/0x%x, 0x%X -> 0x%X)",
-                    shell, shell_win,
-                    wdata->state, state);
-
-    if (!wdata->isShowing) {
-        /*
-         * Not showing, so just record requested state; pShow will set
-         * initial state hints/properties appropriately before poping
-         * us up again.
-         */
-        DTRACE_PRINTLN("TL:     NOT showing (just record the new state)");
-        wdata->state = state;
-        AWT_UNLOCK();
-        return;
-    }
-
-    /*
-     * Request the state transition from WM here and do java upcalls
-     * in shell event handler when WM actually changes our state.
-     */
-    changed = wdata->state ^ state;
-
-    changeIconic = changed & java_awt_Frame_ICONIFIED;
-    iconic = (state & java_awt_Frame_ICONIFIED) ? True : False;
-
-    if (changeIconic && iconic) {
-        DTRACE_PRINTLN("TL:     set iconic = True");
-        XIconifyWindow(XtDisplay(shell), shell_win,
-                       XScreenNumberOfScreen(XtScreen(shell)));
-    }
-
-    /*
-     * If a change in both iconic and extended states requested, do
-     * changes to extended state when we are in iconic state.
-     */
-    if ((changed & ~java_awt_Frame_ICONIFIED) != 0) {
-        awt_wm_setExtendedState(wdata, state);
-    }
-
-    if (changeIconic && !iconic) {
-        DTRACE_PRINTLN("TL:     set iconic = False");
-        XMapWindow(XtDisplay(shell), shell_win);
-    }
-
-    AWT_FLUSH_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    pHide
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowPeer_pHide(JNIEnv *env, jobject this)
-{
-    struct FrameData *wdata;
-
-    AWT_LOCK();
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL
-        || wdata->winData.comp.widget == NULL
-        || wdata->winData.shell == NULL)
-    {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    /**
-     * Disable proxy mechanism when Window's shell is being hidden
-     */
-    clearFocusPath(wdata->winData.shell);
-
-    wdata->isShowing = False;   /* ignore window state events */
-
-    if (XtIsRealized(wdata->winData.shell)) {
-        /* XXX: uwe: this is bogus */
-        /*
-         * Make sure we withdraw a window in an unmaximized state, or
-         * we'll lose out normal bounds (pShow will take care of
-         * hinting maximization, so when the window is shown again it
-         * will be correctly shown maximized).
-         */
-        if (wdata->state & java_awt_Frame_MAXIMIZED_BOTH) {
-            awt_wm_setExtendedState(wdata,
-                wdata->state & ~java_awt_Frame_MAXIMIZED_BOTH);
-        }
-        XtUnmanageChild(wdata->winData.comp.widget);
-        XtPopdown(wdata->winData.shell);
-    }
-
-    AWT_FLUSH_UNLOCK();
-}
-
-
-/* sun_awt_motif_MWindowPeer_pReshape() is native (X/Motif) routine that
-   is called to effect a reposition and / or resize of the target frame.
-   The parameters x,y,w,h specify target's x, y position, width, height.*/
-
-/*
- * This functionality is invoked from both java and native code, and
- * we only want to lock when invoking it from java, so wrap the native
- * method version with the locking.
- */
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    pReshape
- * Signature: (IIII)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowPeer_pReshape(JNIEnv *env, jobject this,
-    jint x, jint y, jint w, jint h)
-{
-    struct FrameData    *wdata;
-
-    AWT_LOCK();
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL ||
-        wdata->winData.comp.widget == NULL ||
-        wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    // See if our new location is on a new screen
-    if (wdata->reparented) {
-        checkNewXineramaScreen(env, this, wdata, x, y, w, h);
-    }
-
-    /**
-     * Fix for 4652685.
-     * Avoid setting position for embedded frames, since this conflicts with the
-     * fix for 4419207. We assume that the embedded frame never changes its
-     * position relative to the parent.
-     */
-    if (wdata->winData.flags & W_IS_EMBEDDED) {
-        x = 0;
-        y = 0;
-    }
-
-    reshape(env, this, wdata, x, y, w, h, True);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MEmbeddedFramePeer
- * Method:    pReshapePrivate
- * Signature: (IIII)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MEmbeddedFramePeer_pReshapePrivate(JNIEnv *env, jobject this,
-    jint x, jint y, jint w, jint h)
-{
-    struct FrameData    *wdata;
-
-    AWT_LOCK();
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL ||
-        wdata->winData.comp.widget == NULL ||
-        wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    reshape(env, this, wdata, x, y, w, h, True);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-static void
-reshape(JNIEnv *env, jobject this, struct FrameData *wdata,
-        jint x, jint y, jint w, jint h, Boolean setXY)
-{
-    int32_t     topAdjust,      /* top adjustment of offset     */
-                bottomAdjust;   /* bottom adjustment of offset  */
-    int32_t     width,          /* of X/Motif shell and form    */
-                height;         /* of X/Motif shell and form    */
-    int32_t     w1, h1;
-    enum wmgr_t wm;             /* window manager */
-    XWindowAttributes winAttr;
-
-    DTRACE_PRINTLN7("TL: reshape(0x%x/0x%x,\n"/**/
-                    "TL:         x = %d, y = %d, w = %d, h = %d, %s)",
-                    wdata->winData.shell, XtWindow(wdata->winData.shell),
-                    x, y, w, h,
-                    setXY ? "setXY" : "false");
-
-    wm = awt_wm_getRunningWM();
-
-    /* Make adjustments in case of a dynamically added/removed menu bar */
-    awtJNI_setMbAndWwHeightAndOffsets(env, this, wdata);
-
-#ifdef _pauly_debug
-    fprintf(stdout,"    reshape. offsets - top: %d, bottom: %d, left: %d, right: %d\n",
-            wdata->top, wdata->bottom, wdata->left, wdata->right);
-    fflush(stdout);
-#endif /* _pauly_debug */
-
-    /* The abstract java (target) position coordinates (x,y)
-       are for the bordered window.  Eventually(!), the Motif
-       (shell) coordinates (XmNx, XmNy) will exclude borders.
-       (This is true only AFTER shell is massaged by the WM.)   */
-
-    /* The abstract java (target) width and height includes any WM
-       borders. But the Motif width and height excludes WM borders.
-       The wdata top and bottom fields may include space for menu bar,
-       warning window, etc. We must adjust by these values for shell.   */
-    topAdjust = 0;
-    bottomAdjust = 0;
-    /* Surprise - do not(!) check for nonNull MenuBar because that can
-       occur separately (in ...pSetMenubar()) from calculation of the
-       menu bar height and offsets (in setMbAndWwHeightAndOffsets()).
-       In any event, the offsets and wdata mbHeight field should jive.  */
-    topAdjust += wdata->mbHeight;
-    if  (wdata->warningWindow != NULL) {
-#ifdef NETSCAPE
-        bottomAdjust += wdata->wwHeight;
-#else /* NETSCAPE */
-        topAdjust += wdata->wwHeight;
-#endif /* NETSCAPE */
-    }
-    if (wdata->hasTextComponentNative) {
-        bottomAdjust +=  wdata->imHeight;
-    }
-#ifdef _pauly_debug
-    fprintf(stdout,"    reshape. adjustments - top: %d, bottom: %d\n", topAdjust, bottomAdjust);
-    fflush(stdout);
-#endif /* _pauly_debug */
-
-    width  = w - (wdata->left + wdata->right);
-    height = h - (wdata->top + wdata->bottom) + (topAdjust + bottomAdjust);
-
-    /*
-     * Shell size.
-     * 4033151.  If nonpositive size specified (e.g., if no size
-     * given), establish minimum allowable size.  Note: Motif shell
-     * can not be sized 0.
-     */
-    w1 = (width  > 0) ? width  : 1;
-    h1 = (height > 0) ? height : 1;
-
-    if (awt_wm_configureGravityBuggy() /* WM ignores window gravity */
-        && wdata->reparented && wdata->isShowing)
-    {
-        /*
-         * Buggy WM places client window at (x,y) ignoring the window
-         * gravity.  All our windows are NorthWestGravity, so adjust
-         * (x,y) by insets appropriately.
-         */
-        x += wdata->left;
-        y += wdata->top;
-        DTRACE_PRINTLN2("TL: work around WM gravity bug: x += %d, y += %d",
-                        wdata->left, wdata->top);
-    }
-
-    if (wdata->imRemove) {
-        XtVaSetValues(XtParent(wdata->winData.comp.widget),
-                      XmNheight, (((h - (wdata->top + wdata->bottom)) > 0) ?
-                                  (h - (wdata->top + wdata->bottom)) : 1),
-                      NULL);
-        wdata->imRemove = False;
-    }
-
-#if 0 /* XXX: this screws insets calculation under KDE2 in the case of
-         negative x, y */
-    /*
-     * Without these checks, kwm places windows slightly off the screen,
-     * when there is a window underneath at (0,0) and empty space below,
-     * but not to the right.
-     */
-    if (x < 0) x = 0;
-    if (y < 0) y = 0;
-#endif
-    if ((wdata->winData.flags & W_IS_EMBEDDED) == 0) {
-        if ((wm == MOTIF_WM) || (wm == CDE_WM)) {
-            /*
-             * By default MWM has "usePPosition: nonzero" and so ignores
-             * windows with PPosition (0,0).  Work around (should we???).
-             */
-            if ((x == 0) && (y == 0)) {
-                x = y = 1;
-            }
-        }
-    }
-
-    if ( wdata->decor == AWT_NO_DECOR ) {
-        if (setXY)
-            XtConfigureWidget(wdata->winData.shell, x, y, w1, h1, 0 );
-        else
-            XtResizeWidget(wdata->winData.shell, w1, h1, 0);
-    }
-    else {
-        /*
-         * 5006248, workaround for OpenLook WM.
-         * Thread gets stuck at XtVaSetValues call awaiting for first
-         * ConfigureNotify to come. For OpenLook it looks like a showstopper.
-         * We put dummy ConfigureNotify to satisfy the requirements.
-         */
-        if (awt_wm_getRunningWM() == OPENLOOK_WM) {
-            XEvent xev;
-            xev.xconfigure.type = ConfigureNotify;
-            xev.xconfigure.display = awt_display;
-            xev.xconfigure.window = XtWindow(wdata->winData.shell);
-            xev.xconfigure.event = xev.xconfigure.window;
-            xev.xconfigure.x = x;
-            xev.xconfigure.y = y;
-            xev.xconfigure.height = h1;
-            xev.xconfigure.width = w1;
-            xev.xconfigure.serial = NextRequest(awt_display) + 1; // see isMine() Xt inner function code.
-
-            XPutBackEvent(awt_display, &xev);
-        }
-
-        if (wdata->isResizable) {
-            XtVaSetValues(wdata->winData.shell,
-                          XmNwidth, w1,
-                          XmNheight, h1,
-                          NULL);
-        }
-        else {
-            /*
-             * Fix for BugTraq ID 4313607 - call awt_wm_setShellNotResizable
-             * regardless of wdata->isFixedSizeSet and wdata->reparented values.
-             */
-            DTRACE_PRINTLN("TL: set fixed size from reshape");
-            awt_wm_setShellNotResizable(wdata, w1, h1, True);
-            if (wdata->reparented && (w1 > 0) && (h1 > 0)) {
-                wdata->isFixedSizeSet = True;
-            }
-        }
-        if (setXY)
-            XtVaSetValues(wdata->winData.shell,
-                          XmNx, x,
-                          XmNy, y,
-                          NULL);
-    }
-    /* inner/parent drawing area (parent is form) */
-    h1 = h - (wdata->top + wdata->bottom);
-    h1 = ( h1 > 0 ) ? h1 : 1;
-#if 0
-    XtConfigureWidget(XtParent(wdata->winData.comp.widget),
-                      0, topAdjust, w1, h1, 0 );
-#else
-    XtVaSetValues(XtParent(wdata->winData.comp.widget),
-                  XmNx, 0,
-                  XmNy, topAdjust,
-                  XmNwidth, w1,
-                  XmNheight, h1,
-                  NULL);
-#endif
-
-#ifdef _pauly_debug
-        fprintf(stdout,"    reshape. setting inner canvas to: %d,%d,%d,%d\n",
-        0, topAdjust, w1, h1 );
-        fflush(stdout);
-#endif /* _pauly_debug */
-
-    wdata->menuBarReset = False;
-
-    /* DTRACE_PRINTLN("TL: reshape -> returning"); */
-    return;
-}
-
-/*
- * Class:     sun_awt_motif_MEmbeddedFramePeer
- * Method:    getBoundsPrivate
- * Signature: ()Ljava/awt/Rectangle
- */
-JNIEXPORT jobject JNICALL Java_sun_awt_motif_MEmbeddedFramePeer_getBoundsPrivate
-  (JNIEnv * env, jobject this)
-{
-    jobject bounds = NULL;
-    struct FrameData *cdata;
-    XWindowAttributes attr;
-
-    AWT_LOCK();
-
-    cdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (cdata == NULL || cdata->mainWindow == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return NULL;
-    }
-    if (!XtIsRealized(cdata->mainWindow) || !XtIsRealized(cdata->winData.shell)) {
-        JNU_ThrowInternalError(env, "widget not visible on screen");
-        AWT_UNLOCK();
-        return NULL;
-    }
-
-    memset(&attr, 0, sizeof(XWindowAttributes));
-    XGetWindowAttributes(awt_display, XtWindow(cdata->winData.shell), &attr);
-
-    bounds = JNU_NewObjectByName(env, "java/awt/Rectangle", "(IIII)V",
-                                (jint)attr.x, (jint)attr.y, (jint)attr.width, (jint)attr.height);
-    if (((*env)->ExceptionOccurred(env)) || JNU_IsNull(env, bounds)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return NULL;
-    }
-
-    AWT_UNLOCK();
-
-    return bounds;
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    pDispose
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MWindowPeer_pDispose
-(JNIEnv *env, jobject this)
-{
-    struct FrameData *wdata;
-
-    AWT_LOCK();
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL || wdata->mainWindow == NULL || wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (wdata->winData.flags & W_IS_EMBEDDED) {
-        awt_util_delEmbeddedFrame(wdata->winData.shell);
-        deinstall_xembed(wdata);
-    }
-    scheduleDispose(env, this);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MFramePeer
- * Method:    pGetIconSize
- * Signature: (II)Z
- */
-JNIEXPORT jboolean JNICALL Java_sun_awt_motif_MFramePeer_pGetIconSize
-(JNIEnv *env, jobject this, jint widthHint, jint heightHint)
-{
-    struct FrameData *wdata;
-    uint32_t width, height, border_width, depth;
-    Window win;
-    int32_t x, y;
-    uint32_t mask;
-    XSetWindowAttributes attrs;
-    uint32_t saveWidth = 0;
-    uint32_t saveHeight = 0;
-    uint32_t dist = 0xffffffff;
-    int32_t diff = 0;
-    int32_t closestWidth;
-    int32_t closestHeight;
-    int32_t newDist;
-    int32_t found = 0;
-    AwtGraphicsConfigDataPtr adata;
-
-    AWT_LOCK();
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return FALSE;
-    }
-    XtVaGetValues(wdata->winData.shell,
-                  XmNiconWindow, &win,
-                  NULL);
-    if (!win) {
-        int32_t count;
-        int32_t i;
-        XIconSize *sizeList;
-
-        adata = getGraphicsConfigFromComponentPeer(env, this);
-
-        if (!XGetIconSizes(awt_display,
-                           RootWindow(awt_display, adata->awt_visInfo.screen),
-                           &sizeList, &count)) {
-            /* No icon sizes so can't set it -- Should we throw an exception?*/
-            /* [jk] I don't think so: simply fall back to 16x16 */
-            saveWidth = saveHeight = 16;
-            goto top;
-        }
-        for (i=0; i < count; i++) {
-            if (widthHint >= sizeList[i].min_width &&
-                widthHint <= sizeList[i].max_width &&
-                heightHint >= sizeList[i].min_height &&
-                heightHint <= sizeList[i].max_height) {
-                found = 1;
-                if ((((widthHint-sizeList[i].min_width)
-                      % sizeList[i].width_inc) == 0) &&
-                    (((heightHint-sizeList[i].min_height)
-                      % sizeList[i].height_inc) ==0)) {
-                    /* Found an exact match */
-                    saveWidth = widthHint;
-                    saveHeight = heightHint;
-                    dist = 0;
-                    break;
-                }
-                diff = widthHint - sizeList[i].min_width;
-                if (diff == 0) {
-                    closestWidth = widthHint;
-                } else {
-                    diff = diff%sizeList[i].width_inc;
-                    closestWidth = widthHint - diff;
-                }
-                diff = heightHint - sizeList[i].min_height;
-                if (diff == 0) {
-                    closestHeight = heightHint;
-                } else {
-                    diff = diff%sizeList[i].height_inc;
-                    closestHeight = heightHint - diff;
-                }
-                newDist = closestWidth*closestWidth +
-                    closestHeight*closestHeight;
-                if (dist > newDist) {
-                    saveWidth = closestWidth;
-                    saveHeight = closestHeight;
-                    dist = newDist;
-                }
-            }
-        }
-
-        if (!found) {
-#if 1
-            /* [sbb] this code should work better than the original Solaris
-               code */
-            if (widthHint  >= sizeList[0].max_width ||
-                heightHint >= sizeList[0].max_height) {
-              /* determine which way to scale */
-              int32_t wdiff = widthHint - sizeList[0].max_width;
-              int32_t hdiff = heightHint - sizeList[0].max_height;
-              if (wdiff >= hdiff) { /* need to scale width more  */
-                saveWidth = sizeList[0].max_width;
-                saveHeight = (int32_t)(((double)sizeList[0].max_width/widthHint) *
-                                   heightHint);
-              } else {
-                saveWidth = (int32_t)(((double)sizeList[0].max_height/heightHint) *
-                                  widthHint);
-                saveHeight = sizeList[0].max_height;
-              }
-            } else if (widthHint  < sizeList[0].min_width ||
-                       heightHint < sizeList[0].min_height) {
-                saveWidth = (sizeList[0].min_width+sizeList[0].max_width)/2;
-                saveHeight = (sizeList[0].min_height+sizeList[0].max_height)/2;
-            } else {            /* it fits within the right size */
-              saveWidth = widthHint;
-              saveHeight = heightHint;
-            }
-
-#else /* XXX: old Solaris code */
-            /* REMIND: Aspect ratio */
-            if (widthHint  >= sizeList[0].max_width &&
-                heightHint >= sizeList[0].max_height) {
-                saveWidth = sizeList[0].max_width;
-                saveHeight = sizeList[0].max_height;
-            } else if (widthHint  >= sizeList[0].min_width &&
-                       heightHint >= sizeList[0].min_height) {
-                saveWidth = sizeList[0].min_width;
-                saveHeight = sizeList[0].min_height;
-            } else {
-                saveWidth = (sizeList[0].min_width+sizeList[0].max_width)/2;
-                saveHeight = (sizeList[0].min_height+sizeList[0].max_height)/2;
-            }
-#endif
-        }
-        free((void *) sizeList);
-    } else {
-        Window root;
-        if (XGetGeometry(awt_display,
-                         win,
-                         &root,
-                         &x,
-                         &y,
-                         (uint32_t *)&saveWidth,
-                         (uint32_t *)&saveHeight,
-                         (uint32_t *)&border_width,
-                         (uint32_t *)&depth)) {
-        }
-    }
-
- top:
-    (*env)->SetIntField(env, this, mWindowPeerIDs.iconWidth, (jint)saveWidth);
-    (*env)->SetIntField(env, this, mWindowPeerIDs.iconHeight, (jint)saveHeight);
-
-    AWT_UNLOCK();
-    return TRUE;
-}
-
-/*
- * Class:     sun_awt_motif_MFramePeer
- * Method:    pSetIconImage
- * Signature: ([B[I[SII)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MFramePeer_pSetIconImage___3B_3I_3SII
-(JNIEnv *env, jobject this,
- jbyteArray jbyteData, jintArray jintData, jshortArray jushortData,
- jint iconWidth, jint iconHeight)
-{
-    struct FrameData *wdata;
-    Window win;
-    GC gc;
-    int32_t x, y;
-    XImage *dst;
-    uint32_t mask;
-    XSetWindowAttributes attrs;
-    jobject jbuf = NULL;
-    void *buf = NULL;
-    int32_t len = 0;
-    int32_t bpp, slp, bpsl;
-    AwtGraphicsConfigDataPtr adata;
-
-    if (JNU_IsNull(env, jbyteData)) {
-        if (JNU_IsNull(env, jintData)) {
-            if (JNU_IsNull(env, jushortData)) {
-                /* [jk] Don't throw an exception here, it breaks
-                 * programs that run correctly on Windows
-                 * JNU_ThrowNullPointerException(env, "NullPointerException");
-                 */
-                return;
-            } else {
-                jbuf = jushortData;
-            }
-        } else {
-            jbuf = jintData;
-        }
-    } else {
-        jbuf = jbyteData;
-        len = (*env)->GetArrayLength(env, jbyteData);
-    }
-    AWT_LOCK();
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    /* REMIND: Need to figure out how to display image on a pixmap */
-
-    if (wdata == NULL || wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    adata = getGraphicsConfigFromComponentPeer(env, this);
-
-    /* [jk] we need a new pixmap everytime:
-     * Test case: src/share/test/awt/FrameTest.html Look at the icon,
-     * select Operations/Change IconImage, you should see a different
-     * icon now.
-     */
-    if (wdata->iconPixmap) {
-        XFreePixmap(awt_display, wdata->iconPixmap);
-        wdata->iconPixmap = None;
-    }
-
-    if (wdata->iconPixmap == None) {
-        if ((wdata->iconPixmap =
-             XCreatePixmap(awt_display,
-                           RootWindow(awt_display, adata->awt_visInfo.screen),
-                           iconWidth, iconHeight,
-                           adata->awtImage->Depth)) == None) {
-            /* REMIND: How to warn that there was a problem? */
-            AWT_UNLOCK();
-            return;
-        }
-        wdata->iconWidth = iconWidth;
-        wdata->iconHeight = iconHeight;
-    }
-
-    buf = (void *) (*env)->GetPrimitiveArrayCritical(env, jbuf, NULL);
-    if (jbyteData != NULL) {
-        int32_t i;
-        unsigned char *ubuf = (unsigned char *) buf;
-        /* Need to map from ICM lut to cmap */
-        for (i=0; i < len; i++) {
-            ubuf[i] = (ubuf[i] >= adata->color_data->awt_numICMcolors)
-                        ? 0
-                        : adata->color_data->awt_icmLUT2Colors[ubuf[i]];
-        }
-    }
-
-    bpp = adata->awtImage->wsImageFormat.bits_per_pixel;
-    slp = adata->awtImage->wsImageFormat.scanline_pad;
-    bpsl = paddedwidth(iconWidth * bpp, slp) >> 3;
-    if (((bpsl << 3) / bpp) < iconWidth) {
-        (*env)->ReleasePrimitiveArrayCritical(env, jbuf, buf, JNI_ABORT);
-        AWT_UNLOCK();
-        return;
-    }
-    dst = XCreateImage(awt_display, adata->awt_visInfo.visual,
-                       adata->awtImage->Depth, ZPixmap, 0,
-                       buf, iconWidth, iconHeight, 32, bpsl);
-    if (dst == NULL) {
-        /* REMIND: How to warn that there was a problem? */
-        (*env)->ReleasePrimitiveArrayCritical(env, jbuf, buf, JNI_ABORT);
-        AWT_UNLOCK();
-        return;
-    }
-
-    if ((gc = XCreateGC(awt_display, wdata->iconPixmap, 0, 0)) == NULL) {
-        XDestroyImage (dst);
-        (*env)->ReleasePrimitiveArrayCritical(env, jbuf, buf, JNI_ABORT);
-        AWT_UNLOCK();
-        return;
-    }
-
-    XPutImage(awt_display, wdata->iconPixmap, gc, dst,
-              0, 0, 0, 0, iconWidth, iconHeight);
-    (*env)->ReleasePrimitiveArrayCritical(env, jbuf, buf, JNI_ABORT);
-    dst->data=NULL;
-    XDestroyImage(dst);
-    XFreeGC(awt_display, gc);
-
-    XtVaGetValues(wdata->winData.shell,
-                  XmNiconWindow, &win,
-                  NULL);
-    if (!win) {
-        mask = CWBorderPixel | CWColormap | CWBackPixmap;
-        attrs.border_pixel = awt_defaultFg;
-        attrs.colormap = adata->awt_cmap;
-        attrs.background_pixmap = wdata->iconPixmap;
-        if (!(win = XCreateWindow(awt_display,
-                                  RootWindow(awt_display,
-                                             adata->awt_visInfo.screen),
-                                  0, 0, iconWidth, iconHeight,
-                                  (uint32_t) 0,
-                                  adata->awtImage->Depth,
-                                  InputOutput,
-                                  adata->awt_visInfo.visual,
-                                  mask, &attrs))) {
-            /* Still can't create the window so try setting iconPixmap */
-            XtVaSetValues(wdata->winData.shell,
-                          XmNiconPixmap, wdata->iconPixmap,
-                          NULL);
-            AWT_FLUSH_UNLOCK();
-            return;
-        }
-    }
-
-    XtVaSetValues(wdata->winData.shell,
-                  XmNiconPixmap, wdata->iconPixmap,
-                  XmNiconWindow, win,
-                  NULL);
-
-    XSetWindowBackgroundPixmap(awt_display, win, wdata->iconPixmap);
-    XClearWindow(awt_display, win);
-    AWT_FLUSH_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    setResizable
- * Signature: (Z)V
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MWindowPeer_setResizable(JNIEnv *env, jobject this,
-    jboolean resizable)
-{
-    struct FrameData    *wdata;
-    jobject             target;
-    int32_t             targetWidth,
-                        targetHeight;
-    int32_t             width,          /* fixed width if not resizable */
-                        height;         /* fixed height if not resizable*/
-    int32_t             verticalAdjust; /* menubar, warning window, etc.*/
-
-    if ((*env)->EnsureLocalCapacity(env, 1) < 0) {
-        return;
-    }
-
-    AWT_LOCK();
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL
-        || wdata->winData.comp.widget == NULL
-        || wdata->winData.shell == NULL
-        || JNU_IsNull(env, target))
-    {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        if (!JNU_IsNull(env, target))
-            (*env)->DeleteLocalRef(env, target);
-        AWT_UNLOCK();
-        return;
-    }
-
-    DTRACE_PRINTLN3("TL: setResizable(0x%x/0x%x, %s)",
-                    wdata->winData.shell, XtWindow(wdata->winData.shell),
-                    resizable ? "true" : "false");
-
-    if ((!wdata->isResizable) && (resizable)) {
-        awt_wm_setShellResizable(wdata);
-        wdata->isFixedSizeSet = False;
-    }
-    else if ((wdata->isResizable) && (!resizable)) {
-        /*
-         * To calculate fixed window width, height, we must subtract
-         * off the window manager borders as stored in the wdata
-         * structure.  But note that the wdata top and bottom fields
-         * may include space for warning window, menubar, IM status;
-         * this IS part of shell.
-         */
-        verticalAdjust = wdata->mbHeight;
-        if (wdata->warningWindow != NULL) {
-            verticalAdjust += wdata->wwHeight;
-        }
-        if (wdata->hasTextComponentNative) {
-            verticalAdjust += wdata->imHeight;
-        }
-
-        targetWidth  = (*env)->GetIntField(env, target, componentIDs.width);
-        targetHeight = (*env)->GetIntField(env, target, componentIDs.height);
-        width  = targetWidth  - (wdata->left + wdata->right);
-        height = targetHeight - (wdata->top + wdata->bottom) + verticalAdjust;
-#ifdef __linux__
-        width  = (width  > 0) ? width  : 1;
-        height = (height > 0) ? height : 1;
-#endif
-        DTRACE_PRINTLN2("TL:     setting fixed size %ld x %ld", width, height);
-        awt_wm_setShellNotResizable(wdata, width, height, False);
-        if ((width > 0) && (height > 0)) {
-            wdata->isFixedSizeSet = True;
-        }
-    }
-
-    wdata->isResizable = (Boolean)resizable;
-
-    (*env)->DeleteLocalRef(env, target);
-    AWT_FLUSH_UNLOCK();
-}
-
-
-/* sun_awt_motif_MWindowPeer_pSetMenuBar() is native (X/Motif) routine
-   which handles insertion or deletion of a menubar from this frame.    */
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    pSetMenuBar
- * Signature: (Lsun/awt/motif/MMenuBarPeer;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MWindowPeer_pSetMenuBar
-(JNIEnv *env, jobject this, jobject mb)
-{
-    struct FrameData            *wdata;
-    struct ComponentData        *mdata;
-    jobject                     target;
-    Widget                      innerCanvasW;   /* Motif inner canvas   */
-#ifdef _pauly_debug
-    Dimension                   mbHeight;       /* Motif menubar height */
-#endif /* _pauly_debug */
-
-#ifdef _pauly_debug
-    fprintf(stdout," ++ ...pSetMenuBar.\n");
-    fflush(stdout);
-#endif /* _pauly_debug */
-
-
-    if ((*env)->EnsureLocalCapacity(env, 1) < 0) {
-        return;
-    }
-    AWT_LOCK();
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (JNU_IsNull(env, target) || wdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        if  (!JNU_IsNull(env, target)) {
-            (*env)->DeleteLocalRef(env, target);
-        }
-        AWT_UNLOCK();
-        return;
-    }
-
-    if (mb == NULL) {
-#ifdef _pauly_debug
-        fprintf(stdout,"    ...pSetMenuBar. mb is null.\n");
-        fflush(stdout);
-#endif /* _pauly_debug */
-        if  (wdata->menuBar != NULL) {
-            /* Redo attachments of other form widgets appropriately now */
-            innerCanvasW = XtParent(wdata->winData.comp.widget);
-
-            if  (wdata->warningWindow == NULL) {
-                /* no warning window: canvas is now attached to form    */
-                XtVaSetValues(innerCanvasW,
-                              XmNtopAttachment, XmATTACH_FORM,
-                              NULL);
-            } else {
-                /* warning window present - conditional on #define NETSCAPE:
-                   if NETSCAPE, warning window is at bottom, so canvas is
-                   attached to the form (as above); otherwise (not NETSCAPE),
-                   warning window itself is instead attached to form.   */
-#ifdef NETSCAPE
-                XtVaSetValues(innerCanvasW,
-                              XmNtopAttachment, XmATTACH_FORM,
-                              NULL);
-#else  /* NETSCAPE */
-                XtVaSetValues(wdata->warningWindow,
-                              XmNtopAttachment, XmATTACH_FORM,
-                              NULL);
-#endif /* NETSCAPE */
-            }
-
-            wdata->menuBarReset = True;
-        }
-        wdata->menuBar = NULL;
-        awtJNI_setMbAndWwHeightAndOffsets(env, this, wdata);
-        (*env)->DeleteLocalRef(env, target);
-        AWT_FLUSH_UNLOCK();
-#ifdef _pauly_debug
-        fprintf(stdout,"    ...pSetMenuBar. Done.\n");
-        fflush(stdout);
-#endif /* _pauly_debug */
-        return;
-    }
-
-    mdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, mb, mMenuBarPeerIDs.pData);
-    if (mdata == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        (*env)->DeleteLocalRef(env, target);
-        AWT_UNLOCK();
-        return;
-    }
-
-    /* OK - insert the new menu bar into the form (at the top).
-       Redo the attachments of other form widgets appropriately.*/
-
-    if  (wdata->menuBar == NULL)
-        wdata->menuBarReset = True;
-    wdata->menuBar = mdata->widget;
-
-#ifdef _pauly_debug
-    XtVaGetValues(mdata->widget, XmNheight, &mbHeight, NULL);
-    fprintf(stdout,"    ...pSetMenuBar. new menu bar (widget %x, parent: %x) - menu bar height: %d\n", wdata->menuBar, XtParent(wdata->menuBar), mbHeight);
-    fflush(stdout);
-#endif /* _pauly_debug */
-
-    XtVaSetValues(mdata->widget,
-                  XmNtopAttachment, XmATTACH_FORM,
-                  XmNleftAttachment, XmATTACH_FORM,
-                  XmNrightAttachment, XmATTACH_FORM,
-                  NULL);
-
-    innerCanvasW = XtParent(wdata->winData.comp.widget);
-
-    if  (wdata->warningWindow == NULL) {
-        /* no warning window: menu bar at top, canvas attached to it    */
-        XtVaSetValues(innerCanvasW,
-                      XmNtopAttachment, XmATTACH_WIDGET,
-                      XmNtopWidget, mdata->widget,
-                      NULL);
-    } else {
-        /* warning window present - conditional on #define NETSCAPE:
-           if NETSCAPE, warning window is at bottom, so canvas is
-           attached to menu bar (as above); otherwise (not NETSCAPE),
-           the warning window is attached just below the menu bar.  */
-#ifdef NETSCAPE
-        XtVaSetValues(innerCanvasW,
-                      XmNtopAttachment, XmATTACH_WIDGET,
-                      XmNtopWidget, mdata->widget,
-                      NULL);
-#else  /* NETSCAPE */
-        XtVaSetValues(wdata->warningWindow,
-                      XmNtopAttachment, XmATTACH_WIDGET,
-                      XmNtopWidget, mdata->widget,
-                      NULL);
-#endif /* NETSCAPE */
-    }
-
-    XtManageChild(mdata->widget);
-    XtMapWidget(mdata->widget);
-    XSync(awt_display, False);
-    awtJNI_setMbAndWwHeightAndOffsets(env, this, wdata);
-
-#ifdef _pauly_debug
-    XtVaGetValues(mdata->widget, XmNheight, &mbHeight, NULL);
-    fprintf(stdout,"    ...pSetMenuBar. with menu bar: menu bar height: %d, top offset: %d, bottom offset: %d\n", mbHeight, wdata->top, wdata->bottom);
-    fflush(stdout);
-#endif /* _pauly_debug */
-
-    (*env)->DeleteLocalRef(env, target);
-
-    AWT_FLUSH_UNLOCK();
-
-#ifdef _pauly_debug
-    fprintf(stdout,"    ...pSetMenuBar. Done\n");
-    fflush(stdout);
-#endif /* _pauly_debug */
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    toBack
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MWindowPeer_toBack
-(JNIEnv *env, jobject this)
-{
-    struct FrameData *wdata;
-
-    AWT_LOCK();
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL || wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (XtWindow(wdata->winData.shell) != 0) {
-        XLowerWindow(awt_display, XtWindow(wdata->winData.shell));
-    }
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    updateAlwaysOnTop
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MWindowPeer_updateAlwaysOnTop
-(JNIEnv *env, jobject this, jboolean isOnTop)
-{
-    struct FrameData *wdata;
-    AWT_LOCK();
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    awt_wm_updateAlwaysOnTop(wdata, isOnTop);
-    AWT_FLUSH_UNLOCK();
-}
-
-JNIEXPORT void JNICALL Java_sun_awt_motif_MWindowPeer_addTextComponentNative
-(JNIEnv *env, jobject this, jobject tc)
-{
-    struct FrameData            *wdata;
-    jobject                     target;
-
-    if (JNU_IsNull(env, this)) {
-        return;
-    }
-
-    AWT_LOCK();
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL ||
-        wdata->winData.comp.widget==NULL ||
-        wdata->winData.shell==NULL ||
-        JNU_IsNull(env, target)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if ( !wdata->hasTextComponentNative) {
-        wdata->hasTextComponentNative = True;
-        wdata->imHeight = awt_motif_getIMStatusHeight(wdata->winData.shell, tc);
-        wdata->bottom += wdata->imHeight;
-        awtJNI_ChangeInsets(env, this, wdata);
-        reshape(env, this, wdata,
-                (*env)->GetIntField(env, target, componentIDs.x),
-                (*env)->GetIntField(env, target, componentIDs.y),
-                (*env)->GetIntField(env, target, componentIDs.width),
-                (*env)->GetIntField(env, target, componentIDs.height),
-                True);
-    }
-    AWT_UNLOCK();
-}
-
-JNIEXPORT void JNICALL Java_sun_awt_motif_MWindowPeer_removeTextComponentNative
-(JNIEnv *env, jobject this)
-{
-    struct FrameData            *wdata;
-    jobject                     target;
-
-    if (JNU_IsNull(env, this)) {
-        return;
-    }
-
-    AWT_LOCK();
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL ||
-        wdata->winData.comp.widget== NULL ||
-        wdata->winData.shell== NULL ||
-        JNU_IsNull(env, target)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    if (!wdata->hasTextComponentNative) {
-        AWT_UNLOCK();
-        return;
-    }
-
-    wdata->bottom -= wdata->imHeight;
-    awtJNI_ChangeInsets(env, this, wdata);
-    wdata->imRemove = True;
-    reshape(env, this, wdata,
-            (*env)->GetIntField(env, target, componentIDs.x),
-            (*env)->GetIntField(env, target, componentIDs.y),
-            (*env)->GetIntField(env, target, componentIDs.width),
-            (*env)->GetIntField(env, target, componentIDs.height),
-            True);
-
-    wdata->hasTextComponentNative = False;
-    wdata->imHeight = 0;
-
-    AWT_UNLOCK();
-} /* ...removeTextComponentPeer() */
-
-static Atom java_protocol = None;
-static Atom motif_wm_msgs = None;
-
-static void im_callback(Widget shell, XtPointer client_data, XtPointer call_data)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    JNU_CallMethodByName(env, NULL,
-                         (jobject)client_data,
-                         "notifyIMMOptionChange",
-                         "()V");
-}
-
-JNIEXPORT void JNICALL Java_sun_awt_motif_MWindowPeer_pSetIMMOption
-(JNIEnv *env, jobject this, jstring option)
-{
-    char        *coption;
-    char        *empty = "InputMethod";
-    char        *menuItem;
-    jobject     globalRef;
-    struct FrameData *wdata;
-
-    AWT_LOCK();
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL || wdata->winData.shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    globalRef = (jobject)JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.jniGlobalRef);
-    coption = (JNU_IsNull(env, option)) ? empty : (char *) JNU_GetStringPlatformChars(env, option, NULL);
-    if (java_protocol == None || motif_wm_msgs == None) {
-        java_protocol = XmInternAtom(awt_display, "_JAVA_IM_MSG", False);
-        motif_wm_msgs = XmInternAtom(awt_display, "_MOTIF_WM_MESSAGES", False);
-    }
-    XmAddProtocols (wdata->winData.shell, motif_wm_msgs, &java_protocol, 1);
-    XmAddProtocolCallback(wdata->winData.shell, motif_wm_msgs, java_protocol, im_callback, (XtPointer)globalRef);
-
-    if ((menuItem = awt_util_makeWMMenuItem(coption, java_protocol))) {
-        XtVaSetValues(wdata->winData.shell,
-                      XmNmwmMenu,
-                      menuItem,
-                      NULL);
-        free(menuItem);
-    }
-    if (coption != empty)
-        JNU_ReleaseStringPlatformChars(env, option, (const char *) coption);
-    AWT_FLUSH_UNLOCK();
-}
-
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MEmbeddedFramePeer_synthesizeFocusInOut(JNIEnv *env, jobject this,
-                                                           jboolean b)
-{
-    EmbeddedFrame *ef;
-    Boolean dummy;
-
-    AWT_LOCK();
-    ef = theEmbeddedFrameList;
-    while (ef != NULL) {
-        if ((*env)->IsSameObject(env, ef->javaRef, this)) {
-            XFocusChangeEvent xev;
-            xev.display = awt_display;
-            xev.serial = 0;
-            xev.type = b ? FocusIn : FocusOut;
-            xev.send_event = False;
-            xev.window = XtWindow(ef->embeddedFrame);
-            xev.mode = NotifyNormal;
-            xev.detail = NotifyNonlinear;
-            shellEH(ef->embeddedFrame, this, (XEvent*)&xev, &dummy);
-            break;
-        }
-        ef = ef->next;
-    }
-    AWT_UNLOCK();
-}
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MEmbeddedFramePeer_traverseOut(JNIEnv *env, jobject this, jboolean direction)
-{
-    struct FrameData            *wdata;
-
-    if (JNU_IsNull(env, this)) {
-        return;
-    }
-
-    AWT_LOCK();
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL ||
-        wdata->winData.comp.widget== NULL ||
-        wdata->winData.shell== NULL)
-    {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    xembed_traverse_out(wdata, direction);
-    AWT_UNLOCK();
-}
-
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MEmbeddedFramePeer_NEFcreate(JNIEnv *env, jobject this,
-                                                jobject parent, jlong handle)
-{
-#undef MAX_ARGC
-#define MAX_ARGC 40
-    Arg      args[MAX_ARGC];
-    int32_t  argc;
-    struct   FrameData *wdata;
-    jobject  target;
-    jstring  warningString;
-    jboolean resizable;
-    jobject  globalRef = awtJNI_CreateAndSetGlobalRef(env, this);
-    Widget   innerCanvasW;  /* form's child, parent of the outer canvas
-                               drawing area */
-    AwtGraphicsConfigDataPtr adata;
-    AwtGraphicsConfigDataPtr defConfig;
-
-    AWT_LOCK();
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    if (JNU_IsNull(env, target)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    wdata = ZALLOC(FrameData);
-    JNU_SetLongFieldFromPtr(env, this, mComponentPeerIDs.pData, wdata);
-    if (wdata == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        AWT_UNLOCK();
-        return;
-    }
-
-    adata = getGraphicsConfigFromComponentPeer(env, this);
-    defConfig = getDefaultConfig(adata->awt_visInfo.screen);
-
-    /* A variation on Netscape's hack for embedded frames: the client area
-     * of the browser is a Java Frame for parenting purposes, but really a
-     * Motif child window
-     */
-    wdata->winData.flags |= W_IS_EMBEDDED;
-
-    wdata->top = 0;
-    wdata->left = 0;
-    wdata->bottom = 0;
-    wdata->right = 0;
-    awtJNI_ChangeInsets(env, this, wdata);
-
-
-    wdata->isModal = 0;
-    wdata->isShowing = False;
-    wdata->shellResized = False;
-    wdata->canvasResized = False;
-    wdata->menuBarReset = False;
-
-    resizable = (*env)->GetBooleanField(env, target, frameIDs.resizable);
-
-    wdata->winData.shell = (Widget)handle;
-    awt_util_addEmbeddedFrame(wdata->winData.shell, globalRef);
-
-    install_xembed((Widget)handle, wdata);
-
-    setDeleteCallback(globalRef, wdata);
-    /* Establish resizability.  For the case of not resizable, do not
-       yet set a fixed size here; we must wait until in the routine
-       sun_awt_motif_MWindowPeer_pReshape() after insets have been fixed.
-       This is because correction of the insets may affect shell size.
-       (See comments in shellEH() concerning correction of the insets.  */
-    /*
-     * Fix for BugTraq ID 4313607.
-     * Initial resizability will be set later in MWindowPeer_setResizable()
-     * called from init(). But the real changes will be made only if the new
-     * and old resizability values are different at that point, so we
-     * initialize isResizable with inverse value here to get the job done.
-     */
-    wdata->isResizable = !resizable;
-    wdata->isFixedSizeSet = False;
-#if 0
-    if (resizable) {
-        awt_wm_setShellResizable(wdata);
-    }
-#endif
-
-    XtAddEventHandler(wdata->winData.shell, StructureNotifyMask | FocusChangeMask,
-                      FALSE, (XtEventHandler)shellEH, globalRef);
-
-
-    argc = 0;
-    XtSetArg(args[argc], XmNvisual, defConfig->awt_visInfo.visual); argc++;
-    XtSetArg(args[argc], XmNcolormap, defConfig->awt_cmap); argc++;
-    XtSetArg(args[argc], XmNdepth, defConfig->awt_depth); argc++;
-    XtSetArg(args[argc], XmNmarginWidth, 0); argc++;
-    XtSetArg(args[argc], XmNmarginHeight, 0); argc++;
-    XtSetArg(args[argc], XmNhorizontalSpacing, 0); argc++;
-    XtSetArg(args[argc], XmNverticalSpacing, 0); argc++;
-    XtSetArg(args[argc], XmNscreen,
-             ScreenOfDisplay(awt_display, defConfig->awt_visInfo.screen)); argc++;
-
-
-    XtSetArg(args[argc], XmNresizePolicy, XmRESIZE_NONE); argc++;
-
-    DASSERT(!(argc > MAX_ARGC));
-    wdata->mainWindow = XmCreateForm(wdata->winData.shell, "main", args, argc);
-
-    /* The widget returned by awt_canvas_create is a drawing area
-       (i.e., canvas) which is the child of another drawing area
-       parent widget.  The parent is the drawing area within the
-       form just created.  The child is an drawing area layer over
-       the entire frame window, including the form, any menu bar
-       and warning windows present, and also window manager stuff.
-       The top, bottom, left, and right fields in wdata maintain
-       the respective offsets between these two drawing areas.  */
-
-    wdata->winData.comp.widget = awt_canvas_create((XtPointer)globalRef,
-                                                   wdata->mainWindow,
-                                                   "frame_",
-                                                   -1,
-                                                   -1,
-                                                   True,
-                                                   wdata,
-                                                   defConfig);
-
-    XtAddCallback(wdata->winData.comp.widget,
-                  XmNresizeCallback,
-                  outerCanvasResizeCB,
-                  globalRef);
-
-
-    innerCanvasW = XtParent(wdata->winData.comp.widget);
-    XtVaSetValues(innerCanvasW,
-                  XmNleftAttachment, XmATTACH_FORM,
-                  XmNrightAttachment, XmATTACH_FORM,
-                  NULL);
-
-
-    XtAddEventHandler(innerCanvasW, StructureNotifyMask, FALSE,
-                      (XtEventHandler)innerCanvasEH, globalRef);
-
-    /* No menu bar initially */
-    wdata->menuBar = NULL;
-    wdata->mbHeight = 0;
-
-    /* If a warning window (string) is needed, establish it now.*/
-    warningString =
-        (*env)->GetObjectField(env, target, windowIDs.warningString);
-
-    /* No warning window present */
-    XtVaSetValues(innerCanvasW,
-                  XmNtopAttachment, XmATTACH_FORM,
-                  XmNbottomAttachment, XmATTACH_FORM,
-                  NULL);
-    wdata->warningWindow = NULL;
-    wdata->wwHeight = 0;
-
-
-    awt_util_show(wdata->winData.comp.widget);
-
-    AWT_FLUSH_UNLOCK();
-}  /* MEmbeddedFramePeer_NEFcreate() */
-
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MEmbeddedFramePeer_pShowImpl(JNIEnv *env, jobject this)
-{
-    struct FrameData *wdata;
-
-    AWT_LOCK();
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL ||
-        wdata->winData.comp.widget == NULL ||
-        wdata->winData.shell == NULL ||
-        wdata->mainWindow == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-    XtVaSetValues(wdata->winData.comp.widget,
-                  XmNx, -(wdata->left),
-                  XmNy, -(wdata->top), NULL);
-
-    if (wdata->menuBar != 0) {
-        awt_util_show(wdata->menuBar);
-    }
-
-    XtManageChild(wdata->mainWindow);
-    if (XtWindow(wdata->winData.shell) == None) {
-        XtRealizeWidget(wdata->winData.shell);
-    }
-    XtManageChild(wdata->winData.comp.widget);
-    XtSetMappedWhenManaged(wdata->winData.shell, True);
-    XtPopup(wdata->winData.shell, XtGrabNone);
-    wdata->isShowing = True;
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Create a local managed widget inside a given X window.
- * We allocate a top-level shell and then reparent it into the
- * given window id.
- *
- * This is used to take the X11 window ID that has been passed
- * to us by our parent Navigator plugin and return a widget
- * that can be used as the base for our Java EmbeddeFrame.
- *
- * Note that the ordering of the various calls is tricky here as
- * we have to cope with the variations between 1.1.3, 1.1.6,
- * and 1.2.
- */
-JNIEXPORT jlong JNICALL
-Java_sun_awt_motif_MEmbeddedFrame_getWidget(
-                JNIEnv *env, jclass clz, jlong winid)
-{
-    Arg args[40];
-    int argc;
-    Widget w;
-    Window child, parent;
-    Visual *visual;
-    Colormap cmap;
-    int depth;
-    int ncolors;
-
-    /*
-     * Create a top-level shell.  Note that we need to use the
-     * AWT's own awt_display to initialize the widget.  If we
-     * try to create a second X11 display connection the Java
-     * runtimes get very confused.
-     */
-    AWT_LOCK();
-
-    argc = 0;
-    XtSetArg(args[argc], XtNsaveUnder, False); argc++;
-    XtSetArg(args[argc], XtNallowShellResize, False); argc++;
-
-    /* the awt initialization should be done by now (awt_GraphicsEnv.c) */
-
-    getAwtData(&depth,&cmap,&visual,&ncolors,NULL);
-
-    XtSetArg(args[argc], XtNvisual, visual); argc++;
-    XtSetArg(args[argc], XtNdepth, depth); argc++;
-    XtSetArg(args[argc], XtNcolormap, cmap); argc++;
-
-    XtSetArg(args[argc], XtNwidth, 1); argc++;
-    XtSetArg(args[argc], XtNheight, 1); argc++;
-    /* The shell has to have relative coords of O,0? */
-    XtSetArg(args[argc], XtNx, 0); argc++;
-    XtSetArg(args[argc], XtNy, 0); argc++;
-
-    /* The shell widget starts out as a top level widget.
-     * Without intervention, it will be managed by the window
-     * manager and will be its own widow. So, until it is reparented,
-     *  we don't map it.
-     */
-    XtSetArg(args[argc], XtNmappedWhenManaged, False); argc++;
-
-    w = XtAppCreateShell("AWTapp","XApplication",
-                                    vendorShellWidgetClass,
-                                    awt_display,
-                                    args,
-                                    argc);
-    XtRealizeWidget(w);
-
-    /*
-     * Now reparent our new Widget into our Navigator window
-     */
-    parent = (Window) winid;
-    child = XtWindow(w);
-    XReparentWindow(awt_display, child, parent, 0, 0);
-    XFlush(awt_display);
-    XSync(awt_display, False);
-    XtVaSetValues(w, XtNx, 0, XtNy, 0, NULL);
-    XFlush(awt_display);
-    XSync(awt_display, False);
-
-    AWT_UNLOCK();
-
-    return (jlong)w;
-}
-
-/*
- * Make sure the given widget is mapped.
- *
- * This isn't necessary on JDK 1.1.5 but is needed on JDK 1.1.4
- */
-JNIEXPORT jint JNICALL
-Java_sun_awt_motif_MEmbeddedFrame_mapWidget(JNIEnv *env, jclass clz, jlong widget)
-{
-    Widget w = (Widget)widget;
-    /*
-     * this is what JDK 1.1.5 does in MFramePeer.pShow.
-     */
-    AWT_LOCK();
-    XtSetMappedWhenManaged(w, True);
-    XtPopup(w, XtGrabNone);
-    AWT_UNLOCK();
-    return (jint) 1;
-}
-
-
-JNIEXPORT jboolean JNICALL
-Java_sun_awt_motif_MEmbeddedFramePeer_isXEmbedActive(JNIEnv *env, jobject this)
-{
-    struct FrameData *wdata;
-    Boolean res;
-
-    AWT_LOCK();
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL ||
-        wdata->winData.comp.widget == NULL ||
-        wdata->winData.shell == NULL ||
-        wdata->mainWindow == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return False;
-    }
-
-    res = isXEmbedActive(wdata);
-    AWT_UNLOCK();
-    return res;
-
-}
-
-JNIEXPORT jboolean JNICALL
-Java_sun_awt_motif_MEmbeddedFramePeer_isXEmbedApplicationActive(JNIEnv *env, jobject this)
-{
-    struct FrameData *wdata;
-    Boolean res;
-
-    AWT_LOCK();
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL ||
-        wdata->winData.comp.widget == NULL ||
-        wdata->winData.shell == NULL ||
-        wdata->mainWindow == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return False;
-    }
-
-    res = isXEmbedApplicationActive(wdata);
-    AWT_UNLOCK();
-    return res;
-
-}
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MEmbeddedFramePeer_requestXEmbedFocus(JNIEnv *env, jobject this)
-{
-    struct FrameData *wdata;
-
-    AWT_LOCK();
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-    if (wdata == NULL ||
-        wdata->winData.comp.widget == NULL ||
-        wdata->winData.shell == NULL ||
-        wdata->mainWindow == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    requestXEmbedFocus(wdata);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    setSaveUnder
- * Signature: (Z)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MWindowPeer_setSaveUnder
-(JNIEnv *env, jobject this, jboolean state)
-{
-    struct FrameData    *wdata;
-    jobject             target;
-
-    AWT_LOCK();
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL ||
-        wdata->winData.comp.widget == NULL ||
-        wdata->winData.shell == NULL ||
-        JNU_IsNull(env, target)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        if  (!JNU_IsNull(env, target))
-            (*env)->DeleteLocalRef(env, target);
-        AWT_UNLOCK();
-        return;
-    }
-
-    XtVaSetValues(wdata->winData.shell, XmNsaveUnder, state, NULL);
-
-    AWT_FLUSH_UNLOCK();
-}
-
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    setFocusableWindow
- * Signature: (Z)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MWindowPeer_setFocusableWindow
-(JNIEnv *env, jobject this, jboolean isFocusableWindow)
-{
-    struct FrameData    *wdata;
-    jobject             target;
-
-    AWT_LOCK();
-
-    target = (*env)->GetObjectField(env, this, mComponentPeerIDs.target);
-
-    wdata = (struct FrameData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (wdata == NULL ||
-        wdata->winData.comp.widget == NULL ||
-        wdata->winData.shell == NULL ||
-        JNU_IsNull(env, target)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        if  (!JNU_IsNull(env, target))
-            (*env)->DeleteLocalRef(env, target);
-        AWT_UNLOCK();
-        return;
-    }
-
-    wdata->isFocusableWindow = isFocusableWindow;
-
-    AWT_FLUSH_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MWindowPeer
- * Method:    resetTargetGC
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MWindowPeer_resetTargetGC
-  (JNIEnv * env, jobject this, jobject target)
-{
-    (*env)->CallVoidMethod(env, target, windowIDs.resetGCMID);
-}
-
-
-/*
- * Old, compatibility, backdoor for DT.  This is a different
- * implementation.  It keeps the signature, but acts on
- * awt_root_shell, not the frame passed as an argument.  Note, that
- * the code that uses the old backdoor doesn't work correctly with
- * gnome session proxy that checks for WM_COMMAND when the window is
- * firts mapped, because DT code calls this old backdoor *after* the
- * frame is shown or it would get NPE with old AWT (previous
- * implementation of this backdoor) otherwise.  Old style session
- * managers (e.g. CDE) that check WM_COMMAND only during session
- * checkpoint should work fine, though.
- *
- * NB: The function name looks deceptively like a JNI native method
- * name.  It's not!  It's just a plain function.
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_XsessionWMcommand(JNIEnv *env, jobject this,
-    jobject frame, jstring jcommand)
-{
-    const char *command;
-    XTextProperty text_prop;
-    char *c[1];
-    int32_t status;
-
-    AWT_LOCK();
-
-    if (awt_root_shell == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    if (XtWindow(awt_root_shell) == None) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    /* need to convert ctitle to CompoundText */
-    command = (char *) JNU_GetStringPlatformChars(env, jcommand, NULL);
-    c[0] = (char *)command;
-    status = XmbTextListToTextProperty(awt_display, c, 1,
-                                       XStdICCTextStyle, &text_prop);
-
-    if (status == Success || status > 0) {
-        XSetTextProperty(awt_display, XtWindow(awt_root_shell),
-                         &text_prop, XA_WM_COMMAND);
-        if (text_prop.value != NULL)
-            XFree(text_prop.value);
-    }
-
-    JNU_ReleaseStringPlatformChars(env, jcommand, command);
-
-    AWT_UNLOCK();
-    return;
-}
-
-
-/*
- * New DT backdoor to set WM_COMMAND.  New code should use this
- * backdoor and call it *before* the first frame is shown so that
- * gnome session proxy can correctly handle it.
- *
- * NB: The function name looks deceptively like a JNI native method
- * name.  It's not!  It's just a plain function.
- */
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_XsessionWMcommand_New(JNIEnv *env, jobjectArray jargv)
-{
-    static const char empty[] = "";
-
-    int argc;
-    const char **cargv;
-    XTextProperty text_prop;
-    int status;
-    int i;
-
-    AWT_LOCK();
-
-    if (awt_root_shell == NULL) {
-        JNU_ThrowNullPointerException(env, "AWT root shell");
-        AWT_UNLOCK();
-        return;
-    }
-
-    if (XtWindow(awt_root_shell) == None) {
-        JNU_ThrowNullPointerException(env, "AWT root shell is unrealized");
-        AWT_UNLOCK();
-        return;
-    }
-
-    argc = (int)(*env)->GetArrayLength(env, jargv);
-    if (argc == 0) {
-        /* nothing to do */
-        AWT_UNLOCK();
-        return;
-    }
-
-    /* array of C strings */
-    cargv = (const char **)calloc(argc, sizeof(char *));
-    if (cargv == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "Unable to allocate cargv");
-        AWT_UNLOCK();
-        return;
-    }
-
-    /* fill C array with platform chars of java strings */
-    for (i = 0; i < argc; ++i) {
-        jstring js;
-        const char *cs;
-
-        cs = NULL;
-        js = (*env)->GetObjectArrayElement(env, jargv, i);
-        if (js != NULL) {
-            cs = JNU_GetStringPlatformChars(env, js, NULL);
-        }
-        if (cs == NULL) {
-            cs = empty;
-        }
-
-        cargv[i] = cs;
-        (*env)->DeleteLocalRef(env, js);
-    }
-
-    /* grr, X prototype doesn't declare cargv as const, thought it really is */
-    status = XmbTextListToTextProperty(awt_display, (char **)cargv, argc,
-                                       XStdICCTextStyle, &text_prop);
-    if (status < 0) {
-        switch (status) {
-        case XNoMemory:
-            JNU_ThrowOutOfMemoryError(env,
-                "XmbTextListToTextProperty: XNoMemory");
-            break;
-        case XLocaleNotSupported:
-            JNU_ThrowInternalError(env,
-                "XmbTextListToTextProperty: XLocaleNotSupported");
-            break;
-        case XConverterNotFound:
-            JNU_ThrowNullPointerException(env,
-                "XmbTextListToTextProperty: XConverterNotFound");
-            break;
-        default:
-            JNU_ThrowInternalError(env,
-                "XmbTextListToTextProperty: unknown error");
-        }
-    } else {
-        /*
-         * status == Success (i.e. 0) or
-         * status > 0 - a number of unconvertible characters
-         *              (cannot happen for XStdICCTextStyle).
-         */
-        XSetTextProperty(awt_display, XtWindow(awt_root_shell),
-                         &text_prop, XA_WM_COMMAND);
-    }
-
-    /* release platform chars */
-    for (i = 0; i < argc; ++i) {
-        jstring js;
-
-        if (cargv[i] == empty)
-            continue;
-
-        js = (*env)->GetObjectArrayElement(env, jargv, i);
-        JNU_ReleaseStringPlatformChars(env, js, cargv[i]);
-        (*env)->DeleteLocalRef(env, js);
-    }
-    if (text_prop.value != NULL)
-      XFree(text_prop.value);
-
-    AWT_UNLOCK();
-    return;
-}
-
-/*
- * Class:     java_awt_TrayIcon
- * Method:    initIDs
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_java_awt_TrayIcon_initIDs(JNIEnv *env , jclass clazz)
-{
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_xembed.c openjdk/jdk/src/solaris/native/sun/awt/awt_xembed.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_xembed.c	2014-04-08 05:27:03.466875324 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_xembed.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,430 +0,0 @@
-/*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-
-#include <X11/Xproto.h>
-#include <X11/Xlib.h>
-#include <X11/Xatom.h>
-#include <Xm/MwmUtil.h>
-
-/* JNI headers */
-#include "java_awt_Frame.h"     /* for frame state constants */
-
-#include "awt_wm.h"
-#include "awt_util.h"           /* for X11 error handling macros */
-#include "awt_xembed.h"
-#include "awt_MToolkit.h"
-#include "awt_DataTransferer.h"   /* for DECLARE_XXX macros */
-
-#ifdef DOTRACE
-#define MTRACE(param) fprintf(myerr, param)
-#define MTRACEP1(format, p1) fprintf(myerr, format, p1)
-#define MTRACEP2(format, p1, p2) fprintf(myerr, format, p1, p2)
-#define MTRACEP3(format, p1, p2, p3) fprintf(myerr, format, p1, p2, p3)
-#define MTRACEP4(format, p1, p2, p3, p4) fprintf(myerr, format, p1, p2, p3, p4)
-#define MTRACEP5(format, p1, p2, p3, p4, p5) fprintf(myerr, format, p1, p2, p3, p4, p5)
-#define MTRACEP6(format, p1, p2, p3, p4, p5, p6) fprintf(myerr, format, p1, p2, p3, p4, p5, p6)
-#define MTRACEP7(format, p1, p2, p3, p4, p5, p6, p7) fprintf(myerr, format, p1, p2, p3, p4, p5, p6, p7)
-#else
-#define MTRACE(param)
-#define MTRACEP1(format, p1)
-#define MTRACEP2(format, p1, p2)
-#define MTRACEP3(format, p1, p2, p3)
-#define MTRACEP4(format, p1, p2, p3, p4)
-#define MTRACEP5(format, p1, p2, p3, p4, p5)
-#define MTRACEP6(format, p1, p2, p3, p4, p5, p6)
-#define MTRACEP7(format, p1, p2, p3, p4, p5, p6, p7)
-#endif
-
-#ifdef DOTRACE
-static FILE* myerr;
-#endif
-
-static Window getParent(Window window);
-static Window getEmbedder(Window client);
-static jmethodID handleFocusInMID;
-
-const char * error_msg = "UNKNOWN XEMBED MESSAGE";
-
-const char * xembed_strs[] = {
-    "EMBEDDED_NOTIFY",
-    "WINDOW_ACTIVATE",
-    "WINDOW_DEACTIVATE",
-    "REQUEST_FOCUS",
-    "FOCUS_IN",
-    "FOCUS_OUT",
-    "FOCUS_NEXT",
-    "FOCUS_PREV" ,
-    "GRAB_KEY",
-    "UNGRAB_KEY",
-    "MODALITY_ON" ,
-    "MODALITY_OFF",
-    "REGISTER_ACCELERATOR",
-    "UNREGISTER_ACCELERATOR",
-    "ACTIVATE_ACCELERATOR"
-};
-
-const char *
-msg_to_str(int msg) {
-    if (msg >= 0 && msg <= XEMBED_LAST_MSG) {
-        return xembed_strs[msg];
-    } else {
-        return error_msg;
-    }
-}
-
-DECLARE_JAVA_CLASS(MEmbeddedFramePeerClass, "sun/awt/motif/MEmbeddedFramePeer");
-
-typedef struct _xembed_info {
-    CARD32 version;
-    CARD32 flags;
-} xembed_info;
-
-typedef struct _xembed_data {
-    struct FrameData * wdata; // pointer to EmbeddedFrame wdata
-    Window client; // pointer to plugin intermediate widget, XEmbed client
-    Boolean active; // whether xembed is active for this client
-    Boolean applicationActive; // whether the embedding application is active
-    Window embedder; // Window ID of the embedder
-    struct _xembed_data * next;
-} xembed_data, * pxembed_data;
-
-static pxembed_data xembed_list = NULL;
-
-static pxembed_data
-getData(Window client) {
-    pxembed_data temp = xembed_list;
-    while (temp != NULL) {
-        if (temp->client == client) {
-            return temp;
-        }
-        temp = temp->next;
-    }
-    return NULL;
-}
-
-static pxembed_data
-getDataByFrame(struct FrameData* wdata) {
-    pxembed_data temp = xembed_list;
-    while (temp != NULL) {
-        if (temp->wdata == wdata) {
-            return temp;
-        }
-        temp = temp->next;
-    }
-    return NULL;
-}
-
-static pxembed_data
-addData(Window client) {
-    xembed_data * data = malloc(sizeof(xembed_data));
-    memset(data, 0, sizeof(xembed_data));
-    data->client = client;
-    data->next = xembed_list;
-    xembed_list = data;
-    return data;
-}
-
-static void
-removeData(Window client) {
-    pxembed_data * temp = &xembed_list;
-    while (*temp != NULL) {
-        if ((*temp)->client == client) {
-            xembed_data * data = *temp;
-            *temp = (*temp)->next;
-            free(data);
-            return;
-        }
-        temp = &(*temp)->next;
-    }
-}
-
-static Atom XA_XEmbedInfo;
-static Atom XA_XEmbed;
-
-void
-init_xembed() {
-    XA_XEmbedInfo = XInternAtom(awt_display, "_XEMBED_INFO", False);
-    XA_XEmbed = XInternAtom(awt_display, "_XEMBED", False);
-#ifdef DOTRACE
-    myerr = fopen("xembedclient.log","w");
-#endif
-}
-
-static Time
-getCurrentServerTime() {
-    return awt_util_getCurrentServerTime();
-}
-
-
-void
-sendMessageHelper(Window window, int message, long detail,
-                              long data1, long data2)
-{
-    JNIEnv      *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    XEvent ev;
-    XClientMessageEvent * req = (XClientMessageEvent*)&ev;
-    memset(&ev, 0, sizeof(ev));
-
-    req->type = ClientMessage;
-    req->window = window;
-    req->message_type = XA_XEmbed;
-    req->format = 32;
-    req->data.l[0] = getCurrentServerTime();
-    req->data.l[1] = message;
-    req->data.l[2] = detail;
-    req->data.l[3] = data1;
-    req->data.l[4] = data2;
-    AWT_LOCK();
-    XSendEvent(awt_display, window, False, NoEventMask, &ev);
-    AWT_UNLOCK();
-}
-
-void
-sendMessage(Window window, int message) {
-    sendMessageHelper(window, message, 0, 0, 0);
-}
-
-
-static Window
-getParent(Window window) {
-    Window root, parent = None, *children = NULL;
-    unsigned int count;
-    XQueryTree(awt_display, window, &root, &parent, &children, &count);
-    if (children != NULL) {
-        XFree(children);
-    }
-    return parent;
-}
-
-static Window
-getEmbedder(Window client) {
-    return getParent(client);
-}
-
-
-static void
-handleFocusIn(struct FrameData* wdata, int detail) {
-    JNIEnv      *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    struct WidgetInfo* winfo;
-    MTRACE("HandleFocusIn\n");
-    winfo = findWidgetInfo(wdata->winData.comp.widget);
-    if (winfo != NULL) {
-        jobject peer = winfo->peer;
-        if (handleFocusInMID == NULL) {
-            jclass clazz = (*env)->FindClass(env, "sun/awt/motif/MEmbeddedFramePeer");
-            DASSERT(clazz != NULL);
-            handleFocusInMID = (*env)->GetMethodID(env, clazz, "handleFocusIn", "(I)V");
-            DASSERT(handleFocusInMID != NULL);
-            if (clazz != NULL) {
-                (*env)->DeleteLocalRef(env, clazz);
-            }
-        }
-        if (handleFocusInMID != NULL) {
-            (*env)->CallVoidMethod(env, peer, handleFocusInMID, (jint)detail);
-        }
-    }
-}
-
-static void
-genWindowFocus(struct FrameData *wdata, Boolean gain) {
-    XEvent ev;
-    JNIEnv      *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    memset(&ev, 0, sizeof(ev));
-
-    ev.type = (gain?FocusIn:FocusOut);
-    ev.xany.send_event = True;
-    ev.xany.display = awt_display;
-    ev.xfocus.mode = NotifyNormal;
-    ev.xfocus.detail = NotifyNonlinear;
-    ev.xfocus.window = XtWindow(wdata->winData.shell);
-    awt_put_back_event(env, &ev);
-}
-
-extern Boolean skipNextFocusIn;
-
-static void
-callNotifyStarted(JNIEnv* env, jobject peer) {
-    DECLARE_VOID_JAVA_METHOD(notifyStartedMID, MEmbeddedFramePeerClass,
-                             "notifyStarted", "()V");
-
-    (*env)->CallVoidMethod(env, peer, notifyStartedMID);
-}
-
-void
-xembed_eventHandler(XEvent *event)
-{
-    JNIEnv      *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    struct FrameData *wdata;
-    xembed_data * data;
-
-    data = getData(event->xany.window);
-    if (data == NULL) {
-        MTRACEP1("No XEMBED client registered for this window %x\n", event->xany.window);
-        if (event->xany.type == ClientMessage) {
-            MTRACEP7("Unprocessed handleClientMessage: type=%d 0=%ld 1=%ld(%s) 2=%ld 3=%ld 4=%ld\n",
-                     event->xclient.message_type, event->xclient.data.l[0],
-                     event->xclient.data.l[1], msg_to_str(event->xclient.data.l[1]),
-                     event->xclient.data.l[2],
-                     event->xclient.data.l[3], event->xclient.data.l[4]);
-        }
-        return;
-    }
-
-    wdata = data->wdata;
-
-    if (event->xany.type == ClientMessage) {
-        MTRACEP6("handleClientMessage: type=%d 0=%ld 1=%ld 2=%ld 3=%ld 4=%ld\n",
-                 event->xclient.message_type, event->xclient.data.l[0],
-                 event->xclient.data.l[1], event->xclient.data.l[2],
-                 event->xclient.data.l[3], event->xclient.data.l[4]);
-        // Probably a message from embedder
-        if (event->xclient.message_type == XA_XEmbed) {
-            // XEmbed message, data[1] contains message
-            switch ((int)event->xclient.data.l[1]) {
-              case XEMBED_EMBEDDED_NOTIFY:
-                  MTRACE("EMBEDDED_NOTIFY\n");
-                  data->active = True;
-                  data->embedder = getEmbedder(data->client);
-                  // If Frame has not been reparented already we should "reparent"
-                  // it manually
-                  if (!(wdata->reparented)) {
-                      wdata->reparented = True;
-                      // in XAWT we also update WM_NORMAL_HINTS here.
-                  }
-                  {
-                      struct WidgetInfo* winfo =
-                          findWidgetInfo(wdata->winData.comp.widget);
-                      JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_4);
-                      if (winfo != NULL) {
-                          callNotifyStarted(env, winfo->peer);
-                      }
-                  }
-                  MTRACE("Embedded notify in client\n");
-                  break;
-              case XEMBED_WINDOW_DEACTIVATE:
-                  MTRACE("DEACTIVATE\n");
-                  data->applicationActive = False;
-                  break;
-              case XEMBED_WINDOW_ACTIVATE:
-                  MTRACE("ACTIVATE\n");
-                  data->applicationActive = True;
-                  break;
-              case XEMBED_FOCUS_IN:
-                  MTRACE("FOCUS IN\n");
-                  skipNextFocusIn = False;
-                  handleFocusIn(wdata, (int)(event->xclient.data.l[2]));
-                  genWindowFocus(wdata, True);
-                  break;
-              case XEMBED_FOCUS_OUT:
-                  MTRACE("FOCUS OUT\n");
-                  genWindowFocus(wdata, False);
-                  break;
-            }
-        }
-    } else if (event->xany.type == ReparentNotify) {
-        data->embedder = event->xreparent.parent;
-    }
-}
-
-void
-notify_ready(Window client) {
-    sendMessage(getEmbedder(client), _SUN_XEMBED_START);
-}
-
-void
-install_xembed(Widget client_widget, struct FrameData* wdata) {
-    JNIEnv      *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    xembed_info info = {XEMBED_VERSION, XEMBED_MAPPED};
-    Window client = XtWindow(client_widget);
-    xembed_data * data;
-
-    AWT_LOCK();
-    data = addData(client);
-    data->wdata = wdata;
-
-    // Install event handler for messages from embedder
-    XSelectInput(awt_display, client, StructureNotifyMask);
-
-    // Install XEMBED_INFO information
-    XChangeProperty(awt_display, client, XA_XEmbedInfo,
-                    XA_XEmbedInfo, 32, PropModeReplace,
-                    (unsigned char*)&info, 2);
-    MTRACE("Installing xembed\n");
-
-    notify_ready(client);
-
-    AWT_UNLOCK();
-}
-
-void
-deinstall_xembed(struct FrameData* wdata) {
-    xembed_data * data = getDataByFrame(wdata);
-
-    if (data != NULL) {
-        removeData(data->client);
-    }
-}
-
-void
-requestXEmbedFocus(struct FrameData * wdata) {
-    xembed_data * data = getDataByFrame(wdata);
-
-    if (data != NULL) {
-        if (data->active && data->applicationActive) {
-            sendMessage(data->embedder, XEMBED_REQUEST_FOCUS);
-        }
-    }
-}
-
-Boolean
-isXEmbedActive(struct FrameData * wdata) {
-    xembed_data * data = getDataByFrame(wdata);
-    return (data != NULL && data->active);
-}
-
-Boolean
-isXEmbedActiveByWindow(Window client) {
-    xembed_data * data = getData(client);
-    return (data != NULL && data->active);
-}
-
-
-Boolean
-isXEmbedApplicationActive(struct FrameData * wdata) {
-    xembed_data * data = getDataByFrame(wdata);
-    return (data != NULL && data->applicationActive);
-}
-
-void
-xembed_traverse_out(struct FrameData * wdata, jboolean direction) {
-    xembed_data * data = getDataByFrame(wdata);
-    sendMessage(data->embedder, (direction == JNI_TRUE)?XEMBED_FOCUS_NEXT:XEMBED_FOCUS_PREV);
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_XmDnD.c openjdk/jdk/src/solaris/native/sun/awt/awt_XmDnD.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_XmDnD.c	2014-04-08 05:27:03.454875147 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_XmDnD.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2282 +0,0 @@
-/*
- * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include <stdio.h>
-#include <string.h>
-
-#include "jvm.h"
-#include "jni.h"
-#include "jni_util.h"
-#include "jlong.h"
-
-#include "awt_DataTransferer.h"
-#include "awt_XmDnD.h"
-
-#include "awt_p.h"
-
-#include "java_awt_Cursor.h"
-#include "java_awt_dnd_DnDConstants.h"
-#include "java_awt_event_MouseEvent.h"
-#include "sun_awt_dnd_SunDragSourceContextPeer.h"
-#include "sun_awt_motif_MComponentPeer.h"
-#include "sun_awt_motif_MDragSourceContextPeer.h"
-#include "sun_awt_motif_MDropTargetContextPeer.h"
-
-#include <X11/cursorfont.h>
-#include <X11/Xutil.h>
-/*
- * Fix for 4285634.
- * Include the private Motif header to enable access to lastEventState.
- */
-#include <Xm/DragCP.h>
-
-#include "awt_Component.h"
-#include "awt_Cursor.h"
-#include "awt_AWTEvent.h"
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern struct CursorIDs cursorIDs;
-extern struct ContainerIDs containerIDs;
-
-/* globals */
-
-
-/* forwards */
-
-static void awt_XmDropProc(Widget, XtPointer, XmDropProcCallbackStruct*);
-static void awt_XmDragProc(Widget, XtPointer, XmDragProcCallbackStruct*);
-
-static void awt_XmTransferProc(Widget, XtPointer, Atom*, Atom*, XtPointer,
-                               unsigned long*, int32_t*);
-
-/* for XmDragContext callbacks etc ... */
-static void awt_XmDragEnterProc(Widget, XtPointer,
-                                XmDropSiteEnterCallbackStruct*);
-static void awt_XmDragMotionProc(Widget, XtPointer,
-                                 XmDragMotionCallbackStruct*);
-static void awt_XmDragLeaveProc(Widget, XtPointer,
-                                XmDropSiteLeaveCallbackStruct*);
-static void awt_XmDropOperationChangedProc(Widget, XtPointer,
-                                           XmDropStartCallbackStruct*);
-static void awt_XmDropFinishProc(Widget, XtPointer,
-                                 XmDropFinishCallbackStruct*);
-
-static unsigned char DnDConstantsToXm(jint operations);
-static jint XmToDnDConstants(unsigned char operations);
-static unsigned char selectOperation(unsigned char operations);
-
-static void flush_cache(JNIEnv* env);
-static void    cacheDropDone(Boolean dropDone);
-static Boolean isDropDone();
-
-static void setCursor(JNIEnv* env, Display* d, jobject c, jint type, Time t);
-
-static Atom MOTIF_DROP_ATOM = None;
-
-/* in canvas.c */
-extern jint getModifiers(uint32_t state, jint button, jint keyCode);
-
-/**
- * static cache of DropTarget related info.
- */
-
-static struct {
-    Widget        w;                /* if NULL, cache invalid */
-
-    jobject       peer;
-    jobject       component;
-
-    jobject       dtcpeer;
-
-    Widget        dt;
-
-    jlongArray    targets;
-    Cardinal      nTargets;
-
-    Boolean       dropDone;
-    int32_t       transfersPending;
-    Widget        transfer;
-
-    jint          dropAction;       /* used only on JVM transfers */
-
-    Boolean       flushPending;
-
-    Window win;
-    uint32_t state;
-} _cache;
-
-uint32_t
-buttonToMask(uint32_t button) {
-    switch (button) {
-        case Button1:
-            return Button1Mask;
-        case Button2:
-            return Button2Mask;
-        case Button3:
-            return Button3Mask;
-        case Button4:
-            return Button4Mask;
-        case Button5:
-            return Button5Mask;
-        default:
-            return 0;
-    }
-}
-
-/* Fix for 4215643: extract the values cached on drag start and send
-   ButtonRelease event to the window which originated the drag */
-
-void
-dragsource_track_release(Widget w, XtPointer client_data,
-                         XEvent * event, Boolean * cont)
-{
-    DASSERT (event != NULL);
-
-    if (_cache.win != None &&
-        (buttonToMask(event->xbutton.button) & _cache.state)) {
-
-        JNIEnv *env = (JNIEnv *) JNU_GetEnv(jvm, JNI_VERSION_1_2);
-        Window win = event->xbutton.window;
-        event->xbutton.window = _cache.win;
-        awt_put_back_event(env, event);
-        event->xbutton.window = win;
-        _cache.win = None;
-        _cache.state = 0;
-        XtRemoveEventHandler(w, ButtonReleaseMask, False,
-                             dragsource_track_release, NULL);
-    }
-}
-
-static void
-cancel_drag(XtPointer client_data, XtIntervalId* id) {
-    Time time = awt_util_getCurrentServerTime();
-    Widget dc = XmGetDragContext(awt_root_shell, time);
-
-    if (dc != NULL) {
-        Boolean sourceIsExternal = True;
-        XtVaGetValues(dc, XmNsourceIsExternal, &sourceIsExternal, NULL);
-        if (!sourceIsExternal) {
-            XEvent xevent;
-            XmDragCancel(dc);
-
-            /*
-             * When running the internal drag-and-drop event loop
-             * (see DragC.c:InitiatorMainLoop) Motif DnD uses XtAppNextEvent,
-             * that processes all timer callbacks and then returns the next X
-             * event from the queue. Motif DnD doesn't check if the drag
-             * operation is cancelled after XtAppNextEvent returns and processes
-             * the returned event. When the drag operation is cancelled the
-             * XmDragContext widget is destroyed and Motif will crash if the new
-             * event is dispatched to the destroyed XmDragContext.
-             * We cancel the drag operation in the timer callback, so we putback
-             * a dummy X event. This event will be returned from XtAppNextEvent
-             * and Motif DnD will safely exit from the internal event loop.
-             */
-            xevent.type = LASTEvent;
-            xevent.xany.send_event = True;
-            xevent.xany.display = awt_display;
-            xevent.xany.window = XtWindow(awt_root_shell);
-            XPutBackEvent(awt_display, &xevent);
-        }
-    }
-}
-
-#define DONT_CARE -1
-
-static void
-awt_popupCallback(Widget shell, XtPointer closure, XtPointer call_data) {
-    XtGrabKind grab_kind = XtGrabNone;
-
-    if (call_data != NULL) {
-        grab_kind = *((XtGrabKind*)call_data);
-    }
-
-    if (XmIsVendorShell(shell)) {
-        int input_mode;
-        XtVaGetValues(shell, XmNmwmInputMode, &input_mode, NULL);
-        switch (input_mode) {
-        case DONT_CARE:
-        case MWM_INPUT_MODELESS:
-            grab_kind = XtGrabNonexclusive; break;
-        case MWM_INPUT_PRIMARY_APPLICATION_MODAL:
-        case MWM_INPUT_SYSTEM_MODAL:
-        case MWM_INPUT_FULL_APPLICATION_MODAL:
-            grab_kind = XtGrabExclusive; break;
-        }
-    }
-
-    if (grab_kind == XtGrabExclusive) {
-        /*
-         * We should cancel the drag on the toolkit thread. Otherwise, it can be
-         * called while the toolkit thread is waiting inside some drag callback.
-         * In this case Motif will crash when the drag callback returns.
-         */
-        XtAppAddTimeOut(awt_appContext, 0L, cancel_drag, NULL);
-    }
-}
-
-static XtInitProc xt_shell_initialize = NULL;
-
-static void
-awt_ShellInitialize(Widget req, Widget new, ArgList args, Cardinal *num_args) {
-    XtAddCallback(new, XtNpopupCallback, awt_popupCallback, NULL);
-    (*xt_shell_initialize)(req, new, args, num_args);
-}
-
-/*
- * Fix for 4484572.
- * Modify the 'initialize' routine for all ShellWidget instances, so that it
- * will install an XtNpopupCallback that cancels the current drag operation.
- * It is needed, since AWT doesn't have full control over all ShellWidget
- * instances (e.g. XmPopupMenu internally creates and popups an XmMenuShell).
- */
-static void
-awt_set_ShellInitialize() {
-    static Boolean inited = False;
-
-    DASSERT(!inited);
-    if (inited) {
-        return;
-    }
-
-    xt_shell_initialize = shellWidgetClass->core_class.initialize;
-    shellWidgetClass->core_class.initialize = (XtInitProc)awt_ShellInitialize;
-    inited = True;
-}
-
-/**
- * global function to initialize this client as a Dynamic-only app.
- *
- * gets called once during toolkit initialization.
- */
-
-void awt_initialize_Xm_DnD(Display* dpy) {
-    JNIEnv* env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jclass  clazz;
-
-    XtVaSetValues(XmGetXmDisplay(dpy),
-                  XmNdragInitiatorProtocolStyle, XmDRAG_DYNAMIC,
-                  XmNdragReceiverProtocolStyle,  XmDRAG_DYNAMIC,
-                  NULL
-                  );
-
-    MOTIF_DROP_ATOM = XInternAtom(dpy, _XA_MOTIF_DROP, False);
-    if (XSaveContext(dpy, MOTIF_DROP_ATOM, awt_convertDataContext,
-                     (XPointer)NULL) == XCNOMEM) {
-        JNU_ThrowInternalError(env, "");
-        return;
-    }
-
-    /* No drop in progress. */
-    cacheDropDone(True);
-
-    /*
-     * Fix for BugTraq ID 4407057.
-     * Have to disable Motif default drag support, since it doesn't work
-     * reliably with our event dispatch mechanism. To do this we allow a drag
-     * operation only if it is registered on the awt_root_shell.
-     */
-    awt_motif_enableSingleDragInitiator(awt_root_shell);
-
-    awt_set_ShellInitialize();
-
-    /*
-     * load the Cursor stuff
-     */
-
-    clazz = (*env)->FindClass(env, "sun/awt/motif/MCustomCursor");
-
-    if (!JNU_IsNull(env, ((*env)->ExceptionOccurred(env)))) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-}
-
-typedef struct DSInfoRec {
-    Widget         widget;
-
-    Pixmap         animation_mask;
-    Pixmap         animation_pixmap;
-    int32_t        animation_pixmap_depth;
-    unsigned char  animation_style;
-    XtPointer      client_data;
-    XtCallbackProc drag_proc;
-    XtCallbackProc drop_proc;
-    XRectangle     *drop_rectangles;
-    unsigned char  drop_site_activity;
-    unsigned char  drop_site_operations;
-    unsigned char  drop_site_type;
-    Atom           *import_targets;
-    Cardinal       num_drop_rectangles;
-    Cardinal       num_import_targets;
-
-    struct DSInfoRec* next;
-} DSInfoRec, * DSInfoPtr;
-
-#define ARG_COUNT 14
-
-/*
- * Allocates DSInfoRect structure, retrieves all attributes of a Motif drop site
- * registered on the specified widget and puts them into the allocated storage.
- * The caller should free the storage after use.
- */
-DSInfoPtr get_drop_site_info(Widget w) {
-    Arg       arglist[ARG_COUNT];
-    Cardinal  argcount = 0;
-    DSInfoPtr info = ZALLOC(DSInfoRec);
-
-    if (info == NULL) {
-        JNIEnv* env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-        JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-        return NULL;
-    }
-
-    XtSetArg(arglist[argcount], XmNanimationMask,
-             (XtArgVal)&info->animation_mask); argcount++;
-    XtSetArg(arglist[argcount], XmNanimationPixmap,
-             (XtArgVal)&info->animation_pixmap); argcount++;
-    XtSetArg(arglist[argcount], XmNanimationPixmapDepth,
-             (XtArgVal)&info->animation_pixmap_depth); argcount++;
-    XtSetArg(arglist[argcount], XmNanimationStyle,
-             (XtArgVal)&info->animation_style); argcount++;
-    XtSetArg(arglist[argcount], XmNclientData,
-             (XtArgVal)&info->client_data); argcount++;
-    XtSetArg(arglist[argcount], XmNdragProc,
-             (XtArgVal)&info->drag_proc); argcount++;
-    XtSetArg(arglist[argcount], XmNdropProc,
-             (XtArgVal)&info->drop_proc); argcount++;
-    XtSetArg(arglist[argcount], XmNdropSiteActivity,
-             (XtArgVal)&info->drop_site_activity); argcount++;
-    XtSetArg(arglist[argcount], XmNdropSiteOperations,
-             (XtArgVal)&info->drop_site_operations); argcount++;
-    XtSetArg(arglist[argcount], XmNdropSiteType,
-             (XtArgVal)&info->drop_site_type); argcount++;
-    XtSetArg(arglist[argcount], XmNnumDropRectangles,
-             (XtArgVal)&info->num_drop_rectangles); argcount++;
-    XtSetArg(arglist[argcount], XmNnumImportTargets,
-             (XtArgVal)&info->num_import_targets); argcount++;
-    DASSERT(argcount == ARG_COUNT - 2);
-
-    XmDropSiteRetrieve(w, arglist, argcount);
-
-    if (info->num_import_targets > 0) {
-        Atom *targets = NULL;
-
-        info->import_targets = malloc(info->num_import_targets * sizeof(Atom));
-
-        if (info->import_targets == NULL) {
-            JNIEnv* env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-            free(info);
-            JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-            return NULL;
-        }
-
-        XtSetArg(arglist[0], XmNimportTargets, (XtArgVal)&targets);
-        XmDropSiteRetrieve(w, arglist, 1);
-
-        memcpy(info->import_targets, targets,
-               info->num_import_targets * sizeof(Atom));
-    }
-
-    if (info->drop_site_type == XmDROP_SITE_SIMPLE && info->num_drop_rectangles > 0) {
-            XRectangle *rectangles = NULL;
-            info->drop_rectangles =
-                malloc(info->num_drop_rectangles * sizeof(XRectangle));
-
-            if (info->drop_rectangles == NULL) {
-                JNIEnv* env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-                if (info->import_targets != NULL) {
-                    free(info->import_targets);
-                }
-                free(info);
-                JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-                return NULL;
-            }
-
-            XtSetArg(arglist[0], XmNdropRectangles, (XtArgVal)&rectangles);
-            XmDropSiteRetrieve(w, arglist, 1);
-
-            memcpy(info->drop_rectangles, rectangles,
-                   info->num_drop_rectangles * sizeof(XRectangle));
-    } else /* if (info->drop_site_type == XmDROP_SITE_COMPOSITE) */ {
-        info->num_drop_rectangles = 1;
-        info->drop_rectangles = NULL;
-    }
-
-    info->widget = w;
-    return info;
-}
-
-/*
- * Registers a Motif drop site on a widget given the information
- * in the passed DSInfoRec structure.
- */
-void restore_drop_site(DSInfoPtr info) {
-    Arg      arglist[ARG_COUNT];
-    Cardinal argcount = 0;
-
-    if (info->drop_site_type == XmDROP_SITE_COMPOSITE) {
-        info->num_drop_rectangles = 1;
-        info->drop_rectangles = NULL;
-    }
-
-    XtSetArg(arglist[argcount], XmNanimationMask,
-             (XtArgVal)info->animation_mask); argcount++;
-    XtSetArg(arglist[argcount], XmNanimationPixmap,
-             (XtArgVal)info->animation_pixmap); argcount++;
-    XtSetArg(arglist[argcount], XmNanimationPixmapDepth,
-             (XtArgVal)info->animation_pixmap_depth); argcount++;
-    XtSetArg(arglist[argcount], XmNanimationStyle,
-             (XtArgVal)info->animation_style); argcount++;
-    XtSetArg(arglist[argcount], XmNclientData,
-             (XtArgVal)info->client_data); argcount++;
-    XtSetArg(arglist[argcount], XmNdragProc,
-             (XtArgVal)info->drag_proc); argcount++;
-    XtSetArg(arglist[argcount], XmNdropProc,
-             (XtArgVal)info->drop_proc); argcount++;
-    XtSetArg(arglist[argcount], XmNdropRectangles,
-             (XtArgVal)info->drop_rectangles); argcount++;
-    XtSetArg(arglist[argcount], XmNdropSiteActivity,
-             (XtArgVal)info->drop_site_activity); argcount++;
-    XtSetArg(arglist[argcount], XmNdropSiteOperations,
-             (XtArgVal)info->drop_site_operations); argcount++;
-    XtSetArg(arglist[argcount], XmNdropSiteType,
-             (XtArgVal)info->drop_site_type); argcount++;
-    XtSetArg(arglist[argcount], XmNimportTargets,
-             (XtArgVal)info->import_targets); argcount++;
-    XtSetArg(arglist[argcount], XmNnumDropRectangles,
-             (XtArgVal)info->num_drop_rectangles); argcount++;
-    XtSetArg(arglist[argcount], XmNnumImportTargets,
-             (XtArgVal)info->num_import_targets); argcount++;
-    DASSERT(argcount == ARG_COUNT);
-
-    XmDropSiteUnregister(info->widget);
-    XmDropSiteRegister(info->widget, arglist, argcount);
-    XmDropSiteConfigureStackingOrder(info->widget, (Widget)NULL, XmABOVE);
-}
-
-#undef ARG_COUNT
-
-/*
- * This routine ensures that hierarchy of Motif drop sites is not broken
- * when a new drop site is registered or an existing drop site is
- * unregistered. It unregisters all drop sites registered on the descendants of
- * the specified widget, then registers or unregisters a Motif drop site on the
- * root widget depending on the value of registerNewSite. After that the routine
- * restores all the drop sites on the descendants.
- * The routine recursively traverses through the hierarchy of descendant Motif
- * drop sites and stores the info for all drop sites in a list. Then this list
- * is used to restore all descendant drop sites.
- * @param w    current widget in the hierarchy traversal
- * @param top  root widget of the traversed hierarchy - the one to be inserted or
- *             removed
- * @param list a list of DSInfoRec structures which keep drop site info for
- *             child drop sites
- * @param registerNewSite if True a new Motif drop site should be registered on
- *             the root widget. If False an existing drop site of the root widget
- *             should be unregistered.
- * @param isDropSite if True the widget being currently traversed has an
- *             associated Motif drop site.
- */
-static DSInfoPtr
-update_drop_site_hierarchy(Widget w, Widget top, DSInfoPtr list,
-                           Boolean registerNewSite, Boolean isDropSite) {
-
-    Widget     parent = NULL;
-    Widget     *children = NULL;
-    Cardinal   num_children = 0;
-
-    if (w == NULL || !XtIsObject(w) || w->core.being_destroyed) {
-        return NULL;
-    }
-
-    /* Get the child drop sites of the widget.*/
-    if (XmDropSiteQueryStackingOrder(w, &parent, &children,
-                                     &num_children) == 0) {
-        /*
-         * The widget is declared to be a drop site, but the query fails.
-         * The drop site must be corrupted. Truncate traversal.
-         */
-        if (isDropSite) {
-            return NULL;
-        }
-    } else {
-        /* The query succeded, so the widget is definitely a drop site. */
-        isDropSite = True;
-    }
-
-    /* Traverse descendants of the widget, if it is composite. */
-    if (XtIsComposite(w)) {
-        Cardinal   i = 0;
-
-        /* If it is not a drop site, check all its children. */
-        if (!isDropSite) {
-            XtVaGetValues(w, XmNchildren, &children,
-                          XmNnumChildren, &num_children, NULL);
-        }
-
-        for (i = 0; i < num_children; i++) {
-            list = update_drop_site_hierarchy(children[i], top, list,
-                                              registerNewSite, isDropSite);
-        }
-    }
-
-    /* The storage allocated by XmDropSiteQueryStackingOrder must be freed.*/
-    if (isDropSite && children != NULL) {
-        XtFree((void*)children);
-    }
-
-    if (w != top) {
-        if (isDropSite) {
-            /* Prepend drop site info to the list and unregister a drop site.*/
-            DSInfoPtr info = get_drop_site_info(w);
-
-            if (info != NULL) {
-                info->next = list;
-                list = info;
-            }
-            XmDropSiteUnregister(w);
-        }
-    } else {
-        /* Traversal is complete.*/
-        DSInfoPtr info = list;
-
-        if (isDropSite) {
-            XmDropSiteUnregister(w);
-        }
-
-        if (registerNewSite) {
-            Arg              args[10];
-            unsigned int nargs = 0;
-
-#define SetArg(n, v) args[nargs].name = n; args[nargs++].value = (XtArgVal)(v);
-
-            SetArg(XmNanimationStyle,   XmDRAG_UNDER_NONE);
-            SetArg(XmNdragProc,                awt_XmDragProc);
-            SetArg(XmNdropProc,                awt_XmDropProc);
-            SetArg(XmNdropSiteActivity, XmDROP_SITE_ACTIVE);
-
-            SetArg(XmNdropSiteOperations,
-                   XmDROP_LINK | XmDROP_MOVE | XmDROP_COPY);
-
-            SetArg(XmNimportTargets,    NULL);
-            SetArg(XmNnumImportTargets, 0);
-
-            SetArg(XmNdropSiteType,     XmDROP_SITE_COMPOSITE);
-            SetArg(XmNdropRectangles,   (XRectangle*)NULL);
-#undef  SetArg
-
-            XmDropSiteRegister(w, args, nargs);
-            XmDropSiteConfigureStackingOrder(w, (Widget)NULL, XmABOVE);
-        }
-
-        /* Go through the list and restore all child drop sites.*/
-        while (info != NULL) {
-            restore_drop_site(info);
-
-            info = info->next;
-            list->next = NULL;
-            if (list->import_targets != NULL) {
-                free(list->import_targets);
-            }
-            if (list->drop_rectangles != NULL) {
-                free(list->drop_rectangles);
-            }
-            free(list);
-            list = info;
-        }
-    }
-    return list;
-}
-
-void
-register_drop_site(Widget w) {
-    update_drop_site_hierarchy(w, w, NULL, True, False);
-}
-
-void
-unregister_drop_site(Widget w) {
-    update_drop_site_hierarchy(w, w, NULL, False, True);
-}
-
-DECLARE_JAVA_CLASS(dSCClazz, "sun/awt/motif/MDragSourceContextPeer")
-DECLARE_JAVA_CLASS(dTCClazz, "sun/awt/motif/MDropTargetContextPeer")
-
-static void
-call_dSCenter(JNIEnv* env, jobject this, jint targetActions,
-              jint modifiers, jint x, jint y) {
-    DECLARE_VOID_JAVA_METHOD(dSCenter, dSCClazz, "dragEnter", "(IIII)V");
-    DASSERT(!JNU_IsNull(env, this));
-    (*env)->CallVoidMethod(env, this, dSCenter, targetActions, modifiers, x, y);
-}
-
-static void
-call_dSCmotion(JNIEnv* env, jobject this, jint targetActions,
-               jint modifiers, jint x, jint y) {
-    DECLARE_VOID_JAVA_METHOD(dSCmotion, dSCClazz, "dragMotion", "(IIII)V");
-    DASSERT(!JNU_IsNull(env, this));
-    (*env)->CallVoidMethod(env, this, dSCmotion, targetActions,
-                           modifiers, x, y);
-}
-
-static void
-call_dSCchanged(JNIEnv* env, jobject this, jint targetActions,
-                jint modifiers, jint x, jint y) {
-    DECLARE_VOID_JAVA_METHOD(dSCchanged, dSCClazz, "operationChanged",
-                             "(IIII)V");
-    DASSERT(!JNU_IsNull(env, this));
-    (*env)->CallVoidMethod(env, this, dSCchanged, targetActions,
-                           modifiers, x, y);
-}
-
-static void
-call_dSCmouseMoved(JNIEnv* env, jobject this, jint targetActions,
-                   jint modifiers, jint x, jint y) {
-    DECLARE_VOID_JAVA_METHOD(dSCmouseMoved, dSCClazz, "dragMouseMoved",
-                             "(IIII)V");
-    DASSERT(!JNU_IsNull(env, this));
-    (*env)->CallVoidMethod(env, this, dSCmouseMoved, targetActions,
-                           modifiers, x, y);
-}
-
-static void
-call_dSCexit(JNIEnv* env, jobject this, jint x, jint y) {
-    DECLARE_VOID_JAVA_METHOD(dSCexit, dSCClazz, "dragExit", "(II)V");
-    DASSERT(!JNU_IsNull(env, this));
-    (*env)->CallVoidMethod(env, this, dSCexit, x, y);
-}
-
-static void
-call_dSCddfinished(JNIEnv* env, jobject this, jboolean success,
-                   jint operations, jint x, jint y) {
-    DECLARE_VOID_JAVA_METHOD(dSCddfinished, dSCClazz, "dragDropFinished",
-                             "(ZIII)V");
-    DASSERT(!JNU_IsNull(env, this));
-    (*env)->CallVoidMethod(env, this, dSCddfinished, success, operations, x, y);
-}
-
-static jobject
-call_dTCcreate(JNIEnv* env) {
-    DECLARE_STATIC_OBJECT_JAVA_METHOD(dTCcreate, dTCClazz,
-                                     "createMDropTargetContextPeer",
-                                     "()Lsun/awt/motif/MDropTargetContextPeer;");
-    return (*env)->CallStaticObjectMethod(env, clazz, dTCcreate);
-}
-
-static jint
-call_dTCenter(JNIEnv* env, jobject this, jobject component, jint x, jint y,
-              jint dropAction, jint actions, jlongArray formats,
-              jlong nativeCtxt) {
-    DECLARE_JINT_JAVA_METHOD(dTCenter, dTCClazz, "handleEnterMessage",
-                            "(Ljava/awt/Component;IIII[JJ)I");
-    DASSERT(!JNU_IsNull(env, this));
-    return (*env)->CallIntMethod(env, this, dTCenter, component, x, y, dropAction,
-                                 actions, formats, nativeCtxt);
-}
-
-static void
-call_dTCexit(JNIEnv* env, jobject this, jobject component, jlong nativeCtxt) {
-    DECLARE_VOID_JAVA_METHOD(dTCexit, dTCClazz, "handleExitMessage",
-                            "(Ljava/awt/Component;J)V");
-    DASSERT(!JNU_IsNull(env, this));
-    (*env)->CallVoidMethod(env, this, dTCexit, component, nativeCtxt);
-}
-
-static jint
-call_dTCmotion(JNIEnv* env, jobject this, jobject component, jint x, jint y,
-               jint dropAction, jint actions, jlongArray formats,
-               jlong nativeCtxt) {
-    DECLARE_JINT_JAVA_METHOD(dTCmotion, dTCClazz, "handleMotionMessage",
-                            "(Ljava/awt/Component;IIII[JJ)I");
-    DASSERT(!JNU_IsNull(env, this));
-    return (*env)->CallIntMethod(env, this, dTCmotion, component, x, y,
-                                 dropAction, actions, formats, nativeCtxt);
-}
-
-static void
-call_dTCdrop(JNIEnv* env, jobject this, jobject component, jint x, jint y,
-             jint dropAction, jint actions, jlongArray formats,
-             jlong nativeCtxt) {
-    DECLARE_VOID_JAVA_METHOD(dTCdrop, dTCClazz, "handleDropMessage",
-                            "(Ljava/awt/Component;IIII[JJ)V");
-    DASSERT(!JNU_IsNull(env, this));
-    (*env)->CallVoidMethod(env, this, dTCdrop, component, x, y,
-                           dropAction, actions, formats, nativeCtxt);
-}
-
-static void
-call_dTCnewData(JNIEnv* env, jobject this, jlong format, jobject type,
-                jbyteArray data) {
-    DECLARE_VOID_JAVA_METHOD(dTCnewData, dTCClazz, "newData",
-                            "(JLjava/lang/String;[B)V");
-    DASSERT(!JNU_IsNull(env, this));
-    (*env)->CallVoidMethod(env, this, dTCnewData, format, type, data);
-}
-
-static void
-call_dTCtxFailed(JNIEnv* env, jobject this, jlong format) {
-    DECLARE_VOID_JAVA_METHOD(dTCtxFailed, dTCClazz, "transferFailed", "(J)V");
-    DASSERT(!JNU_IsNull(env, this));
-    (*env)->CallVoidMethod(env, this, dTCtxFailed, format);
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    addNativeDropTarget
- * Signature: (Ljava/awt/dnd/DropTarget;)V
- */
-
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_addNativeDropTarget
-    (JNIEnv *env, jobject this, jobject droptarget)
-{
-    struct ComponentData* cdata     = (struct ComponentData *)NULL;
-    DropSitePtr          dropsite  = (DropSitePtr)NULL;
-
-    if (JNU_IsNull(env, droptarget)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-
-    AWT_LOCK();
-
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    /* introduce a new Component as a root of a set of DropTargets */
-
-    if ((dropsite = cdata->dsi) == (DropSitePtr)NULL) {
-        dropsite = cdata->dsi = (DropSitePtr)ZALLOC(DropSiteInfo);
-
-        if (dropsite == (DropSitePtr)NULL) {
-            JNU_ThrowOutOfMemoryError (env, "OutOfMemoryError");
-            AWT_UNLOCK ();
-            return;
-        }
-
-        dropsite->component = (*env)->NewGlobalRef
-            (env, (*env)->GetObjectField(env, this,
-                                         mComponentPeerIDs.target));
-        dropsite->isComposite = True;
-
-        /*
-         * Fix for Bug Id 4389284.
-         * Revalidate drop site hierarchy so that this drop site doesn't obscure
-         * drop sites that are already registered on its children.
-         */
-        register_drop_site(cdata->widget);
-    }
-
-    dropsite->dsCnt++;
-
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MComponentPeer
- * Method:    removeNativeDropTarget
- * Signature: (Ljava/awt/dnd/DropTarget;)V
- */
-
-JNIEXPORT void JNICALL Java_sun_awt_motif_MComponentPeer_removeNativeDropTarget
-    (JNIEnv *env, jobject this, jobject droptarget)
-{
-    struct ComponentData* cdata;
-    DropSitePtr           dropsite;
-
-    if (JNU_IsNull(env, droptarget)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return;
-    }
-
-    AWT_LOCK();
-
-    cdata = (struct ComponentData *)
-        JNU_GetLongFieldAsPtr(env, this, mComponentPeerIDs.pData);
-
-    if (cdata == NULL || cdata->widget == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    if ((dropsite = cdata->dsi) == (DropSitePtr)NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        AWT_UNLOCK();
-        return;
-    }
-
-    dropsite->dsCnt--;
-    if (dropsite->dsCnt == 0) {
-        /*
-         * Fix for Bug Id 4411368.
-         * Revalidate drop site hierarchy to prevent crash when a composite drop
-         * site is unregistered before its child drop sites.
-         */
-        unregister_drop_site(cdata->widget);
-
-        (*env)->DeleteGlobalRef(env, dropsite->component);
-
-        free((void *)(cdata->dsi));
-        cdata->dsi = (DropSitePtr)NULL;
-    }
-
-    AWT_UNLOCK();
-}
-
-/**
- *
- */
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MDragSourceContextPeer_setNativeCursor(JNIEnv *env,
-                                                          jobject this,
-                                                          jlong nativeCtxt,
-                                                          jobject cursor,
-                                                          jint type) {
-    /*
-     * NOTE: no need to synchronize on awt_lock here, since we should have
-     * already acquired it in MDragSourceContextPeer.setCursor().
-     */
-    setCursor(env, awt_display, cursor, type, CurrentTime);
-}
-
-/**
- *
- */
-
-JNIEXPORT jlong JNICALL
-Java_sun_awt_motif_MDropTargetContextPeer_startTransfer(JNIEnv *env,
-                                                        jobject this,
-                                                        jlong dragContextVal,
-                                                        jlong atom) {
-    XmDropTransferEntryRec trec;
-    Widget                 dropTransfer;
-    Arg                    args[3];
-    Cardinal               nargs = 0;
-    jboolean               isCopy;
-    Widget                 dragContext = (Widget)jlong_to_ptr(dragContextVal);
-
-    AWT_LOCK();
-
-    trec.target      = (Atom) atom;
-    trec.client_data = (XtPointer)trec.target;
-
-
-#define SetArg(n, v) args[nargs].name = n; args[nargs++].value = (XtArgVal)(v);
-
-    SetArg(XmNdropTransfers,    &trec);
-    SetArg(XmNnumDropTransfers, 1    );
-    SetArg(XmNtransferProc,     awt_XmTransferProc);
-
-#undef SetArg
-
-    _cache.transfer = dropTransfer =
-        XmDropTransferStart(dragContext, args, nargs);
-
-    _cache.transfersPending++;
-
-    AWT_NOTIFY_ALL();
-    AWT_UNLOCK();
-
-    return ptr_to_jlong(dropTransfer);
-}
-
-/**
- *
- */
-
-JNIEXPORT void JNICALL
-Java_sun_awt_motif_MDropTargetContextPeer_addTransfer(JNIEnv *env,
-                                                      jobject this,
-                                                      jlong dropTransferVal,
-                                                      jlong atom) {
-    XmDropTransferEntryRec trec;
-    jboolean               isCopy;
-    Widget                 dropTransfer=(Widget)jlong_to_ptr(dropTransferVal);
-    trec.target      = (Atom)atom;
-    trec.client_data = (XtPointer)trec.target;
-
-    AWT_LOCK();
-
-    XmDropTransferAdd(dropTransfer, &trec, 1);
-
-    _cache.transfersPending++;
-
-    AWT_NOTIFY_ALL();
-    AWT_UNLOCK();
-}
-
-/**
- *
- */
-
-JNIEXPORT void JNICALL Java_sun_awt_motif_MDropTargetContextPeer_dropDone
-    (JNIEnv *env, jobject this, jlong dragContextVal, jlong dropTransferVal,
-     jboolean isLocal, jboolean success, jint dropAction)
-{
-    Widget dropTransfer = (Widget)jlong_to_ptr(dropTransferVal);
-    Widget dragContext = (Widget)jlong_to_ptr(dragContextVal);
-
-    AWT_LOCK();
-
-    if (_cache.w == (Widget)NULL) {
-        AWT_UNLOCK();
-        return;
-    }
-
-    if (!isDropDone()) {
-        if (dropTransfer != (jlong)NULL) {
-            XtVaSetValues(dropTransfer,
-                          XmNtransferStatus,
-                          success == JNI_TRUE
-                          ? XmTRANSFER_SUCCESS : XmTRANSFER_FAILURE,
-                          NULL
-                          );
-        } else {
-            /*
-             * start a transfer that notifies failure
-             * this causes src side callbacks to be processed.
-             * However, you cannot pass an a success, so the workaround is
-             * to set _cache.transferSuccess to the proper value and read it
-             * on the other side.
-             */
-
-
-            Arg arg;
-
-            /*
-             * this is the workaround code
-             */
-            _cache.transfer = NULL;
-            _cache.dropAction = dropAction;
-
-            /*
-             * End workaround code
-             */
-
-            arg.name  = XmNtransferStatus;
-            arg.value = (XtArgVal)(success == JNI_TRUE ? XmTRANSFER_SUCCESS
-                                   : XmTRANSFER_FAILURE
-                                   );
-
-            XmDropTransferStart(dragContext, &arg, 1);
-        }
-
-        /*
-         * bugid# 4146717
-         *
-         * If this is a local tx, then we never exec the awt_XmTransferProc,
-         * thus we need to flush the cache here as it is our only chance,
-         * otherwise we leave a mess for the next operation to fail on ....
-         *
-         */
-
-        if (isLocal == JNI_TRUE)
-            flush_cache(env); /* flush now, last chance */
-        else
-            _cache.flushPending = True; /* flush pending in transfer proc */
-    }
-
-    cacheDropDone(True);
-
-    AWT_NOTIFY_ALL();
-    AWT_UNLOCK();
-}
-
-
-static Boolean exitIdleProc = False;
-static int32_t x_root = -1, y_root = -1;
-
-extern void waitForEvents(JNIEnv *env, int32_t fdXPipe, int32_t fdAWTPipe);
-
-static jint convertModifiers(uint32_t modifiers) {
-    return getModifiers(modifiers, 0, 0);
-}
-
-static void
-checkMouseMoved(XtPointer client_data) {
-    Window rootWindow, childWindow;
-    int32_t xw, yw, xr, yr;
-    uint32_t modifiers;
-
-    /*
-     * When dragging over the root window XmNdragMotionCallback is not called
-     * (Motif feature).
-     * Since there is no legal way to receive MotionNotify events during drag
-     * we have to query for mouse position periodically.
-     */
-    if (XQueryPointer(awt_display, XDefaultRootWindow(awt_display),
-                      &rootWindow, &childWindow,
-                      &xr, &yr, &xw, &yw, &modifiers) &&
-        childWindow == None && (xr != x_root || yr != y_root)) {
-
-        JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-        jobject this = (jobject)client_data;
-
-        call_dSCmouseMoved(env, this, XmDROP_NOOP, convertModifiers(modifiers),
-                           xr, yr);
-
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-
-        x_root = xr;
-        y_root = yr;
-    }
-}
-
-static void IdleProc(XtPointer client_data, XtIntervalId* id) {
-    if (!exitIdleProc) {
-        JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-        /* The pipe where X events arrive */
-        int32_t fdXPipe = ConnectionNumber(awt_display) ;
-
-        /*
-         * Motif DnD internal event loop doesn't process the events
-         * from the AWT putback event queue. So we pass -1 instead
-         * of the AWT read pipe descriptor to disable checking of
-         * the putback event queue.
-         */
-        waitForEvents(env, fdXPipe, -1);
-
-        checkMouseMoved(client_data);
-        /* Reschedule the timer callback */
-        XtAppAddTimeOut(awt_appContext, AWT_DND_POLL_INTERVAL / 10,
-                        IdleProc, client_data);
-    }
-}
-
-static void RemoveIdleProc(Widget w,
-                           XtPointer client_data,
-                           XmDropFinishCallbackStruct* cbstruct) {
-    exitIdleProc = True;
-}
-
-/**
- *
- */
-
-JNIEXPORT jlong JNICALL
-Java_sun_awt_motif_MDragSourceContextPeer_startDrag(JNIEnv *env,
-                                                    jobject this,
-                                                    jobject component,
-                                                    jobject transferable,
-                                                    jobject trigger,
-                                                    jobject cursor,
-                                                    jint ctype,
-                                                    jint actions,
-                                                    jlongArray formats,
-                                                    jobject formatMap) {
-    Arg                    args[32];
-    Cardinal               nargs = 0;
-    jobject                dscp  = (*env)->NewGlobalRef(env, this);
-    jbyteArray             bdata =
-        (jbyteArray)(*env)->GetObjectField(env, trigger, awtEventIDs.bdata);
-    Atom*                  targets = NULL;
-    jlong*                 jTargets;
-    jsize                  nTargets;
-    Widget                 dc;
-    XtCallbackRec          dsecbr[2];
-    XtCallbackRec          dmcbr[2];
-    XtCallbackRec          occbr[2];
-    XtCallbackRec          dslcbr[2];
-    XtCallbackRec          dscbr[2];
-    XtCallbackRec          ddfcbr[2];
-    XEvent*                xevent;
-    unsigned char          xmActions = DnDConstantsToXm(actions);
-    jboolean               isCopy=JNI_TRUE;
-    awt_convertDataCallbackStruct* structPtr;
-
-#ifndef _LP64 /* Atom and jlong are different sizes in the 32-bit build */
-    jsize                  i;
-    jlong*                 saveJTargets;
-    Atom*                  saveTargets;
-#endif
-
-    if (xmActions == XmDROP_NOOP) {
-        JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                        "Invalid source actions.");
-        return ptr_to_jlong(NULL);
-    }
-
-    if (JNU_IsNull(env, formats)) {
-        JNU_ThrowNullPointerException(env, "formats");
-        return ptr_to_jlong(NULL);
-    }
-
-    if (JNU_IsNull(env, bdata)) {
-        JNU_ThrowNullPointerException(env,
-                                      "null native data for trigger event");
-        return ptr_to_jlong(NULL);
-    }
-
-    nTargets = (*env)->GetArrayLength(env, formats);
-
-    /*
-     * In debug build GetLongArrayElements aborts with assertion on an empty
-     * array.
-     */
-    if (nTargets > 0) {
-        jTargets = (*env)->GetLongArrayElements(env, formats, &isCopy);
-        if (!JNU_IsNull(env, ((*env)->ExceptionOccurred(env)))) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-        if (jTargets != NULL) {
-            targets = (Atom *)malloc(nTargets * sizeof(Atom));
-            if (targets != NULL) {
-#ifdef _LP64
-                memcpy(targets, jTargets, nTargets * sizeof(Atom));
-#else
-                saveJTargets = jTargets;
-                saveTargets = targets;
-                for (i = 0; i < nTargets; i++, targets++, jTargets++) {
-                    *targets = (Atom)*jTargets;
-                }
-                jTargets = saveJTargets;
-                targets = saveTargets;
-#endif
-            }
-            (*env)->ReleaseLongArrayElements(env, formats, jTargets, JNI_ABORT);
-        }
-    }
-    if (targets == NULL) {
-        nTargets = 0;
-    }
-
-#define SetCB(cbr, cb, cl) cbr[0].callback = (XtCallbackProc)cb; cbr[0].closure = (XtPointer)cl; cbr[1].callback = (XtCallbackProc)NULL; cbr[1].closure = (XtPointer)NULL
-
-#define SetArg(n, v) args[nargs].name = n; args[nargs++].value = (XtArgVal)(v);
-
-    SetCB(dsecbr, awt_XmDragEnterProc,            dscp);
-    SetCB(dmcbr,  awt_XmDragMotionProc,           dscp);
-    SetCB(occbr,  awt_XmDropOperationChangedProc, dscp);
-    SetCB(dslcbr, awt_XmDragLeaveProc,            dscp);
-    SetCB(ddfcbr, awt_XmDropFinishProc,           dscp);
-
-    SetArg(XmNblendModel,               XmBLEND_NONE      );
-    SetArg(XmNdragOperations,           xmActions         );
-    /* No incremental transfer */
-    SetArg(XmNconvertProc,              awt_convertData    );
-    SetArg(XmNdropSiteEnterCallback,    dsecbr             );
-    SetArg(XmNdragMotionCallback,       dmcbr              );
-    SetArg(XmNoperationChangedCallback, occbr              );
-    SetArg(XmNdropSiteLeaveCallback,    dslcbr             );
-    SetArg(XmNdropFinishCallback,       ddfcbr             );
-    SetArg(XmNexportTargets,            targets            );
-    SetArg(XmNnumExportTargets,         (Cardinal)nTargets );
-
-    {
-        jsize len = (*env)->GetArrayLength(env, bdata);
-        if (len <= 0) {
-            free(targets);
-            return ptr_to_jlong(NULL);
-        }
-
-        xevent = calloc(1, len);
-
-        if (xevent == NULL) {
-            free(targets);
-            JNU_ThrowOutOfMemoryError(env, "");
-            return ptr_to_jlong(NULL);
-        }
-
-        (*env)->GetByteArrayRegion(env, bdata, 0, len, (jbyte *)xevent);
-
-        DASSERT(JNU_IsNull(env, (*env)->ExceptionOccurred(env)));
-    }
-
-    if (xevent->type != ButtonPress &&
-        xevent->type != ButtonRelease &&
-        xevent->type != KeyRelease &&
-        xevent->type != KeyPress &&
-        xevent->type != MotionNotify) {
-
-        JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                        "A drag can only be initiated in response to an InputEvent.");
-        free(xevent);
-        free(targets);
-        return ptr_to_jlong(NULL);
-    }
-
-    /* This call causes an UnsatisfiedLinkError on Linux.
-     * This function is a no-op for Motif 2.1.
-     * Since Linux only links against Motif 2.1, we can safely remove
-     * this function altogether from the Linux build.
-     * bchristi 1/22/2001
-     */
-
-#ifdef __solaris__
-    awt_motif_adjustDragTriggerEvent(xevent);
-#endif
-
-    AWT_LOCK();
-
-    /*
-     * Fix for BugTraq ID 4357905.
-     * Drop is processed asynchronously on the event dispatch thread.
-     * Reject all drag attempts until the current drop is done.
-     */
-    if (!isDropDone()) {
-        JNU_ThrowByName(env, "java/awt/dnd/InvalidDnDOperationException",
-                        "Drop transfer in progress.");
-        free(xevent);
-        free(targets);
-        AWT_UNLOCK();
-        return ptr_to_jlong(NULL);
-    }
-
-    if (XFindContext(awt_display, MOTIF_DROP_ATOM, awt_convertDataContext,
-                     (XPointer*)&structPtr) == XCNOMEM || structPtr != NULL) {
-        free(xevent);
-        free(targets);
-        AWT_UNLOCK();
-        return ptr_to_jlong(NULL);
-    }
-
-    structPtr = calloc(1, sizeof(awt_convertDataCallbackStruct));
-    if (structPtr == NULL) {
-        free(xevent);
-        free(targets);
-        JNU_ThrowOutOfMemoryError(env, "");
-        AWT_UNLOCK();
-        return ptr_to_jlong(NULL);
-    }
-
-    structPtr->source              = (*env)->NewGlobalRef(env, component);
-    structPtr->transferable        = (*env)->NewGlobalRef(env, transferable);
-    structPtr->formatMap           = (*env)->NewGlobalRef(env, formatMap);
-    structPtr->formats             = (*env)->NewGlobalRef(env, formats);
-
-    if (XSaveContext(awt_display, MOTIF_DROP_ATOM, awt_convertDataContext,
-                     (XPointer)structPtr) == XCNOMEM) {
-        free(structPtr);
-        free(xevent);
-        free(targets);
-        AWT_UNLOCK();
-        return ptr_to_jlong(NULL);
-    }
-
-    dc = XmDragStart(awt_root_shell, xevent, args, nargs);
-
-    /* Fix for 4215643: remember the window corresponding to the drag source
-       and the button mask after the event which triggered drag start */
-
-    if (xevent->type == ButtonPress || xevent->type == MotionNotify) {
-        _cache.win = xevent->xbutton.window;
-        if (xevent->type == ButtonPress) {
-            _cache.state = buttonToMask(xevent->xbutton.button);
-        } else {
-            _cache.state = xevent->xmotion.state & (Button1Mask | Button2Mask);
-        }
-        XtAddEventHandler(dc, ButtonReleaseMask, False,
-                          dragsource_track_release, NULL);
-    }
-
-    free(targets);
-
-    if (dc != (Widget)NULL) {
-        setCursor(env, awt_display, cursor, ctype, xevent->xbutton.time);
-    }
-
-    free(xevent);
-
-    /*
-     * With the new synchronization model we don't release awt_lock
-     * in the DragContext callbacks. During drag-n-drop operation
-     * the events processing is performed not by our awt_MToolkit_loop,
-     * but by internal Motif InitiatorMainLoop, which returns only
-     * when the operation is completed. So our polling mechanism doesn't
-     * have a chance to execute and even if there are no events in
-     * the queue AWT_LOCK will still be held by the Toolkit thread
-     * and so other threads will likely be blocked on it.
-     *
-     * The solution is to schedule a timer callback which checks
-     * for events and if the queue is empty releases AWT_LOCK and polls
-     * the X pipe for some time, then acquires AWT_LOCK back again
-     * and reschedules itself.
-     */
-    if (dc != NULL) {
-        exitIdleProc = False;
-        XtAddCallback(dc, XmNdragDropFinishCallback,
-                      (XtCallbackProc)RemoveIdleProc, NULL);
-        XtAppAddTimeOut(awt_appContext, AWT_DND_POLL_INTERVAL / 10,
-                        IdleProc, (XtPointer)dscp);
-    }
-
-    AWT_UNLOCK();
-
-    return ptr_to_jlong(dc);
-
-#undef SetArg
-#undef SetCB
-}
-
-/*****************************************************************************/
-
-/**
- *
- */
-
-static void setCursor(JNIEnv* env, Display* dpy, jobject cursor, jint type,
-                      Time time)
-{
-    Cursor xcursor = None;
-
-    if (JNU_IsNull(env, cursor)) return;
-
-    XChangeActivePointerGrab(dpy,
-                             ButtonPressMask   |
-                             ButtonMotionMask  |
-                             ButtonReleaseMask |
-                             EnterWindowMask   |
-                             LeaveWindowMask,
-                             getCursor(env, cursor),
-                             time
-                             );
-
-    XSync(dpy, False);
-}
-
-/**
- * Update the cached targets for this widget
- */
-
-static Boolean updateCachedTargets(JNIEnv* env, Widget dt) {
-    Atom*              targets  = (Atom*)NULL;
-    Cardinal           nTargets = (Cardinal)0;
-    Arg                args[2];
-
-    /*
-     * Get the targets for this component
-     */
-    args[0].name = XmNexportTargets;    args[0].value = (XtArgVal)&targets;
-    args[1].name = XmNnumExportTargets; args[1].value = (XtArgVal)&nTargets;
-    XtGetValues(_cache.dt = dt, args, 2);
-
-    /*
-     * Free the previous targets if there were any
-     */
-    if (!JNU_IsNull(env, _cache.targets)) {
-        (*env)->DeleteGlobalRef(env, _cache.targets);
-        _cache.targets = (jlongArray)NULL;
-    }
-
-    _cache.nTargets = nTargets;
-
-    /*
-     * If the widget has targets (atoms) then copy them to the cache
-     */
-    if (nTargets > 0) {
-        jboolean isCopy;
-        jlong*   jTargets;
-
-#ifndef _LP64 /* Atom and jlong are different sizes in the 32-bit build */
-        jlong*   saveJTargets;
-        Cardinal i;
-#endif
-
-        _cache.targets = (*env)->NewLongArray(env, nTargets);
-        if (_cache.targets == NULL) {
-            _cache.nTargets = 0;
-            return False;
-        }
-
-        _cache.targets = (*env)->NewGlobalRef(env, _cache.targets);
-        if (_cache.targets == NULL) {
-            _cache.nTargets = 0;
-            return False;
-        }
-
-        jTargets = (*env)->GetLongArrayElements(env, _cache.targets, &isCopy);
-        if (jTargets == NULL) {
-            (*env)->DeleteGlobalRef(env, _cache.targets);
-            _cache.targets = NULL;
-            _cache.nTargets = 0;
-            return False;
-        }
-
-#ifdef _LP64
-        memcpy(jTargets, targets, nTargets * sizeof(Atom));
-#else
-        saveJTargets = jTargets;
-        for (i = 0; i < nTargets; i++, jTargets++, targets++) {
-            *jTargets = (*targets & 0xFFFFFFFFLU);
-        }
-        jTargets = saveJTargets;
-#endif
-
-        (*env)->ReleaseLongArrayElements(env, _cache.targets, jTargets, 0);
-        return True;
-    }
-
-    return False;
-}
-
-
-/**
- *
- */
-
-static void flush_cache(JNIEnv* env) {
-    _cache.w  = (Widget)NULL;
-    _cache.dt = (Widget)NULL;
-
-    (*env)->DeleteGlobalRef(env, _cache.peer);
-    _cache.peer = (jobject)NULL;
-
-    (*env)->DeleteGlobalRef(env, _cache.component);
-    _cache.component = (jobject)NULL;
-
-    if (_cache.dtcpeer != (jobject)NULL) {
-        (*env)->DeleteGlobalRef(env, _cache.dtcpeer);
-
-        _cache.dtcpeer = (jobject)NULL;
-    }
-
-    _cache.nTargets  = (Cardinal)0;
-    if (_cache.targets != (jlongArray)NULL) {
-        (*env)->DeleteGlobalRef(env, _cache.targets);
-        _cache.targets = (jlongArray)NULL;
-    }
-
-    _cache.transfersPending = 0;
-    _cache.flushPending     = False;
-    _cache.transfer         = (Widget)NULL;
-    cacheDropDone(True);
-}
-
-/**
- *
- */
-
-static void update_cache(JNIEnv* env, Widget w, Widget dt) {
-    if(w != _cache.w) {
-        struct ComponentData* cdata   = (struct ComponentData *)NULL;
-        Arg                   args[1] =
-        {{ XmNuserData, (XtArgVal)&_cache.peer}};
-
-        flush_cache(env);
-
-        if (w == (Widget)NULL) return;
-
-        XtGetValues(w, args, 1);
-
-        if (JNU_IsNull(env, _cache.peer)) {
-            _cache.w = NULL;
-
-            return;
-        }
-
-        cdata = (struct ComponentData *)
-            JNU_GetLongFieldAsPtr(env, _cache.peer, mComponentPeerIDs.pData);
-
-        if (cdata         == NULL ||
-            cdata->widget != w ||
-            cdata->dsi    == (DropSitePtr)NULL) {
-            _cache.w = NULL;
-
-            return;
-        }
-
-        _cache.w         = w;
-        _cache.component = (*env)->NewGlobalRef(env, cdata->dsi->component);
-        _cache.peer      = (*env)->NewGlobalRef(env, _cache.peer);
-        /* SECURITY: OK to call this on privileged thread - peer is secure */
-        {
-            jobject dtcpeer = call_dTCcreate(env);
-            if (!JNU_IsNull(env, dtcpeer)) {
-                _cache.dtcpeer = (*env)->NewGlobalRef(env, dtcpeer);
-                (*env)->DeleteLocalRef(env, dtcpeer);
-            } else {
-                _cache.dtcpeer = NULL;
-            }
-        }
-
-        _cache.transfersPending = 0;
-        cacheDropDone(True);
-    }
-
-    if (_cache.w != (Widget)NULL) updateCachedTargets(env, dt);
-}
-
-
-/**
- *
- */
-
-static void
-cacheDropDone(Boolean dropDone) {
-    _cache.dropDone = dropDone;
-}
-
-static Boolean
-isDropDone() {
-    return _cache.dropDone;
-}
-
-/**
- *
- */
-
-static jint XmToDnDConstants(unsigned char operations) {
-    jint src = java_awt_dnd_DnDConstants_ACTION_NONE;
-
-    if (operations & XmDROP_MOVE) src |= java_awt_dnd_DnDConstants_ACTION_MOVE;
-    if (operations & XmDROP_COPY) src |= java_awt_dnd_DnDConstants_ACTION_COPY;
-    if (operations & XmDROP_LINK) src |= java_awt_dnd_DnDConstants_ACTION_LINK;
-
-    return src;
-}
-
-static unsigned char selectOperation(unsigned char operations) {
-    if (operations & XmDROP_MOVE) return XmDROP_MOVE;
-    if (operations & XmDROP_COPY) return XmDROP_COPY;
-    if (operations & XmDROP_LINK) return XmDROP_LINK;
-
-    return XmDROP_NOOP;
-}
-
-/**
- *
- */
-
-static unsigned char DnDConstantsToXm(jint actions) {
-    unsigned char ret = XmDROP_NOOP;
-
-    if (actions & java_awt_dnd_DnDConstants_ACTION_COPY) ret |= XmDROP_COPY;
-    if (actions & java_awt_dnd_DnDConstants_ACTION_MOVE) ret |= XmDROP_MOVE;
-    if (actions & java_awt_dnd_DnDConstants_ACTION_LINK) ret |= XmDROP_LINK;
-
-    return ret;
-}
-
-/**
- *
- */
-
-typedef struct DragExitProcStruct {
-    XtIntervalId timerId;
-    jobject      dtcpeer;     /* global reference */
-    jobject      component;   /* global reference */
-    jlong        dragContext; /* pointer          */
-} DragExitProcStruct;
-
-static DragExitProcStruct pending_drag_exit_data =
-    { (XtIntervalId)0, NULL, NULL, (jlong)0 };
-
-static void drag_exit_proc(XtPointer client_data, XtIntervalId* id) {
-    JNIEnv* env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-    DASSERT(!JNU_IsNull(env, pending_drag_exit_data.dtcpeer));
-    DASSERT(!JNU_IsNull(env, pending_drag_exit_data.component));
-    DASSERT(pending_drag_exit_data.dragContext != NULL);
-
-    if (pending_drag_exit_data.timerId != (XtIntervalId)0) {
-        if (id == NULL) {
-            XtRemoveTimeOut(pending_drag_exit_data.timerId);
-        }
-        if (id == NULL || pending_drag_exit_data.timerId == *id) {
-
-            /* SECURITY: OK to call this on privileged thread -
-               peer is secure */
-            call_dTCexit(env, pending_drag_exit_data.dtcpeer,
-                         pending_drag_exit_data.component,
-                         pending_drag_exit_data.dragContext);
-
-            if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-            }
-        }
-    }
-
-    /* cleanup */
-    (*env)->DeleteGlobalRef(env, pending_drag_exit_data.dtcpeer);
-    (*env)->DeleteGlobalRef(env, pending_drag_exit_data.component);
-
-    memset(&pending_drag_exit_data, 0, sizeof(DragExitProcStruct));
-}
-
-static void awt_XmDragProc(Widget w, XtPointer closure,
-                           XmDragProcCallbackStruct* cbstruct)
-{
-    JNIEnv* env       = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject component = (jobject)NULL;
-    jint    src       = java_awt_dnd_DnDConstants_ACTION_NONE;
-    jint    usrAction = java_awt_dnd_DnDConstants_ACTION_NONE;
-    jint    ret       = java_awt_dnd_DnDConstants_ACTION_NONE;
-    unsigned char srcOps = XmDROP_NOOP;
-
-    /*
-     * Fix for BugTraq ID 4395290.
-     * We should dispatch any pending java upcall right now
-     * to keep the order of upcalls.
-     */
-    if (pending_drag_exit_data.timerId != (XtIntervalId)0) {
-        drag_exit_proc(NULL, NULL);
-    }
-
-    /*
-     * Fix for BugTraq ID 4357905.
-     * Drop is processed asynchronously on the event dispatch thread.
-     * We reject other drop attempts to protect the SunDTCP context
-     * from being overwritten by an upcall before the drop is done.
-     */
-    if (!isDropDone()) {
-        cbstruct->operation  = XmDROP_NOOP;
-        cbstruct->dropSiteStatus = XmINVALID_DROP_SITE;
-        return;
-    }
-
-    if (cbstruct->dragContext == NULL) {
-        cbstruct->operation  = XmDROP_NOOP;
-        cbstruct->dropSiteStatus = XmINVALID_DROP_SITE;
-        return;
-    }
-
-    (*env)->PushLocalFrame(env, 0);
-
-    /*
-     * Fix for BugTraq ID 4285634.
-     * If some modifier keys are pressed the Motif toolkit initializes
-     * cbstruct->operations this field to the bitwise AND of the
-     * XmDragOperations resource of the XmDragContext for this drag operation
-     * and the drop action corresponding to the current modifiers state.
-     * We need to determine the drag operations supported by the drag source, so
-     * we have to get XmNdragOperations value of the XmDragSource.
-     */
-    XtVaGetValues(cbstruct->dragContext, XmNdragOperations, &srcOps, NULL);
-    src = XmToDnDConstants(srcOps);
-    usrAction = XmToDnDConstants(selectOperation(cbstruct->operations));
-
-    update_cache(env, w, cbstruct->dragContext);
-
-    if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-        flush_cache(env);
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-        goto wayout;
-    }
-
-    switch (cbstruct->reason) {
-    case XmCR_DROP_SITE_ENTER_MESSAGE: {
-
-        /* SECURITY: OK to call this on privileged thread -
-           peer is secure */
-        ret = call_dTCenter(env, _cache.dtcpeer, _cache.component,
-                            cbstruct->x, cbstruct->y,
-                            usrAction, src,
-                            _cache.targets,ptr_to_jlong(cbstruct->dragContext));
-
-        if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-            flush_cache(env);
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-    }
-    break;
-
-    case XmCR_DROP_SITE_LEAVE_MESSAGE: {
-
-        DASSERT(pending_drag_exit_data.timerId == (XtIntervalId)0);
-        DASSERT(JNU_IsNull(env, pending_drag_exit_data.dtcpeer));
-        DASSERT(JNU_IsNull(env, pending_drag_exit_data.component));
-        DASSERT(pending_drag_exit_data.dragContext == (jlong)0);
-
-        DASSERT(!JNU_IsNull(env, _cache.dtcpeer));
-        DASSERT(!JNU_IsNull(env, _cache.component));
-        DASSERT(cbstruct->dragContext != NULL);
-
-        pending_drag_exit_data.dtcpeer =
-            (*env)->NewGlobalRef(env, _cache.dtcpeer);
-        pending_drag_exit_data.component =
-            (*env)->NewGlobalRef(env, _cache.component);
-        pending_drag_exit_data.dragContext =
-            ptr_to_jlong(cbstruct->dragContext);
-
-        /*
-         * Fix for BugTraq ID 4395290.
-         * Postpone upcall to java, so that we can abort it in case
-         * if drop immediatelly follows.
-         */
-        if (!JNU_IsNull(env, pending_drag_exit_data.dtcpeer) &&
-            !JNU_IsNull(env, pending_drag_exit_data.component)) {
-            pending_drag_exit_data.timerId =
-                XtAppAddTimeOut(awt_appContext, 0, drag_exit_proc, NULL);
-            DASSERT(pending_drag_exit_data.timerId != (XtIntervalId)0);
-        } else {
-            JNU_ThrowOutOfMemoryError(env, "OutOfMemoryError");
-            if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-            }
-            if (!JNU_IsNull(env, pending_drag_exit_data.dtcpeer)) {
-                (*env)->DeleteGlobalRef(env, pending_drag_exit_data.dtcpeer);
-            }
-            if (!JNU_IsNull(env, pending_drag_exit_data.component)) {
-                (*env)->DeleteGlobalRef(env, pending_drag_exit_data.component);
-            }
-            memset(&pending_drag_exit_data, 0, sizeof(DragExitProcStruct));
-        }
-
-        ret = java_awt_dnd_DnDConstants_ACTION_NONE;
-
-        /* now cleanup */
-
-        flush_cache(env);
-    }
-    break;
-
-    case XmCR_DROP_SITE_MOTION_MESSAGE: {
-
-        /* SECURITY: OK to call this on privileged thread -
-           peer is secure */
-        ret = call_dTCmotion(env, _cache.dtcpeer, _cache.component,
-                             cbstruct->x, cbstruct->y,
-                             usrAction, src,
-                             _cache.targets,
-                             ptr_to_jlong(cbstruct->dragContext));
-
-        if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-            flush_cache(env);
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-
-    }
-    break;
-
-    case XmCR_OPERATION_CHANGED: {
-
-        /* SECURITY: OK to call this on privileged thread -
-           peer is secure */
-        ret = call_dTCmotion(env, _cache.dtcpeer, _cache.component,
-                             cbstruct->x, cbstruct->y,
-                             usrAction, src,
-                             _cache.targets,
-                             ptr_to_jlong(cbstruct->dragContext));
-
-        if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-            flush_cache(env);
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-
-    }
-    break;
-
-    default: break;
-    }
-
- wayout:
-
-    /*
-     * Fix for BugTraq ID 4285634.
-     * If some modifier keys are pressed the Motif toolkit initializes
-     * cbstruct->operations this field to the bitwise AND of the
-     * XmDragOperations resource of the XmDragContext for this drag operation
-     * and the drop action corresponding to the current modifiers state.
-     * We should allow the drop target to select a drop action independent of
-     * the current modifiers state.
-     */
-    cbstruct->operation  = DnDConstantsToXm(ret);
-
-    if (cbstruct->reason != XmCR_DROP_SITE_LEAVE_MESSAGE) {
-        Arg arg;
-        arg.name = XmNdropSiteOperations;
-        arg.value = (XtArgVal)cbstruct->operation;
-
-        XmDropSiteUpdate(w, &arg, 1);
-    }
-
-    if (ret != java_awt_dnd_DnDConstants_ACTION_NONE) {
-        cbstruct->dropSiteStatus = XmVALID_DROP_SITE;
-    }  else {
-        cbstruct->dropSiteStatus = XmINVALID_DROP_SITE;
-    }
-
-    (*env)->PopLocalFrame(env, NULL);
-}
-
-static void drop_failure_cleanup(JNIEnv* env, Widget dragContext) {
-    Arg arg;
-
-    DASSERT(dragContext != NULL);
-    _cache.transfer = NULL;
-    _cache.dropAction = XmDROP_NOOP;
-
-    arg.name  = XmNtransferStatus;
-    arg.value = (XtArgVal)XmTRANSFER_FAILURE;
-    XmDropTransferStart(dragContext, &arg, 1);
-
-    /* Flush here, since awt_XmTransferProc won't be called. */
-    flush_cache(env);
-}
-
-/**
- *
- */
-
-static void awt_XmDropProc(Widget w, XtPointer closure,
-                           XmDropProcCallbackStruct* cbstruct)
-{
-    JNIEnv*       env       = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jint          src       = java_awt_dnd_DnDConstants_ACTION_NONE;
-    unsigned char operation = selectOperation(cbstruct->operations);
-    unsigned char srcOps = XmDROP_NOOP;
-    unsigned char dstOps = XmDROP_NOOP;
-    Arg           arg;
-    Boolean       sourceIsExternal = False;
-
-    arg.name = XmNdropSiteOperations;
-    arg.value = (XtArgVal)&dstOps;
-    XmDropSiteRetrieve(w, &arg, 1);
-    arg.value = (XtArgVal)(XmDROP_COPY | XmDROP_MOVE | XmDROP_LINK);
-    XmDropSiteUpdate(w, &arg, 1);
-
-    /*
-     * Fix for BugTraq ID 4357905.
-     * Drop is processed asynchronously on the event dispatch thread.
-     * We reject other drop attempts to protect the SunDTCP context
-     * from being overwritten by an upcall before the drop is done.
-     */
-    if (!isDropDone()) {
-        return;
-    }
-
-    if (cbstruct->dragContext == NULL) {
-        cbstruct->operation  = XmDROP_NOOP;
-        cbstruct->dropSiteStatus = XmINVALID_DROP_SITE;
-        return;
-    }
-
-    /*
-     * Fix for BugTraq ID 4492640.
-     * Because of the Motif bug #4528191 XmNdragOperations resource is always
-     * equal to XmDROP_MOVE | XmDROP_COPY when the drag source is external.
-     * The workaround for this bug is to assume that an external drag source
-     * supports all drop actions.
-     */
-    XtVaGetValues(cbstruct->dragContext,
-                  XmNsourceIsExternal, &sourceIsExternal, NULL);
-
-    if (sourceIsExternal) {
-        srcOps = XmDROP_LINK | XmDROP_MOVE | XmDROP_COPY;
-    } else {
-        /*
-         * Fix for BugTraq ID 4285634.
-         * If some modifier keys are pressed the Motif toolkit initializes
-         * cbstruct->operations to the bitwise AND of the
-         * XmDragOperations resource of the XmDragContext for this drag operation
-         * and the drop action corresponding to the current modifiers state.
-         * We need to determine the drag operations supported by the drag source, so
-         * we have to get XmNdragOperations value of the XmDragSource.
-         */
-        XtVaGetValues(cbstruct->dragContext, XmNdragOperations, &srcOps, NULL);
-    }
-
-    src = XmToDnDConstants(srcOps);
-
-    if ((srcOps & dstOps) == 0) {
-        cbstruct->operation  = XmDROP_NOOP;
-        cbstruct->dropSiteStatus = XmINVALID_DROP_SITE;
-        drop_failure_cleanup(env, cbstruct->dragContext);
-        return;
-    }
-
-    (*env)->PushLocalFrame(env, 0);
-
-    update_cache(env, w, cbstruct->dragContext);
-
-    cacheDropDone(False);
-
-    if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-        (*env)->PopLocalFrame(env, NULL);
-        drop_failure_cleanup(env, cbstruct->dragContext);
-        return;
-    }
-
-    /*
-     * Fix for BugTraq ID 4395290.
-     * Abort a pending upcall to dragExit.
-     */
-    pending_drag_exit_data.timerId = (XtIntervalId)0;
-
-    /* SECURITY: OK to call this on privileged thread - peer is secure */
-    call_dTCdrop(env, _cache.dtcpeer, _cache.component,
-                 cbstruct->x, cbstruct->y,
-                 XmToDnDConstants(operation), src, _cache.targets,
-                 ptr_to_jlong(cbstruct->dragContext));
-
-    if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-        flush_cache(env);
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-    (*env)->PopLocalFrame(env, NULL);
-}
-
-/**
- *
- */
-
-static void awt_XmTransferProc(Widget w, XtPointer closure, Atom* selection,
-                               Atom* type, XtPointer value,
-                               unsigned long* length, int32_t* format)
-{
-    JNIEnv*  env   = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    Atom     req   = (Atom)closure;
-    Display* dpy   = XtDisplayOfObject(w);
-    jobject  tName = NULL;
-
-    /*
-     * Note: this method is only called to transfer data between clients
-     * in different JVM's or native apps. For Intra-JVM transfers the peer
-     * code shares the sources Transferable with the destination.
-     */
-
-    if (_cache.w == (Widget)NULL || _cache.transfer != w) {
-        if (value != NULL) {
-            XtFree(value);
-            value = NULL;
-        }
-        /* we have already cleaned up ... */
-        return;
-    }
-
-    (*env)->PushLocalFrame(env, 0);
-
-    if (*type == None || *type == XT_CONVERT_FAIL) {
-        /* SECURITY: OK to call this on privileged thread - peer is secure
-         */
-        call_dTCtxFailed(env, _cache.dtcpeer, (jlong)req);
-    } else {
-        switch (*format) {
-        case  8:
-        case 16:
-        case 32: {
-            jsize size = (*length <= INT_MAX) ? (jsize)*length : INT_MAX;
-            jbyteArray arry = (*env)->NewByteArray(env, size);
-
-            if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-
-                /* SECURITY: OK to call this on privileged thread -
-                   peer is secure */
-                call_dTCtxFailed(env, _cache.dtcpeer, (jlong)req);
-
-                goto wayout;
-            }
-
-            (*env)->SetByteArrayRegion(env, arry, 0, size, (jbyte*)value);
-            if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-
-                /* SECURITY: OK to call this on privileged thread -
-                   peer is secure */
-                call_dTCtxFailed(env, _cache.dtcpeer, (jlong)req);
-                goto wayout;
-            }
-
-            arry = (*env)->NewGlobalRef(env, arry);
-
-            if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-            }
-
-            {
-                char* tn = XGetAtomName(dpy, *type);
-
-                tName = (*env)->NewStringUTF(env, (const char *)tn);
-
-                if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-                    (*env)->ExceptionDescribe(env);
-                    (*env)->ExceptionClear(env);
-                }
-
-                XFree((void *)tn);
-            }
-
-            /* SECURITY: OK to call this on privileged thread - peer is
-               secure */
-            call_dTCnewData(env, _cache.dtcpeer, (jlong)req, tName, arry);
-
-            if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-                (*env)->ExceptionDescribe(env);
-                (*env)->ExceptionClear(env);
-            }
-        }
-
-        default:
-            break;
-        }
-    }
-
- wayout:
-    if (value != NULL) {
-        XtFree(value);
-        value = NULL;
-    }
-
-    _cache.transfersPending--;
-    while (_cache.transfersPending == 0 && !isDropDone()) {
-        AWT_WAIT(0);
-    }
-
-    if (isDropDone() && _cache.flushPending) {
-        flush_cache(env);
-    }
-
-    (*env)->PopLocalFrame(env, NULL);
-}
-
-/**
- *
- */
-
-static void awt_XmDragEnterProc(Widget w, XtPointer closure,
-                                XmDropSiteEnterCallbackStruct* cbstruct)
-{
-    JNIEnv*  env   = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject  this  = (jobject)closure;
-
-    /*  This should only be valid, but Im leaving this part of the old code */
-    jboolean valid = cbstruct->dropSiteStatus == XmVALID_DROP_SITE
-        ? JNI_TRUE : JNI_FALSE;
-
-    if (valid == JNI_TRUE) {
-        /*
-         * Workaround for Motif bug id #4457656.
-         * Pointer coordinates passed in cbstruct are incorrect.
-         * We have to make a round-trip query.
-         */
-        Window rootWindow, childWindow;
-        int32_t xw, yw, xr, yr;
-        uint32_t modifiers;
-
-        XQueryPointer(awt_display, XtWindow(w),
-                      &rootWindow, &childWindow, &xr, &yr, &xw, &yw, &modifiers);
-
-        (*env)->PushLocalFrame(env, 0);
-
-        /* SECURITY: OK to call this on privileged thread - peer is secure */
-        call_dSCenter(env, this, XmToDnDConstants(cbstruct->operation),
-                      convertModifiers(modifiers), xr, yr);
-
-        if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-
-        (*env)->PopLocalFrame(env, NULL);
-    }
-}
-
-/**
- *
- */
-
-static void awt_XmDragMotionProc(Widget w, XtPointer closure,
-                                 XmDragMotionCallbackStruct* cbstruct)
-{
-    JNIEnv*  env   = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject  this  = (jobject)closure;
-
-    /*  This should only be valid, but Im leaving this part of the old code */
-    jboolean valid = cbstruct->dropSiteStatus == XmVALID_DROP_SITE
-        ? JNI_TRUE : JNI_FALSE;
-    Window rootWindow, childWindow;
-    int32_t xw, yw, xr, yr;
-    uint32_t modifiers;
-
-    XQueryPointer(awt_display, XtWindow(w),
-                  &rootWindow, &childWindow, &xr, &yr, &xw, &yw, &modifiers);
-    /*
-     * Fix for 4285634.
-     * Use the cached modifiers state, since the directly queried state can
-     * differ from the one associated with this dnd notification.
-     */
-    modifiers = ((XmDragContext)w)->drag.lastEventState;
-    if (xr != x_root || yr != y_root) {
-        call_dSCmouseMoved(env, this, XmToDnDConstants(cbstruct->operation),
-                           convertModifiers(modifiers), xr, yr);
-
-        if ((*env)->ExceptionCheck(env) == JNI_TRUE) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-
-        x_root = xr;
-        y_root = yr;
-    }
-
-    if (valid == JNI_TRUE) {
-
-        (*env)->PushLocalFrame(env, 0);
-
-        /* SECURITY: OK to call this on privileged thread - peer is secure */
-        call_dSCmotion(env, this, XmToDnDConstants(cbstruct->operation),
-                       convertModifiers(modifiers), xr, yr);
-
-        if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-
-        (*env)->PopLocalFrame(env, NULL);
-    } else {
-        (*env)->PushLocalFrame(env, 0);
-
-        /* SECURITY: OK to call this on privileged thread - peer is secure */
-        call_dSCexit(env, this, xr, yr);
-
-        if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-            (*env)->ExceptionDescribe(env);
-            (*env)->ExceptionClear(env);
-        }
-
-        (*env)->PopLocalFrame(env, NULL);
-    }
-}
-
-/**
- *
- */
-
-static void awt_XmDragLeaveProc(Widget w, XtPointer closure,
-                                XmDropSiteLeaveCallbackStruct* cbstruct)
-{
-    JNIEnv* env  = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject this = (jobject)closure;
-    Window rootWindow, childWindow;
-    int32_t xw, yw, xr, yr;
-    uint32_t modifiers;
-
-    XQueryPointer(XtDisplay(w), XtWindow(w),
-                  &rootWindow, &childWindow, &xr, &yr, &xw, &yw, &modifiers);
-
-    (*env)->PushLocalFrame(env, 0);
-
-    /* SECURITY: OK to call this on privileged thread - peer is secure */
-    call_dSCexit(env, this, xr, yr);
-
-    if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-
-    (*env)->PopLocalFrame(env, NULL);
-}
-
-/**
- *
- */
-
-static void awt_XmDropOperationChangedProc(Widget w, XtPointer closure,
-                                           XmDropStartCallbackStruct* cbstruct)
-{
-    JNIEnv*  env   = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject  this  = (jobject)closure;
-    Window rootWindow, childWindow;
-    int32_t xw, yw, xr, yr;
-    uint32_t modifiers;
-
-    XQueryPointer(XtDisplay(w), XtWindow(w),
-                  &rootWindow, &childWindow, &xr, &yr, &xw, &yw, &modifiers);
-
-    (*env)->PushLocalFrame(env, 0);
-
-
-    /* SECURITY: OK to call this on privileged thread - peer is secure */
-    call_dSCchanged(env, this, XmToDnDConstants(cbstruct->operation),
-                    convertModifiers(modifiers), xr, yr);
-
-    if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-
-    (*env)->PopLocalFrame(env, NULL);
-}
-
-/**
- *
- */
-
-static void awt_XmDropFinishProc(Widget w, XtPointer closure,
-                                 XmDropFinishCallbackStruct* cbstruct)
-{
-    JNIEnv* env  = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject this = (jobject)closure;
-    unsigned char completionStatus = cbstruct->completionStatus;
-    jint dropAction = XmToDnDConstants(cbstruct->operation);
-    Window rootWindow, childWindow;
-    int32_t xw, yw, xr, yr;
-    uint32_t modifiers;
-
-    XQueryPointer(XtDisplay(w), XtWindow(w),
-                  &rootWindow, &childWindow, &xr, &yr, &xw, &yw, &modifiers);
-
-    /* cleanup */
-
-    if (_cache.transfer == NULL) {
-        dropAction = _cache.dropAction;
-    }
-
-    _cache.dropAction = java_awt_dnd_DnDConstants_ACTION_NONE;
-    _cache.win = None;
-    _cache.state = 0;
-    XtRemoveEventHandler(w, ButtonReleaseMask, False,
-                         dragsource_track_release, NULL);
-
-    /* SECURITY: OK to call this on privileged thread - peer is secure */
-    call_dSCddfinished(env, this, completionStatus, dropAction, xr, yr);
-
-    if (!JNU_IsNull(env, (*env)->ExceptionOccurred(env))) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-
-    awt_cleanupConvertDataContext(env, MOTIF_DROP_ATOM);
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/awt_XmDnD.h openjdk/jdk/src/solaris/native/sun/awt/awt_XmDnD.h
--- openjdk.orig/jdk/src/solaris/native/sun/awt/awt_XmDnD.h	2014-04-08 05:27:03.454875147 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_XmDnD.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/*
- * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include <Xm/Display.h>
-#include <Xm/DropSMgr.h>
-#include <Xm/DropTrans.h>
-#include <inttypes.h>
-
-/**
- *
- */
-
-typedef struct DropSiteInfo {
-        Widget                  tlw;
-
-        jobject                 component;
-        Boolean                 isComposite;
-        uint32_t                dsCnt;
-} DropSiteInfo;
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/canvas.c openjdk/jdk/src/solaris/native/sun/awt/canvas.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/canvas.c	2014-04-08 05:27:03.466875324 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/canvas.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,3227 +0,0 @@
-/*
- * Copyright (c) 1995, 2005, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include <sys/time.h> /* timeval */
-
-#define XK_KATAKANA
-#include <X11/keysym.h>     /* standard X keysyms */
-#include <X11/DECkeysym.h>  /* DEC vendor-specific */
-#include <X11/Sunkeysym.h>  /* Sun vendor-specific */
-#include <X11/ap_keysym.h>  /* Apollo (HP) vendor-specific */
-/*
- * #include <X11/HPkeysym.h>    HP vendor-specific
- * I checked HPkeysym.h into the workspace because it ships
- * with X11R6.4.2 (and later) but not with X11R6.4.1.
- * So, it ought to ship with Solaris 9, but not Solaris 8.
- * Same deal for Linux - newer versions of XFree have it.
- *
- * Note: this is mainly done for the hp keysyms; it does NOT
- * give us the osf keysyms that are also defined in HPkeysym.h.
- * This is because we are already getting /Xm/VirtKeys.h
- * from awt_p.h <- /Xm/Xm.h <- /Xm/VirtKeys.h, and VirtKeys.h
- * #defines _OSF_Keysyms before we get here.  We are
- * missing a couple of osf keysyms because of this,
- * so I have #defined them below.
- */
-#include "HPkeysym.h"   /* HP vendor-specific */
-
-#include <Xm/Display.h>
-#include <ctype.h>
-#include "java_awt_Frame.h"
-#include "java_awt_Component.h"
-#include "java_awt_AWTEvent.h"
-#include "java_awt_event_KeyEvent.h"
-#include "java_awt_event_FocusEvent.h"
-#include "java_awt_event_MouseEvent.h"
-#include "java_awt_event_MouseWheelEvent.h"
-#include "java_awt_event_InputEvent.h"
-#include "java_awt_event_WindowEvent.h"
-#include "sun_awt_motif_MComponentPeer.h"
-#include "color.h"
-#include "canvas.h"
-#include "awt_Cursor.h"
-#include "VDrawingArea.h"
-#include "XDrawingArea.h"
-#include "awt_Component.h"
-#include "awt_AWTEvent.h"
-#include "awt_Event.h"
-#include "awt_KeyboardFocusManager.h"
-#include "awt_MToolkit.h"
-#include "awt_TopLevel.h"
-#include "awt_util.h"
-
-#include <jni.h>
-#include <jni_util.h>
-#include <jvm.h>
-#include <jawt.h>
-
-#ifdef NDEBUG   /* NDEBUG overrides DEBUG */
-#undef DEBUG
-#endif
-
-/*
- * Two osf keys are not defined in standard keysym.h,
- * /Xm/VirtKeys.h, or HPkeysym.h, so I added them below.
- * I found them in /usr/openwin/lib/X11/XKeysymDB
- */
-#ifndef osfXK_Prior
-#define osfXK_Prior 0x1004FF55
-#endif
-#ifndef osfXK_Next
-#define osfXK_Next 0x1004FF56
-#endif
-/*
- * osfXK_Escape is defined in HPkeysym.h, but not in
- * /Xm/VirtKeys.h, so I added it below.  It is also in
- * /usr/openwin/lib/X11/XKeysymDB
- * Note: it is in /Xm/VirtKeys.h in the AWT motif workspace,
- * but not in /usr/local/Motif/include/Xm/VirtKeys.h
- * on the Solaris 7, 8, or 9 machines I tried.
- */
-#ifndef osfXK_Escape
-#define osfXK_Escape 0x1004FF1B
-#endif
-
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern struct AWTEventIDs awtEventIDs;
-extern struct KeyEventIDs keyEventIDs;
-extern struct InputEventIDs inputEventIDs;
-extern struct ComponentIDs componentIDs;
-extern struct KeyboardFocusManagerIDs keyboardFocusManagerIDs;
-
-#ifdef DEBUG
-static Boolean debugKeys = False;
-#endif
-
-jint awt_multiclick_smudge = 4;
-
-extern Widget drag_source;
-
-Widget prevWidget = NULL; /* for bug fix 4017222 */
-
-FocusListElt *focusList = NULL, *focusListEnd = NULL;
-
-jweak forGained = NULL;
-
-extern Boolean scrollBugWorkAround;
-extern jobject currentX11InputMethodInstance;
-extern Window  currentFocusWindow;
-extern Boolean awt_x11inputmethod_lookupString(XKeyPressedEvent *, KeySym *);
-Boolean awt_UseType4Patch = True;
-Boolean awt_ServerDetected = False;
-Boolean awt_IsXsun = False;
-Boolean awt_UseXKB = False;
-
-void awt_post_java_key_event(XtPointer client_data, jint id,
-                             XEvent *xevent, Time when, jint keycode,
-                             jchar keychar, jint modifiers,
-                             jint keyLocation, XEvent *anEvent);
-void awt_post_java_focus_event(XtPointer client_data, jint id, jobject cause,
-                               XEvent *event);
-void awt_post_java_mouse_event(XtPointer client_data, jint id,
-                               XEvent *event, Time when, jint modifiers,
-                               jint x, jint y,
-                               jint xAbs, jint yAbs,
-                               jint clickcount, Boolean popuptrigger,
-                               jint wheelAmt, jint button);
-
-typedef struct KEYMAP_ENTRY {
-    jint awtKey;
-    KeySym x11Key;
-    Boolean mapsToUnicodeChar;
-    jint keyLocation;
-} KeymapEntry;
-
-/* NB: XK_R? keysyms are for Type 4 keyboards.
- * The corresponding XK_F? keysyms are for Type 5
- *
- * Note: this table must be kept in sorted order, since it is traversed
- * according to both Java keycode and X keysym.  There are a number of
- * keycodes that map to more than one corresponding keysym, and we need
- * to choose the right one.  Unfortunately, there are some keysyms that
- * can map to more than one keycode, depending on what kind of keyboard
- * is in use (e.g. F11 and F12).
- */
-
-KeymapEntry keymapTable[] =
-{
-    {java_awt_event_KeyEvent_VK_A, XK_a, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_B, XK_b, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_C, XK_c, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_D, XK_d, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_E, XK_e, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F, XK_f, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_G, XK_g, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_H, XK_h, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_I, XK_i, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_J, XK_j, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_K, XK_k, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_L, XK_l, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_M, XK_m, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_N, XK_n, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_O, XK_o, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_P, XK_p, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_Q, XK_q, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_R, XK_r, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_S, XK_s, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_T, XK_t, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_U, XK_u, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_V, XK_v, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_W, XK_w, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_X, XK_x, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_Y, XK_y, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_Z, XK_z, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* TTY Function keys */
-    {java_awt_event_KeyEvent_VK_BACK_SPACE, XK_BackSpace, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_TAB, XK_Tab, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_CLEAR, XK_Clear, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_ENTER, XK_Return, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_ENTER, XK_Linefeed, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PAUSE, XK_Pause, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PAUSE, XK_F21, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PAUSE, XK_R1, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_SCROLL_LOCK, XK_Scroll_Lock, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_SCROLL_LOCK, XK_F23, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_SCROLL_LOCK, XK_R3, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_ESCAPE, XK_Escape, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Other vendor-specific versions of TTY Function keys */
-    {java_awt_event_KeyEvent_VK_BACK_SPACE, osfXK_BackSpace, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_CLEAR, osfXK_Clear, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_ESCAPE, osfXK_Escape, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Modifier keys */
-    {java_awt_event_KeyEvent_VK_SHIFT, XK_Shift_L, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_LEFT},
-    {java_awt_event_KeyEvent_VK_SHIFT, XK_Shift_R, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_RIGHT},
-    {java_awt_event_KeyEvent_VK_CONTROL, XK_Control_L, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_LEFT},
-    {java_awt_event_KeyEvent_VK_CONTROL, XK_Control_R, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_RIGHT},
-    {java_awt_event_KeyEvent_VK_ALT, XK_Alt_L, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_LEFT},
-    {java_awt_event_KeyEvent_VK_ALT, XK_Alt_R, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_RIGHT},
-    {java_awt_event_KeyEvent_VK_META, XK_Meta_L, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_LEFT},
-    {java_awt_event_KeyEvent_VK_META, XK_Meta_R, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_RIGHT},
-    {java_awt_event_KeyEvent_VK_CAPS_LOCK, XK_Caps_Lock, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Misc Functions */
-    {java_awt_event_KeyEvent_VK_PRINTSCREEN, XK_Print, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PRINTSCREEN, XK_F22, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PRINTSCREEN, XK_R2, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_CANCEL, XK_Cancel, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_HELP, XK_Help, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_NUM_LOCK, XK_Num_Lock, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-
-    /* Other vendor-specific versions of Misc Functions */
-    {java_awt_event_KeyEvent_VK_CANCEL, osfXK_Cancel, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_HELP, osfXK_Help, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Rectangular Navigation Block */
-    {java_awt_event_KeyEvent_VK_HOME, XK_Home, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_HOME, XK_R7, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PAGE_UP, XK_Page_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PAGE_UP, XK_Prior, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PAGE_UP, XK_R9, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PAGE_DOWN, XK_Page_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PAGE_DOWN, XK_Next, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PAGE_DOWN, XK_R15, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_END, XK_End, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_END, XK_R13, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_INSERT, XK_Insert, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DELETE, XK_Delete, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Keypad equivalents of Rectangular Navigation Block */
-    {java_awt_event_KeyEvent_VK_HOME, XK_KP_Home, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_PAGE_UP, XK_KP_Page_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_PAGE_UP, XK_KP_Prior, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_PAGE_DOWN, XK_KP_Page_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_PAGE_DOWN, XK_KP_Next, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_END, XK_KP_End, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_INSERT, XK_KP_Insert, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_DELETE, XK_KP_Delete, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-
-    /* Other vendor-specific Rectangular Navigation Block */
-    {java_awt_event_KeyEvent_VK_PAGE_UP, osfXK_PageUp, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PAGE_UP, osfXK_Prior, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PAGE_DOWN, osfXK_PageDown, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PAGE_DOWN, osfXK_Next, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_END, osfXK_EndLine, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_INSERT, osfXK_Insert, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DELETE, osfXK_Delete, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Triangular Navigation Block */
-    {java_awt_event_KeyEvent_VK_LEFT, XK_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_UP, XK_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_RIGHT, XK_Right, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DOWN, XK_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Keypad equivalents of Triangular Navigation Block */
-    {java_awt_event_KeyEvent_VK_KP_LEFT, XK_KP_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_UP, XK_KP_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_RIGHT, XK_KP_Right, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_DOWN, XK_KP_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-
-    /* Other vendor-specific Triangular Navigation Block */
-    {java_awt_event_KeyEvent_VK_LEFT, osfXK_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_UP, osfXK_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_RIGHT, osfXK_Right, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DOWN, osfXK_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Remaining Cursor control & motion */
-    {java_awt_event_KeyEvent_VK_BEGIN, XK_Begin, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_BEGIN, XK_KP_Begin, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-
-    {java_awt_event_KeyEvent_VK_0, XK_0, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_1, XK_1, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_2, XK_2, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_3, XK_3, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_4, XK_4, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_5, XK_5, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_6, XK_6, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_7, XK_7, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_8, XK_8, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_9, XK_9, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    {java_awt_event_KeyEvent_VK_SPACE, XK_space, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_EXCLAMATION_MARK, XK_exclam, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_QUOTEDBL, XK_quotedbl, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_NUMBER_SIGN, XK_numbersign, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DOLLAR, XK_dollar, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_AMPERSAND, XK_ampersand, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_QUOTE, XK_apostrophe, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_LEFT_PARENTHESIS, XK_parenleft, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_RIGHT_PARENTHESIS, XK_parenright, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_ASTERISK, XK_asterisk, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PLUS, XK_plus, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_COMMA, XK_comma, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_MINUS, XK_minus, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PERIOD, XK_period, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_SLASH, XK_slash, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    {java_awt_event_KeyEvent_VK_COLON, XK_colon, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_SEMICOLON, XK_semicolon, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_LESS, XK_less, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_EQUALS, XK_equal, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_GREATER, XK_greater, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    {java_awt_event_KeyEvent_VK_AT, XK_at, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    {java_awt_event_KeyEvent_VK_OPEN_BRACKET, XK_bracketleft, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_BACK_SLASH, XK_backslash, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_CLOSE_BRACKET, XK_bracketright, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_CIRCUMFLEX, XK_asciicircum, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_UNDERSCORE, XK_underscore, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_BACK_QUOTE, XK_grave, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    {java_awt_event_KeyEvent_VK_BRACELEFT, XK_braceleft, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_BRACERIGHT, XK_braceright, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    {java_awt_event_KeyEvent_VK_INVERTED_EXCLAMATION_MARK, XK_exclamdown, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Remaining Numeric Keypad Keys */
-    {java_awt_event_KeyEvent_VK_NUMPAD0, XK_KP_0, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_NUMPAD1, XK_KP_1, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_NUMPAD2, XK_KP_2, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_NUMPAD3, XK_KP_3, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_NUMPAD4, XK_KP_4, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_NUMPAD5, XK_KP_5, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_NUMPAD6, XK_KP_6, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_NUMPAD7, XK_KP_7, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_NUMPAD8, XK_KP_8, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_NUMPAD9, XK_KP_9, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_SPACE, XK_KP_Space, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_TAB, XK_KP_Tab, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_ENTER, XK_KP_Enter, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_EQUALS, XK_KP_Equal, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_EQUALS, XK_R4, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_MULTIPLY, XK_KP_Multiply, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_MULTIPLY, XK_F26, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_MULTIPLY, XK_R6, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_ADD, XK_KP_Add, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_SEPARATOR, XK_KP_Separator, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_SUBTRACT, XK_KP_Subtract, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_SUBTRACT, XK_F24, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_DECIMAL, XK_KP_Decimal, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_DIVIDE, XK_KP_Divide, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_DIVIDE, XK_F25, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_DIVIDE, XK_R5, TRUE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-
-    /* Function Keys */
-    {java_awt_event_KeyEvent_VK_F1, XK_F1, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F2, XK_F2, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F3, XK_F3, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F4, XK_F4, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F5, XK_F5, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F6, XK_F6, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F7, XK_F7, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F8, XK_F8, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F9, XK_F9, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F10, XK_F10, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F11, XK_F11, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F12, XK_F12, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Sun vendor-specific version of F11 and F12 */
-    {java_awt_event_KeyEvent_VK_F11, SunXK_F36, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_F12, SunXK_F37, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* X11 keysym names for input method related keys don't always
-     * match keytop engravings or Java virtual key names, so here we
-     * only map constants that we've found on real keyboards.
-     */
-    /* Type 5c Japanese keyboard: kakutei */
-    {java_awt_event_KeyEvent_VK_ACCEPT, XK_Execute, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    /* Type 5c Japanese keyboard: henkan */
-    {java_awt_event_KeyEvent_VK_CONVERT, XK_Kanji, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    /* Type 5c Japanese keyboard: nihongo */
-    {java_awt_event_KeyEvent_VK_INPUT_METHOD_ON_OFF, XK_Henkan_Mode, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    /* VK_KANA_LOCK is handled separately because it generates the
-     * same keysym as ALT_GRAPH in spite of its different behavior.
-     */
-
-    {java_awt_event_KeyEvent_VK_COMPOSE, XK_Multi_key, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_ALT_GRAPH, XK_Mode_switch, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Editing block */
-    {java_awt_event_KeyEvent_VK_AGAIN, XK_Redo, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_AGAIN, XK_L2, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_UNDO, XK_Undo, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_UNDO, XK_L4, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_COPY, XK_L6, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PASTE, XK_L8, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_CUT, XK_L10, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_FIND, XK_Find, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_FIND, XK_L9, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PROPS, XK_L3, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_STOP, XK_L1, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Sun vendor-specific versions for editing block */
-    {java_awt_event_KeyEvent_VK_AGAIN, SunXK_Again, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_UNDO, SunXK_Undo, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_COPY, SunXK_Copy, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PASTE, SunXK_Paste, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_CUT, SunXK_Cut, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_FIND, SunXK_Find, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PROPS, SunXK_Props, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_STOP, SunXK_Stop, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Apollo (HP) vendor-specific versions for editing block */
-    {java_awt_event_KeyEvent_VK_COPY, apXK_Copy, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_CUT, apXK_Cut, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PASTE, apXK_Paste, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Other vendor-specific versions for editing block */
-    {java_awt_event_KeyEvent_VK_COPY, osfXK_Copy, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_CUT, osfXK_Cut, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_PASTE, osfXK_Paste, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_UNDO, osfXK_Undo, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Dead key mappings (for European keyboards) */
-    {java_awt_event_KeyEvent_VK_DEAD_GRAVE, XK_dead_grave, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_ACUTE, XK_dead_acute, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_CIRCUMFLEX, XK_dead_circumflex, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_TILDE, XK_dead_tilde, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_MACRON, XK_dead_macron, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_BREVE, XK_dead_breve, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_ABOVEDOT, XK_dead_abovedot, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_DIAERESIS, XK_dead_diaeresis, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_ABOVERING, XK_dead_abovering, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_DOUBLEACUTE, XK_dead_doubleacute, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_CARON, XK_dead_caron, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_CEDILLA, XK_dead_cedilla, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_OGONEK, XK_dead_ogonek, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_IOTA, XK_dead_iota, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_VOICED_SOUND, XK_dead_voiced_sound, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_SEMIVOICED_SOUND, XK_dead_semivoiced_sound, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Sun vendor-specific dead key mappings (for European keyboards) */
-    {java_awt_event_KeyEvent_VK_DEAD_GRAVE, SunXK_FA_Grave, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_CIRCUMFLEX, SunXK_FA_Circum, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_TILDE, SunXK_FA_Tilde, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_ACUTE, SunXK_FA_Acute, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_DIAERESIS, SunXK_FA_Diaeresis, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_CEDILLA, SunXK_FA_Cedilla, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* DEC vendor-specific dead key mappings (for European keyboards) */
-    {java_awt_event_KeyEvent_VK_DEAD_ABOVERING, DXK_ring_accent, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_CIRCUMFLEX, DXK_circumflex_accent, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_CEDILLA, DXK_cedilla_accent, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_ACUTE, DXK_acute_accent, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_GRAVE, DXK_grave_accent, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_TILDE, DXK_tilde, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_DIAERESIS, DXK_diaeresis, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    /* Other vendor-specific dead key mappings (for European keyboards) */
-    {java_awt_event_KeyEvent_VK_DEAD_ACUTE, hpXK_mute_acute, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_GRAVE, hpXK_mute_grave, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_CIRCUMFLEX, hpXK_mute_asciicircum, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_DIAERESIS, hpXK_mute_diaeresis, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-    {java_awt_event_KeyEvent_VK_DEAD_TILDE, hpXK_mute_asciitilde, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
-
-    {java_awt_event_KeyEvent_VK_UNDEFINED, NoSymbol, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN}
-};
-
-static Boolean
-keyboardHasKanaLockKey()
-{
-    static Boolean haveResult = FALSE;
-    static Boolean result = FALSE;
-
-    int32_t minKeyCode, maxKeyCode, keySymsPerKeyCode;
-    KeySym *keySyms, *keySymsStart, keySym;
-    int32_t i;
-    int32_t kanaCount = 0;
-
-    // Solaris doesn't let you swap keyboards without rebooting,
-    // so there's no need to check for the kana lock key more than once.
-    if (haveResult) {
-       return result;
-    }
-
-    // There's no direct way to determine whether the keyboard has
-    // a kana lock key. From available keyboard mapping tables, it looks
-    // like only keyboards with the kana lock key can produce keysyms
-    // for kana characters. So, as an indirect test, we check for those.
-
-    XDisplayKeycodes(awt_display, &minKeyCode, &maxKeyCode);
-    keySyms = XGetKeyboardMapping(awt_display, minKeyCode, maxKeyCode - minKeyCode + 1, &keySymsPerKeyCode);
-    keySymsStart = keySyms;
-    for (i = 0; i < (maxKeyCode - minKeyCode + 1) * keySymsPerKeyCode; i++) {
-        keySym = *keySyms++;
-        if ((keySym & 0xff00) == 0x0400) {
-            kanaCount++;
-        }
-    }
-    XFree(keySymsStart);
-
-    // use a (somewhat arbitrary) minimum so we don't get confused by a stray function key
-    result = kanaCount > 10;
-    haveResult = TRUE;
-    return result;
-}
-
-void
-keysymToAWTKeyCode(KeySym x11Key, jint *keycode, Boolean *mapsToUnicodeChar,
-  jint *keyLocation)
-{
-    int32_t i;
-
-    // Solaris uses XK_Mode_switch for both the non-locking AltGraph
-    // and the locking Kana key, but we want to keep them separate for
-    // KeyEvent.
-    if (x11Key == XK_Mode_switch && keyboardHasKanaLockKey()) {
-        *keycode = java_awt_event_KeyEvent_VK_KANA_LOCK;
-        *mapsToUnicodeChar = FALSE;
-        *keyLocation = java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN;
-        return;
-    }
-
-    for (i = 0;
-         keymapTable[i].awtKey != java_awt_event_KeyEvent_VK_UNDEFINED;
-         i++) {
-        if (keymapTable[i].x11Key == x11Key) {
-            *keycode = keymapTable[i].awtKey;
-            *mapsToUnicodeChar = keymapTable[i].mapsToUnicodeChar;
-            *keyLocation = keymapTable[i].keyLocation;
-            return;
-        }
-    }
-
-    *keycode = java_awt_event_KeyEvent_VK_UNDEFINED;
-    *mapsToUnicodeChar = FALSE;
-    *keyLocation = java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN;
-
-    DTRACE_PRINTLN1("keysymToAWTKeyCode: no key mapping found: keysym = %x", x11Key);
-}
-
-KeySym
-awt_getX11KeySym(jint awtKey)
-{
-    int32_t i;
-
-    if (awtKey == java_awt_event_KeyEvent_VK_KANA_LOCK && keyboardHasKanaLockKey()) {
-        return XK_Mode_switch;
-    }
-
-    for (i = 0; keymapTable[i].awtKey != 0; i++) {
-        if (keymapTable[i].awtKey == awtKey) {
-            return keymapTable[i].x11Key;
-        }
-    }
-
-    DTRACE_PRINTLN1("awt_getX11KeySym: no key mapping found: awtKey = %x", awtKey);
-    return NoSymbol;
-}
-
-
-typedef struct COLLAPSE_INFO {
-    Window win;
-    DamageRect *r;
-} CollapseInfo;
-
-static void
-expandDamageRect(DamageRect * drect, XEvent * xev, Boolean debug, char *str)
-{
-    int32_t x1 = xev->xexpose.x;
-    int32_t y1 = xev->xexpose.y;
-    int32_t x2 = x1 + xev->xexpose.width;
-    int32_t y2 = y1 + xev->xexpose.height;
-
-    /*
-      if (debug) {
-      printf("   %s: collapsing (%d,%d %dx%d) into (%d,%d %dx%d) ->>",
-      str, x1, y1, xev->xexpose.width, xev->xexpose.height,
-      drect->x1, drect->y1, drect->x2 - drect->x1, drect->y2 - drect->y1);
-      }
-    */
-
-    drect->x1 = MIN(x1, drect->x1);
-    drect->y1 = MIN(y1, drect->y1);
-    drect->x2 = MAX(x2, drect->x2);
-    drect->y2 = MAX(y2, drect->y2);
-
-    /*
-      if (debug) {
-      printf("(%d,%d %dx%d) %s\n",
-      drect->x1, drect->y1, drect->x2 - drect->x1, drect->y2 - drect->y1);
-      }
-    */
-
-}
-
-static Bool
-checkForExpose(Display * dpy, XEvent * evt, XPointer client_data)
-{
-    CollapseInfo *cinfo = (CollapseInfo *) client_data;
-
-    if ((evt->type == Expose && evt->xexpose.window == cinfo->win &&
-         INTERSECTS(cinfo->r->x1, cinfo->r->x2, cinfo->r->y1, cinfo->r->y2,
-                    evt->xexpose.x,
-                    evt->xexpose.x + evt->xexpose.width,
-                    evt->xexpose.y,
-                    evt->xexpose.y + evt->xexpose.height)) ||
-        (evt->type == GraphicsExpose && evt->xgraphicsexpose.drawable == cinfo->win &&
-         INTERSECTS(cinfo->r->x1, cinfo->r->x2, cinfo->r->y1, cinfo->r->y2,
-                    evt->xgraphicsexpose.x,
-                    evt->xgraphicsexpose.x + evt->xgraphicsexpose.width,
-                    evt->xgraphicsexpose.y,
-                    evt->xgraphicsexpose.y + evt->xgraphicsexpose.height))) {
-
-        return True;
-    }
-    return False;
-}
-
-/*
- * javaObject is an MComponentPeer instance
- */
-static void
-HandleExposeEvent(Widget w, jobject javaObject, XEvent * event)
-{
-    jobject target;
-    jint wdth, hght;
-
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-    switch (event->type) {
-        case Expose:
-        case GraphicsExpose:
-        {
-            struct ComponentData *cdata;
-            Boolean debug = FALSE;
-            jint drawState;
-
-            /* Set the draw state */
-            drawState = (*env)->GetIntField(env, javaObject,
-                mComponentPeerIDs.drawState);
-            (*env)->SetIntField(env, javaObject, mComponentPeerIDs.drawState,
-                drawState | JAWT_LOCK_CLIP_CHANGED);
-            cdata = (struct ComponentData *)
-              JNU_GetLongFieldAsPtr(env, javaObject, mComponentPeerIDs.pData);
-            if (JNU_IsNull(env, javaObject) || (cdata == NULL)) {
-                return;
-            }
-            if (event->xexpose.send_event) {
-                if (cdata->repaintPending & RepaintPending_REPAINT) {
-                    cdata->repaintPending &= ~RepaintPending_REPAINT;
-
-                    JNU_CallMethodByName(env,
-                                         NULL,
-                                         javaObject,
-                                         "handleRepaint",
-                                         "(IIII)V",
-                                         (jint) cdata->repaintRect.x1,
-                                         (jint) cdata->repaintRect.y1,
-                                         (jint) cdata->repaintRect.x2
-                                         - cdata->repaintRect.x1,
-                                         (jint) cdata->repaintRect.y2
-                                         - cdata->repaintRect.y1);
-                    if ((*env)->ExceptionOccurred(env)) {
-                        (*env)->ExceptionDescribe(env);
-                        (*env)->ExceptionClear(env);
-                    }
-                }
-                return;
-            }
-            if ((cdata->repaintPending & RepaintPending_EXPOSE) == 0) {
-                cdata->exposeRect.x1 = event->xexpose.x;
-                cdata->exposeRect.y1 = event->xexpose.y;
-                cdata->exposeRect.x2 = cdata->exposeRect.x1 + event->xexpose.width;
-                cdata->exposeRect.y2 = cdata->exposeRect.y1 + event->xexpose.height;
-                cdata->repaintPending |= RepaintPending_EXPOSE;
-            } else {
-                expandDamageRect(&(cdata->exposeRect), event, debug, "1");
-            }
-
-            /* Only post Expose/Repaint if we know others arn't following
-             * directly in the queue.
-             */
-            if (event->xexpose.count == 0) {
-                int32_t count = 0;
-                CollapseInfo cinfo;
-
-                cinfo.win = XtWindow(w);
-                cinfo.r = &(cdata->exposeRect);
-
-                /* Do a little more inspecting and collapse further if there
-                 * are additional expose events pending on this window where
-                 * the damage rects intersect with the current exposeRect.
-                 */
-                while (TRUE) {
-                    XEvent xev;
-
-                    if (XCheckIfEvent(XtDisplay(w), &xev
-                                      ,checkForExpose, (XtPointer) & cinfo)) {
-                        count = xev.xexpose.count;
-                        expandDamageRect(&(cdata->exposeRect), &xev, debug, "2");
-
-                    } else {
-                        /* XCheckIfEvent Failed. */
-                        break;
-                    }
-                }
-
-                cdata->repaintPending &= ~RepaintPending_EXPOSE;
-
-                /* Fix for bugtraq id 4262108. Paint events should not be
-                 * delivered to components that have one of their
-                 * dimensions equal to zero.
-                 */
-
-                if ((*env)->EnsureLocalCapacity(env, 1) < 0) {
-                    return;
-                }
-
-                target = (*env)->GetObjectField(env, javaObject,
-                                                    mComponentPeerIDs.target);
-                wdth = (*env)->GetIntField(env, target, componentIDs.width);
-                hght = (*env)->GetIntField(env, target, componentIDs.height);
-                (*env)->DeleteLocalRef(env, target);
-
-                if ( wdth != 0 && hght != 0) {
-                    JNU_CallMethodByName(env,
-                                        NULL,
-                                        javaObject,
-                                        "handleExpose",
-                                        "(IIII)V",
-                                        (jint) cdata->exposeRect.x1,
-                                        (jint) cdata->exposeRect.y1,
-                                        (jint) cdata->exposeRect.x2
-                                        - cdata->exposeRect.x1,
-                                        (jint) cdata->exposeRect.y2
-                                        - cdata->exposeRect.y1);
-                    if ((*env)->ExceptionOccurred(env)) {
-                        (*env)->ExceptionDescribe(env);
-                        (*env)->ExceptionClear(env);
-                    }
-                }
-            }
-        }
-        break;
-
-        default:
-            jio_fprintf(stderr, "Got event %d in HandleExposeEvent!\n", event->type);
-    }
-}
-
-/* We always store and return JNI GlobalRefs. */
-static jweak focusOwnerPeer = NULL;
-static jweak focusedWindowPeer = NULL;
-
-/*
- * This function should only be called under the
- * protection of AWT_LOCK(). Otherwise, multithreaded access
- * can corrupt the value of focusOwnerPeer variable.
- * This function returns LocalRef, result should be deleted
- * explicitly if called on a thread that never returns to
- * Java.
- */
-jobject
-awt_canvas_getFocusOwnerPeer() {
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject res;
-    AWT_LOCK();
-    res = (*env)->NewLocalRef(env, focusOwnerPeer);
-    AWT_UNLOCK();
-    return res;
-}
-
-/*
- * This function should only be called under the
- * protection of AWT_LOCK(). Otherwise, multithreaded access
- * can corrupt the value of focusedWindowPeer variable.
- * This function returns LocalRef, result should be deleted
- * explicitly if called on a thread that never returns to
- * Java.
- */
-jobject
-awt_canvas_getFocusedWindowPeer() {
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject res;
-    AWT_LOCK();
-    res = (*env)->NewLocalRef(env, focusedWindowPeer);
-    AWT_UNLOCK();
-    return res;
-}
-
-/*
- * Only call this function under AWT_LOCK(). Otherwise, multithreaded
- * access can corrupt the value of focusOwnerPeer variable.
- */
-void
-awt_canvas_setFocusOwnerPeer(jobject peer) {
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    AWT_LOCK();
-    if (focusOwnerPeer != NULL) {
-        (*env)->DeleteWeakGlobalRef(env, focusOwnerPeer);
-    }
-    focusOwnerPeer = (peer != NULL)
-        ? (*env)->NewWeakGlobalRef(env, peer) : NULL;
-    AWT_UNLOCK();
-}
-
-/*
- * Only call this function under AWT_LOCK(). Otherwise, multithreaded
- * access can corrupt the value of focusedWindowPeer variable.
- */
-void
-awt_canvas_setFocusedWindowPeer(jobject peer) {
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    AWT_LOCK();
-    if (focusedWindowPeer != NULL) {
-        (*env)->DeleteWeakGlobalRef(env, focusedWindowPeer);
-    }
-    focusedWindowPeer = (peer != NULL)
-        ? (*env)->NewWeakGlobalRef(env, peer) : NULL;
-    AWT_UNLOCK();
-}
-
-void callFocusCallback(jobject focusPeer, int focus_type, jobject cause) {
-    awt_post_java_focus_event(focusPeer,
-                              focus_type,
-                              cause,
-                              NULL);
-    awt_canvas_setFocusOwnerPeer(focusPeer);
-}
-
-
-void
-handleFocusEvent(Widget w,
-                 XFocusChangeEvent * fevent,
-                 XtPointer client_data,
-                 Boolean * cont,
-                 Boolean passEvent,
-                 jobject cause)
-{
-    if (fevent->type == FocusIn) {
-        if (fevent->mode == NotifyNormal &&
-            fevent->detail != NotifyPointer && fevent->detail != NotifyVirtual)
-        {
-#ifdef DEBUG_FOCUS
-            printf("window = %d, mode = %d, detail = %d\n", fevent->window, fevent->mode, fevent->detail);
-            printf("----posting java FOCUS GAINED on window %d, pass = %d\n", XtWindow(w), passEvent);
-#endif
-            awt_post_java_focus_event(client_data,
-                                      java_awt_event_FocusEvent_FOCUS_GAINED,
-                                      cause,
-                                      NULL);
-            awt_canvas_setFocusOwnerPeer(client_data);
-        }
-    } else {
-        /* FocusOut */
-        if (fevent->mode == NotifyNormal &&
-            fevent->detail != NotifyPointer && fevent->detail != NotifyVirtual)
-        {
-#ifdef DEBUG_FOCUS
-          printf("window = %d, mode = %d, detail = %d\n", fevent->window, fevent->mode, fevent->detail);
-          printf("----posting java FOCUS LOST on window %d, pass = %d, temp = %d\n", XtWindow(w), passEvent, temp);
-#endif
-            awt_post_java_focus_event(client_data,
-                                      java_awt_event_FocusEvent_FOCUS_LOST,
-                                      cause,
-                                      NULL);
-            awt_canvas_setFocusOwnerPeer(NULL);
-        }
-    }
-    *cont = TRUE;
-}
-
-void callFocusHandler(Widget w, int eventType, jobject cause) {
-    jobject peer = NULL;
-    XFocusChangeEvent event;
-    Boolean cont;
-    JNIEnv *env = (JNIEnv *) JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-    if (w == NULL) {
-        return;
-    }
-
-    peer = findPeer(&w);
-    if (peer == NULL) {
-        w = findTopLevelByShell(w);
-        if (w != NULL) {
-            peer = findPeer(&w);
-        }
-    }
-    if (peer == NULL) {
-        return;
-    }
-    memset(&event, 0, sizeof(event));
-    event.type = eventType;
-    event.mode = NotifyNormal;
-    event.detail = NotifyAncestor;
-    event.window = XtWindow(w);
-    cont = FALSE;
-    handleFocusEvent(w, &event, (XtPointer)peer, &cont, TRUE, cause);
-}
-
-/**
- * Copy XEvent to jbyteArray and save it in AWTEvent
- */
-void
-awt_copyXEventToAWTEvent(JNIEnv *env, XEvent * xev, jobject jevent)
-{
-    jbyteArray bdata;
-    if (xev != NULL) {
-        if ((*env)->EnsureLocalCapacity(env, 1) < 0) {
-            return;
-        }
-        bdata = (*env)->NewByteArray(env, sizeof(XEvent));
-        if (bdata != NULL) {
-            (*env)->SetByteArrayRegion(env, bdata, 0, sizeof(XEvent),
-                                       (jbyte *)xev);
-            (*env)->SetObjectField(env, jevent, awtEventIDs.bdata, bdata);
-            (*env)->DeleteLocalRef(env, bdata);
-        }
-    }
-}
-
-/* Returns new modifiers set like ???_DOWN_MASK for keyboard and mouse after the event.
- * The modifiers on a Java key event reflect the state of the modifier keys
- * immediately AFTER the key press or release.  This usually doesn't require
- * us to change the modifiers: the exception is when the key pressed or
- * released is a modifier key.  Since the state of an XEvent represents
- * the modifiers BEFORE the event, we change the modifiers according to
- * the button and keycode.
- */
-jint
-getModifiers(uint32_t state, jint button, jint keyCode)
-{
-    jint modifiers = 0;
-
-    if (((state & ShiftMask) != 0) ^ (keyCode == java_awt_event_KeyEvent_VK_SHIFT))
-    {
-        modifiers |= java_awt_event_InputEvent_SHIFT_DOWN_MASK;
-    }
-    if (((state & ControlMask) != 0) ^ (keyCode == java_awt_event_KeyEvent_VK_CONTROL))
-    {
-        modifiers |= java_awt_event_InputEvent_CTRL_DOWN_MASK;
-    }
-    if (((state & awt_MetaMask) != 0) ^ (keyCode == java_awt_event_KeyEvent_VK_META))
-    {
-        modifiers |= java_awt_event_InputEvent_META_DOWN_MASK;
-    }
-    if (((state & awt_AltMask) != 0) ^ (keyCode == java_awt_event_KeyEvent_VK_ALT))
-    {
-        modifiers |= java_awt_event_InputEvent_ALT_DOWN_MASK;
-    }
-    if (((state & awt_ModeSwitchMask) != 0) ^ (keyCode == java_awt_event_KeyEvent_VK_ALT_GRAPH))
-    {
-        modifiers |= java_awt_event_InputEvent_ALT_GRAPH_DOWN_MASK;
-    }
-    if (((state & Button1Mask) != 0) ^ (button == java_awt_event_MouseEvent_BUTTON1)) {
-        modifiers |= java_awt_event_InputEvent_BUTTON1_DOWN_MASK;
-    }
-    if (((state & Button2Mask) != 0) ^ (button == java_awt_event_MouseEvent_BUTTON2)) {
-        modifiers |= java_awt_event_InputEvent_BUTTON2_DOWN_MASK;
-    }
-    if (((state & Button3Mask) != 0) ^ (button == java_awt_event_MouseEvent_BUTTON3)) {
-        modifiers |= java_awt_event_InputEvent_BUTTON3_DOWN_MASK;
-    }
-    return modifiers;
-}
-
-/* Returns which mouse button has changed state
- */
-jint
-getButton(uint32_t button)
-{
-    switch (button) {
-    case Button1:
-        return java_awt_event_MouseEvent_BUTTON1;
-    case Button2:
-        return java_awt_event_MouseEvent_BUTTON2;
-    case Button3:
-        return java_awt_event_MouseEvent_BUTTON3;
-    }
-    return java_awt_event_MouseEvent_NOBUTTON;
-}
-
-
-/* This function changes the state of the native XEvent AFTER
- * the corresponding Java event has been processed.  The XEvent
- * needs to be modified before it is dispatched to the native widget.
- */
-void
-awt_modify_KeyEvent(JNIEnv *env, XEvent *xevent, jobject jevent)
-{
-    jint keyCode;
-    jchar keyChar;
-    jint modifiers;
-    KeySym keysym = (KeySym) java_awt_event_KeyEvent_CHAR_UNDEFINED;
-
-    if (xevent->type != KeyPress && xevent->type != KeyRelease) {
-        return;
-    }
-
-    keyCode = (*env)->GetIntField(env, jevent, keyEventIDs.keyCode);
-    keyChar = (*env)->GetCharField(env, jevent, keyEventIDs.keyChar);
-    modifiers = (*env)->GetIntField(env, jevent, inputEventIDs.modifiers);
-
-    switch (keyCode) {
-        case java_awt_event_KeyEvent_VK_MULTIPLY:
-        case java_awt_event_KeyEvent_VK_SUBTRACT:
-        case java_awt_event_KeyEvent_VK_DIVIDE:
-            /* Bugid 4103229:  Change the X event so these three Numpad
-             * keys work with the NumLock off.  For some reason, Motif
-             * widgets ignore the events produced by these three keys
-             * unless the NumLock is on.  It also ignores them if some
-             * other modifiers are set.  Turn off ALL modifiers, then
-             * turn NumLock mask on in the X event.
-             */
-            xevent->xkey.state = awt_NumLockMask;
-            return;
-        case java_awt_event_KeyEvent_VK_ENTER:
-        case java_awt_event_KeyEvent_VK_BACK_SPACE:
-        case java_awt_event_KeyEvent_VK_TAB:
-        case java_awt_event_KeyEvent_VK_ESCAPE:
-        case java_awt_event_KeyEvent_VK_ADD:
-        case java_awt_event_KeyEvent_VK_DECIMAL:
-        case java_awt_event_KeyEvent_VK_NUMPAD0:
-        case java_awt_event_KeyEvent_VK_NUMPAD1:
-        case java_awt_event_KeyEvent_VK_NUMPAD2:
-        case java_awt_event_KeyEvent_VK_NUMPAD3:
-        case java_awt_event_KeyEvent_VK_NUMPAD4:
-        case java_awt_event_KeyEvent_VK_NUMPAD5:
-        case java_awt_event_KeyEvent_VK_NUMPAD6:
-        case java_awt_event_KeyEvent_VK_NUMPAD7:
-        case java_awt_event_KeyEvent_VK_NUMPAD8:
-        case java_awt_event_KeyEvent_VK_NUMPAD9:
-            keysym = awt_getX11KeySym(keyCode);
-            break;
-        case java_awt_event_KeyEvent_VK_DELETE:
-            /* For some reason XKeysymToKeycode returns incorrect value for
-             * Delete, so we don't want to modify the original event
-             */
-            break;
-        default:
-            if (keyChar < (KeySym) 256) {
-                keysym = (KeySym) keyChar;
-            } else {
-                keysym = awt_getX11KeySym(keyCode);
-            }
-            break;
-    }
-
-    if (keysym < (KeySym) 256) {
-        if (modifiers & java_awt_event_InputEvent_CTRL_MASK) {
-            switch (keysym + 64) {
-                case '[':
-                case ']':
-                case '\\':
-                case '_':
-                    keysym += 64;
-                    break;
-                default:
-                    if (isalpha((int32_t)(keysym + 'a' - 1))) {
-                        keysym += ('a' - 1);
-                    }
-                    break;
-            }
-        }
-        /*
-         * 0xff61 is Unicode value of first XK_kana_fullstop.
-         * We need X Keysym to Unicode map in post1.1 release
-         * to support more international keyboards.
-         */
-        if (keysym >= (KeySym) 0xff61 && keysym <= (KeySym) 0xff9f) {
-            keysym = keysym - 0xff61 + XK_kana_fullstop;
-        }
-        xevent->xkey.keycode = XKeysymToKeycode(awt_display, keysym);
-    }
-
-    if (keysym >= 'A' && keysym <= 'Z') {
-        xevent->xkey.state |= ShiftMask;
-    }
-    if (modifiers & java_awt_event_InputEvent_SHIFT_DOWN_MASK) {
-        xevent->xkey.state |= ShiftMask;
-    }
-    if (modifiers & java_awt_event_InputEvent_CTRL_DOWN_MASK) {
-        xevent->xkey.state |= ControlMask;
-    }
-    if (modifiers & java_awt_event_InputEvent_META_DOWN_MASK) {
-        xevent->xkey.state |= awt_MetaMask;
-    }
-    if (modifiers & java_awt_event_InputEvent_ALT_DOWN_MASK) {
-        xevent->xkey.state |= awt_AltMask;
-    }
-    if (modifiers & java_awt_event_InputEvent_ALT_GRAPH_DOWN_MASK) {
-        xevent->xkey.state |= awt_ModeSwitchMask;
-    }
-    if (modifiers & java_awt_event_InputEvent_BUTTON1_DOWN_MASK) {
-        xevent->xkey.state |= Button1Mask;
-    }
-    if (modifiers & java_awt_event_InputEvent_BUTTON2_DOWN_MASK) {
-        xevent->xkey.state |= Button2Mask;
-    }
-    if (modifiers & java_awt_event_InputEvent_BUTTON3_DOWN_MASK) {
-        xevent->xkey.state |= Button3Mask;
-    }
-}
-
-
-/* Called from handleKeyEvent.  The purpose of this function is
- * to check for a list of vendor-specific keysyms, most of which
- * have values greater than 0xFFFF.  Most of these keys don't map
- * to unicode characters, but some do.
- *
- * For keys that don't map to unicode characters, the keysym
- * is irrelevant at this point.  We set the keysym to zero
- * to ensure that the switch statement immediately below
- * this function call (in adjustKeySym) won't incorrectly act
- * on them after the high bits are stripped off.
- *
- * For keys that do map to unicode characters, we change the keysym
- * to the equivalent that is < 0xFFFF
- */
-static void
-handleVendorKeySyms(XEvent *event, KeySym *keysym)
-{
-    KeySym originalKeysym = *keysym;
-
-    switch (*keysym) {
-        /* Apollo (HP) vendor-specific from <X11/ap_keysym.h> */
-        case apXK_Copy:
-        case apXK_Cut:
-        case apXK_Paste:
-        /* DEC vendor-specific from <X11/DECkeysym.h> */
-        case DXK_ring_accent:         /* syn usldead_ring */
-        case DXK_circumflex_accent:
-        case DXK_cedilla_accent:      /* syn usldead_cedilla */
-        case DXK_acute_accent:
-        case DXK_grave_accent:
-        case DXK_tilde:
-        case DXK_diaeresis:
-        /* Sun vendor-specific from <X11/Sunkeysym.h> */
-        case SunXK_FA_Grave:
-        case SunXK_FA_Circum:
-        case SunXK_FA_Tilde:
-        case SunXK_FA_Acute:
-        case SunXK_FA_Diaeresis:
-        case SunXK_FA_Cedilla:
-        case SunXK_F36:                /* Labeled F11 */
-        case SunXK_F37:                /* Labeled F12 */
-        case SunXK_Props:
-        case SunXK_Copy:
-        case SunXK_Open:
-        case SunXK_Paste:
-        case SunXK_Cut:
-        /* Other vendor-specific from HPkeysym.h */
-        case hpXK_mute_acute:          /* syn usldead_acute */
-        case hpXK_mute_grave:          /* syn usldead_grave */
-        case hpXK_mute_asciicircum:    /* syn usldead_asciicircum */
-        case hpXK_mute_diaeresis:      /* syn usldead_diaeresis */
-        case hpXK_mute_asciitilde:     /* syn usldead_asciitilde */
-        case osfXK_Copy:
-        case osfXK_Cut:
-        case osfXK_Paste:
-        case osfXK_PageUp:
-        case osfXK_PageDown:
-        case osfXK_EndLine:
-        case osfXK_Clear:
-        case osfXK_Left:
-        case osfXK_Up:
-        case osfXK_Right:
-        case osfXK_Down:
-        case osfXK_Prior:
-        case osfXK_Next:
-        case osfXK_Insert:
-        case osfXK_Undo:
-        case osfXK_Help:
-            *keysym = 0;
-            break;
-        /*
-         * The rest DO map to unicode characters, so translate them
-         */
-        case osfXK_BackSpace:
-            *keysym = XK_BackSpace;
-            break;
-        case osfXK_Escape:
-            *keysym = XK_Escape;
-            break;
-        case osfXK_Cancel:
-            *keysym = XK_Cancel;
-            break;
-        case osfXK_Delete:
-            *keysym = XK_Delete;
-            break;
-        default:
-            break;
-    }
-
-    if (originalKeysym != *keysym) {
-        DTRACE_PRINTLN2("In handleVendorKeySyms: originalKeysym=%x, keysym=%x",
-          originalKeysym, *keysym);
-    }
-}
-
-/* Called from handleKeyEvent.
- * The purpose of this function is to adjust the keysym and XEvent
- * keycode for a key event.  This is basically a conglomeration of
- * bugfixes that require these adjustments.
- */
-static void
-adjustKeySym(XEvent *event, KeySym *keysym)
-{
-    KeySym originalKeysym = *keysym;
-
-    /* We have seen bits set in the high two bytes on Linux,
-     * which prevents this switch statement from executing
-     * correctly.  Strip off the high order bits.
-     */
-    *keysym &= 0x0000FFFF;
-
-    switch (*keysym) {
-        case XK_Return:
-            *keysym = XK_Linefeed;     /* fall thru */
-        case XK_BackSpace:
-        case XK_Tab:
-        case XK_Linefeed:
-        case XK_Escape:
-        case XK_Delete:
-            /* strip off highorder bits defined in keysymdef.h
-             * I think doing this converts them to values that
-             * we can cast to jchars and use as java keychars.
-             * If so, it's really a hack.
-             */
-            *keysym &= 0x007F;
-            break;
-        case XK_Cancel:
-            *keysym = 0x0018;  /* the unicode char for Cancel */
-            break;
-        case XK_KP_Decimal:
-            *keysym = '.';
-            break;
-        case XK_KP_Add:
-            *keysym = '+';
-            break;
-        case XK_F24:           /* NumLock off */
-        case XK_KP_Subtract:   /* NumLock on */
-            *keysym = '-';
-            break;
-        case XK_F25:           /* NumLock off */
-        case XK_KP_Divide:     /* NumLock on */
-            *keysym = '/';
-            break;
-        case XK_F26:           /* NumLock off */
-        case XK_KP_Multiply:   /* NumLock on */
-            *keysym = '*';
-            break;
-        case XK_KP_Equal:
-            *keysym = '=';
-            break;
-        case XK_KP_0:
-            *keysym = '0';
-            break;
-        case XK_KP_1:
-            *keysym = '1';
-            break;
-        case XK_KP_2:
-            *keysym = '2';
-            break;
-        case XK_KP_3:
-            *keysym = '3';
-            break;
-        case XK_KP_4:
-            *keysym = '4';
-            break;
-        case XK_KP_5:
-            *keysym = '5';
-            break;
-        case XK_KP_6:
-            *keysym = '6';
-            break;
-        case XK_KP_7:
-            *keysym = '7';
-            break;
-        case XK_KP_8:
-            *keysym = '8';
-            break;
-        case XK_KP_9:
-            *keysym = '9';
-            break;
-        case XK_KP_Left:  /* Bug 4350175 */
-            *keysym = XK_Left;
-            event->xkey.keycode = XKeysymToKeycode(awt_display, *keysym);
-            break;
-        case XK_KP_Up:
-            *keysym = XK_Up;
-            event->xkey.keycode = XKeysymToKeycode(awt_display, *keysym);
-            break;
-        case XK_KP_Right:
-            *keysym = XK_Right;
-            event->xkey.keycode = XKeysymToKeycode(awt_display, *keysym);
-            break;
-        case XK_KP_Down:
-            *keysym = XK_Down;
-            event->xkey.keycode = XKeysymToKeycode(awt_display, *keysym);
-            break;
-        case XK_KP_Home:
-            *keysym = XK_Home;
-            event->xkey.keycode = XKeysymToKeycode(awt_display, *keysym);
-            break;
-        case XK_KP_End:
-            *keysym = XK_End;
-            event->xkey.keycode = XKeysymToKeycode(awt_display, *keysym);
-            break;
-        case XK_KP_Page_Up:
-            *keysym = XK_Page_Up;
-            event->xkey.keycode = XKeysymToKeycode(awt_display, *keysym);
-            break;
-        case XK_KP_Page_Down:
-            *keysym = XK_Page_Down;
-            event->xkey.keycode = XKeysymToKeycode(awt_display, *keysym);
-            break;
-        case XK_KP_Begin:
-            *keysym = XK_Begin;
-            event->xkey.keycode = XKeysymToKeycode(awt_display, *keysym);
-            break;
-        case XK_KP_Insert:
-            *keysym = XK_Insert;
-            event->xkey.keycode = XKeysymToKeycode(awt_display, *keysym);
-            break;
-        case XK_KP_Delete:
-            *keysym = XK_Delete;
-            event->xkey.keycode = XKeysymToKeycode(awt_display, *keysym);
-            *keysym &= 0x007F;
-            break;
-        case XK_KP_Enter:
-            *keysym = XK_Linefeed;
-            event->xkey.keycode = XKeysymToKeycode(awt_display, XK_Return);
-            *keysym &= 0x007F;
-            break;
-        default:
-            break;
-    }
-
-    if (originalKeysym != *keysym) {
-        DTRACE_PRINTLN2("In adjustKeySym: originalKeysym=%x, keysym=%x",
-          originalKeysym, *keysym);
-    }
-}
-
-/*
- * What a sniffer sez?
- * Xsun and Xorg if NumLock is on do two thing different:
- * keep Keypad key in different places of keysyms array and
- * ignore/obey "ModLock is ShiftLock", so we should choose.
- * People say, it's right to use behavior and not Vendor tags to decide.
- * Maybe. But why these tags were invented, then?
- * TODO: use behavior, not tags. Maybe.
- */
-static Boolean
-isXsunServer(XEvent *event) {
-    if( awt_ServerDetected ) return awt_IsXsun;
-    if( strncmp( ServerVendor( event->xkey.display ), "Sun Microsystems, Inc.", 32) ) {
-        awt_ServerDetected = True;
-        awt_IsXsun = False;
-        return False;
-    }
-    // Now, it's Sun. It still may be Xorg though, eg on Solaris 10, x86.
-    // Today (2005), VendorRelease of Xorg is a Big Number unlike Xsun.
-    if( VendorRelease( event->xkey.display ) > 10000 ) {
-        awt_ServerDetected = True;
-        awt_IsXsun = False;
-        return False;
-    }
-    awt_ServerDetected = True;
-    awt_IsXsun = True;
-    return True;
-}
-static Boolean
-isKPevent(XEvent *event)
-{
-    /*
-       Xlib manual, ch 12.7 says, as a first rule for choice of keysym:
-       The numlock modifier is on and the second KeySym is a keypad KeySym. In this case,
-       if the Shift modifier is on, or if the Lock modifier is on and is interpreted as ShiftLock,
-       then the first KeySym is used, otherwise the second KeySym is used.
-
-       However, Xsun server does ignore ShiftLock and always takes 3-rd element from an array.
-
-       So, is it a keypad keysym?
-     */
-    jint mods = getModifiers(event->xkey.state, 0, event->xkey.keycode);
-    Boolean bsun = isXsunServer( event );
-
-    return IsKeypadKey( XKeycodeToKeysym(event->xkey.display, event->xkey.keycode,(bsun && !awt_UseXKB ? 2 : 1) ) );
-}
-/*
- * In a next redesign, get rid of this code altogether.
- *
- */
-static void
-handleKeyEventWithNumLockMask_New(XEvent *event, KeySym *keysym)
-{
-    KeySym originalKeysym = *keysym;
-    if( !isKPevent( event ) ) {
-        return;
-    }
-    if( isXsunServer( event ) && !awt_UseXKB ) {
-        if( (event->xkey.state & ShiftMask) ) { // shift modifier is on
-            *keysym = XKeycodeToKeysym(event->xkey.display,
-                                   event->xkey.keycode, 3);
-         }else {
-            *keysym = XKeycodeToKeysym(event->xkey.display,
-                                   event->xkey.keycode, 2);
-         }
-    } else {
-        if( (event->xkey.state & ShiftMask) || // shift modifier is on
-            ((event->xkey.state & LockMask) && // lock modifier is on
-             (awt_ModLockIsShiftLock)) ) {     // it is interpreted as ShiftLock
-            *keysym = XKeycodeToKeysym(event->xkey.display,
-                                   event->xkey.keycode, 0);
-        }else{
-            *keysym = XKeycodeToKeysym(event->xkey.display,
-                                   event->xkey.keycode, 1);
-        }
-    }
-}
-
-/* Called from handleKeyEvent.
- * The purpose of this function is to make some adjustments to keysyms
- * that have been found to be necessary when the NumLock mask is set.
- * They come from various bug fixes and rearchitectures.
- * This function is meant to be called when
- * (event->xkey.state & awt_NumLockMask) is TRUE.
- */
-static void
-handleKeyEventWithNumLockMask(XEvent *event, KeySym *keysym)
-{
-    KeySym originalKeysym = *keysym;
-
-#ifndef __linux__
-    /* The following code on Linux will cause the keypad keys
-     * not to echo on JTextField when the NumLock is on. The
-     * keysyms will be 0, because the last parameter 2 is not defined.
-     * See Xlib Programming Manual, O'Reilly & Associates, Section
-     * 9.1.5 "Other Keyboard-handling Routines", "The meaning of
-     * the keysym list beyond the first two (unmodified, Shift or
-     * Shift Lock) is not defined."
-     */
-
-    /* Translate again with NumLock as modifier. */
-    /* ECH - I wonder why we think that NumLock corresponds to 2?
-     * On Linux, we've seen xmodmap -pm yield mod2 as NumLock,
-     * but I don't know that it will be for every configuration.
-     * Perhaps using the index (modn in awt_MToolkit.c:setup_modifier_map)
-     * would be more correct.
-     */
-    *keysym = XKeycodeToKeysym(event->xkey.display,
-                               event->xkey.keycode, 2);
-    if (originalKeysym != *keysym) {
-        DTRACE_PRINTLN3("%s=%x, keysym=%x",
-          "In handleKeyEventWithNumLockMask ifndef linux: originalKeysym",
-          originalKeysym, *keysym);
-    }
-#endif
-
-    /* Note: the XK_R? key assignments are for Type 4 kbds */
-    switch (*keysym) {
-        case XK_R13:
-            *keysym = XK_KP_1;
-            break;
-        case XK_R14:
-            *keysym = XK_KP_2;
-            break;
-        case XK_R15:
-            *keysym = XK_KP_3;
-            break;
-        case XK_R10:
-            *keysym = XK_KP_4;
-            break;
-        case XK_R11:
-            *keysym = XK_KP_5;
-            break;
-        case XK_R12:
-            *keysym = XK_KP_6;
-            break;
-        case XK_R7:
-            *keysym = XK_KP_7;
-            break;
-        case XK_R8:
-            *keysym = XK_KP_8;
-            break;
-        case XK_R9:
-            *keysym = XK_KP_9;
-            break;
-        case XK_KP_Insert:
-            *keysym = XK_KP_0;
-            break;
-        case XK_KP_Delete:
-            *keysym = XK_KP_Decimal;
-            break;
-        case XK_R4:
-            *keysym = XK_KP_Equal;  /* Type 4 kbd */
-            break;
-        case XK_R5:
-            *keysym = XK_KP_Divide;
-            break;
-        case XK_R6:
-            *keysym = XK_KP_Multiply;
-            break;
-        /*
-         * Need the following keysym changes for Linux key releases.
-         * Sometimes the modifier state gets messed up, so we get a
-         * KP_Left when we should get a KP_4, for example.
-         * XK_KP_Insert and XK_KP_Delete were already handled above.
-         */
-        case XK_KP_Left:
-            *keysym = XK_KP_4;
-            break;
-        case XK_KP_Up:
-            *keysym = XK_KP_8;
-            break;
-        case XK_KP_Right:
-            *keysym = XK_KP_6;
-            break;
-        case XK_KP_Down:
-            *keysym = XK_KP_2;
-            break;
-        case XK_KP_Home:
-            *keysym = XK_KP_7;
-            break;
-        case XK_KP_End:
-            *keysym = XK_KP_1;
-            break;
-        case XK_KP_Page_Up:
-            *keysym = XK_KP_9;
-            break;
-        case XK_KP_Page_Down:
-            *keysym = XK_KP_3;
-            break;
-        case XK_KP_Begin:
-            *keysym = XK_KP_5;
-            break;
-        default:
-            break;
-    }
-
-    if (originalKeysym != *keysym) {
-        DTRACE_PRINTLN2("In handleKeyEventWithNumLockMask: originalKeysym=%x, keysym=%x",
-          originalKeysym, *keysym);
-    }
-}
-
-static void
-handleKeyEvent(jint keyEventId,
-               XEvent *event,
-               XtPointer *client_data,
-               Boolean *cont,
-               Boolean passEvent)
-{
-    KeySym keysym = NoSymbol;
-    jint keycode = java_awt_event_KeyEvent_VK_UNDEFINED;
-    Modifiers mods = 0;
-    Boolean mapsToUnicodeChar = FALSE;
-    jint keyLocation = java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN;
-    jint modifiers = 0;
-
-    DTRACE_PRINTLN4("\nEntered handleKeyEvent: type=%d, xkeycode=%x, xstate=%x, keysym=%x",
-      event->type, event->xkey.keycode, event->xkey.state, keysym);
-
-    if (currentX11InputMethodInstance != NULL
-        && keyEventId == java_awt_event_KeyEvent_KEY_PRESSED
-        && event->xkey.window == currentFocusWindow)
-    {
-        /* invokes XmbLookupString to get a committed string or keysym if any.  */
-        if (awt_x11inputmethod_lookupString((XKeyPressedEvent*)event, &keysym)) {
-            *cont = FALSE;
-            return;
-        }
-    }
-
-    /* Ignore the keysym found immediately above in
-     * awt_x11inputmethod_lookupString; the methodology in that function
-     * sometimes returns incorrect results.
-     *
-     * Get keysym without taking modifiers into account first.
-     * This keysym is not necessarily for the character that was typed:
-     * it is for the primary layer.  So, if $ were typed by pressing
-     * shift-4, this call should give us 4, not $
-     *
-     * We only want this keysym so we can use it to index into the
-     * keymapTable to get the Java keycode associated with the
-     * primary layer key that was pressed.
-     */
-    keysym = XKeycodeToKeysym(event->xkey.display, event->xkey.keycode, 0);
-
-    /* Linux: Sometimes the keysym returned is uppercase when CapsLock is
-     * on and LockMask is not set in event->xkey.state.
-     */
-    if (keysym >= (KeySym) 'A' && keysym <= (KeySym) 'Z') {
-        event->xkey.state |= LockMask;
-        keysym = (KeySym) tolower((int32_t) keysym);
-    }
-
-    DTRACE_PRINTLN4("In handleKeyEvent: type=%d, xkeycode=%x, xstate=%x, keysym=%x",
-      event->type, event->xkey.keycode, event->xkey.state, keysym);
-
-    if (keysym == NoSymbol) {
-        *cont = TRUE;
-        return;
-    }
-
-    if (keysym < (KeySym) 256) {
-        keysymToAWTKeyCode(keysym, &keycode, &mapsToUnicodeChar, &keyLocation);
-
-        /* Now get real keysym which looks at modifiers
-         * XtGetActionKeySym() returns wrong value with Kana Lock,
-         * so use XtTranslateKeycode().
-         */
-        XtTranslateKeycode(event->xkey.display, (KeyCode) event->xkey.keycode,
-                           event->xkey.state, &mods, &keysym);
-        DTRACE_PRINTLN6("%s: type=%d, xkeycode=%x, xstate=%x, keysym=%x, xmods=%d",
-          "In handleKeyEvent keysym<256 ", event->type, event->xkey.keycode,
-          event->xkey.state, keysym, mods);
-
-        /* Linux: With caps lock on, chars echo lowercase. */
-        if ((event->xkey.state & LockMask) &&
-             (keysym >= (KeySym) 'a' && keysym <= (KeySym) 'z'))
-        {
-            keysym = (KeySym) toupper((int32_t) keysym);
-        }
-
-        if ((event->xkey.state & ControlMask)) {
-            switch (keysym) {
-                case '[':
-                case ']':
-                case '\\':
-                case '_':
-                    keysym -= 64;
-                    break;
-                default:
-                    if (isalpha((int32_t) keysym)) {
-                        keysym = (KeySym) tolower((int32_t) keysym) - 'a' + 1;
-                    }
-                    break;
-            }
-        }
-
-        if (keysym >= (KeySym) XK_kana_fullstop &&
-            keysym <= (KeySym) XK_semivoicedsound) {
-            /*
-             * 0xff61 is Unicode value of first XK_kana_fullstop.
-             * We need X Keysym to Unicode map in post1.1 release
-             * to support more intenational keyboard.
-             */
-            keysym = keysym - XK_kana_fullstop + 0xff61;
-        }
-
-        modifiers = getModifiers(event->xkey.state, 0, keycode);
-        DTRACE_PRINTLN6("%s: type=%d, xkeycode=%x, xstate=%x, keysym=%x, AWTmodifiers=%d",
-          "In handleKeyEvent keysym<256 ", event->type, event->xkey.keycode,
-          event->xkey.state, keysym, modifiers);
-
-        awt_post_java_key_event(client_data,
-                                keyEventId,
-                                (passEvent == TRUE) ?  event : NULL,
-                                event->xkey.time,
-                                keycode,
-                                (jchar) keysym,
-                                modifiers,
-                                keyLocation,
-                                event);
-
-        if (keyEventId == java_awt_event_KeyEvent_KEY_PRESSED) {
-            awt_post_java_key_event(client_data,
-              java_awt_event_KeyEvent_KEY_TYPED,
-              NULL,
-              event->xkey.time,
-              java_awt_event_KeyEvent_VK_UNDEFINED,
-              (jchar) keysym,
-              modifiers,
-              java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN,
-              event);
-
-        }
-    } else {
-        if (event->xkey.state & awt_NumLockMask) {
-            if( awt_UseType4Patch ) {
-                handleKeyEventWithNumLockMask(event, &keysym);
-            }else{
-                handleKeyEventWithNumLockMask_New(event, &keysym);
-            }
-        }
-
-        if (keysym == XK_ISO_Left_Tab) {
-            keysym = XK_Tab;
-        }
-
-        /* The keysym here does not consider modifiers, so these results
-         * are relevant to the KEY_PRESSED event only, not the KEY_TYPED
-         */
-        keysymToAWTKeyCode(keysym, &keycode, &mapsToUnicodeChar, &keyLocation);
-        DTRACE_PRINTLN3("In handleKeyEvent: keysym=%x, AWTkeycode=%x, mapsToUnicodeChar=%d",
-          keysym, keycode, mapsToUnicodeChar);
-
-        if (keycode == java_awt_event_KeyEvent_VK_UNDEFINED) {
-            *cont = TRUE;
-            return;
-        }
-
-        /* Need to take care of keysyms > 0xFFFF here
-         * Most of these keys don't map to unicode characters, but some do.
-         *
-         * For keys that don't map to unicode characters, the keysym
-         * is irrelevant at this point.  We set the keysym to zero
-         * to ensure that the switch statement immediately below
-         * this function call (in adjustKeySym) won't incorrectly act
-         * on them after the high bits are stripped off.
-         *
-         * For keys that do map to unicode characters, we change the keysym
-         * to the equivalent that is < 0xFFFF
-         */
-        handleVendorKeySyms(event, &keysym);
-
-        /* This function is a conglomeration of bug fixes that adjust
-         * the keysym and XEvent keycode for this key event.
-         */
-        adjustKeySym(event, &keysym);
-
-        modifiers = getModifiers(event->xkey.state, 0, keycode);
-
-        DTRACE_PRINTLN6("%s: type=%d, xkeycode=%x, xstate=%x, keysym=%x, xmods=%d",
-          "In handleKeyEvent keysym>=256 ", event->type, event->xkey.keycode,
-          event->xkey.state, keysym, mods);
-        DTRACE_PRINTLN2("                              AWTkeycode=%x, AWTmodifiers=%d",
-          keycode, modifiers);
-
-        awt_post_java_key_event(client_data,
-          keyEventId,
-          (passEvent == TRUE) ? event : NULL,
-          event->xkey.time,
-          keycode,
-          (jchar) (mapsToUnicodeChar ? keysym :
-            java_awt_event_KeyEvent_CHAR_UNDEFINED),
-          modifiers,
-          keyLocation,
-          event);
-
-        /* If this was a keyPressed event, we may need to post a
-         * keyTyped event, too.  Otherwise, return.
-         */
-        if (keyEventId == java_awt_event_KeyEvent_KEY_RELEASED) {
-            return;
-        }
-        DTRACE_PRINTLN("This is a keyPressed event");
-
-        /* XtTranslateKeycode seems to return slightly bogus values for the
-         * Escape key (keysym==1004ff69==osfXK_Cancel, xmods=2) on Solaris,
-         * so we just create the KEY_TYPED as a special case for Escape here.
-         * (Linux works fine, and this was also okay running under VNC.)
-         */
-        if (keycode == java_awt_event_KeyEvent_VK_ESCAPE) {
-            awt_post_java_key_event(client_data,
-              java_awt_event_KeyEvent_KEY_TYPED,
-              NULL,
-              event->xkey.time,
-              java_awt_event_KeyEvent_VK_UNDEFINED,
-              (jchar) keysym,
-              modifiers,
-              java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN,
-              event);
-
-            DTRACE_PRINTLN("Posted a keyTyped event for VK_ESCAPE");
-            return;
-        }
-
-        /* Now get real keysym which looks at modifiers for keyTyped event.
-         * XtGetActionKeySym() returns wrong value with Kana Lock,
-         * so use XtTranslateKeycode().
-         */
-        XtTranslateKeycode(event->xkey.display, (KeyCode) event->xkey.keycode,
-                           event->xkey.state, &mods, &keysym);
-        DTRACE_PRINTLN6("%s: type=%d, xkeycode=%x, xstate=%x, keysym=%x, xmods=%d",
-          "In handleKeyEvent keysym>=256 ", event->type, event->xkey.keycode,
-          event->xkey.state, keysym, mods);
-
-        if (keysym == NoSymbol) {
-            return;
-        }
-
-        if (event->xkey.state & awt_NumLockMask) {
-            if( awt_UseType4Patch ) {
-                handleKeyEventWithNumLockMask(event, &keysym);
-            }else{
-                handleKeyEventWithNumLockMask_New(event, &keysym);
-            }
-        }
-
-        if (keysym == XK_ISO_Left_Tab) {
-            keysym = XK_Tab;
-        }
-
-        /* Map the real keysym to a Java keycode */
-        keysymToAWTKeyCode(keysym, &keycode, &mapsToUnicodeChar, &keyLocation);
-        DTRACE_PRINTLN3("In handleKeyEvent: keysym=%x, AWTkeycode=%x, mapsToUnicodeChar=%d",
-          keysym, keycode, mapsToUnicodeChar);
-
-        /* If it doesn't map to a Unicode character, don't post a keyTyped event */
-        if (!mapsToUnicodeChar) {
-            return;
-        }
-
-        handleVendorKeySyms(event, &keysym);
-        adjustKeySym(event, &keysym);
-        DTRACE_PRINT4("In handleKeyEvent: type=%d, xkeycode=%x, xstate=%x, keysym=%x",
-          event->type, event->xkey.keycode, event->xkey.state, keysym);
-        DTRACE_PRINTLN2(", AWTkeycode=%x, AWTmodifiers=%d", keycode, modifiers);
-
-        awt_post_java_key_event(client_data,
-          java_awt_event_KeyEvent_KEY_TYPED,
-          NULL,
-          event->xkey.time,
-          java_awt_event_KeyEvent_VK_UNDEFINED,
-          (jchar) keysym,
-          modifiers,
-          java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN,
-          event);
-    }
-}
-
-
-static void
-translateXY(Widget w, jint *xp, jint *yp)
-{
-    Position wx, wy;
-
-    XtVaGetValues(w, XmNx, &wx, XmNy, &wy, NULL);
-    *xp += wx;
-    *yp += wy;
-}
-
-
-/*
- * Part fix for bug id 4017222. Return the root widget of the Widget parameter.
- */
-Widget
-getRootWidget(Widget w) {
-    if(!w) return NULL;
-
-    if(XtParent(w))
-        return getRootWidget(XtParent(w));
-    else
-        return w;
-}
-
-#define ABS(x) ((x) < 0 ? -(x) : (x))
-
-/* This proc is the major AWT engine for processing X events
- * for Java components and is the proc responsible for taking
- * X events and posting their corresponding Java event to the
- * AWT EventQueue.  It is set up to be called both from an Xt
- * event handler and directly from MToolkit.c:shouldDispatchToWidget().
- * For the latter case, the "passEvent" parameter will be true,
- * which means that the event is being posted on the Java queue
- * BEFORE it is being passed to Xt and so a copy of the X event
- * must be stored within the Java event structure so it can be
- * dispatched to Xt later on.
- */
-void
-awt_canvas_handleEvent(Widget w, XtPointer client_data,
-                       XEvent * event, struct WidgetInfo *winfo,
-                       Boolean * cont, Boolean passEvent)
-{
-    static jint clickCount = 1;
-    static XtPointer lastPeer = NULL;
-    static Time lastTime = 0;
-    static jint lastx = 0;
-    static jint lasty = 0;
-    static int32_t rbutton = 0;
-    static int32_t lastButton = 0;
-    Boolean popupTrigger;
-    jint x, y;
-    jint modifiers = 0;
-    jint button = java_awt_event_MouseEvent_NOBUTTON;
-    uint32_t fullRelease = 0;
-    WidgetClass wclass = NULL;
-
-    /* Any event handlers which take peer instance pointers as
-     * client_data should check to ensure the widget has not been
-     * marked as destroyed as a result of a dispose() call on the peer
-     * (which can result in the peer instance pointer already haven
-     * been gc'd by the time this event is processed)
-     */
-    if (w->core.being_destroyed) {
-        return;
-    }
-    *cont = FALSE;
-
-    switch (event->type) {
-        case SelectionClear:
-        case SelectionNotify:
-        case SelectionRequest:
-            *cont = TRUE;
-            break;
-        case GraphicsExpose:
-        case Expose:
-            HandleExposeEvent(w, (jobject) client_data, event);
-            break;
-        case FocusIn:
-        case FocusOut:
-            *cont = TRUE;
-            updateCursor(client_data, CACHE_UPDATE); // 4840883
-            // We no longer listen to the Motif focus notifications.
-            // Instead we call focus callbacks in the times we think
-            // appropriate trying to simulate correct Motif widget system
-            // behavior.
-            break;
-        case ButtonPress:
-            x = (jint) event->xbutton.x;
-            y = (jint) event->xbutton.y;
-
-            if (lastPeer == client_data &&
-                lastButton == event->xbutton.button &&
-                (event->xbutton.time - lastTime) <= (Time) awt_multiclick_time) {
-                    clickCount++;
-            } else {
-                clickCount = 1;
-                lastPeer = client_data;
-                lastButton = event->xbutton.button;
-                lastx = x;
-                lasty = y;
-            }
-            lastTime = event->xbutton.time;
-
-            /* On MouseEvent.MOUSE_PRESSED, RELEASED and CLICKED  only new modifiers and
-             * modifier for changed mouse button are set.
-             */
-            button = getButton(event->xbutton.button);
-            modifiers = getModifiers(event->xbutton.state, button, 0);
-
-
-            /* If the widget is a subwidget on a component we need to
-             * translate the x,y into the coordinate space of the component.
-             */
-            if (winfo != NULL && winfo->widget != winfo->origin) {
-                translateXY(winfo->widget, &x, &y);
-            }
-
-            if (XtIsSubclass(w, xmScrollBarWidgetClass) && findWidgetInfo(w) != NULL) {
-                passEvent = FALSE;
-                *cont = TRUE;
-            }
-
-            /* Mouse wheel events come in as button 4 (wheel up) and
-             * button 5 (wheel down).
-             */
-            if (lastButton == 4 || lastButton == 5) {
-                *cont = FALSE;
-                awt_post_java_mouse_event(client_data,
-                                          java_awt_event_MouseEvent_MOUSE_WHEEL,
-                                          (passEvent == TRUE) ? event : NULL,
-                                          event->xbutton.time,
-                                          modifiers,
-                                          x, y,
-                                          (jint) (event->xbutton.x_root),
-                                          (jint) (event->xbutton.y_root),
-                                          clickCount,
-                                          False,
-                                          lastButton == 4 ? -1 : 1,
-                                          java_awt_event_MouseEvent_NOBUTTON);
-                /* we're done with this event */
-                break;
-            }
-
-            /* (4168006) Find out out how many buttons we have
-             * If this is a two button system Right == 2
-             * If this is a three button system Right == 3
-             */
-            if ( rbutton == 0 ) {
-                unsigned char map[5];
-                rbutton = XGetPointerMapping ( awt_display, map, 3 );
-            }
-
-            if (event->xbutton.button == rbutton || event->xbutton.button > 2) {
-                popupTrigger = True;
-            } else {
-                popupTrigger = False;
-            }
-
-            awt_post_java_mouse_event(client_data,
-                                      java_awt_event_MouseEvent_MOUSE_PRESSED,
-                                      (passEvent == TRUE) ? event : NULL,
-                                      event->xbutton.time,
-                                      modifiers,
-                                      x, y,
-                                      (jint) (event->xbutton.x_root),
-                                      (jint) (event->xbutton.y_root),
-                                      clickCount,
-                                      popupTrigger, 0,
-                                      button);
-
-            drag_source = w;
-
-            break;
-        case ButtonRelease:
-            if (XtIsSubclass(w, xmScrollBarWidgetClass) && findWidgetInfo(w) != NULL) {
-                passEvent = FALSE;
-                *cont = TRUE;
-            }
-
-            /*
-             * For button 4 & 5 (mouse wheel) we can simply ignore this event.
-             * We dispatch the wheel on the ButtonPress.
-             */
-            if (event->xbutton.button == 4 ||
-                event->xbutton.button == 5) {
-                break;
-            }
-
-            prevWidget = NULL;
-            x = (jint) event->xbutton.x;
-            y = (jint) event->xbutton.y;
-            /* On MouseEvent.MOUSE_PRESSED, RELEASED and CLICKED  only new modifiers and
-             * modifier for changed mouse button are set.
-             */
-            button = getButton(event->xbutton.button);
-            modifiers = getModifiers(event->xbutton.state, button, 0);
-
-            fullRelease =
-              ((event->xbutton.state & Button1Mask) &&
-               !(event->xbutton.state & Button2Mask) &&
-               !(event->xbutton.state & Button3Mask) &&
-               (event->xbutton.button == Button1)) ||
-              (!(event->xbutton.state & Button1Mask) &&
-               (event->xbutton.state & Button2Mask) &&
-               !(event->xbutton.state & Button3Mask) &&
-               (event->xbutton.button == Button2)) ||
-              (!(event->xbutton.state & Button1Mask) &&
-               !(event->xbutton.state & Button2Mask) &&
-               (event->xbutton.state & Button3Mask) &&
-               (event->xbutton.button == Button3));
-
-            /* If the widget is a subwidget on a component we need to
-             * translate the x,y into the coordinate space of the component.
-             */
-            if (winfo != NULL && winfo->widget != winfo->origin) {
-                translateXY(winfo->widget, &x, &y);
-            }
-            drag_source = NULL;
-            awt_post_java_mouse_event(client_data,
-                                      java_awt_event_MouseEvent_MOUSE_RELEASED,
-                                      (passEvent == TRUE) ? event : NULL,
-                                      event->xbutton.time,
-                                      modifiers,
-                                      x, y,
-                                      (jint) (event->xbutton.x_root),
-                                      (jint) (event->xbutton.y_root),
-                                      clickCount,
-                                      FALSE, 0,
-                                      button);
-
-            if (lastPeer == client_data) {
-                awt_post_java_mouse_event(client_data,
-                                          java_awt_event_MouseEvent_MOUSE_CLICKED,
-                                          NULL,
-                                          event->xbutton.time,
-                                          modifiers,
-                                          x, y,
-                                          (jint) (event->xbutton.x_root),
-                                          (jint) (event->xbutton.y_root),
-                                          clickCount,
-                                          FALSE, 0,
-                                          button);
-            }
-
-            if (fullRelease) {
-                updateCursor(client_data, UPDATE_ONLY);
-            }
-
-        break;
-        case MotionNotify:
-            if (XtIsSubclass(w, xmScrollBarWidgetClass) && findWidgetInfo(w) != NULL) {
-                passEvent = FALSE;
-                *cont = TRUE;
-            }
-
-            x = (jint) event->xmotion.x;
-            y = (jint) event->xmotion.y;
-
-            /* If a motion comes in while a multi-click is pending,
-             * allow a smudge factor so that moving the mouse by a small
-             * amount does not wipe out the multi-click state variables.
-             */
-            if (!(lastPeer == client_data &&
-                  ((event->xmotion.time - lastTime) <= (Time) awt_multiclick_time) &&
-                  (ABS(lastx - x) < awt_multiclick_smudge &&
-                   ABS(lasty - y) < awt_multiclick_smudge))) {
-                clickCount = (jint) 0;
-                lastTime = (Time) 0;
-                lastPeer = NULL;
-                lastx = (jint) 0;
-                lasty = (jint) 0;
-            }
-            /* On other MouseEvent only new modifiers and
-             * old mouse modifiers are set.
-             */
-            modifiers = getModifiers(event->xmotion.state, 0, 0);
-
-            /* If the widget is a subwidget on a component we need to
-             * translate the x,y into the coordinate space of the component.
-             */
-            if (winfo != NULL && winfo->widget != winfo->origin) {
-                translateXY(winfo->widget, &x, &y);
-            }
-            if (event->xmotion.state & (Button1Mask | Button2Mask | Button3Mask)) {
-                if (!clickCount) {
-
-            /*
-                Fix for bug id 4017222. A button is down, so EnterNotify and
-                LeaveNotify events are only being sent to this widget. If
-                the pointer has moved over a new widget, manually generate
-                MouseEnter and MouseExit and send them to the right widgets.
-            */
-
-                extern Widget awt_WidgetAtXY(Widget root, Position x, Position y);
-                extern Widget awt_GetWidgetAtPointer();
-                Widget currentWidget=NULL, topLevelW;
-                Position wx=0, wy=0;
-
-                XtTranslateCoords(w, (int32_t) x, (int32_t) y, &wx, &wy);
-                /* Get the top level widget underneath the mouse pointer */
-                currentWidget = awt_GetWidgetAtPointer();
-                /* Get the exact widget at the current XY from the top level */
-                currentWidget = awt_WidgetAtXY(currentWidget, wx, wy);
-                if ((prevWidget != NULL) && (prevWidget != w) &&
-                    (currentWidget != prevWidget) && awt_isAwtWidget(prevWidget) &&
-                    !prevWidget->core.being_destroyed) {
-                    XtPointer userData=NULL;
-                    XtVaGetValues(prevWidget, XmNuserData, &userData, NULL);
-                    if (userData) {
-                        awt_post_java_mouse_event(userData,
-                            java_awt_event_MouseEvent_MOUSE_EXITED,
-                            (passEvent==TRUE) ? event : NULL,
-                            event->xmotion.time,
-                            modifiers,
-                            x, y,
-                            (jint) (event->xmotion.x_root),
-                            (jint) (event->xmotion.y_root),
-                            clickCount,
-                            FALSE, 0,
-                            java_awt_event_MouseEvent_NOBUTTON);
-                    }
-                }
-
-                if ((currentWidget != NULL) && (currentWidget != w) &&
-                    (currentWidget != prevWidget) && awt_isAwtWidget(currentWidget)) {
-                    XtPointer userData=NULL;
-                    XtVaGetValues(currentWidget, XmNuserData, &userData, NULL);
-                    if (userData) {
-                        awt_post_java_mouse_event(userData,
-                            java_awt_event_MouseEvent_MOUSE_ENTERED,
-                            (passEvent==TRUE) ? event : NULL,
-                            event->xmotion.time,
-                            modifiers,
-                            x, y,
-                            (jint) (event->xmotion.x_root),
-                            (jint) (event->xmotion.y_root),
-                            clickCount,
-                            FALSE, 0,
-                            java_awt_event_MouseEvent_NOBUTTON);
-                    }
-
-                    updateCursor(userData, CACHE_ONLY);
-                    awt_util_setCursor(currentWidget, None);
-                }
-
-                prevWidget = currentWidget;
-                /* end 4017222 */
-
-
-                awt_post_java_mouse_event(client_data,
-                                          java_awt_event_MouseEvent_MOUSE_DRAGGED,
-                                          (passEvent == TRUE) ? event : NULL,
-                                          event->xmotion.time,
-                                          modifiers,
-                                          x, y,
-                                          (jint) (event->xmotion.x_root),
-                                          (jint) (event->xmotion.y_root),
-                                          clickCount,
-                                          FALSE, 0,
-                                          java_awt_event_MouseEvent_NOBUTTON);
-
-            }
-            } else {
-
-                awt_post_java_mouse_event(client_data,
-                                          java_awt_event_MouseEvent_MOUSE_MOVED,
-                                          (passEvent == TRUE) ? event : NULL,
-                                          event->xmotion.time,
-                                          modifiers,
-                                          x, y,
-                                          (jint) (event->xmotion.x_root),
-                                          (jint) (event->xmotion.y_root),
-                                          clickCount,
-                                          FALSE, 0,
-                                          java_awt_event_MouseEvent_NOBUTTON);
-            }
-            break;
-        case KeyPress:
-            handleKeyEvent(java_awt_event_KeyEvent_KEY_PRESSED,
-                           event, client_data, cont, TRUE);
-            break;
-        case KeyRelease:
-            handleKeyEvent(java_awt_event_KeyEvent_KEY_RELEASED,
-                           event, client_data, cont, TRUE);
-            break;
-        case EnterNotify:
-        case LeaveNotify:
-/*
-  printf("----->%s on %s(%x):mode=%d detail = %d\n",
-  event->type == EnterNotify?"EnterNotify":"LeaveNotify",
-  XtName(w), w,
-  ((XCrossingEvent*)event)->mode, ((XCrossingEvent*)event)->detail);
-*/
-        if (event->xcrossing.mode != NotifyNormal ||
-                ((event->xcrossing.detail == NotifyVirtual ||
-                  event->xcrossing.detail == NotifyNonlinearVirtual) &&
-                 !XtIsSubclass(w, xmScrolledWindowWidgetClass))) {
-                *cont = TRUE;
-                return;
-            }
-
-            /* fix for 4454304.
-             * We should not post MOUSE_ENTERED and MOUSE_EXITED events
-             * if the mouse pointer is in the place between component
-             * and its scrollbars.
-             * kdm@sparc.spb.su
-             */
-            if (winfo != NULL && winfo->widget != NULL) {
-                wclass = XtClass(winfo->widget);
-                if (event->xcrossing.subwindow == NULL
-                    && event->xcrossing.detail == NotifyInferior
-                    && (wclass == xmTextWidgetClass
-                        || wclass == xmListWidgetClass)) {
-                    *cont = TRUE;
-                    return;
-                }
-            }
-
-            clickCount = (jint) 0;
-            lastTime = (Time) 0;
-            lastPeer = NULL;
-
-            /* On other MouseEvent only new modifiers and
-             * old mouse modifiers are set.
-             */
-            modifiers = getModifiers(event->xcrossing.state, 0, 0);
-
-            switch (event->type) {
-                case EnterNotify:
-                    awt_post_java_mouse_event(client_data,
-                                              java_awt_event_MouseEvent_MOUSE_ENTERED,
-                                              (passEvent == TRUE) ? event : NULL,
-                                              event->xcrossing.time,
-                                              modifiers,
-                                              (jint) (event->xcrossing.x),
-                                              (jint) (event->xcrossing.y),
-                                              (jint) (event->xcrossing.x_root),
-                                              (jint) (event->xcrossing.y_root),
-                                              clickCount,
-                                              FALSE, 0,
-                                              java_awt_event_MouseEvent_NOBUTTON);
-                    if (!(event->xcrossing.state
-                        & (Button1Mask | Button2Mask | Button3Mask))) {
-                        updateCursor(client_data, CACHE_UPDATE);
-                    }
-
-                    break;
-                case LeaveNotify:
-                    awt_post_java_mouse_event(client_data,
-                                              java_awt_event_MouseEvent_MOUSE_EXITED,
-                                              (passEvent == TRUE) ? event : NULL,
-                                              event->xcrossing.time,
-                                              modifiers,
-                                              (jint) (event->xcrossing.x),
-                                              (jint) (event->xcrossing.y),
-                                              (jint) (event->xcrossing.x_root),
-                                              (jint) (event->xcrossing.y_root),
-                                              clickCount,
-                                              FALSE, 0,
-                                              java_awt_event_MouseEvent_NOBUTTON);
-                    break;
-            }
-            break;
-
-        default:
-            break;
-    }
-}
-
-/*
- * client_data is MComponentPeer subclass
- */
-void
-awt_canvas_event_handler(Widget w, XtPointer client_data,
-                         XEvent * event, Boolean * cont)
-{
-    awt_canvas_handleEvent(w, client_data, event, NULL, cont, FALSE);
-}
-
-void
-awt_canvas_reconfigure(struct FrameData *wdata)
-{
-    Dimension w, h;
-
-    if (wdata->winData.comp.widget == NULL ||
-        XtParent(wdata->winData.comp.widget) == NULL) {
-        return;
-    }
-    XtVaGetValues(XtParent(wdata->winData.comp.widget), XmNwidth, &w, XmNheight, &h, NULL);
-    XtConfigureWidget(wdata->winData.comp.widget,
-                      -(wdata->left),
-                      -(wdata->top),
-                      w + (wdata->left + wdata->right),
-                      h + (wdata->top + wdata->bottom),
-                      0);
-}
-
-static void
-Wrap_event_handler(Widget widget,
-                   XtPointer client_data,
-                   XmDrawingAreaCallbackStruct * call_data)
-{
-    awt_canvas_reconfigure((struct FrameData *) client_data);
-}
-
-
-Widget
-awt_canvas_create(XtPointer this,
-                  Widget parent,
-                  char *base,
-                  int32_t width,
-                  int32_t height,
-                  Boolean parentIsFrame,
-                  struct FrameData *wdata,
-                  AwtGraphicsConfigDataPtr awtData)
-{
-    Widget newCanvas;
-    Widget wrap;
-#define MAX_ARGC 20
-    Arg args[MAX_ARGC];
-    int32_t argc;
-    char name[128];
-    static XtTranslations translationKeyDown = NULL;
-
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-
-    if (parent == NULL) {
-        JNU_ThrowNullPointerException(env, "NullPointerException");
-        return NULL;
-    }
-    if (width == 0) {
-        width = 1;
-    }
-    if (height == 0) {
-        height = 1;
-    }
-
-    if (wdata != NULL) {
-        argc = 0;
-        if  (!parentIsFrame)
-        {
-            XtSetArg(args[argc], XmNwidth, width);
-            argc++;
-            XtSetArg(args[argc], XmNheight, height);
-            argc++;
-        }
-        XtSetArg(args[argc], XmNmarginWidth, 0);
-        argc++;
-        XtSetArg(args[argc], XmNmarginHeight, 0);
-        argc++;
-        XtSetArg(args[argc], XmNspacing, 0);
-        argc++;
-        XtSetArg(args[argc], XmNresizePolicy, XmRESIZE_NONE);
-        argc++;
-        /* check for overflowing name? */
-        strcpy(name, base);
-        strcat(name, "wrap");
-
-        DASSERT(!(argc > MAX_ARGC));
-        wrap = XmCreateDrawingArea(parent, name, args, argc);
-        if  (!parentIsFrame)
-        {
-            /* Fixing bugs in frame module (awt_Frame.c).  It will now
-               provide the resize handling for this inner/parent canvas.*/
-            XtAddCallback(wrap, XmNresizeCallback,
-                          (XtCallbackProc) Wrap_event_handler, wdata);
-        }
-        XtManageChild(wrap);
-    } else {
-        wrap = parent;
-    }
-
-    /* check for overflowing name? */
-    strcpy(name, base);
-    strcat(name, "canvas");
-
-    argc = 0;
-    XtSetArg(args[argc], XmNspacing, 0);
-    argc++;
-    if  (!parentIsFrame)
-    {
-        XtSetArg(args[argc], XmNwidth, width);
-        argc++;
-        XtSetArg(args[argc], XmNheight, height);
-        argc++;
-    }
-    XtSetArg(args[argc], XmNmarginHeight, 0);
-    argc++;
-    XtSetArg(args[argc], XmNmarginWidth, 0);
-    argc++;
-    XtSetArg(args[argc], XmNresizePolicy, XmRESIZE_NONE);
-    argc++;
-    XtSetArg(args[argc], XmNuserData, this);
-    argc++;
-    /* Fixed 4059430, 3/11/98, robi.khan@eng
-     * install insert proc callback so components are ordered correctly
-     * when added directly to frame/dialogs/windows
-     */
-    XtSetArg(args[argc], XmNinsertPosition, (XtPointer) awt_util_insertCallback);
-    argc++;
-
-    if (awtData != getDefaultConfig(awtData->awt_visInfo.screen)) {
-        XtSetArg (args[argc], XtNvisual, awtData->awt_visInfo.visual); argc++;
-        XtSetArg (args[argc], XmNdepth, awtData->awt_depth); argc++;
-        XtSetArg (args[argc], XmNscreen,
-                  ScreenOfDisplay(awt_display,
-                                  awtData->awt_visInfo.screen)); argc++;
-
-        if (awtData->awt_cmap == None) {
-            awtJNI_CreateColorData (env, awtData, 1);
-        }
-
-        XtSetArg (args[argc], XmNcolormap, awtData->awt_cmap); argc++;
-
-        DASSERT(!(argc > MAX_ARGC));
-        newCanvas = XtCreateWidget(name, vDrawingAreaClass, wrap,
-                                   args, argc);
-
-    } else {
-        newCanvas = XtCreateWidget(name, xDrawingAreaClass,
-            wrap, args, argc);
-    }
-
-    XtSetMappedWhenManaged(newCanvas, False);
-    XtManageChild(newCanvas);
-/*
-  XXX: causes problems on 2.5
-  if (!scrollBugWorkAround) {
-  awt_setWidgetGravity(newCanvas, StaticGravity);
-  }
-*/
-    /* Fixed 4250354 7/28/99 ssi@sparc.spb.su
-     * XtParseTranslationTable leaks in old ver of Xtoolkit
-     * and result should be deletetd in any case
-     *
-     * XtOverrideTranslations(newCanvas,
-     *                      XtParseTranslationTable("<KeyDown>:DrawingAreaInput()"));
-     */
-    if (NULL==translationKeyDown)
-        translationKeyDown=XtParseTranslationTable("<KeyDown>:DrawingAreaInput()");
-    XtOverrideTranslations(newCanvas,translationKeyDown);
-
-    XtSetSensitive(newCanvas, True);
-
-    return newCanvas;
-}
-
-static void
-messWithGravity(Widget w, int32_t gravity)
-{
-    extern void awt_changeAttributes(Display * dpy, Widget w,
-                                     unsigned long mask,
-                                     XSetWindowAttributes * xattr);
-    XSetWindowAttributes xattr;
-
-    xattr.bit_gravity = gravity;
-    xattr.win_gravity = gravity;
-
-    awt_changeAttributes(XtDisplay(w), w, (CWBitGravity | CWWinGravity), &xattr);
-
-}
-
-struct MoveRecord {
-    long dx;
-    long dy;
-};
-
-void
-moveWidget(Widget w, void *data)
-{
-    struct MoveRecord *rec = (struct MoveRecord *) data;
-
-    if (XtIsRealized(w) && XmIsRowColumn(w)) {
-        w->core.x -= rec->dx;
-        w->core.y -= rec->dy;
-    }
-}
-
-#if 0
-/* Scroll entire contents of window by dx and dy.  Currently only
-   dy is supported.  A negative dy means scroll backwards, i.e.,
-   contents in window move down. */
-void
-awt_canvas_scroll(XtPointer this,
-                  struct CanvasData *wdata,
-                  long dx,
-                  long dy)
-{
-
-    Window win;
-    XWindowChanges xchgs;
-    Window root;
-    int x, y;
-    unsigned int width, height, junk;
-    Display *dpy;
-    struct MoveRecord mrec;
-
-    mrec.dx = dx;
-    mrec.dy = dy;
-
-    dpy = XtDisplay(wdata->comp.widget);
-    win = XtWindow(wdata->comp.widget);
-
-    /* REMIND: consider getting rid of this! */
-    XGetGeometry(awt_display,
-                 win,
-                 &root,
-                 &x,
-                 &y,
-                 &width,
-                 &height,
-                 &junk,
-                 &junk);
-
-    /* we need to actually update the coordinates for manager widgets, */
-    /* otherwise the parent won't pass down events to them properly */
-    /* after scrolling... */
-    awt_util_mapChildren(wdata->comp.widget, moveWidget, 0, &mrec);
-
-    if (dx < 0) {
-        /* scrolling backward */
-
-        if (scrollBugWorkAround) {
-            messWithGravity(wdata->comp.widget, NorthWestGravity);
-        }
-        xchgs.x = x + dx;
-        xchgs.y = y;
-        xchgs.width = width - dx;
-        xchgs.height = height;
-        XConfigureWindow(awt_display,
-                         win,
-                         CWX | CWY | CWWidth | CWHeight,
-                         &xchgs);
-
-        if (scrollBugWorkAround) {
-            messWithGravity(wdata->comp.widget, NorthWestGravity);
-        }
-        xchgs.x = x;
-        xchgs.y = y;
-        XConfigureWindow(awt_display,
-                         win,
-                         CWX | CWY,
-                         &xchgs);
-
-        xchgs.width = width;
-        xchgs.height = height;
-        XConfigureWindow(awt_display,
-                         win,
-                         CWWidth | CWHeight,
-                         &xchgs);
-    } else {
-        /* forward scrolling */
-
-        /* make window a little taller */
-        xchgs.width = width + dx;
-        xchgs.height = height;
-        XConfigureWindow(awt_display,
-                         win,
-                         CWWidth | CWHeight,
-                         &xchgs);
-
-        if (scrollBugWorkAround) {
-            messWithGravity(wdata->comp.widget, NorthEastGravity);
-        }
-        /* move window by amount we're scrolling */
-        xchgs.x = x - dx;
-        xchgs.y = y;
-        XConfigureWindow(awt_display,
-                         win,
-                         CWX | CWY,
-                         &xchgs);
-
-        if (scrollBugWorkAround) {
-            messWithGravity(wdata->comp.widget, NorthWestGravity);
-        }
-        /* resize to original size */
-        xchgs.x = x;
-        xchgs.y = y;
-        xchgs.width = width;
-        xchgs.height = height;
-        XConfigureWindow(awt_display,
-                         win,
-                         CWX | CWY | CWWidth | CWHeight,
-                         &xchgs);
-    }
-    /* Because of the weird way we're scrolling this window,
-       we have to eat all the exposure events that result from
-       scrolling forward, and translate them up by the amount we're
-       scrolling by.
-
-       Rather than just eating all the exposures and having the
-       java code fill in what it knows is exposed, we do it this
-       way.  The reason is that there might be some other exposure
-       events caused by overlapping windows on top of us that we
-       also need to deal with. */
-    {
-        XRectangle rect;
-
-        rect.x = -1;
-        eatAllExposures(dpy, win, &rect);
-        if (rect.x != -1) {         /* we got at least one expose event */
-            if (dx > 0) {
-                rect.x -= dx;
-                rect.width += dx;
-            }
-/*
-  printf("EXPOSE (%d): %d, %d, %d, %d\n",
-  dy, rect.x, rect.y, rect.width, rect.height);
-*/
-            callJavaExpose(this, &rect);
-            XSync(awt_display, False);
-        }
-    }
-    if (dy < 0) {
-        /* scrolling backward */
-
-        if (scrollBugWorkAround) {
-            messWithGravity(wdata->comp.widget, SouthGravity);
-        }
-        xchgs.x = x;
-        xchgs.y = y + dy;
-        xchgs.width = width;
-        xchgs.height = height - dy;
-        XConfigureWindow(awt_display,
-                         win,
-                         CWX | CWY | CWWidth | CWHeight,
-                         &xchgs);
-
-        if (scrollBugWorkAround) {
-            messWithGravity(wdata->comp.widget, NorthWestGravity);
-        }
-        xchgs.x = x;
-        xchgs.y = y;
-        XConfigureWindow(awt_display,
-                         win,
-                         CWX | CWY,
-                         &xchgs);
-
-        xchgs.width = width;
-        xchgs.height = height;
-        XConfigureWindow(awt_display,
-                         win,
-                         CWWidth | CWHeight,
-                         &xchgs);
-    } else {
-        /* forward scrolling */
-
-        /* make window a little taller */
-        xchgs.width = width;
-        xchgs.height = height + dy;
-        XConfigureWindow(awt_display,
-                         win,
-                         CWWidth | CWHeight,
-                         &xchgs);
-
-        /* move window by amount we're scrolling */
-        xchgs.x = x;
-        xchgs.y = y - dy;
-        XConfigureWindow(awt_display,
-                         win,
-                         CWX | CWY,
-                         &xchgs);
-
-        if (scrollBugWorkAround) {
-            messWithGravity(wdata->comp.widget, SouthGravity);
-        }
-        /* resize to original size */
-        xchgs.x = x;
-        xchgs.y = y;
-        xchgs.width = width;
-        xchgs.height = height;
-        XConfigureWindow(awt_display,
-                         win,
-                         CWX | CWY | CWWidth | CWHeight,
-                         &xchgs);
-        if (scrollBugWorkAround) {
-            messWithGravity(wdata->comp.widget, NorthWestGravity);
-        }
-    }
-    /* Because of the weird way we're scrolling this window,
-       we have to eat all the exposure events that result from
-       scrolling forward, and translate them up by the amount we're
-       scrolling by.
-
-       Rather than just eating all the exposures and having the
-       java code fill in what it knows is exposed, we do it this
-       way.  The reason is that there might be some other exposure
-       events caused by overlapping windows on top of us that we
-       also need to deal with. */
-    {
-        XRectangle rect;
-
-        rect.x = -1;
-        eatAllExposures(dpy, win, &rect);
-        if (rect.x != -1) {         /* we got at least one expose event */
-            if (dy > 0) {
-                rect.y -= dy;
-                rect.height += dy;
-            }
-            if (dx > 0) {
-                rect.x -= dx;
-                rect.width += dx;
-            }
-/*
-  printf("EXPOSE (%d): %d, %d, %d, %d\n",
-  dy, rect.x, rect.y, rect.width, rect.height);
-*/
-            callJavaExpose(this, &rect);
-            XSync(awt_display, False);
-        }
-    }
-}
-#endif
-
-extern Window focusProxyWindow;
-/*
- * client_data is MComponentPeer instance
- */
-void
-awt_post_java_key_event(XtPointer client_data, jint id, XEvent *event,
-  Time when, jint keycode, jchar keychar, jint modifiers, jint keyLocation, XEvent *anEvent)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject peer = (jobject) client_data;
-    jobject target;
-    static jclass classKeyEvent = NULL;
-    static jmethodID mid = NULL;
-    char *clsName = "java/awt/event/KeyEvent";
-    jobject hEvent;
-    jlong jWhen;
-    Boolean isProxyActive = (focusProxyWindow != None);
-
-    if (anEvent != NULL && anEvent->xany.send_event == 2){
-        isProxyActive = False;
-        if (event != NULL) {
-            event->xany.send_event = 0;
-        }
-    }
-    if ((*env)->PushLocalFrame(env, 16) < 0)
-        return;
-
-    target = (*env)->GetObjectField(env, peer, mComponentPeerIDs.target);
-
-    if (classKeyEvent == NULL) {
-        jobject sysClass;
-
-        sysClass = (*env)->FindClass(env, clsName);
-        if (sysClass != NULL) {
-            /* Make this class 'sticky', we don't want it GC'd */
-            classKeyEvent = (*env)->NewGlobalRef(env, sysClass);
-            mid = (*env)->GetMethodID(env, classKeyEvent, "<init>",
-              "(Ljava/awt/Component;IJIICIZ)V");
-        }
-        if (JNU_IsNull(env, classKeyEvent) || mid == NULL) {
-            JNU_ThrowClassNotFoundException(env, clsName);
-            (*env)->PopLocalFrame(env, 0);
-            return;
-        }
-    }
-
-    jWhen = awt_util_nowMillisUTC_offset(when); /* convert Time to UTC */
-
-    hEvent = (*env)->NewObject(env, classKeyEvent, mid,
-                               target, id, jWhen, modifiers,
-                               keycode, keychar, keyLocation,
-                               isProxyActive?JNI_TRUE:JNI_FALSE);
-
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-    if (JNU_IsNull(env, hEvent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException: constructor failed.");
-        (*env)->PopLocalFrame(env, 0);
-        return;
-    }
-    awt_copyXEventToAWTEvent(env, event, hEvent);
-    #ifdef DEBUG
-    if (debugKeys) {
-        jio_fprintf(stderr, "native posting event id:%d  keychar:%c\n", (int)id, (char)keychar);
-    }
-    #endif
-    JNU_CallMethodByName(env, NULL, peer,
-                         "postEvent", "(Ljava/awt/AWTEvent;)V", hEvent);
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-    (*env)->PopLocalFrame(env, 0);
-} /* awt_post_java_key_event() */
-
-/*
- * Note: this routine returns a global reference which should be deleted
- * after use.
- */
-jobject
-awt_canvas_wrapInSequenced(jobject awtevent) {
-    static jclass classSequencedEvent = NULL;
-    static jmethodID mid = NULL;
-    jobject wrapperEventLocal = NULL;
-    jobject wrapperEvent = NULL;
-
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-
-    if ((*env)->PushLocalFrame(env, 5) < 0)
-        return NULL;
-
-    if (classSequencedEvent == NULL) {
-        jobject sysClass = (*env)->FindClass(env, "java/awt/SequencedEvent");
-        if (sysClass != NULL) {
-            /* Make this class 'sticky', we don't want it GC'd */
-            classSequencedEvent = (*env)->NewGlobalRef(env, sysClass);
-            if (mid == NULL) {
-              mid = (*env)->GetMethodID(env, classSequencedEvent
-                                        ,"<init>"
-                                        ,"(Ljava/awt/AWTEvent;)V");
-            }
-        }
-        if (JNU_IsNull(env, classSequencedEvent) || mid == NULL) {
-            JNU_ThrowClassNotFoundException(env, "java/awt/SequencedEvent");
-            (*env)->PopLocalFrame(env, 0);
-            return NULL;
-        }
-    }
-    wrapperEventLocal = (*env)->NewObject(env, classSequencedEvent, mid, awtevent);
-
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-    if (JNU_IsNull(env, wrapperEventLocal)) {
-        JNU_ThrowNullPointerException(env, "constructor failed.");
-        (*env)->PopLocalFrame(env, 0);
-        return NULL;
-    }
-    wrapperEvent = (*env)->NewGlobalRef(env, wrapperEventLocal);
-    if (!JNU_IsNull(env, ((*env)->ExceptionOccurred(env)))) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-        (*env)->PopLocalFrame(env, 0);
-        return NULL;
-    }
-    if (JNU_IsNull(env, wrapperEvent)) {
-        JNU_ThrowNullPointerException(env, "NewGlobalRef failed.");
-        (*env)->PopLocalFrame(env, 0);
-        return NULL;
-    }
-
-    (*env)->PopLocalFrame(env, 0);
-    return wrapperEvent;
-}
-
-jobject
-findTopLevelOpposite(JNIEnv *env, jint eventType)
-{
-    jobject target, peer, opposite;
-
-    if ((*env)->EnsureLocalCapacity(env, 2) < 0) {
-        return NULL;
-    }
-
-    /* 4462056: Get a usable handle for a weakly referenced object */
-    target = (*env)->NewLocalRef(env,
-                 (eventType == java_awt_event_WindowEvent_WINDOW_GAINED_FOCUS)
-                                 ? forGained
-                                 : focusList->requestor);
-    if (target == NULL) {
-        return NULL;
-    }
-
-    peer = (*env)->GetObjectField(env, target, componentIDs.peer);
-    (*env)->DeleteLocalRef(env, target);
-    if (peer == NULL) {
-        return NULL;
-    }
-
-    opposite = findTopLevel(peer, env);
-    (*env)->DeleteLocalRef(env, peer);
-
-    return opposite;
-}
-
-void
-cleanFocusList(JNIEnv *env){
-
-  while(focusList) {
-    FocusListElt *tmp = focusList->next;
-    (*env)->DeleteWeakGlobalRef(env, focusList->requestor);
-    free(focusList);
-    focusList = tmp;
-  }
-  focusListEnd = NULL;
-}
-
-static jweak
-computeOpposite(jint id, jobject target)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject top;
-    jboolean isSameObject;
-
-    if (focusList == NULL) {
-        return NULL;
-    }
-
-    /* 4462056: Get a usable handle for a weakly referenced object */
-    top = (*env)->NewLocalRef(env, focusList->requestor);
-    if (top == NULL) {
-        /* weakly referenced component was deleted -- clean up focus list */
-        cleanFocusList(env);
-        return NULL;
-    }
-
-    isSameObject = (*env)->IsSameObject(env, target, top);
-    (*env)->DeleteLocalRef(env, top);
-
-    if (isSameObject) {
-        if (id == java_awt_event_FocusEvent_FOCUS_GAINED) {
-            return forGained;
-        } else { /* focus lost */
-            FocusListElt *tmp = focusList->next;
-            (*env)->DeleteWeakGlobalRef(env, forGained);
-            forGained = focusList->requestor;
-            free(focusList);
-            focusList = tmp;
-
-            if (focusList == NULL) {
-                focusListEnd = NULL;
-                return NULL;
-            }
-            return focusList->requestor;
-        }
-    } else { /* target does not match top of list */
-        /* be gentle with focus lost for now... */
-        if (id == java_awt_event_FocusEvent_FOCUS_LOST) {
-            (*env)->DeleteWeakGlobalRef(env, forGained);
-            forGained = (*env)->NewWeakGlobalRef(env, target);
-            return NULL;
-        }
-
-        cleanFocusList(env);
-        return NULL;
-    }
-}
-
-
-/*
- * client_data is MComponentPeer instance
- */
-void
-awt_post_java_focus_event(XtPointer client_data,
-                          jint id, jobject cause,
-                          XEvent* event)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject peer = (jobject) client_data;
-    jobject target;
-    jobject opposite;
-    static jclass classFocusEvent = NULL;
-    static jmethodID mid = NULL;
-    char *clsName = "sun/awt/CausedFocusEvent";
-    jobject hEvent;
-
-    if ((*env)->PushLocalFrame(env, 16) < 0)
-        return;
-
-    target = (*env)->GetObjectField(env, peer, mComponentPeerIDs.target);
-
-    opposite = (*env)->NewLocalRef(env, computeOpposite(id, target));
-
-   if (classFocusEvent == NULL) {
-        jobject sysClass;
-
-        sysClass = (*env)->FindClass(env, clsName);
-        if (sysClass != NULL) {
-            /* Make this class 'sticky', we don't want it GC'd */
-            classFocusEvent = (*env)->NewGlobalRef(env, sysClass);
-            mid = (*env)->GetMethodID(env, classFocusEvent
-                                      ,"<init>"
-                                      ,"(Ljava/awt/Component;IZLjava/awt/Component;Lsun/awt/CausedFocusEvent$Cause;)V");
-        }
-        if (JNU_IsNull(env, classFocusEvent) || mid == 0) {
-            JNU_ThrowClassNotFoundException(env, clsName);
-            (*env)->PopLocalFrame(env, 0);
-            return;
-        }
-    }
-    hEvent = (*env)->NewObject(env, classFocusEvent, mid,
-                               target, id, JNI_FALSE, opposite, cause);
-    (*env)->DeleteLocalRef(env, opposite);
-
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-    if (JNU_IsNull(env, hEvent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException: constructor failed.");
-        (*env)->PopLocalFrame(env, 0);
-        return;
-    }
-    awt_copyXEventToAWTEvent(env, event, hEvent);
-    {
-        jobject awtEvent = awt_canvas_wrapInSequenced(hEvent);
-        JNU_CallMethodByName(env, NULL, peer,
-                             "postEvent", "(Ljava/awt/AWTEvent;)V",
-                             awtEvent);
-        (*env)->DeleteGlobalRef(env, awtEvent);
-    }
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-    (*env)->PopLocalFrame(env, 0);
-}
-
-
-void
-awt_canvas_addToFocusListDefault(jobject target) {
-    awt_canvas_addToFocusListWithDuplicates(target, JNI_FALSE);
-}
-
-void
-awt_canvas_addToFocusListWithDuplicates(jobject target, jboolean acceptDuplicates)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jboolean isSameObject;
-
-    if (focusListEnd) {
-        jobject localRef = (*env)->NewLocalRef(env, focusListEnd->requestor);
-
-        if (localRef == NULL) {
-            isSameObject = JNI_FALSE;
-        } else {
-            isSameObject = (*env)->IsSameObject(env, target, localRef);
-            (*env)->DeleteLocalRef(env, localRef);
-        }
-
-        if (isSameObject && !acceptDuplicates) {
-            return;
-        }
-
-        focusListEnd->next = malloc(sizeof(FocusListElt));
-        focusListEnd = focusListEnd->next;
-    } else {
-        jobject l_focusOwnerPeer = awt_canvas_getFocusOwnerPeer();
-        if (l_focusOwnerPeer == NULL) {
-            isSameObject = JNI_FALSE;
-        } else {
-            jobject l_focusOwner =
-                (*env)->GetObjectField(env, l_focusOwnerPeer,
-                                       mComponentPeerIDs.target);
-            isSameObject =
-                (*env)->IsSameObject(env, target, l_focusOwner);
-            (*env)->DeleteLocalRef(env, l_focusOwner);
-            (*env)->DeleteLocalRef(env, l_focusOwnerPeer);
-        }
-
-        if (isSameObject && !acceptDuplicates) {
-            return;
-        }
-
-        focusList = focusListEnd = malloc(sizeof(FocusListElt));
-    }
-
-    focusListEnd->requestor = (*env)->NewWeakGlobalRef(env, target);
-    focusListEnd->next = NULL;
-}
-
-/*
- * client_data is MComponentPeer instance
- */
-void
-awt_post_java_mouse_event(XtPointer client_data, jint id, XEvent* event,
-                          Time when, jint modifiers, jint x, jint y,
-                          jint xAbs, jint yAbs,
-                          jint clickcount,
-                          Boolean popuptrigger,
-                          jint wheelAmt, jint button)
-{
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jobject peer = (jobject) client_data;
-    jobject target;
-
-    static jclass classMouseEvent = NULL;
-    static jclass classMouseWheelEvent = NULL;
-
-    static jmethodID mid = NULL;
-    static jmethodID wheelmid = NULL;
-
-    char *clsName = "java/awt/event/MouseEvent";
-    char *wheelClsName = "java/awt/event/MouseWheelEvent";
-
-    jobject hEvent;
-    jobject sysClass;
-    jlong jWhen;
-
-    if ((*env)->PushLocalFrame(env, 16) < 0)
-        return;
-
-    target = (*env)->GetObjectField(env, peer, mComponentPeerIDs.target);
-
-    if (classMouseEvent == NULL) {
-        sysClass = (*env)->FindClass(env, clsName);
-        if (sysClass != NULL) {
-            /* Make this class 'sticky', we don't want it GC'd */
-            classMouseEvent = (*env)->NewGlobalRef(env, sysClass);
-            mid = (*env)->GetMethodID(env, classMouseEvent
-                                      ,"<init>"
-                                      ,"(Ljava/awt/Component;IJIIIIIIZI)V");
-        }
-        if (JNU_IsNull(env, classMouseEvent) || mid == 0) {
-            JNU_ThrowClassNotFoundException(env, clsName);
-            (*env)->PopLocalFrame(env, 0);
-            return;
-        }
-    }
-
-    if (id == java_awt_event_MouseEvent_MOUSE_WHEEL &&
-        classMouseWheelEvent == NULL) {
-        sysClass = (*env)->FindClass(env, wheelClsName);
-        if (sysClass != NULL) {
-            /* Make this class 'sticky', we don't want it GC'd */
-            classMouseWheelEvent = (*env)->NewGlobalRef(env, sysClass);
-            wheelmid = (*env)->GetMethodID(env, classMouseWheelEvent,
-                                       "<init>",
-                                       "(Ljava/awt/Component;IJIIIIIIZIII)V");
-        }
-        if (JNU_IsNull(env, classMouseWheelEvent) || wheelmid == 0) {
-            JNU_ThrowClassNotFoundException(env, wheelClsName);
-            (*env)->PopLocalFrame(env, 0);
-            return;
-        }
-    }
-
-    jWhen = awt_util_nowMillisUTC_offset(when); /* convert Time to UTC */
-
-    if (id == java_awt_event_MouseEvent_MOUSE_WHEEL) {
-        hEvent = (*env)->NewObject(env, classMouseWheelEvent, wheelmid,
-                              target, id, jWhen, modifiers,
-                              x, y,
-                              xAbs, yAbs,
-                              clickcount, popuptrigger,
-                              /* Linux has no API for setting how a Component
-                               * should scroll in response to the mouse wheel,
-                               * so we have to make up our own.
-                               * The default behavior on Windows is 3 lines of
-                               * text, so we use that to match.
-                               */
-                              java_awt_event_MouseWheelEvent_WHEEL_UNIT_SCROLL,
-                              3,
-                              wheelAmt);
-    }
-    else {
-        hEvent = (*env)->NewObject(env, classMouseEvent, mid,
-                                   target, id, jWhen, modifiers,
-                                   x, y,
-                                   xAbs, yAbs,
-                                   clickcount, popuptrigger, button);
-    }
-
-
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-    if (JNU_IsNull(env, hEvent)) {
-        JNU_ThrowNullPointerException(env, "NullPointerException: constructor failed.");
-        (*env)->PopLocalFrame(env, 0);
-        return;
-    }
-    awt_copyXEventToAWTEvent(env, event, hEvent);
-    JNU_CallMethodByName(env, NULL, peer,
-                         "postEvent", "(Ljava/awt/AWTEvent;)V", hEvent);
-    if ((*env)->ExceptionOccurred(env)) {
-        (*env)->ExceptionDescribe(env);
-        (*env)->ExceptionClear(env);
-    }
-    (*env)->PopLocalFrame(env, 0);
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/cursor.c openjdk/jdk/src/solaris/native/sun/awt/cursor.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/cursor.c	2014-04-08 05:27:03.470875384 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/cursor.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,132 +0,0 @@
-/*
- * Copyright (c) 1997, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifdef HEADLESS
-    #error This file should not be included in headless library
-#endif
-
-#include "awt_p.h"
-#include "java_awt_Cursor.h"
-#include "awt_Cursor.h"
-#include "sun_awt_motif_MCustomCursor.h"
-
-#include "jni.h"
-#include "jni_util.h"
-
-extern struct CursorIDs cursorIDs;
-static jfieldID widthID;
-static jfieldID heightID;
-
-/*
- * Class:     sun_awt_motif_MCustomCursor
- * Method:    cacheInit
- * Signature: ()V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MCustomCursor_cacheInit
-  (JNIEnv *env, jclass cls)
-{
-    jclass clsDimension = (*env)->FindClass(env, "java/awt/Dimension");
-    widthID = (*env)->GetFieldID(env, clsDimension, "width", "I");
-    heightID = (*env)->GetFieldID(env, clsDimension, "height", "I");
-}
-
-/*
- * Class:     sun_awt_motif_MCustomCursor
- * Method:    queryBestCursor
- * Signature: (Ljava/awt/Dimension;)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MCustomCursor_queryBestCursor
-  (JNIEnv *env, jclass cls, jobject dimension)
-{
-    Window root;
-    uint32_t width, height;
-
-    AWT_LOCK();
-    root = RootWindow(awt_display, DefaultScreen(awt_display));
-    XQueryBestCursor(awt_display, root,
-                     (*env)->GetIntField(env, dimension, widthID),
-                     (*env)->GetIntField(env, dimension, heightID),
-                     &width, &height);
-    (*env)->SetIntField(env, dimension, widthID, (int32_t) width);
-    (*env)->SetIntField(env, dimension, heightID, (int32_t) height);
-    AWT_UNLOCK();
-}
-
-/*
- * Class:     sun_awt_motif_MCustomCursor
- * Method:    createCursor
- * Signature: ([B[BIIII)V
- */
-JNIEXPORT void JNICALL Java_sun_awt_motif_MCustomCursor_createCursor
-  (JNIEnv *env , jobject this, jbyteArray xorMask, jbyteArray andMask,
-   jint width, jint height, jint fc, jint bc, jint xHotSpot, jint yHotSpot)
-{
-    Cursor cursor;
-    char *sourceBits, *maskBits;
-    Window root;
-    Pixmap source, mask;
-    XColor fcolor, bcolor;
-    AwtGraphicsConfigDataPtr defaultConfig =
-        getDefaultConfig(DefaultScreen(awt_display));
-
-    AWT_LOCK();
-
-    root = RootWindow(awt_display, DefaultScreen(awt_display));
-    fcolor.flags = DoRed | DoGreen | DoBlue;
-    fcolor.red = ((fc >> 16) & 0x000000ff) << 8;
-    fcolor.green = ((fc >> 8) & 0x000000ff) << 8;
-    fcolor.blue = ((fc >> 0) & 0x000000ff) << 8;
-    XAllocColor(awt_display, defaultConfig->awt_cmap, &fcolor);
-    bcolor.flags = DoRed | DoGreen | DoBlue;
-    bcolor.red = ((bc >> 16) & 0x000000ff) << 8;
-    bcolor.green = ((bc >> 8) & 0x000000ff) << 8;
-    bcolor.blue = ((bc >> 0) & 0x000000ff) << 8;
-    XAllocColor(awt_display, defaultConfig->awt_cmap, &bcolor);
-
-    /* Create source pixmap. */
-    sourceBits = (char *)(*env)->GetPrimitiveArrayCritical(env, xorMask, NULL);
-    source = XCreateBitmapFromData(awt_display, root, sourceBits,
-                                         width, height);
-
-    /* Create mask pixmap */
-    maskBits = (char *)(*env)->GetPrimitiveArrayCritical(env, andMask, NULL);
-    mask = XCreateBitmapFromData(awt_display, root, maskBits,
-                                       width, height);
-
-    /* Create cursor */
-    cursor = XCreatePixmapCursor(awt_display, source, mask, &fcolor, &bcolor,
-                                 xHotSpot, yHotSpot);
-
-    /* Free resources */
-    XFreePixmap(awt_display, source);
-    XFreePixmap(awt_display, mask);
-
-    (*env)->ReleasePrimitiveArrayCritical(env, xorMask, sourceBits, JNI_ABORT);
-    (*env)->ReleasePrimitiveArrayCritical(env, andMask, maskBits, JNI_ABORT);
-
-        JNU_SetLongFieldFromPtr(env, this, cursorIDs.pData, cursor);
-
-    AWT_FLUSH_UNLOCK();
-}
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/initIDs.c openjdk/jdk/src/solaris/native/sun/awt/initIDs.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/initIDs.c	2014-04-08 05:27:03.474875443 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/initIDs.c	2014-04-10 02:56:51.418480011 +0100
@@ -26,7 +26,7 @@
 #include "java_awt_Color.h"
 #include "java_awt_Dimension.h"
 #include "java_awt_MenuBar.h"
-#include "java_awt_Label.h"
+//#include "java_awt_Label.h"
 #include "java_awt_FontMetrics.h"
 #include "java_awt_event_MouseEvent.h"
 #include "java_awt_Rectangle.h"
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/awt/multi_font.c openjdk/jdk/src/solaris/native/sun/awt/multi_font.c
--- openjdk.orig/jdk/src/solaris/native/sun/awt/multi_font.c	2014-04-08 05:27:03.554876623 +0100
+++ openjdk/jdk/src/solaris/native/sun/awt/multi_font.c	2014-04-10 02:56:51.426480128 +0100
@@ -52,8 +52,8 @@
 extern XFontStruct *loadFont(Display *, char *, int32_t);
 
 extern struct FontIDs fontIDs;
-extern struct MComponentPeerIDs mComponentPeerIDs;
-extern struct MMenuItemPeerIDs mMenuItemPeerIDs;
+//extern struct MComponentPeerIDs mComponentPeerIDs;
+//extern struct MMenuItemPeerIDs mMenuItemPeerIDs;
 extern struct PlatformFontIDs platformFontIDs;
 extern struct MFontPeerIDs mFontPeerIDs;
 
@@ -151,8 +151,8 @@
     struct gRefStruct *temp;
 
     gRef = (jobject)
-      JNU_GetLongFieldAsPtr(env, this, mMenuItemPeerIDs.jniGlobalRef);
-    JNU_SetLongFieldFromPtr(env, this, mMenuItemPeerIDs.jniGlobalRef, NULL);
+    //JNU_GetLongFieldAsPtr(env, this, mMenuItemPeerIDs.jniGlobalRef);
+    //JNU_SetLongFieldFromPtr(env, this, mMenuItemPeerIDs.jniGlobalRef, NULL);
 
     /*
      * Verra handy for tracking down race conditions. If you
