diff -r 6cf33f955d7d make/sun/awt/FILES_c_windows.gmk
--- openjdk/jdk/make/sun/awt/FILES_c_windows.gmk	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/make/sun/awt/FILES_c_windows.gmk	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1997, 2009, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -104,7 +104,8 @@
         OGLVertexCache.c \
         WGLGraphicsConfig.c \
         WGLSurfaceData.c \
-        AccelGlyphCache.c
+        AccelGlyphCache.c \
+        rect.c
 
 FILES_cpp = \
 	CmdIDList.cpp \
diff -r 6cf33f955d7d make/sun/awt/Makefile
--- openjdk/jdk/make/sun/awt/Makefile	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/make/sun/awt/Makefile	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1995, 2008, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1995, 2009, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -224,6 +224,7 @@
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/shell
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/medialib
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/debug
+vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/utility
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/../java2d
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/../java2d/loops
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/../java2d/pipe
diff -r 6cf33f955d7d make/sun/awt/make.depend
--- openjdk/jdk/make/sun/awt/make.depend	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/make/sun/awt/make.depend	Tue Feb 15 15:12:57 2011 +0000
@@ -16,7 +16,7 @@
 
 $(OBJDIR)/awt_AWTEvent.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_BitmapUtil.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_BitmapUtil.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_BitmapUtil.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_BitmapUtil.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h ../../../src/windows/native/sun/awt/utility/rect.h
 
 $(OBJDIR)/awt_Brush.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
@@ -32,7 +32,7 @@
 
 $(OBJDIR)/awt_Color.obj::	$(CLASSHDRDIR)/sun_awt_windows_WColor.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Color.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Component.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Color.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_InputMethodEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_MouseWheelEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Insets.h $(CLASSHDRDIR)/java_awt_KeyboardFocusManager.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Toolkit.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WInputMethod.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WPanelPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jawt.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Cursor.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dimension.h ../../../src/windows/native/sun/windows/awt_DnDDT.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_InputEvent.h ../../../src/windows/native/sun/windows/awt_InputTextInfor.h ../../../src/windows/native/sun/windows/awt_Insets.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_KeyEvent.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_MouseEvent.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Component.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Color.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_InputMethodEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_MouseWheelEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Insets.h $(CLASSHDRDIR)/java_awt_KeyboardFocusManager.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Toolkit.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WInputMethod.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WPanelPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jawt.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Cursor.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dimension.h ../../../src/windows/native/sun/windows/awt_DnDDT.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_InputEvent.h ../../../src/windows/native/sun/windows/awt_InputTextInfor.h ../../../src/windows/native/sun/windows/awt_Insets.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_KeyEvent.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_MouseEvent.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h ../../../src/windows/native/sun/awt/utility/rect.h
 
 $(OBJDIR)/awt_Container.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
@@ -150,9 +150,9 @@
 
 $(OBJDIR)/awt_Window.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Container.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_ComponentEvent.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Insets.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_BitmapUtil.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_IconCursor.h ../../../src/windows/native/sun/windows/awt_Insets.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Panel.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/Blit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_Blit.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
+$(OBJDIR)/Blit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_Blit.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/awt/utility/rect.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/BlitBg.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_BlitBg.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
+$(OBJDIR)/BlitBg.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_BlitBg.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/awt/utility/rect.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
 $(OBJDIR)/BufferedMaskBlit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedMaskBlit.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedOpCodes.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntBgr.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/IntRgb.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
@@ -246,11 +246,11 @@
 
 $(OBJDIR)/GDIRenderer.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_geom_PathIterator.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_windows_GDIRenderer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/GDIWindowSurfaceData.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_windows_GDIWindowSurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/Disposer.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/GDIWindowSurfaceData.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_windows_GDIWindowSurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/Disposer.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/awt/utility/rect.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h 
 
 $(OBJDIR)/gifdecoder.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/GraphicsPrimitiveMgr.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_GraphicsPrimitiveMgr.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
+$(OBJDIR)/GraphicsPrimitiveMgr.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_GraphicsPrimitiveMgr.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/awt/utility/rect.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
 $(OBJDIR)/Hashtable.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
@@ -278,7 +278,7 @@
 
 $(OBJDIR)/IntRgbx.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/AnyInt.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/ByteIndexed.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntArgbBm.h ../../../src/share/native/sun/java2d/loops/IntArgbPre.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/IntRgb.h ../../../src/share/native/sun/java2d/loops/IntRgbx.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/LoopMacros.h ../../../src/share/native/sun/java2d/loops/ThreeByteBgr.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/MaskBlit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_MaskBlit.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
+$(OBJDIR)/MaskBlit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_MaskBlit.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/awt/utility/rect.h
 
 $(OBJDIR)/MaskFill.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_MaskFill.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
@@ -290,7 +290,7 @@
 
 $(OBJDIR)/OGLBufImgOps.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLBufImgOps.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/OGLContext.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
+$(OBJDIR)/OGLContext.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h ../../../src/windows/native/sun/awt/utility/rect.h
 
 $(OBJDIR)/OGLFuncs.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
@@ -312,11 +312,11 @@
 
 $(OBJDIR)/ProcessPath.obj::	$(CLASSHDRDIR)/java_awt_geom_PathIterator.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/ProcessPath.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/Region.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h
+$(OBJDIR)/Region.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/awt/utility/rect.h
 
 $(OBJDIR)/RenderBuffer.obj::	$(CLASSHDRDIR)/sun_java2d_pipe_RenderBuffer.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/ScaledBlit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_ScaledBlit.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
+$(OBJDIR)/ScaledBlit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_ScaledBlit.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/awt/utility/rect.h
 
 $(OBJDIR)/ShapeSpanIterator.obj::	$(CLASSHDRDIR)/java_awt_geom_PathIterator.h $(CLASSHDRDIR)/sun_java2d_pipe_ShapeSpanIterator.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/pipe/PathConsumer2D.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
@@ -332,7 +332,7 @@
 
 $(OBJDIR)/Trace.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/TransformHelper.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_loops_TransformHelper.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
+$(OBJDIR)/TransformHelper.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_loops_TransformHelper.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/awt/utility/rect.h
 
 $(OBJDIR)/UnicowsLoader.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
diff -r 6cf33f955d7d make/sun/awt/mapfile-mawt-vers
--- openjdk/jdk/make/sun/awt/mapfile-mawt-vers	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/make/sun/awt/mapfile-mawt-vers	Tue Feb 15 15:12:57 2011 +0000
@@ -291,6 +291,7 @@
 		Java_sun_awt_X11GraphicsConfig_createBackBuffer;
 		Java_sun_awt_X11GraphicsConfig_destroyBackBuffer;
 		Java_sun_awt_X11GraphicsConfig_swapBuffers;
+                Java_sun_awt_X11GraphicsConfig_isTranslucencyCapable;
 		Java_sun_awt_X11GraphicsDevice_isDBESupported;
 		Java_sun_awt_X11GraphicsDevice_getDisplay;
 		Java_sun_awt_X11GraphicsDevice_getDoubleBufferVisuals;
diff -r 6cf33f955d7d make/sun/awt/mapfile-vers-linux
--- openjdk/jdk/make/sun/awt/mapfile-vers-linux	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/make/sun/awt/mapfile-vers-linux	Tue Feb 15 15:12:57 2011 +0000
@@ -406,6 +406,7 @@
 		Java_sun_awt_X11GraphicsConfig_getNumColors;
 		Java_sun_awt_X11GraphicsConfig_getXResolution;
 		Java_sun_awt_X11GraphicsConfig_getYResolution;
+                Java_sun_awt_X11GraphicsConfig_isTranslucencyCapable;
 		Java_sun_awt_X11GraphicsDevice_isDBESupported;
 		Java_sun_awt_X11GraphicsDevice_getDisplay;
 		Java_sun_awt_X11GraphicsDevice_getDoubleBufferVisuals;
diff -r 6cf33f955d7d make/sun/xawt/mapfile-vers
--- openjdk/jdk/make/sun/xawt/mapfile-vers	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/make/sun/xawt/mapfile-vers	Tue Feb 15 15:12:57 2011 +0000
@@ -216,6 +216,7 @@
         Java_sun_awt_X11GraphicsConfig_createBackBuffer;
 	Java_sun_awt_X11GraphicsConfig_destroyBackBuffer;
 	Java_sun_awt_X11GraphicsConfig_swapBuffers;
+	Java_sun_awt_X11GraphicsConfig_isTranslucencyCapable;
         Java_java_awt_Insets_initIDs;
         Java_java_awt_KeyboardFocusManager_initIDs;
         Java_java_awt_Font_initIDs;
diff -r 6cf33f955d7d src/share/classes/com/sun/awt/AWTUtilities.java
--- openjdk/jdk/src/share/classes/com/sun/awt/AWTUtilities.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/com/sun/awt/AWTUtilities.java	Tue Feb 15 15:12:57 2011 +0000
@@ -26,17 +26,37 @@
 package com.sun.awt;
 
 import java.awt.*;
+
 import sun.awt.AWTAccessor;
-
+import sun.awt.SunToolkit;
 
 /**
  * A collection of utility methods for AWT.
  *
  * The functionality provided by the static methods of the class includes:
  * <ul>
+ * <li>Setting shapes on top-level windows
+ * <li>Setting a constant alpha value for each pixel of a top-level window
+ * <li>Making a window non-opaque, after that it paints only explicitly
+ * painted pixels on the screen, with arbitrary alpha values for every pixel.
  * <li>Setting a 'mixing-cutout' shape for a component.
  * </ul>
  * <p>
+ * A "top-level window" is an instance of the {@code Window} class (or its
+ * descendant, such as {@code JFrame}).
+ * <p>
+ * Some of the mentioned features may not be supported by the native platform.
+ * To determine whether a particular feature is supported, the user must use
+ * the {@code isTranslucencySupported()} method of the class passing a desired
+ * translucency kind (a member of the {@code Translucency} enum) as an
+ * argument.
+ * <p>
+ * The per-pixel alpha feature also requires the user to create her/his
+ * windows using a translucency-capable graphics configuration.
+ * The {@code isTranslucencyCapable()} method must
+ * be used to verify whether any given GraphicsConfiguration supports
+ * the trasnlcency effects.
+ * <p>
  * <b>WARNING</b>: This class is an implementation detail and only meant
  * for limited use outside of the core platform. This API may change
  * drastically between update release, and it may even be
@@ -50,6 +70,344 @@
     private AWTUtilities() {
     }
 
+    /** Kinds of translucency supported by the underlying system.
+     *  @see #isTranslucencySupported
+     */
+    public static enum Translucency {
+        /**
+         * Represents support in the underlying system for windows each pixel
+         * of which is guaranteed to be either completely opaque, with
+         * an alpha value of 1.0, or completely transparent, with an alpha
+         * value of 0.0.
+         */
+        PERPIXEL_TRANSPARENT,
+
+        /**
+         * Represents support in the underlying system for windows all of
+         * the pixels of which have the same alpha value between or including
+         * 0.0 and 1.0.
+         */
+        TRANSLUCENT,
+
+        /**
+         * Represents support in the underlying system for windows that
+         * contain or might contain pixels with arbitrary alpha values
+         * between and including 0.0 and 1.0.
+         */
+        PERPIXEL_TRANSLUCENT;
+    }
+
+
+    /**
+     * Returns whether the given level of translucency is supported by
+     * the underlying system.
+     *
+     * Note that this method may sometimes return the value
+     * indicating that the particular level is supported, but
+     * the native windowing system may still not support the
+     * given level of translucency (due to the bugs in
+     * the windowing system).
+     *
+     * @param translucencyKind a kind of translucency support
+     *                         (either PERPIXEL_TRANSPARENT,
+     *                         TRANSLUCENT, or PERPIXEL_TRANSLUCENT)
+     * @return whether the given translucency kind is supported
+     */
+    public static boolean isTranslucencySupported(Translucency translucencyKind) {
+        switch (translucencyKind) {
+            case PERPIXEL_TRANSPARENT:
+                return isWindowShapingSupported();
+            case TRANSLUCENT:
+                return isWindowOpacitySupported();
+            case PERPIXEL_TRANSLUCENT:
+                return isWindowTranslucencySupported();
+        }
+        return false;
+    }
+
+
+    /**
+     * Returns whether the windowing system supports changing the opacity
+     * value of top-level windows.
+     * Note that this method may sometimes return true, but the native
+     * windowing system may still not support the concept of
+     * translucency (due to the bugs in the windowing system).
+     */
+    private static boolean isWindowOpacitySupported() {
+        Toolkit curToolkit = Toolkit.getDefaultToolkit();
+        if (!(curToolkit instanceof SunToolkit)) {
+            return false;
+        }
+        return ((SunToolkit)curToolkit).isWindowOpacitySupported();
+    }
+
+    /**
+     * Set the opacity of the window. The opacity is at the range [0..1].
+     * Note that setting the opacity level of 0 may or may not disable
+     * the mouse event handling on this window. This is
+     * a platform-dependent behavior.
+     *
+     * In order for this method to enable the translucency effect,
+     * the isTranslucencySupported() method should indicate that the
+     * TRANSLUCENT level of translucency is supported.
+     *
+     * <p>Also note that the window must not be in the full-screen mode
+     * when setting the opacity value &lt; 1.0f. Otherwise
+     * the IllegalArgumentException is thrown.
+     *
+     * @param window the window to set the opacity level to
+     * @param opacity the opacity level to set to the window
+     * @throws NullPointerException if the window argument is null
+     * @throws IllegalArgumentException if the opacity is out of
+     *                                  the range [0..1]
+     * @throws IllegalArgumentException if the window is in full screen mode,
+     *                                  and the opacity is less than 1.0f
+     * @throws UnsupportedOperationException if the TRANSLUCENT translucency
+     *                                       kind is not supported
+     */
+    public static void setWindowOpacity(Window window, float opacity) {
+        if (window == null) {
+            throw new NullPointerException(
+                    "The window argument should not be null.");
+        }
+
+        AWTAccessor.getWindowAccessor().setOpacity(window, opacity);
+    }
+
+    /**
+     * Get the opacity of the window. If the opacity has not
+     * yet being set, this method returns 1.0.
+     *
+     * @param window the window to get the opacity level from
+     * @throws NullPointerException if the window argument is null
+     */
+    public static float getWindowOpacity(Window window) {
+        if (window == null) {
+            throw new NullPointerException(
+                    "The window argument should not be null.");
+        }
+
+        return AWTAccessor.getWindowAccessor().getOpacity(window);
+    }
+
+    /**
+     * Returns whether the windowing system supports changing the shape
+     * of top-level windows.
+     * Note that this method may sometimes return true, but the native
+     * windowing system may still not support the concept of
+     * shaping (due to the bugs in the windowing system).
+     */
+    public static boolean isWindowShapingSupported() {
+        Toolkit curToolkit = Toolkit.getDefaultToolkit();
+        if (!(curToolkit instanceof SunToolkit)) {
+            return false;
+        }
+        return ((SunToolkit)curToolkit).isWindowShapingSupported();
+    }
+
+    /**
+     * Returns an object that implements the Shape interface and represents
+     * the shape previously set with the call to the setWindowShape() method.
+     * If no shape has been set yet, or the shape has been reset to null,
+     * this method returns null.
+     *
+     * @param window the window to get the shape from
+     * @return the current shape of the window
+     * @throws NullPointerException if the window argument is null
+     */
+    public static Shape getWindowShape(Window window) {
+        if (window == null) {
+            throw new NullPointerException(
+                    "The window argument should not be null.");
+        }
+        return AWTAccessor.getWindowAccessor().getShape(window);
+    }
+
+    /**
+     * Sets a shape for the given window.
+     * If the shape argument is null, this methods restores
+     * the default shape making the window rectangular.
+     * <p>Note that in order to set a shape, the window must be undecorated.
+     * If the window is decorated, this method ignores the {@code shape}
+     * argument and resets the shape to null.
+     * <p>Also note that the window must not be in the full-screen mode
+     * when setting a non-null shape. Otherwise the IllegalArgumentException
+     * is thrown.
+     * <p>Depending on the platform, the method may return without
+     * effecting the shape of the window if the window has a non-null warning
+     * string ({@link Window#getWarningString()}). In this case the passed
+     * shape object is ignored.
+     *
+     * @param window the window to set the shape to
+     * @param shape the shape to set to the window
+     * @throws NullPointerException if the window argument is null
+     * @throws IllegalArgumentException if the window is in full screen mode,
+     *                                  and the shape is not null
+     * @throws UnsupportedOperationException if the PERPIXEL_TRANSPARENT
+     *                                       translucency kind is not supported
+     */
+    public static void setWindowShape(Window window, Shape shape) {
+        if (window == null) {
+            throw new NullPointerException(
+                    "The window argument should not be null.");
+        }
+        AWTAccessor.getWindowAccessor().setShape(window, shape);
+    }
+
+    private static boolean isWindowTranslucencySupported() {
+        /*
+         * Per-pixel alpha is supported if all the conditions are TRUE:
+         *    1. The toolkit is a sort of SunToolkit
+         *    2. The toolkit supports translucency in general
+         *        (isWindowTranslucencySupported())
+         *    3. There's at least one translucency-capable
+         *        GraphicsConfiguration
+         */
+
+        Toolkit curToolkit = Toolkit.getDefaultToolkit();
+        if (!(curToolkit instanceof SunToolkit)) {
+            return false;
+        }
+
+        if (!((SunToolkit)curToolkit).isWindowTranslucencySupported()) {
+            return false;
+        }
+
+        GraphicsEnvironment env =
+            GraphicsEnvironment.getLocalGraphicsEnvironment();
+
+        // If the default GC supports translucency return true.
+        // It is important to optimize the verification this way,
+        // see CR 6661196 for more details.
+        if (isTranslucencyCapable(env.getDefaultScreenDevice()
+                    .getDefaultConfiguration()))
+        {
+            return true;
+        }
+
+        // ... otherwise iterate through all the GCs.
+        GraphicsDevice[] devices = env.getScreenDevices();
+
+        for (int i = 0; i < devices.length; i++) {
+            GraphicsConfiguration[] configs = devices[i].getConfigurations();
+            for (int j = 0; j < configs.length; j++) {
+                if (isTranslucencyCapable(configs[j])) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Enables the per-pixel alpha support for the given window.
+     * Once the window becomes non-opaque (the isOpaque is set to false),
+     * the drawing sub-system is starting to respect the alpha value of each
+     * separate pixel. If a pixel gets painted with alpha color component
+     * equal to zero, it becomes visually transparent, if the alpha of the
+     * pixel is equal to 255, the pixel is fully opaque. Interim values
+     * of the alpha color component make the pixel semi-transparent (i.e.
+     * translucent).
+     * <p>Note that in order for the window to support the per-pixel alpha
+     * mode, the window must be created using the GraphicsConfiguration
+     * for which the {@link #isTranslucencyCapable}
+     * method returns true.
+     * <p>Also note that some native systems enable the per-pixel translucency
+     * mode for any window created using the translucency-compatible
+     * graphics configuration. However, it is highly recommended to always
+     * invoke the setWindowOpaque() method for these windows, at least for
+     * the sake of cross-platform compatibility reasons.
+     * <p>Also note that the window must not be in the full-screen mode
+     * when making it non-opaque. Otherwise the IllegalArgumentException
+     * is thrown.
+     * <p>If the window is a {@code Frame} or a {@code Dialog}, the window must
+     * be undecorated prior to enabling the per-pixel translucency effect (see
+     * {@link Frame#setUndecorated()} and/or {@link Dialog#setUndecorated()}).
+     * If the window becomes decorated through a subsequent call to the
+     * corresponding {@code setUndecorated()} method, the per-pixel
+     * translucency effect will be disabled and the opaque property reset to
+     * {@code true}.
+     * <p>Depending on the platform, the method may return without
+     * effecting the opaque property of the window if the window has a non-null
+     * warning string ({@link Window#getWarningString()}). In this case
+     * the passed 'isOpaque' value is ignored.
+     *
+     * @param window the window to set the shape to
+     * @param isOpaque whether the window must be opaque (true),
+     *                 or translucent (false)
+     * @throws NullPointerException if the window argument is null
+     * @throws IllegalArgumentException if the window uses
+     *                                  a GraphicsConfiguration for which the
+     *                                  {@code isTranslucencyCapable()}
+     *                                  method returns false
+     * @throws IllegalArgumentException if the window is in full screen mode,
+     *                                  and the isOpaque is false
+     * @throws IllegalArgumentException if the window is decorated and the
+     * isOpaque argument is {@code false}.
+     * @throws UnsupportedOperationException if the PERPIXEL_TRANSLUCENT
+     *                                       translucency kind is not supported
+     */
+    public static void setWindowOpaque(Window window, boolean isOpaque) {
+        if (window == null) {
+            throw new NullPointerException(
+                    "The window argument should not be null.");
+        }
+        if (!isOpaque && !isTranslucencySupported(Translucency.PERPIXEL_TRANSLUCENT)) {
+            throw new UnsupportedOperationException(
+                    "The PERPIXEL_TRANSLUCENT translucency kind is not supported");
+        }
+        AWTAccessor.getWindowAccessor().setOpaque(window, isOpaque);
+    }
+
+    /**
+     * Returns whether the window is opaque or translucent.
+     *
+     * @param window the window to set the shape to
+     * @return whether the window is currently opaque (true)
+     *         or translucent (false)
+     * @throws NullPointerException if the window argument is null
+     */
+    public static boolean isWindowOpaque(Window window) {
+        if (window == null) {
+            throw new NullPointerException(
+                    "The window argument should not be null.");
+        }
+
+        return AWTAccessor.getWindowAccessor().isOpaque(window);
+    }
+
+    /**
+     * Verifies whether a given GraphicsConfiguration supports
+     * the PERPIXEL_TRANSLUCENT kind of translucency.
+     * All windows that are intended to be used with the {@link #setWindowOpaque}
+     * method must be created using a GraphicsConfiguration for which this method
+     * returns true.
+     * <p>Note that some native systems enable the per-pixel translucency
+     * mode for any window created using a translucency-capable
+     * graphics configuration. However, it is highly recommended to always
+     * invoke the setWindowOpaque() method for these windows, at least
+     * for the sake of cross-platform compatibility reasons.
+     *
+     * @param gc GraphicsConfiguration
+     * @throws NullPointerException if the gc argument is null
+     * @return whether the given GraphicsConfiguration supports
+     *         the translucency effects.
+     */
+    public static boolean isTranslucencyCapable(GraphicsConfiguration gc) {
+        if (gc == null) {
+            throw new NullPointerException("The gc argument should not be null");
+        }
+        /*
+        return gc.isTranslucencyCapable();
+        */
+        Toolkit curToolkit = Toolkit.getDefaultToolkit();
+        if (!(curToolkit instanceof SunToolkit)) {
+            return false;
+        }
+        return ((SunToolkit)curToolkit).isTranslucencyCapable(gc);
+    }
+
     /**
      * Sets a 'mixing-cutout' shape for the given component.
      *
diff -r 6cf33f955d7d src/share/classes/java/awt/Component.java
--- openjdk/jdk/src/share/classes/java/awt/Component.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/java/awt/Component.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -788,8 +788,24 @@
             }
     }
 
+    // Whether this Component has had the background erase flag
+    // specified via SunToolkit.disableBackgroundErase(). This is
+    // needed in order to make this function work on X11 platforms,
+    // where currently there is no chance to interpose on the creation
+    // of the peer and therefore the call to XSetBackground.
+    transient boolean backgroundEraseDisabled;
+
     static {
         AWTAccessor.setComponentAccessor(new AWTAccessor.ComponentAccessor() {
+            public void setBackgroundEraseDisabled(Component comp, boolean disabled) {
+                comp.backgroundEraseDisabled = disabled;
+            }
+            public boolean getBackgroundEraseDisabled(Component comp) {
+                return comp.backgroundEraseDisabled;
+            }
+            public Rectangle getBounds(Component comp) {
+                return new Rectangle(comp.x, comp.y, comp.width, comp.height);
+            }
             public void setMixingCutoutShape(Component comp, Shape shape) {
                 Region region = shape == null ?  null :
                     Region.getInstance(shape, null);
@@ -7426,7 +7442,7 @@
             // sometimes most recent focus owner may be null, but focus owner is not
             // e.g. we reset most recent focus owner if user removes focus owner
             focusOwner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
-            if (focusOwner != null && getContainingWindow(focusOwner) != window) {
+            if (focusOwner != null && focusOwner.getContainingWindow() != window) {
                 focusOwner = null;
             }
         }
@@ -8655,30 +8671,8 @@
      *         null, if component is not a part of window hierarchy
      */
     Window getContainingWindow() {
-        return getContainingWindow(this);
-    }
-    /**
-     * Returns the <code>Window</code> ancestor of the component <code>comp</code>.
-     * @return Window ancestor of the component or component by itself if it is Window;
-     *         null, if component is not a part of window hierarchy
-     */
-    static Window getContainingWindow(Component comp) {
-        while (comp != null && !(comp instanceof Window)) {
-            comp = comp.getParent();
-        }
-
-        return (Window)comp;
-    }
-
-
-
-
-
-
-
-
-
-
+        return SunToolkit.getContainingWindow(this);
+    }
 
     /**
      * Initialize JNI field and method IDs
@@ -9793,4 +9787,29 @@
     }
 
     // ****************** END OF MIXING CODE ********************************
+
+    private static boolean doesClassImplement(Class cls, String interfaceName) {
+        if (cls == null) return false;
+
+        for (Class c : cls.getInterfaces()) {
+            if (c.getName().equals(interfaceName)) {
+                return true;
+            }
+        }
+        return doesClassImplement(cls.getSuperclass(), interfaceName);
+    }
+
+    /**
+     * Checks that the given object implements the given interface.
+     * @param obj Object to be checked
+     * @param interfaceName The name of the interface. Must be fully-qualified interface name.
+     * @return true, if this object implements the given interface,
+     *         false, otherwise, or if obj or interfaceName is null
+     */
+    static boolean doesImplement(Object obj, String interfaceName) {
+        if (obj == null) return false;
+        if (interfaceName == null) return false;
+
+        return doesClassImplement(obj.getClass(), interfaceName);
+    }
 }
diff -r 6cf33f955d7d src/share/classes/java/awt/Container.java
--- openjdk/jdk/src/share/classes/java/awt/Container.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/java/awt/Container.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -167,6 +167,9 @@
     transient int listeningBoundsChildren;
     transient int descendantsCount;
 
+    /* Non-opaque window support -- see Window.setLayersOpaque */
+    transient Color preserveBackgroundColor = null;
+
     /**
      * JDK 1.1 serialVersionUID
      */
diff -r 6cf33f955d7d src/share/classes/java/awt/DefaultKeyboardFocusManager.java
--- openjdk/jdk/src/share/classes/java/awt/DefaultKeyboardFocusManager.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/java/awt/DefaultKeyboardFocusManager.java	Tue Feb 15 15:12:57 2011 +0000
@@ -480,7 +480,7 @@
                 // that a Component outside of the focused Window receives a
                 // FOCUS_GAINED event. We synthesize a WINDOW_GAINED_FOCUS
                 // event in that case.
-                final Window newFocusedWindow = Component.getContainingWindow(newFocusOwner);
+                final Window newFocusedWindow = SunToolkit.getContainingWindow(newFocusOwner);
                 final Window currentFocusedWindow = getGlobalFocusedWindow();
                 if (newFocusedWindow != null &&
                     newFocusedWindow != currentFocusedWindow)
diff -r 6cf33f955d7d src/share/classes/java/awt/GraphicsConfiguration.java
--- openjdk/jdk/src/share/classes/java/awt/GraphicsConfiguration.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/java/awt/GraphicsConfiguration.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -428,4 +428,20 @@
         }
         return defaultImageCaps;
     }
+
+    /**
+     * Returns whether this GraphicsConfiguration supports
+     * the {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT
+     * PERPIXEL_TRANSLUCENT} kind of translucency.
+     *
+     * @param gc GraphicsConfiguration
+     * @throws NullPointerException if the gc argument is null
+     * @return whether the given GraphicsConfiguration supports
+     *         the translucency effects.
+     * @see Window#setBackground(Color)
+     */
+    /*public */boolean isTranslucencyCapable() {
+        // Overridden in subclasses
+        return false;
     }
+}
diff -r 6cf33f955d7d src/share/classes/java/awt/GraphicsDevice.java
--- openjdk/jdk/src/share/classes/java/awt/GraphicsDevice.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/java/awt/GraphicsDevice.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,7 +27,10 @@
 package java.awt;
 
 import java.awt.image.ColorModel;
+
+import sun.awt.AWTAccessor;
 import sun.awt.AppContext;
+import sun.awt.SunToolkit;
 
 /**
  * The <code>GraphicsDevice</code> class describes the graphics devices
@@ -109,6 +112,31 @@
      */
     public final static int TYPE_IMAGE_BUFFER           = 2;
 
+    /** Kinds of translucency supported by the underlying system.
+     *  @see #isTranslucencySupported
+     */
+    /*public */static enum WindowTranslucency {
+        /**
+         * Represents support in the underlying system for windows each pixel
+         * of which is guaranteed to be either completely opaque, with
+         * an alpha value of 1.0, or completely transparent, with an alpha
+         * value of 0.0.
+         */
+        PERPIXEL_TRANSPARENT,
+        /**
+         * Represents support in the underlying system for windows all of
+         * the pixels of which have the same alpha value between or including
+         * 0.0 and 1.0.
+         */
+        TRANSLUCENT,
+        /**
+         * Represents support in the underlying system for windows that
+         * contain or might contain pixels with arbitrary alpha values
+         * between and including 0.0 and 1.0.
+         */
+        PERPIXEL_TRANSLUCENT;
+    }
+
     /**
      * Returns the type of this <code>GraphicsDevice</code>.
      * @return the type of this <code>GraphicsDevice</code>, which can
@@ -235,6 +263,21 @@
      * @since 1.4
      */
     public void setFullScreenWindow(Window w) {
+        if (w != null) {
+            //XXX: The actions should be documented in some non-update release.
+            /*
+            if (w.getShape() != null) {
+                w.setShape(w, null);
+            }
+            if (!w.isOpaque()) {
+                w.setOpaque(false);
+            }
+            if (w.getOpacity() < 1.0f) {
+                w.setOpacity(1.0f);
+            }
+            */
+        }
+
         if (fullScreenWindow != null && windowedModeBounds != null) {
             // if the window went into fs mode before it was realized it may
             // have (0,0) dimensions
@@ -424,4 +467,94 @@
     public int getAvailableAcceleratedMemory() {
         return -1;
     }
+
+    /**
+     * Returns whether the given level of translucency is supported
+     * this graphics device.
+     *
+     * @param translucencyKind a kind of translucency support
+     * @return whether the given translucency kind is supported
+     */
+    /*public */boolean isWindowTranslucencySupported(WindowTranslucency translucencyKind) {
+        switch (translucencyKind) {
+            case PERPIXEL_TRANSPARENT:
+                return isWindowShapingSupported();
+            case TRANSLUCENT:
+                return isWindowOpacitySupported();
+            case PERPIXEL_TRANSLUCENT:
+                return isWindowPerpixelTranslucencySupported();
+        }
+        return false;
+    }
+
+    /**
+     * Returns whether the windowing system supports changing the shape
+     * of top-level windows.
+     * Note that this method may sometimes return true, but the native
+     * windowing system may still not support the concept of
+     * shaping (due to the bugs in the windowing system).
+     */
+    static boolean isWindowShapingSupported() {
+        Toolkit curToolkit = Toolkit.getDefaultToolkit();
+        if (!(curToolkit instanceof SunToolkit)) {
+            return false;
+        }
+        return ((SunToolkit)curToolkit).isWindowShapingSupported();
+    }
+
+    /**
+     * Returns whether the windowing system supports changing the opacity
+     * value of top-level windows.
+     * Note that this method may sometimes return true, but the native
+     * windowing system may still not support the concept of
+     * translucency (due to the bugs in the windowing system).
+     */
+    static boolean isWindowOpacitySupported() {
+        Toolkit curToolkit = Toolkit.getDefaultToolkit();
+        if (!(curToolkit instanceof SunToolkit)) {
+            return false;
+        }
+        return ((SunToolkit)curToolkit).isWindowOpacitySupported();
+    }
+
+    boolean isWindowPerpixelTranslucencySupported() {
+        /*
+         * Per-pixel alpha is supported if all the conditions are TRUE:
+         *    1. The toolkit is a sort of SunToolkit
+         *    2. The toolkit supports translucency in general
+         *        (isWindowTranslucencySupported())
+         *    3. There's at least one translucency-capable
+         *        GraphicsConfiguration
+         */
+        Toolkit curToolkit = Toolkit.getDefaultToolkit();
+        if (!(curToolkit instanceof SunToolkit)) {
+            return false;
+        }
+        if (!((SunToolkit)curToolkit).isWindowTranslucencySupported()) {
+            return false;
+        }
+
+        // TODO: cache translucency capable GC
+        return getTranslucencyCapableGC() != null;
+    }
+
+    GraphicsConfiguration getTranslucencyCapableGC() {
+        // If the default GC supports translucency return true.
+        // It is important to optimize the verification this way,
+        // see CR 6661196 for more details.
+        GraphicsConfiguration defaultGC = getDefaultConfiguration();
+        if (defaultGC.isTranslucencyCapable()) {
+            return defaultGC;
+        }
+
+        // ... otherwise iterate through all the GCs.
+        GraphicsConfiguration[] configs = getConfigurations();
+        for (int j = 0; j < configs.length; j++) {
+            if (configs[j].isTranslucencyCapable()) {
+                return configs[j];
+            }
+        }
+
+        return null;
+    }
 }
diff -r 6cf33f955d7d src/share/classes/java/awt/KeyboardFocusManager.java
--- openjdk/jdk/src/share/classes/java/awt/KeyboardFocusManager.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/java/awt/KeyboardFocusManager.java	Tue Feb 15 15:12:57 2011 +0000
@@ -2210,7 +2210,7 @@
                                                   boolean temporary, boolean focusedWindowChangeAllowed,
                                                   long time)
     {
-        Window parentWindow = Component.getContainingWindow(heavyweight);
+        Window parentWindow = SunToolkit.getContainingWindow(heavyweight);
         if (parentWindow == null || !parentWindow.syncLWRequests) {
             return false;
         }
@@ -2544,7 +2544,7 @@
                 (HeavyweightFocusRequest.CLEAR_GLOBAL_FOCUS_OWNER);
 
             Component activeWindow = ((hwFocusRequest != null)
-                ? Component.getContainingWindow(hwFocusRequest.heavyweight)
+                ? SunToolkit.getContainingWindow(hwFocusRequest.heavyweight)
                 : nativeFocusedWindow);
             while (activeWindow != null &&
                    !((activeWindow instanceof Frame) ||
@@ -3015,8 +3015,8 @@
     }
 
     private static boolean focusedWindowChanged(Component to, Component from) {
-        Window wto = Component.getContainingWindow(to);
-        Window wfrom = Component.getContainingWindow(from);
+        Window wto = SunToolkit.getContainingWindow(to);
+        Window wfrom = SunToolkit.getContainingWindow(from);
         if (wto == null && wfrom == null) {
             return true;
         }
@@ -3030,8 +3030,8 @@
     }
 
     private static boolean isTemporary(Component to, Component from) {
-        Window wto = Component.getContainingWindow(to);
-        Window wfrom = Component.getContainingWindow(from);
+        Window wto = SunToolkit.getContainingWindow(to);
+        Window wfrom = SunToolkit.getContainingWindow(from);
         if (wto == null && wfrom == null) {
             return false;
         }
diff -r 6cf33f955d7d src/share/classes/java/awt/Window.java
--- openjdk/jdk/src/share/classes/java/awt/Window.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/java/awt/Window.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,7 @@
 import java.awt.event.*;
 import java.awt.im.InputContext;
 import java.awt.image.BufferStrategy;
+import java.awt.image.BufferedImage;
 import java.awt.peer.ComponentPeer;
 import java.awt.peer.WindowPeer;
 import java.beans.PropertyChangeListener;
@@ -50,6 +51,7 @@
 import java.util.logging.Logger;
 import java.util.concurrent.atomic.AtomicBoolean;
 import javax.accessibility.*;
+import sun.awt.AWTAccessor;
 import sun.awt.AppContext;
 import sun.awt.CausedFocusEvent;
 import sun.awt.SunToolkit;
@@ -291,6 +293,25 @@
      */
     transient boolean isInShow = false;
 
+    /*
+     * Opacity level of the window
+     *
+     * @see #setOpacity(float)
+     * @see #getOpacity()
+     * @since 1.7
+     */
+    private float opacity = 1.0f;
+
+    /*
+     * The shape assigned to this window. This field is set to null if
+     * no shape is set (rectangular window).
+     *
+     * @see #getShape()
+     * @see #setShape(Shape)
+     * @since 1.7
+     */
+    private Shape shape = null;
+
     private static final String base = "win";
     private static int nameCounter = 0;
 
@@ -661,9 +682,9 @@
             }
             if (peer == null) {
                 peer = getToolkit().createWindow(this);
-            }
-            synchronized (allWindows) {
-                allWindows.add(this);
+                synchronized (allWindows) {
+                    allWindows.add(this);
+                }
             }
             super.addNotify();
         }
@@ -2765,6 +2786,8 @@
          if(aot) {
              setAlwaysOnTop(aot); // since 1.5; subject to permission check
          }
+         shape = (Shape)f.get("shape", null);
+         opacity = (Float)f.get("opacity", 1.0f);
 
          deserializeResources(s);
     }
@@ -3184,6 +3207,225 @@
     }
 
 
+    // ******************** SHAPES & TRANSPARENCY CODE ********************
+
+    /**
+     * JavaDoc
+     */
+    /*public */float getOpacity() {
+        synchronized (getTreeLock()) {
+            return opacity;
+        }
+    }
+
+    /**
+     * JavaDoc
+     */
+    /*public */void setOpacity(float opacity) {
+        synchronized (getTreeLock()) {
+            if (opacity < 0.0f || opacity > 1.0f) {
+                throw new IllegalArgumentException(
+                    "The value of opacity should be in the range [0.0f .. 1.0f].");
+            }
+            GraphicsConfiguration gc = getGraphicsConfiguration();
+            GraphicsDevice gd = gc.getDevice();
+            if (!gd.isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency.TRANSLUCENT)) {
+                throw new UnsupportedOperationException(
+                        "TRANSLUCENT translucency is not supported.");
+            }
+            if ((gc.getDevice().getFullScreenWindow() == this) && (opacity < 1.0f)) {
+                throw new IllegalArgumentException(
+                    "Setting opacity for full-screen window is not supported.");
+            }
+            this.opacity = opacity;
+            WindowPeer peer = (WindowPeer)getPeer();
+            if (peer != null) {
+                peer.setOpacity(opacity);
+            }
+        }
+    }
+
+    /**
+     * JavaDoc
+     */
+    /*public */Shape getShape() {
+        synchronized (getTreeLock()) {
+            return shape;
+        }
+    }
+
+    /**
+     * JavaDoc
+     *
+     * @param window the window to set the shape to
+     * @param shape the shape to set to the window
+     * @throws IllegalArgumentException if the window is in full screen mode,
+     *                                  and the shape is not null
+     */
+    /*public */void setShape(Shape shape) {
+        synchronized (getTreeLock()) {
+            GraphicsConfiguration gc = getGraphicsConfiguration();
+            GraphicsDevice gd = gc.getDevice();
+            if (!gd.isWindowTranslucencySupported(
+                    GraphicsDevice.WindowTranslucency.PERPIXEL_TRANSPARENT))
+            {
+                throw new UnsupportedOperationException(
+                        "PERPIXEL_TRANSPARENT translucency is not supported.");
+            }
+            if ((gc.getDevice().getFullScreenWindow() == this) && (shape != null)) {
+                throw new IllegalArgumentException(
+                    "Setting shape for full-screen window is not supported.");
+            }
+            this.shape = shape;
+            WindowPeer peer = (WindowPeer)getPeer();
+            if (peer != null) {
+                peer.applyShape(shape == null ? null : Region.getInstance(shape, null));
+            }
+        }
+    }
+
+    /**
+     * JavaDoc
+     */
+/*
+    @Override
+    public void setBackground(Color bgColor) {
+        int alpha = bgColor.getAlpha();
+        if (alpha < 255) { // non-opaque window
+            GraphicsConfiguration gc = getGraphicsConfiguration();
+            GraphicsDevice gd = gc.getDevice();
+            if (gc.getDevice().getFullScreenWindow() == this) {
+                throw new IllegalArgumentException(
+                    "Making full-screen window non opaque is not supported.");
+            }
+            if (!gc.isTranslucencyCapable()) {
+                GraphicsConfiguration capableGC = gd.getTranslucencyCapableGC();
+                if (capableGC == null) {
+                    throw new IllegalArgumentException(
+                        "PERPIXEL_TRANSLUCENT translucency is not supported");
+                }
+                // TODO: change GC
+            }
+            setLayersOpaque(this, false);
+        }
+
+        super.setBackground(bgColor);
+
+        WindowPeer peer = (WindowPeer)getPeer();
+        if (peer != null) {
+            peer.setOpaque(alpha == 255);
+        }
+    }
+*/
+
+    private transient boolean opaque = true;
+
+    void setOpaque(boolean opaque) {
+        synchronized (getTreeLock()) {
+            GraphicsConfiguration gc = getGraphicsConfiguration();
+            if (!opaque && !com.sun.awt.AWTUtilities.isTranslucencyCapable(gc)) {
+            throw new IllegalArgumentException(
+                    "The window must use a translucency-compatible graphics configuration");
+            }
+            if (!com.sun.awt.AWTUtilities.isTranslucencySupported(
+                    com.sun.awt.AWTUtilities.Translucency.PERPIXEL_TRANSLUCENT))
+            {
+                throw new UnsupportedOperationException(
+                        "PERPIXEL_TRANSLUCENT translucency is not supported.");
+            }
+            if ((gc.getDevice().getFullScreenWindow() == this) && !opaque) {
+                throw new IllegalArgumentException(
+                    "Making full-screen window non opaque is not supported.");
+            }
+            setLayersOpaque(this, opaque);
+            this.opaque = opaque;
+            WindowPeer peer = (WindowPeer)getPeer();
+            if (peer != null) {
+                peer.setOpaque(opaque);
+            }
+        }
+    }
+
+    private void updateWindow(BufferedImage backBuffer) {
+        synchronized (getTreeLock()) {
+            WindowPeer peer = (WindowPeer)getPeer();
+            if (peer != null) {
+                peer.updateWindow(backBuffer);
+            }
+        }
+    }
+
+    private static final Color TRANSPARENT_BACKGROUND_COLOR = new Color(0, 0, 0, 0);
+
+    private static void setLayersOpaque(Component component, boolean isOpaque) {
+        // Shouldn't use instanceof to avoid loading Swing classes
+        //    if it's a pure AWT application.
+        if (Component.doesImplement(component, "javax.swing.RootPaneContainer")) {
+            javax.swing.RootPaneContainer rpc = (javax.swing.RootPaneContainer)component;
+            javax.swing.JRootPane root = rpc.getRootPane();
+            javax.swing.JLayeredPane lp = root.getLayeredPane();
+            Container c = root.getContentPane();
+            javax.swing.JComponent content =
+                (c instanceof javax.swing.JComponent) ? (javax.swing.JComponent)c : null;
+            javax.swing.JComponent gp =
+                (rpc.getGlassPane() instanceof javax.swing.JComponent) ?
+                (javax.swing.JComponent)rpc.getGlassPane() : null;
+            if (gp != null) {
+                gp.setDoubleBuffered(isOpaque);
+            }
+            lp.setOpaque(isOpaque);
+            root.setOpaque(isOpaque);
+            root.setDoubleBuffered(isOpaque); //XXX: the "white rect" workaround
+            if (content != null) {
+                content.setOpaque(isOpaque);
+                content.setDoubleBuffered(isOpaque); //XXX: the "white rect" workaround
+
+                // Iterate down one level to see whether we have a JApplet
+                // (which is also a RootPaneContainer) which requires processing
+                int numChildren = content.getComponentCount();
+                if (numChildren > 0) {
+                    Component child = content.getComponent(0);
+                    // It's OK to use instanceof here because we've
+                    // already loaded the RootPaneContainer class by now
+                    if (child instanceof javax.swing.RootPaneContainer) {
+                        setLayersOpaque(child, isOpaque);
+                    }
+                }
+            }
+        }
+
+        Color bg = component.getBackground();
+        boolean hasTransparentBg = TRANSPARENT_BACKGROUND_COLOR.equals(bg);
+
+        Container container = null;
+        if (component instanceof Container) {
+            container = (Container) component;
+        }
+
+        if (isOpaque) {
+            if (hasTransparentBg) {
+                // Note: we use the SystemColor.window color as the default.
+                // This color is used in the WindowPeer implementations to
+                // initialize the background color of the window if it is null.
+                // (This might not be the right thing to do for other
+                // RootPaneContainers we might be invoked with)
+                Color newColor = null;
+                if (container != null && container.preserveBackgroundColor != null) {
+                    newColor = container.preserveBackgroundColor;
+                } else {
+                    newColor = SystemColor.window;
+                }
+                component.setBackground(newColor);
+            }
+        } else {
+            if (!hasTransparentBg && container != null) {
+                container.preserveBackgroundColor = bg;
+            }
+            component.setBackground(TRANSPARENT_BACKGROUND_COLOR);
+        }
+    }
+
+
     // ************************** MIXING CODE *******************************
 
     // A window has a parent, but it does NOT have a container
@@ -3221,6 +3463,42 @@
 
     // ****************** END OF MIXING CODE ********************************
 
+    static {
+        AWTAccessor.setWindowAccessor(new AWTAccessor.WindowAccessor() {
+            public float getOpacity(Window window) {
+                return window.opacity;
+            }
+            public void setOpacity(Window window, float opacity) {
+                window.setOpacity(opacity);
+            }
+            public Shape getShape(Window window) {
+                return window.getShape();
+            }
+            public void setShape(Window window, Shape shape) {
+                window.setShape(shape);
+            }
+            public boolean isOpaque(Window window) {
+                /*
+                return window.getBackground().getAlpha() < 255;
+                */
+                synchronized (window.getTreeLock()) {
+                    return window.opaque;
+                }
+            }
+            public void setOpaque(Window window, boolean opaque) {
+                /*
+                Color bg = window.getBackground();
+                window.setBackground(new Color(bg.getRed(), bg.getGreen(), bg.getBlue(),
+                                               opaque ? 255 : 0));
+                */
+                window.setOpaque(opaque);
+            }
+            public void updateWindow(Window window, BufferedImage backBuffer) {
+                window.updateWindow(backBuffer);
+            }
+        }); // WindowAccessor
+    } // static
+
 } // class Window
 
 
diff -r 6cf33f955d7d src/share/classes/java/awt/peer/WindowPeer.java
--- openjdk/jdk/src/share/classes/java/awt/peer/WindowPeer.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/java/awt/peer/WindowPeer.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@
 
 import java.awt.*;
 
+import java.awt.image.BufferedImage;
+
 /**
  * The peer interfaces are intended only for use in porting
  * the AWT. They are not intended for use by application
@@ -43,4 +45,26 @@
     void setModalBlocked(Dialog blocker, boolean blocked);
     void updateMinimumSize();
     void updateIconImages();
+
+    /**
+     * Sets the level of opacity for the window.
+     *
+     * @see Window#setOpacity(float)
+     */
+    void setOpacity(float opacity);
+
+    /**
+     * Enables the per-pixel alpha support for the window.
+     *
+     * @see Window#setBackground(Color)
+     */
+    void setOpaque(boolean isOpaque);
+
+    /**
+     * Updates the native part of non-opaque window using
+     * the given image with color+alpha values for each pixel.
+     *
+     * @see Window#setBackground(Color)
+     */
+    void updateWindow(BufferedImage backBuffer);
 }
diff -r 6cf33f955d7d src/share/classes/javax/swing/RepaintManager.java
--- openjdk/jdk/src/share/classes/javax/swing/RepaintManager.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/javax/swing/RepaintManager.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -34,6 +34,7 @@
 import java.util.*;
 import java.applet.*;
 
+import sun.awt.AWTAccessor;
 import sun.awt.AppContext;
 import sun.awt.DisplayChangedListener;
 import sun.awt.SunToolkit;
@@ -681,6 +682,44 @@
         }
     }
 
+    private Map<Component,Rectangle>
+        updateWindows(Map<Component,Rectangle> dirtyComponents)
+    {
+        Toolkit toolkit = Toolkit.getDefaultToolkit();
+        if (!(toolkit instanceof SunToolkit &&
+              ((SunToolkit)toolkit).needUpdateWindow()))
+        {
+            return dirtyComponents;
+        }
+
+        Set<Window> windows = new HashSet<Window>();
+        Set<Component> dirtyComps = dirtyComponents.keySet();
+        for (Iterator<Component> it = dirtyComps.iterator(); it.hasNext();) {
+            Component dirty = it.next();
+            Window window = dirty instanceof Window ?
+                (Window)dirty :
+                SwingUtilities.getWindowAncestor(dirty);
+
+            if (window != null &&
+                !AWTAccessor.getWindowAccessor().isOpaque(window))
+            {
+                // if this component's toplevel is perpixel translucent, it will
+                // be repainted below
+                it.remove();
+                // add to the set of windows to update (so that we don't update
+                // the window many times for each component to be repainted that
+                // belongs to this window)
+                windows.add(window);
+            }
+        }
+
+        for (Window window : windows) {
+            AWTAccessor.getWindowAccessor().updateWindow(window, null);
+        }
+
+        return dirtyComponents;
+    }
+
     /**
      * Paint all of the components that have been marked dirty.
      *
@@ -714,6 +753,10 @@
         int localBoundsW = 0;
         Enumeration keys;
 
+        // the components belonging to perpixel-translucent windows will be
+        // removed from the list
+        tmpDirtyComponents = updateWindows(tmpDirtyComponents);
+
         roots = new ArrayList<Component>(count);
 
         for (Component dirty : tmpDirtyComponents.keySet()) {
diff -r 6cf33f955d7d src/share/classes/sun/awt/AWTAccessor.java
--- openjdk/jdk/src/share/classes/sun/awt/AWTAccessor.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/sun/awt/AWTAccessor.java	Tue Feb 15 15:12:57 2011 +0000
@@ -26,6 +26,9 @@
 package sun.awt;
 
 import java.awt.*;
+import java.awt.geom.Point2D;
+import java.awt.image.BufferedImage;
+
 import sun.misc.Unsafe;
 
 /** The AWTAccessor utility class.
@@ -35,37 +38,124 @@
  * for another example.
  */
 public final class AWTAccessor {
+
     private static final Unsafe unsafe = Unsafe.getUnsafe();
 
-    /** We don't need any objects of this class.
+    /*
+     * We don't need any objects of this class.
      * It's rather a collection of static methods
      * and interfaces.
      */
     private AWTAccessor() {
     }
 
-    /** An accessor for the java.awt.Component class.
+    /*
+     * An interface of accessor for the java.awt.Component class.
      */
     public interface ComponentAccessor {
-        // See 6797587
-        // Also see: 6776743, 6768307, and 6768332.
-        /**
+        /*
+         * Sets whether the native background erase for a component
+         * has been disabled via SunToolkit.disableBackgroundErase().
+         */
+        void setBackgroundEraseDisabled(Component comp, boolean disabled);
+        /*
+         * Indicates whether the native background erase for a
+         * component has been disabled via
+         * SunToolkit.disableBackgroundErase().
+         */
+        boolean getBackgroundEraseDisabled(Component comp);
+        /*
+         *
+         * Gets the bounds of this component in the form of a
+         * <code>Rectangle</code> object. The bounds specify this
+         * component's width, height, and location relative to
+         * its parent.
+         */
+        Rectangle getBounds(Component comp);
+        /*
          * Sets the shape of a lw component to cut out from hw components.
+         *
+         * See 6797587, 6776743, 6768307, and 6768332 for details
          */
         void setMixingCutoutShape(Component comp, Shape shape);
     }
 
-    /* The java.awt.Component class accessor object.
+    /*
+     * An interface of accessor for java.awt.Window class.
+     */
+    public interface WindowAccessor {
+        /*
+         * Get opacity level of the given window.
+         */
+        float getOpacity(Window window);
+        /*
+         * Set opacity level to the given window.
+         */
+        void setOpacity(Window window, float opacity);
+        /*
+         * Get a shape assigned to the given window.
+         */
+        Shape getShape(Window window);
+        /*
+         * Set a shape to the given window.
+         */
+        void setShape(Window window, Shape shape);
+        /*
+         * Identify whether the given window is opaque (true)
+         *  or translucent (false).
+         */
+        boolean isOpaque(Window window);
+        /*
+         * Set the opaque preoperty to the given window.
+         */
+        void setOpaque(Window window, boolean isOpaque);
+        /*
+         * Update the image of a non-opaque (translucent) window.
+         */
+        void updateWindow(Window window, BufferedImage backBuffer);
+    }
+
+    /*
+     * An accessor for the AWTEvent class.
+     */
+    public interface AWTEventAccessor {
+        /*
+         *
+         * Sets the flag on this AWTEvent indicating that it was
+         * generated by the system.
+         */
+        void setSystemGenerated(AWTEvent ev);
+        /*
+         *
+         * Indicates whether this AWTEvent was generated by the system.
+         */
+        boolean isSystemGenerated(AWTEvent ev);
+    }
+
+    /*
+     * The java.awt.Component class accessor object.
      */
     private static ComponentAccessor componentAccessor;
 
-    /** Set an accessor object for the java.awt.Component class.
+    /*
+     * The java.awt.Window class accessor object.
+     */
+    private static WindowAccessor windowAccessor;
+
+    /*
+     * The java.awt.AWTEvent class accessor object.
+     */
+    private static AWTEventAccessor awtEventAccessor;
+
+    /*
+     * Set an accessor object for the java.awt.Component class.
      */
     public static void setComponentAccessor(ComponentAccessor ca) {
         componentAccessor = ca;
     }
 
-    /** Retrieve the accessor object for the java.awt.Window class.
+    /*
+     * Retrieve the accessor object for the java.awt.Window class.
      */
     public static ComponentAccessor getComponentAccessor() {
         if (componentAccessor == null) {
@@ -74,4 +164,35 @@
 
         return componentAccessor;
     }
+
+    /*
+     * Set an accessor object for the java.awt.Window class.
+     */
+    public static void setWindowAccessor(WindowAccessor wa) {
+        windowAccessor = wa;
+    }
+
+    /*
+     * Retrieve the accessor object for the java.awt.Window class.
+     */
+    public static WindowAccessor getWindowAccessor() {
+        if (windowAccessor == null) {
+            unsafe.ensureClassInitialized(Window.class);
+        }
+        return windowAccessor;
+    }
+
+    /*
+     * Set an accessor object for the java.awt.AWTEvent class.
+     */
+    public static void setAWTEventAccessor(AWTEventAccessor aea) {
+        awtEventAccessor = aea;
+    }
+
+    /*
+     * Retrieve the accessor object for the java.awt.AWTEvent class.
+     */
+    public static AWTEventAccessor getAWTEventAccessor() {
+        return awtEventAccessor;
+    }
 }
diff -r 6cf33f955d7d src/share/classes/sun/awt/EmbeddedFrame.java
--- openjdk/jdk/src/share/classes/sun/awt/EmbeddedFrame.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/sun/awt/EmbeddedFrame.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -579,5 +579,12 @@
         }
         public void updateMinimumSize() {
         }
-    }
+
+        public void setOpacity(float opacity) {
+        }
+        public void setOpaque(boolean isOpaque) {
+        }
+        public void updateWindow(BufferedImage backBuffer) {
+        }
+     }
 } // class EmbeddedFrame
diff -r 6cf33f955d7d src/share/classes/sun/awt/SunToolkit.java
--- openjdk/jdk/src/share/classes/sun/awt/SunToolkit.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/share/classes/sun/awt/SunToolkit.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -32,14 +32,10 @@
 import java.awt.peer.*;
 import java.awt.event.WindowEvent;
 import java.awt.event.KeyEvent;
-import java.awt.im.spi.InputMethodDescriptor;
 import java.awt.image.*;
-import java.awt.geom.AffineTransform;
 import java.awt.TrayIcon;
 import java.awt.SystemTray;
-import java.io.*;
 import java.net.URL;
-import java.net.JarURLConnection;
 import java.util.*;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
@@ -49,7 +45,6 @@
 import sun.misc.SoftCache;
 import sun.font.FontDesignMetrics;
 import sun.awt.im.InputContext;
-import sun.awt.im.SimpleInputMethodWindow;
 import sun.awt.image.*;
 import sun.security.action.GetPropertyAction;
 import sun.security.action.GetBooleanAction;
@@ -825,16 +820,31 @@
     }
 
     /**
-     * Disables erasing of background on the canvas before painting
-     * if this is supported by the current toolkit.
-     *
-     * @throws IllegalStateException if the canvas is not displayable
-     * @see java.awt.Component#isDisplayable
+     * Disables erasing of background on the canvas before painting if
+     * this is supported by the current toolkit. It is recommended to
+     * call this method early, before the Canvas becomes displayable,
+     * because some Toolkit implementations do not support changing
+     * this property once the Canvas becomes displayable.
      */
     public void disableBackgroundErase(Canvas canvas) {
-        if (!canvas.isDisplayable()) {
-            throw new IllegalStateException("Canvas must have a valid peer");
-        }
+        disableBackgroundEraseImpl(canvas);
+    }
+
+    /**
+     * Disables the native erasing of the background on the given
+     * component before painting if this is supported by the current
+     * toolkit. This only has an effect for certain components such as
+     * Canvas, Panel and Window. It is recommended to call this method
+     * early, before the Component becomes displayable, because some
+     * Toolkit implementations do not support changing this property
+     * once the Component becomes displayable.
+     */
+    public void disableBackgroundErase(Component component) {
+        disableBackgroundEraseImpl(component);
+    }
+
+    private void disableBackgroundEraseImpl(Component component) {
+        AWTAccessor.getComponentAccessor().setBackgroundEraseDisabled(component, true);
     }
 
     /**
@@ -1973,6 +1983,18 @@
         AWTAutoShutdown.getInstance().dumpPeers(aLog);
     }
 
+    /**
+     * Returns the <code>Window</code> ancestor of the component <code>comp</code>.
+     * @return Window ancestor of the component or component by itself if it is Window;
+     *         null, if component is not a part of window hierarchy
+     */
+    public static Window getContainingWindow(Component comp) {
+        while (comp != null && !(comp instanceof Window)) {
+            comp = comp.getParent();
+        }
+        return (Window)comp;
+    }
+
     private static Boolean sunAwtDisableMixing = null;
 
     /**
@@ -1996,6 +2018,73 @@
     public boolean isNativeGTKAvailable() {
         return false;
     }
+
+    // Cosntant alpha
+    public boolean isWindowOpacitySupported() {
+        return false;
+    }
+
+    // Shaping
+    public boolean isWindowShapingSupported() {
+        return false;
+    }
+
+    // Per-pixel alpha
+    public boolean isWindowTranslucencySupported() {
+        return false;
+    }
+
+    public boolean isTranslucencyCapable(GraphicsConfiguration gc) {
+        return false;
+    }
+
+    /**
+     * Returns whether or not a containing top level window for the passed
+     * component is
+     * {@link com.sun.awt.AWTUtilities.Translucency#PERPIXEL_TRANSLUCENT PERPIXEL_TRANSLUCENT}.
+     *
+     * @param c a Component which toplevel's to check
+     * @return {@code true}  if the passed component is not null and has a
+     * containing toplevel window which is opaque (so per-pixel translucency
+     * is not enabled), {@code false} otherwise
+     * @see com.sun.awt.AWTUtilities.Translucency#PERPIXEL_TRANSLUCENT
+     * @see com.sun.awt.AWTUtilities#isWindowOpaque(Window)
+     */
+    public static boolean isContainingTopLevelOpaque(Component c) {
+        Window w = getContainingWindow(c);
+        // return w != null && (w).isOpaque();
+        return w != null && com.sun.awt.AWTUtilities.isWindowOpaque(w);
+    }
+
+    /**
+     * Returns whether or not a containing top level window for the passed
+     * component is
+     * {@link com.sun.awt.AWTUtilities.Translucency#TRANSLUCENT TRANSLUCENT}.
+     *
+     * @param c a Component which toplevel's to check
+     * @return {@code true} if the passed component is not null and has a
+     * containing toplevel window which has opacity less than
+     * 1.0f (which means that it is translucent), {@code false} otherwise
+     * @see com.sun.awt.AWTUtilities.Translucency#TRANSLUCENT
+     * @see com.sun.awt.AWTUtilities#getWindowOpacity(Window)
+     */
+    public static boolean isContainingTopLevelTranslucent(Component c) {
+        Window w = getContainingWindow(c);
+        // return w != null && (w).getOpacity() < 1.0f;
+        return w != null && com.sun.awt.AWTUtilities.getWindowOpacity((Window)w) < 1.0f;
+    }
+
+    /**
+     * Returns whether the native system requires using the peer.updateWindow()
+     * method to update the contents of a non-opaque window, or if usual
+     * painting procedures are sufficient. The default return value covers
+     * the X11 systems. On MS Windows this method is overriden in WToolkit
+     * to return true.
+     */
+    public boolean needUpdateWindow() {
+        return false;
+    }
+
 } // class SunToolkit
 
 
diff -r 6cf33f955d7d src/share/native/sun/awt/utility/rect.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ openjdk/jdk/src/share/native/sun/awt/utility/rect.c	Tue Feb 15 15:12:57 2011 +0000
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2008, 2009, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "utility/rect.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/**
+ * bitsPerPixel must be 32 for now.
+ * outBuf must be large enough to conatin all the rectangles.
+ */
+int BitmapToYXBandedRectangles(int bitsPerPixel, int width, int height, unsigned char * buf, RECT_T * outBuf)
+{
+    //XXX: we might want to reuse the code in the splashscreen library,
+    // though we'd have to deal with the ALPHA_THRESHOLD and different
+    // image formats in this case.
+    int widthBytes = width * bitsPerPixel / 8;
+    int alignedWidth = (((widthBytes - 1) / 4) + 1) * 4;
+
+    RECT_T * out = outBuf;
+
+    RECT_T *pPrevLine = NULL, *pFirst = out, *pThis = pFirst;
+    int i, j, i0;
+    int length;
+
+    for (j = 0; j < height; j++) {
+        /* generate data for a scanline */
+
+        unsigned char *pSrc = (unsigned char *) buf + j * alignedWidth;
+        RECT_T *pLine = pThis;
+
+        i = 0;
+
+        do {
+            // pSrc[0,1,2] == B,G,R; pSrc[3] == Alpha
+            while (i < width && !pSrc[3]) {
+                pSrc += 4;
+                ++i;
+            }
+            if (i >= width)
+                break;
+            i0 = i;
+            while (i < width && pSrc[3]) {
+                pSrc += 4;
+                ++i;
+            }
+            RECT_SET(*pThis, i0, j, i - i0, 1);
+            ++pThis;
+        } while (i < width);
+
+        /*  check if the previous scanline is exactly the same, merge if so
+            (this is the only optimization we can use for YXBanded rectangles,
+            and win32 supports YXBanded only */
+
+        length = pThis - pLine;
+        if (pPrevLine && pLine - pPrevLine == length) {
+            for (i = 0; i < length && RECT_EQ_X(pPrevLine[i], pLine[i]); ++i) {
+            }
+            if (i == pLine - pPrevLine) {
+                // do merge
+                for (i = 0; i < length; i++) {
+                    RECT_INC_HEIGHT(pPrevLine[i]);
+                }
+                pThis = pLine;
+                continue;
+            }
+        }
+        /* or else use the generated scanline */
+
+        pPrevLine = pLine;
+    }
+
+    return pThis - pFirst;
+}
+
+#if defined(__cplusplus)
+}
+#endif
diff -r 6cf33f955d7d src/solaris/classes/sun/awt/X11/XNETProtocol.java
--- openjdk/jdk/src/solaris/classes/sun/awt/X11/XNETProtocol.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XNETProtocol.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -268,6 +268,8 @@
     XAtom XA_NET_WM_WINDOW_TYPE = XAtom.get("_NET_WM_WINDOW_TYPE");
     XAtom XA_NET_WM_WINDOW_TYPE_DIALOG = XAtom.get("_NET_WM_WINDOW_TYPE_DIALOG");
 
+    XAtom XA_NET_WM_WINDOW_OPACITY = XAtom.get("_NET_WM_WINDOW_OPACITY");
+
 /* For _NET_WM_STATE ClientMessage requests */
     final static int _NET_WM_STATE_REMOVE      =0; /* remove/unset property */
     final static int _NET_WM_STATE_ADD         =1; /* add/set property      */
@@ -304,6 +306,12 @@
         boolean res = active() && checkProtocol(XA_NET_SUPPORTED, XA_NET_WM_STATE_MODAL);
         return res;
     }
+
+    boolean doOpacityProtocol() {
+        boolean res = active() && checkProtocol(XA_NET_SUPPORTED, XA_NET_WM_WINDOW_OPACITY);
+        return res;
+    }
+
     boolean isWMName(String name) {
         if (!active()) {
             return false;
diff -r 6cf33f955d7d src/solaris/classes/sun/awt/X11/XToolkit.java
--- openjdk/jdk/src/solaris/classes/sun/awt/X11/XToolkit.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XToolkit.java	Tue Feb 15 15:12:57 2011 +0000
@@ -2181,4 +2181,35 @@
         return new XDesktopPeer();
     }
 
+    @Override
+    public boolean isWindowOpacitySupported() {
+        XNETProtocol net_protocol = XWM.getWM().getNETProtocol();
+
+        if (net_protocol == null) {
+            return false;
+        }
+
+        return net_protocol.doOpacityProtocol();
+    }
+
+    @Override
+    public boolean isWindowShapingSupported() {
+        return XlibUtil.isShapingSupported();
+    }
+
+    @Override
+    public boolean isWindowTranslucencySupported() {
+        //NOTE: it may not be supported. The actual check is being performed
+        //      at com.sun.awt.AWTUtilities(). In X11 we need to check
+        //      whether there's any translucency-capable GC available.
+        return true;
+    }
+
+    @Override
+    public boolean isTranslucencyCapable(GraphicsConfiguration gc) {
+        if (!(gc instanceof X11GraphicsConfig)) {
+            return false;
+        }
+        return ((X11GraphicsConfig)gc).isTranslucencyCapable();
+    }
 }
diff -r 6cf33f955d7d src/solaris/classes/sun/awt/X11/XWindowPeer.java
--- openjdk/jdk/src/solaris/classes/sun/awt/X11/XWindowPeer.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XWindowPeer.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,6 +30,8 @@
 import java.awt.event.FocusEvent;
 import java.awt.event.WindowEvent;
 
+import java.awt.image.BufferedImage;
+
 import java.awt.peer.ComponentPeer;
 import java.awt.peer.WindowPeer;
 
@@ -42,6 +44,7 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import sun.awt.AWTAccessor;
 import sun.awt.ComponentAccessor;
 import sun.awt.WindowAccessor;
 import sun.awt.DisplayChangedListener;
@@ -49,6 +52,8 @@
 import sun.awt.X11GraphicsDevice;
 import sun.awt.X11GraphicsEnvironment;
 
+import sun.java2d.pipe.Region;
+
 class XWindowPeer extends XPanelPeer implements WindowPeer,
                                                 DisplayChangedListener, MWMConstants {
 
@@ -269,6 +274,10 @@
 
         XWM.requestWMExtents(getWindow());
         updateIconImages();
+
+        updateShape();
+        updateOpacity();
+        // no need in updateOpaque() as it is no-op
     }
 
     public void updateIconImages() {
@@ -426,6 +435,22 @@
         return defaultIconInfo;
     }
 
+    private void updateShape() {
+        // Shape shape = ((Window)target).getShape();
+        Shape shape = AWTAccessor.getWindowAccessor().getShape((Window)target);
+        if (shape != null) {
+            applyShape(Region.getInstance(shape, null));
+        }
+    }
+
+    private void updateOpacity() {
+        // float opacity = ((Window)target).getOpacity();
+        float opacity = AWTAccessor.getWindowAccessor().getOpacity((Window)target);
+        if (opacity < 1.0f) {
+            setOpacity(opacity);
+        }
+    }
+
     public void updateMinimumSize() {
         //This function only saves minimumSize value in XWindowPeer
         //Setting WMSizeHints is implemented in XDecoratedPeer
@@ -2122,4 +2147,44 @@
         }
         super.handleButtonPressRelease(xev);
     }
+
+    public void print(Graphics g) {
+        // We assume we print the whole frame,
+        // so we expect no clip was set previously
+        Shape shape = AWTAccessor.getWindowAccessor().getShape((Window)target);
+        if (shape != null) {
+            g.setClip(shape);
+        }
+        super.print(g);
+    }
+
+    @Override
+    public void setOpacity(float opacity) {
+        final long maxOpacity = 0xffffffffl;
+        long iOpacity = (long)(opacity * maxOpacity);
+        if (iOpacity < 0) {
+            iOpacity = 0;
+        }
+        if (iOpacity > maxOpacity) {
+            iOpacity = maxOpacity;
+        }
+
+        XAtom netWmWindowOpacityAtom = XAtom.get("_NET_WM_WINDOW_OPACITY");
+
+        if (iOpacity == maxOpacity) {
+            netWmWindowOpacityAtom.DeleteProperty(getWindow());
+        } else {
+            netWmWindowOpacityAtom.setCard32Property(getWindow(), iOpacity);
+        }
+    }
+
+    @Override
+    public void setOpaque(boolean isOpaque) {
+        // no-op
+    }
+
+    @Override
+    public void updateWindow(BufferedImage backBuffer) {
+        // no-op
+    }
 }
diff -r 6cf33f955d7d src/solaris/classes/sun/awt/X11/generator/WrapperGenerator.java
--- openjdk/jdk/src/solaris/classes/sun/awt/X11/generator/WrapperGenerator.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/solaris/classes/sun/awt/X11/generator/WrapperGenerator.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -859,14 +859,14 @@
                     pw.println("\n\tlong pData;");
                     pw.println("\n\tpublic long getPData() { return pData; }");
 
-                    pw.println("\n\n\t" + stp.getJavaClassName() + "(long addr) {");
+                    pw.println("\n\n\tpublic " + stp.getJavaClassName() + "(long addr) {");
                     if (generateLog) {
                         pw.println("\t\tlog.finest(\"Creating\");");
                     }
                     pw.println("\t\tpData=addr;");
                     pw.println("\t\tshould_free_memory = false;");
                     pw.println("\t}");
-                    pw.println("\n\n\t" + stp.getJavaClassName() + "() {");
+                    pw.println("\n\n\tpublic " + stp.getJavaClassName() + "() {");
                     if (generateLog) {
                         pw.println("\t\tlog.finest(\"Creating\");");
                     }
diff -r 6cf33f955d7d src/solaris/classes/sun/awt/X11/generator/xlibtypes.txt
--- openjdk/jdk/src/solaris/classes/sun/awt/X11/generator/xlibtypes.txt	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/solaris/classes/sun/awt/X11/generator/xlibtypes.txt	Tue Feb 15 15:12:57 2011 +0000
@@ -750,6 +750,7 @@
     pixelStride int
     color_data pointer ColorData
     glxInfo pointer
+    isTranslucencySupported int
 
 AwtScreenData
     numConfigs int
diff -r 6cf33f955d7d src/solaris/classes/sun/awt/X11GraphicsConfig.java
--- openjdk/jdk/src/solaris/classes/sun/awt/X11GraphicsConfig.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/solaris/classes/sun/awt/X11GraphicsConfig.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -458,4 +458,13 @@
             return 0x00; // UNDEFINED
         }
     }
+
+    /*
+    @Override
+    */
+    public boolean isTranslucencyCapable() {
+        return isTranslucencyCapable(getAData());
+    }
+
+    private native boolean isTranslucencyCapable(long x11ConfigData);
 }
diff -r 6cf33f955d7d src/solaris/native/sun/awt/awt_GraphicsEnv.c
--- openjdk/jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	Tue Feb 15 15:12:57 2011 +0000
@@ -323,6 +323,48 @@
     return NULL;
 }
 
+/* Note: until we include the <X11/extensions/Xrender.h> explicitly
+ * we have to define a couple of things ourselves.
+ */
+typedef unsigned long   PictFormat;
+#define PictTypeIndexed             0
+#define PictTypeDirect              1
+
+typedef struct {
+    short   red;
+    short   redMask;
+    short   green;
+    short   greenMask;
+    short   blue;
+    short   blueMask;
+    short   alpha;
+    short   alphaMask;
+} XRenderDirectFormat;
+
+typedef struct {
+    PictFormat      id;
+    int         type;
+    int         depth;
+    XRenderDirectFormat direct;
+    Colormap        colormap;
+} XRenderPictFormat;
+
+#define PictFormatID        (1 << 0)
+#define PictFormatType      (1 << 1)
+#define PictFormatDepth     (1 << 2)
+#define PictFormatRed       (1 << 3)
+#define PictFormatRedMask   (1 << 4)
+#define PictFormatGreen     (1 << 5)
+#define PictFormatGreenMask (1 << 6)
+#define PictFormatBlue      (1 << 7)
+#define PictFormatBlueMask  (1 << 8)
+#define PictFormatAlpha     (1 << 9)
+#define PictFormatAlphaMask (1 << 10)
+#define PictFormatColormap  (1 << 11)
+
+typedef XRenderPictFormat *
+XRenderFindVisualFormatFunc (Display *dpy, _Xconst Visual *visual);
+
 static void
 getAllConfigs (JNIEnv *env, int screen, AwtScreenDataPtr screenDataPtr) {
 
@@ -336,6 +378,9 @@
     int ind;
     char errmsg[128];
     int xinawareScreen;
+    void* xrenderLibHandle = NULL;
+    XRenderFindVisualFormatFunc *XRenderFindVisualFormat = NULL;
+    int major_opcode, first_event, first_error;
 
     if (usingXinerama) {
         xinawareScreen = 0;
@@ -418,6 +463,26 @@
     graphicsConfigs[0] = defaultConfig;
     nConfig = 1; /* reserve index 0 for default config */
 
+    // Only use the RENDER extension if it is available on the X server
+    if (XQueryExtension(awt_display, "RENDER",
+                        &major_opcode, &first_event, &first_error))
+    {
+        xrenderLibHandle = dlopen("libXrender.so.1", RTLD_LAZY | RTLD_GLOBAL);
+
+#ifndef __linux__ /* SOLARIS */
+        if (xrenderLibHandle == NULL) {
+            xrenderLibHandle = dlopen("/usr/sfw/lib/libXrender.so.1",
+                                      RTLD_LAZY | RTLD_GLOBAL);
+        }
+#endif
+
+        if (xrenderLibHandle != NULL) {
+            XRenderFindVisualFormat =
+                (XRenderFindVisualFormatFunc*)dlsym(xrenderLibHandle,
+                                                    "XRenderFindVisualFormat");
+        }
+    }
+
     for (i = 0; i < nTrue; i++) {
         if (XVisualIDFromVisual(pVITrue[i].visual) ==
             XVisualIDFromVisual(defaultConfig->awt_visInfo.visual) ||
@@ -431,6 +496,21 @@
         graphicsConfigs [ind]->awt_depth = pVITrue [i].depth;
         memcpy (&graphicsConfigs [ind]->awt_visInfo, &pVITrue [i],
                 sizeof (XVisualInfo));
+       if (XRenderFindVisualFormat != NULL) {
+            XRenderPictFormat *format = XRenderFindVisualFormat (awt_display,
+                    pVITrue [i].visual);
+            if (format &&
+                format->type == PictTypeDirect &&
+                format->direct.alphaMask)
+            {
+                graphicsConfigs [ind]->isTranslucencySupported = 1;
+            }
+        }
+    }
+
+    if (xrenderLibHandle != NULL) {
+        dlclose(xrenderLibHandle);
+        xrenderLibHandle = NULL;
     }
 
     for (i = 0; i < n8p; i++) {
@@ -1474,6 +1554,26 @@
 }
 
 /*
+ * Class:     sun_awt_X11GraphicsConfig
+ * Method:    isTranslucencyCapable
+ * Signature: (J)V
+ */
+JNIEXPORT jboolean JNICALL
+Java_sun_awt_X11GraphicsConfig_isTranslucencyCapable
+    (JNIEnv *env, jobject this, jlong configData)
+{
+#ifdef HEADLESS
+    return JNI_FALSE;
+#else
+    AwtGraphicsConfigDataPtr aData = (AwtGraphicsConfigDataPtr)jlong_to_ptr(configData);
+    if (aData == NULL) {
+        return JNI_FALSE;
+    }
+    return (jboolean)aData->isTranslucencySupported;
+#endif
+}
+
+/*
  * Class:     sun_awt_X11GraphicsDevice
  * Method:    isDBESupported
  * Signature: ()Z
diff -r 6cf33f955d7d src/solaris/native/sun/awt/awt_p.h
--- openjdk/jdk/src/solaris/native/sun/awt/awt_p.h	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/solaris/native/sun/awt/awt_p.h	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -135,6 +135,7 @@
     int         pixelStride;     /* Used in X11SurfaceData.c */
     ColorData      *color_data;
     struct _GLXGraphicsConfigInfo *glxInfo;
+    int         isTranslucencySupported; /* Uses Xrender to find this out. */
 } AwtGraphicsConfigData;
 
 typedef AwtGraphicsConfigData* AwtGraphicsConfigDataPtr;
diff -r 6cf33f955d7d src/windows/classes/sun/awt/Win32GraphicsConfig.java
--- openjdk/jdk/src/windows/classes/sun/awt/Win32GraphicsConfig.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/Win32GraphicsConfig.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -339,4 +339,12 @@
         }
         // the rest of the flip actions are not supported
     }
+
+    /*
+    @Override
+    */
+    public boolean isTranslucencyCapable() {
+        //XXX: worth checking if 8-bit? Anyway, it doesn't hurt.
+        return true;
+    }
 }
diff -r 6cf33f955d7d src/windows/classes/sun/awt/Win32GraphicsEnvironment.java
--- openjdk/jdk/src/windows/classes/sun/awt/Win32GraphicsEnvironment.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/Win32GraphicsEnvironment.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -379,4 +379,11 @@
     private static void dwmCompositionChanged(boolean enabled) {
         isDWMCompositionEnabled = enabled;
     }
+
+    /**
+     * Used to find out if the OS is Windows Vista or later.
+     *
+     * @return {@code true} if the OS is Vista or later, {@code false} otherwise
+     */
+    public static native boolean isVistaOS();
 }
diff -r 6cf33f955d7d src/windows/classes/sun/awt/windows/TranslucentWindowPainter.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/windows/TranslucentWindowPainter.java	Tue Feb 15 15:12:57 2011 +0000
@@ -0,0 +1,398 @@
+/*
+ * Copyright (c) 2008, 2009, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package sun.awt.windows;
+
+import java.awt.AlphaComposite;
+import java.awt.Color;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.Image;
+import java.awt.Window;
+import java.awt.image.BufferedImage;
+import java.awt.image.DataBufferInt;
+import java.awt.image.VolatileImage;
+import java.lang.ref.WeakReference;
+import java.security.AccessController;
+import sun.awt.image.BufImgSurfaceData;
+import sun.java2d.DestSurfaceProvider;
+import sun.java2d.InvalidPipeException;
+import sun.java2d.Surface;
+import sun.java2d.pipe.RenderQueue;
+import sun.java2d.pipe.hw.AccelGraphicsConfig;
+import sun.java2d.pipe.hw.AccelSurface;
+import sun.security.action.GetPropertyAction;
+
+import static java.awt.image.VolatileImage.*;
+import static java.awt.Transparency.*;
+import static sun.java2d.pipe.hw.AccelSurface.*;
+import static sun.java2d.pipe.hw.ContextCapabilities.*;
+
+/**
+ * This class handles the updates of the non-opaque windows.
+ * The window associated with the peer is updated either given an image or
+ * the window is repainted to an internal buffer which is then used to update
+ * the window.
+ *
+ * Note: this class does not attempt to be thread safe, it is expected to be
+ * called from a single thread (EDT).
+ */
+public abstract class TranslucentWindowPainter {
+
+    protected Window window;
+    protected WWindowPeer peer;
+
+    // REMIND: we probably would want to remove this later
+    private static final boolean forceOpt  =
+        Boolean.valueOf(AccessController.doPrivileged(
+            new GetPropertyAction("sun.java2d.twp.forceopt", "false")));
+    private static final boolean forceSW  =
+        Boolean.valueOf(AccessController.doPrivileged(
+            new GetPropertyAction("sun.java2d.twp.forcesw", "false")));
+
+    /**
+     * Creates an instance of the painter for particular peer.
+     */
+    public static TranslucentWindowPainter createInstance(WWindowPeer peer) {
+        GraphicsConfiguration gc = peer.getGraphicsConfiguration();
+        if (!forceSW && gc instanceof AccelGraphicsConfig) {
+            String gcName = gc.getClass().getSimpleName();
+            AccelGraphicsConfig agc = (AccelGraphicsConfig)gc;
+            // this is a heuristic to check that we have a pcix board
+            // (those have higher transfer rate from gpu to cpu)
+            if ((agc.getContextCapabilities().getCaps() & CAPS_PS30) != 0 ||
+                forceOpt)
+            {
+                // we check for name to avoid loading classes unnecessarily if
+                // a pipeline isn't enabled
+                if (gcName.startsWith("D3D")) {
+                    return new VIOptD3DWindowPainter(peer);
+                } else if (forceOpt && gcName.startsWith("WGL")) {
+                    // on some boards (namely, ATI, even on pcix bus) ogl is
+                    // very slow reading pixels back so for now it is disabled
+                    // unless forced
+                    return new VIOptWGLWindowPainter(peer);
+                }
+            }
+        }
+        return new BIWindowPainter(peer);
+    }
+
+    protected TranslucentWindowPainter(WWindowPeer peer) {
+        this.peer = peer;
+        this.window = (Window)peer.getTarget();
+    }
+
+    /**
+     * Creates (if needed), clears and returns the buffer for this painter.
+     */
+    protected abstract Image getBackBuffer();
+
+    /**
+     * Updates the the window associated with this painter with the contents
+     * of the passed image.
+     * The image can not be null, and NPE will be thrown if it is.
+     */
+    protected abstract boolean update(Image bb);
+
+    /**
+     * Flushes the resources associated with the painter. They will be
+     * recreated as needed.
+     */
+    public abstract void flush();
+
+    /**
+     * Updates the window associated with the painter given the passed image.
+     * If the passed image is null the painter will use its own buffer for
+     * rendering the contents of the window into it and updating the window.
+     *
+     * If the passed buffer has dimensions different from the window, it is
+     * copied into the internal buffer first and the latter is used to update
+     * the window.
+     *
+     * @param bb the image to update the non opaque window with, or null.
+     * If not null, the image must be of ARGB_PRE type.
+     */
+    public void updateWindow(Image bb) {
+        boolean done = false;
+        if (bb != null && (window.getWidth()  != bb.getWidth(null) ||
+                           window.getHeight() != bb.getHeight(null)))
+        {
+            Image ourBB = getBackBuffer();
+            Graphics2D g = (Graphics2D)ourBB.getGraphics();
+            g.drawImage(bb, 0, 0, null);
+            g.dispose();
+            bb = ourBB;
+        }
+        do {
+            if (bb == null) {
+                bb = getBackBuffer();
+                Graphics2D g = (Graphics2D)bb.getGraphics();
+                try {
+                    window.paintAll(g);
+                } finally {
+                    g.dispose();
+                }
+            }
+
+            peer.paintAppletWarning((Graphics2D)bb.getGraphics(),
+                                    bb.getWidth(null), bb.getHeight(null));
+
+            done = update(bb);
+            // in case they passed us a lost VI, next time around we'll use our
+            // own bb because we can not validate and restore the contents of
+            // their VI
+            if (!done) {
+                bb = null;
+            }
+        } while (!done);
+    }
+
+    private static final Image clearImage(Image bb) {
+        Graphics2D g = (Graphics2D)bb.getGraphics();
+        int w = bb.getWidth(null);
+        int h = bb.getHeight(null);
+
+        g.setComposite(AlphaComposite.Src);
+        g.setColor(new Color(0, 0, 0, 0));
+        g.fillRect(0, 0, w, h);
+
+        return bb;
+    }
+
+    /**
+     * A painter which uses BufferedImage as the internal buffer. The window
+     * is painted into this buffer, and the contents then are uploaded
+     * into the layered window.
+     *
+     * This painter handles all types of images passed to its paint(Image)
+     * method (VI, BI, regular Images).
+     */
+    private static class BIWindowPainter extends TranslucentWindowPainter {
+        private WeakReference<BufferedImage> biRef;
+
+        protected BIWindowPainter(WWindowPeer peer) {
+            super(peer);
+        }
+
+        private BufferedImage getBIBackBuffer() {
+            int w = window.getWidth();
+            int h = window.getHeight();
+            BufferedImage bb = biRef == null ? null : biRef.get();
+            if (bb == null || bb.getWidth() != w || bb.getHeight() != h) {
+                if (bb != null) {
+                    bb.flush();
+                    bb = null;
+                }
+                bb = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB_PRE);
+                biRef = new WeakReference<BufferedImage>(bb);
+            }
+            return (BufferedImage)clearImage(bb);
+        }
+
+        @Override
+        protected Image getBackBuffer() {
+            return getBIBackBuffer();
+        }
+
+        @Override
+        protected boolean update(Image bb) {
+            VolatileImage viBB = null;
+
+            if (bb instanceof BufferedImage) {
+                BufferedImage bi = (BufferedImage)bb;
+                int data[] =
+                    ((DataBufferInt)bi.getRaster().getDataBuffer()).getData();
+                peer.updateWindowImpl(data, bi.getWidth(), bi.getHeight());
+                return true;
+            } else if (bb instanceof VolatileImage) {
+                viBB = (VolatileImage)bb;
+                if (bb instanceof DestSurfaceProvider) {
+                    Surface s = ((DestSurfaceProvider)bb).getDestSurface();
+                    if (s instanceof BufImgSurfaceData) {
+                        // the image is probably lost, upload the data from the
+                        // backup surface to avoid creating another heap-based
+                        // image (the parent's buffer)
+                        int w = viBB.getWidth();
+                        int h = viBB.getHeight();
+                        BufImgSurfaceData bisd = (BufImgSurfaceData)s;
+                        int data[] = ((DataBufferInt)bisd.getRaster(0,0,w,h).
+                            getDataBuffer()).getData();
+                        peer.updateWindowImpl(data, w, h);
+                        return true;
+                    }
+                }
+            }
+
+            // copy the passed image into our own buffer, then upload
+            BufferedImage bi = getBIBackBuffer();
+            Graphics2D g = (Graphics2D)bi.getGraphics();
+            g.setComposite(AlphaComposite.Src);
+            g.drawImage(bb, 0, 0, null);
+
+            int data[] =
+                ((DataBufferInt)bi.getRaster().getDataBuffer()).getData();
+            peer.updateWindowImpl(data, bi.getWidth(), bi.getHeight());
+
+            return (viBB != null ? !viBB.contentsLost() : true);
+        }
+
+        public void flush() {
+            if (biRef != null) {
+                biRef.clear();
+            }
+        }
+    }
+
+    /**
+     * A version of the painter which uses VolatileImage as the internal buffer.
+     * The window is painted into this VI and then copied into the parent's
+     * Java heap-based buffer (which is then uploaded to the layered window)
+     */
+    private static class VIWindowPainter extends BIWindowPainter {
+        private WeakReference<VolatileImage> viRef;
+
+        protected VIWindowPainter(WWindowPeer peer) {
+            super(peer);
+        }
+
+        @Override
+        protected Image getBackBuffer() {
+            int w = window.getWidth();
+            int h = window.getHeight();
+            GraphicsConfiguration gc = peer.getGraphicsConfiguration();
+
+            VolatileImage viBB = viRef == null ? null : viRef.get();
+
+            if (viBB == null || viBB.getWidth() != w || viBB.getHeight() != h ||
+                viBB.validate(gc) == IMAGE_INCOMPATIBLE)
+            {
+                if (viBB != null) {
+                    viBB.flush();
+                    viBB = null;
+                }
+
+                if (gc instanceof AccelGraphicsConfig) {
+                    AccelGraphicsConfig agc = ((AccelGraphicsConfig)gc);
+                    viBB = agc.createCompatibleVolatileImage(w, h,
+                                                             TRANSLUCENT,
+                                                             RT_PLAIN);
+                }
+                if (viBB == null) {
+                    viBB = gc.createCompatibleVolatileImage(w, h, TRANSLUCENT);
+                }
+                viBB.validate(gc);
+                viRef = new WeakReference<VolatileImage>(viBB);
+            }
+
+            return clearImage(viBB);
+        }
+
+        @Override
+        public void flush() {
+            if (viRef != null) {
+                VolatileImage viBB = viRef.get();
+                if (viBB != null) {
+                    viBB.flush();
+                    viBB = null;
+                }
+                viRef.clear();
+            }
+        }
+    }
+
+    /**
+     * Optimized version of hw painter. Uses VolatileImages for the
+     * buffer, and uses an optimized path to pull the data from those into
+     * the layered window, bypassing Java heap-based image.
+     */
+    private abstract static class VIOptWindowPainter extends VIWindowPainter {
+
+        protected VIOptWindowPainter(WWindowPeer peer) {
+            super(peer);
+        }
+
+        protected abstract boolean updateWindowAccel(long psdops, int w, int h);
+
+        @Override
+        protected boolean update(Image bb) {
+            if (bb instanceof DestSurfaceProvider) {
+                Surface s = ((DestSurfaceProvider)bb).getDestSurface();
+                if (s instanceof AccelSurface) {
+                    final int w = bb.getWidth(null);
+                    final int h = bb.getHeight(null);
+                    final boolean arr[] = { false };
+                    final AccelSurface as = (AccelSurface)s;
+                    RenderQueue rq = as.getContext().getRenderQueue();
+                    rq.lock();
+                    try {
+                        as.getContext().validateContext(as);
+                        rq.flushAndInvokeNow(new Runnable() {
+                            public void run() {
+                                long psdops = as.getNativeOps();
+                                arr[0] = updateWindowAccel(psdops, w, h);
+                            }
+                        });
+                    } catch (InvalidPipeException e) {
+                        // ignore, false will be returned
+                    } finally {
+                        rq.unlock();
+                    }
+                    return arr[0];
+                }
+            }
+            return super.update(bb);
+        }
+    }
+
+    private static class VIOptD3DWindowPainter extends VIOptWindowPainter {
+
+        protected VIOptD3DWindowPainter(WWindowPeer peer) {
+            super(peer);
+        }
+
+        @Override
+        protected boolean updateWindowAccel(long psdops, int w, int h) {
+            // note: this method is executed on the toolkit thread, no sync is
+            // necessary at the native level, and a pointer to peer can be used
+            return sun.java2d.d3d.D3DSurfaceData.
+                updateWindowAccelImpl(psdops, peer.getData(), w, h);
+        }
+    }
+
+    private static class VIOptWGLWindowPainter extends VIOptWindowPainter {
+
+        protected VIOptWGLWindowPainter(WWindowPeer peer) {
+            super(peer);
+        }
+
+        @Override
+        protected boolean updateWindowAccel(long psdops, int w, int h) {
+            // note: part of this method which deals with GDI will be on the
+            // toolkit thread
+            return sun.java2d.opengl.WGLSurfaceData.
+                updateWindowAccelImpl(psdops, peer, w, h);
+        }
+    }
+}
diff -r 6cf33f955d7d src/windows/classes/sun/awt/windows/WCanvasPeer.java
--- openjdk/jdk/src/windows/classes/sun/awt/windows/WCanvasPeer.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/windows/WCanvasPeer.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,7 @@
 import java.awt.peer.*;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Method;
+import sun.awt.AWTAccessor;
 import sun.awt.ComponentAccessor;
 import sun.awt.SunToolkit;
 import sun.awt.Win32GraphicsDevice;
@@ -110,16 +111,20 @@
     }
 
     public void print(Graphics g) {
-        Dimension d = ((Component)target).getSize();
-        if (g instanceof Graphics2D ||
-            g instanceof sun.awt.Graphics2Delegate) {
-            // background color is setup correctly, so just use clearRect
-            g.clearRect(0, 0, d.width, d.height);
-        } else {
-            // emulate clearRect
-            g.setColor(((Component)target).getBackground());
-            g.fillRect(0, 0, d.width, d.height);
-            g.setColor(((Component)target).getForeground());
+        if (!(target instanceof Window) ||
+            AWTAccessor.getWindowAccessor().isOpaque((Window)target))
+        {
+            Dimension d = ((Component)target).getSize();
+            if (g instanceof Graphics2D ||
+                g instanceof sun.awt.Graphics2Delegate) {
+                // background color is setup correctly, so just use clearRect
+                g.clearRect(0, 0, d.width, d.height);
+            } else {
+                // emulate clearRect
+                g.setColor(((Component)target).getBackground());
+                g.fillRect(0, 0, d.width, d.height);
+                g.setColor(((Component)target).getForeground());
+            }
         }
         super.print(g);
     }
diff -r 6cf33f955d7d src/windows/classes/sun/awt/windows/WComponentPeer.java
--- openjdk/jdk/src/windows/classes/sun/awt/windows/WComponentPeer.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/windows/WComponentPeer.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,21 +39,22 @@
 import java.awt.event.InvocationEvent;
 import java.awt.event.KeyEvent;
 import sun.awt.Win32GraphicsConfig;
+import sun.awt.Win32GraphicsEnvironment;
 import sun.java2d.InvalidPipeException;
 import sun.java2d.SurfaceData;
-import sun.java2d.d3d.D3DScreenUpdateManager;
-import static sun.java2d.d3d.D3DSurfaceData.*;
 import sun.java2d.ScreenUpdateManager;
+import sun.java2d.d3d.D3DSurfaceData;
 import sun.java2d.opengl.OGLSurfaceData;
+import sun.java2d.pipe.Region;
 import sun.awt.DisplayChangedListener;
 import sun.awt.PaintEventDispatcher;
+import sun.awt.SunToolkit;
 import sun.awt.event.IgnorePaintEvent;
 
 import java.awt.dnd.DropTarget;
 import java.awt.dnd.peer.DropTargetPeer;
 import sun.awt.ComponentAccessor;
 
-
 import java.util.logging.*;
 
 
@@ -193,7 +194,7 @@
                 cont.invalidate();
                 cont.validate();
 
-                if (surfaceData instanceof D3DWindowSurfaceData ||
+                if (surfaceData instanceof D3DSurfaceData.D3DWindowSurfaceData ||
                     surfaceData instanceof OGLSurfaceData)
                 {
                     // When OGL or D3D is enabled, it is necessary to
@@ -265,7 +266,7 @@
             int[] pix = createPrintedPixels(0, startY, totalW, h);
             if (pix != null) {
                 BufferedImage bim = new BufferedImage(totalW, h,
-                                              BufferedImage.TYPE_INT_RGB);
+                                              BufferedImage.TYPE_INT_ARGB);
                 bim.setRGB(0, 0, totalW, h, pix, 0, totalW);
                 g.drawImage(bim, 0, startY, null);
                 bim.flush();
@@ -902,9 +903,29 @@
     public void setBoundsOperation(int operation) {
     }
 
+    /**
+     * Returns whether this component is capable of being hw accelerated.
+     * More specifically, whether rendering to this component or a
+     * BufferStrategy's back-buffer for this component can be hw accelerated.
+     *
+     * Conditions which could prevent hw acceleration include the toplevel
+     * window containing this component being
+     * {@link com.sun.awt.AWTUtilities.Translucency#TRANSLUCENT TRANSLUCENT}.
+     *
+     * @return {@code true} if this component is capable of being hw
+     * accelerated, {@code false} otherwise
+     * @see com.sun.awt.AWTUtilities.Translucency#TRANSLUCENT
+     */
+    public boolean isAccelCapable() {
+        boolean isTranslucent =
+            SunToolkit.isContainingTopLevelTranslucent((Component)target);
+        // D3D/OGL and translucent windows interacted poorly in Windows XP;
+        // these problems are no longer present in Vista
+        return !isTranslucent || Win32GraphicsEnvironment.isVistaOS();
+    }
 
     native void setRectangularShape(int lox, int loy, int hix, int hiy,
-                     sun.java2d.pipe.Region region);
+                     Region region);
 
 
     // REMIND: Temp workaround for issues with using HW acceleration
@@ -922,41 +943,10 @@
     }
 
     /**
-     * Returns whether this component is capable of being hw accelerated.
-     * More specifically, whether rendering to this component or a
-     * BufferStrategy's back-buffer for this component can be hw accelerated.
-     *
-     * Conditions which could prevent hw acceleration include the toplevel
-     * window containing this component being
-     * {@link com.sun.awt.AWTUtilities.Translucency#TRANSLUCENT TRANSLUCENT}.
-     *
-     * @return {@code true} if this component is capable of being hw
-     * accelerated, {@code false} otherwise
-     * @see com.sun.awt.AWTUtilities.Translucency#TRANSLUCENT
-     */
-    public boolean isAccelCapable() {
-        // REMIND: Temp workaround for issues with using HW acceleration
-        // in the browser on Vista when DWM is enabled
-        if (!isContainingTopLevelAccelCapable((Component)target)) {
-            return false;
-        }
-
-        // REMIND: translucent windows support-related
-/*
-        boolean isTranslucent =
-            SunToolkit.isContainingTopLevelTranslucent((Component)target);
-        // D3D/OGL and translucent windows interacted poorly in Windows XP;
-        // these problems are no longer present in Vista
-        return !isTranslucent || Win32GraphicsEnvironment.isVistaOS();
-*/
-        return true;
-    }
-
-    /**
      * Applies the shape to the native component window.
      * @since 1.7
      */
-    public void applyShape(sun.java2d.pipe.Region shape) {
+    public void applyShape(Region shape) {
         if (shapeLog.isLoggable(Level.FINER)) {
             shapeLog.finer(
                     "*** INFO: Setting shape: PEER: " + this
diff -r 6cf33f955d7d src/windows/classes/sun/awt/windows/WFileDialogPeer.java
--- openjdk/jdk/src/windows/classes/sun/awt/windows/WFileDialogPeer.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/windows/WFileDialogPeer.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -244,4 +244,10 @@
     public boolean isRestackSupported() {
         return false;
     }
+
+    // The effects are not supported for system dialogs.
+    public void applyShape(sun.java2d.pipe.Region shape) {}
+    public void setOpacity(float opacity) {}
+    public void setOpaque(boolean isOpaque) {}
+    public void updateWindow(java.awt.image.BufferedImage backBuffer) {}
 }
diff -r 6cf33f955d7d src/windows/classes/sun/awt/windows/WPrintDialogPeer.java
--- openjdk/jdk/src/windows/classes/sun/awt/windows/WPrintDialogPeer.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/windows/WPrintDialogPeer.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -156,4 +156,10 @@
     public boolean isRestackSupported() {
         return false;
     }
+
+    // The effects are not supported for system dialogs.
+    public void applyShape(sun.java2d.pipe.Region shape) {}
+    public void setOpacity(float opacity) {}
+    public void setOpaque(boolean isOpaque) {}
+    public void updateWindow(java.awt.image.BufferedImage backBuffer) {}
 }
diff -r 6cf33f955d7d src/windows/classes/sun/awt/windows/WToolkit.java
--- openjdk/jdk/src/windows/classes/sun/awt/windows/WToolkit.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/windows/WToolkit.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -966,4 +966,34 @@
     }
 
     private static native boolean isProtectedMode();
+
+    @Override
+    public boolean isWindowOpacitySupported() {
+        // supported in Win2K and later
+        return true;
+    }
+
+    @Override
+    public boolean isWindowShapingSupported() {
+        return true;
+    }
+
+    @Override
+    public boolean isWindowTranslucencySupported() {
+        // supported in Win2K and later
+        return true;
+    }
+
+    @Override
+    public boolean isTranslucencyCapable(GraphicsConfiguration gc) {
+        //XXX: worth checking if 8-bit? Anyway, it doesn't hurt.
+        return true;
+    }
+
+    // On MS Windows one must use the peer.updateWindow() to implement
+    // non-opaque windows.
+    @Override
+    public boolean needUpdateWindow() {
+        return true;
+    }
 }
diff -r 6cf33f955d7d src/windows/classes/sun/awt/windows/WWindowPeer.java
--- openjdk/jdk/src/windows/classes/sun/awt/windows/WWindowPeer.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/windows/WWindowPeer.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,17 +31,15 @@
 
 import java.beans.*;
 
-import java.lang.ref.*;
 import java.lang.reflect.*;
 
-import java.security.*;
-
 import java.util.*;
 import java.util.List;
 import java.util.logging.*;
 
 import sun.awt.*;
-import sun.awt.image.*;
+
+import sun.java2d.pipe.Region;
 
 public class WWindowPeer extends WPanelPeer implements WindowPeer {
 
@@ -52,6 +50,10 @@
     // extends WWindowPeer, not WDialogPeer
     private WWindowPeer modalBlocker = null;
 
+    private boolean isOpaque;
+
+    private volatile TranslucentWindowPainter painter;
+
     /*
      * A key used for storing a list of active windows in AppContext. The value
      * is a list of windows, sorted by the time of activation: later a window is
@@ -90,9 +92,18 @@
                 l.remove(this);
             }
         }
+
         // Remove ourself from the Map of DisplayChangeListeners
         GraphicsConfiguration gc = getGraphicsConfiguration();
         ((Win32GraphicsDevice)gc.getDevice()).removeDisplayChangedListener(this);
+
+        TranslucentWindowPainter currentPainter = painter;
+        if (currentPainter != null) {
+            currentPainter.flush();
+            // don't set the current one to null here; reduces the chances of
+            // MT issues (like NPEs)
+        }
+
         super.disposeImpl();
     }
 
@@ -164,6 +175,10 @@
         }
 
         updateIconImages();
+
+        updateShape();
+        updateOpacity();
+        updateOpaque();
     }
 
     native void createAwtWindow(WComponentPeer parent);
@@ -197,6 +212,8 @@
         if (((Window)target).isAlwaysOnTopSupported() && alwaysOnTop) {
             setAlwaysOnTop(alwaysOnTop);
         }
+
+        updateWindow(null);
     }
 
     // Synchronize the insets members (here & in helper) with actual window
@@ -279,6 +296,31 @@
         }
     }
 
+    private void updateShape() {
+        // Shape shape = ((Window)target).getShape();
+        Shape shape = AWTAccessor.getWindowAccessor().getShape((Window)target);
+        if (shape != null) {
+            applyShape(Region.getInstance(shape, null));
+        }
+    }
+
+    private void updateOpacity() {
+        // float opacity = ((Window)target).getOpacity();
+        float opacity = AWTAccessor.getWindowAccessor().getOpacity((Window)target);
+        if (opacity < 1.0f) {
+            setOpacity(opacity);
+        }
+    }
+
+    private void updateOpaque() {
+        this.isOpaque = true;
+        // boolean opaque = ((Window)target).isOpaque();
+        boolean opaque = AWTAccessor.getWindowAccessor().isOpaque((Window)target);
+        if (!opaque) {
+            setOpaque(opaque);
+        }
+    }
+
     native void setMinSize(int width, int height);
 
 /*
@@ -531,6 +573,135 @@
          super.setBounds(newBounds.x, newBounds.y, newBounds.width, newBounds.height, op);
      }
 
+    @Override
+    public void print(Graphics g) {
+        // We assume we print the whole frame,
+        // so we expect no clip was set previously
+        Shape shape = AWTAccessor.getWindowAccessor().getShape((Window)target);
+        if (shape != null) {
+            g.setClip(shape);
+        }
+        super.print(g);
+    }
+
+    private void replaceSurfaceDataRecursively(Component c) {
+        if (c instanceof Container) {
+            for (Component child : ((Container)c).getComponents()) {
+                replaceSurfaceDataRecursively(child);
+            }
+        }
+        ComponentPeer cp = c.getPeer();
+        if (cp instanceof WComponentPeer) {
+            ((WComponentPeer)cp).replaceSurfaceDataLater();
+        }
+    }
+
+    private native void setOpacity(int iOpacity);
+
+    public void setOpacity(float opacity) {
+        if (!((SunToolkit)((Window)target).getToolkit()).
+            isWindowOpacitySupported())
+        {
+            return;
+        }
+
+        replaceSurfaceDataRecursively((Component)getTarget());
+
+        final int maxOpacity = 0xff;
+        int iOpacity = (int)(opacity * maxOpacity);
+        if (iOpacity < 0) {
+            iOpacity = 0;
+        }
+        if (iOpacity > maxOpacity) {
+            iOpacity = maxOpacity;
+        }
+
+        setOpacity(iOpacity);
+        updateWindow(null);
+    }
+
+    private native void setOpaqueImpl(boolean isOpaque);
+
+    public void setOpaque(boolean isOpaque) {
+        Window target = (Window)getTarget();
+
+        SunToolkit sunToolkit = (SunToolkit)target.getToolkit();
+        if (!sunToolkit.isWindowTranslucencySupported() ||
+            !sunToolkit.isTranslucencyCapable(target.getGraphicsConfiguration()))
+        {
+            return;
+        }
+
+        boolean opaqueChanged = this.isOpaque != isOpaque;
+        boolean isVistaOS = Win32GraphicsEnvironment.isVistaOS();
+
+        if (opaqueChanged && !isVistaOS){
+            // non-Vista OS: only replace the surface data if the opacity
+            // status changed (see WComponentPeer.isAccelCapable() for more)
+            replaceSurfaceDataRecursively(target);
+        }
+
+        this.isOpaque = isOpaque;
+
+        setOpaqueImpl(isOpaque);
+
+        if (opaqueChanged) {
+            if (isOpaque) {
+                TranslucentWindowPainter currentPainter = painter;
+                if (currentPainter != null) {
+                    currentPainter.flush();
+                    painter = null;
+                }
+            } else {
+                painter = TranslucentWindowPainter.createInstance(this);
+            }
+        }
+
+        if (opaqueChanged && isVistaOS) {
+            // On Vista: setting the window non-opaque makes the window look
+            // rectangular, though still catching the mouse clicks within
+            // its shape only. To restore the correct visual appearance
+            // of the window (i.e. w/ the correct shape) we have to reset
+            // the shape.
+            Shape shape = AWTAccessor.getWindowAccessor().getShape(target);
+            if (shape != null) {
+                AWTAccessor.getWindowAccessor().setShape(target, shape);
+            }
+        }
+
+        updateWindow(null);
+    }
+
+    public native void updateWindowImpl(int[] data, int width, int height);
+
+    public void updateWindow(BufferedImage backBuffer) {
+        if (isOpaque) {
+            return;
+        }
+
+        TranslucentWindowPainter currentPainter = painter;
+        if (currentPainter != null) {
+            currentPainter.updateWindow(backBuffer);
+        } else if (log.isLoggable(Level.FINER)) {
+            log.log(Level.FINER,
+                    "Translucent window painter is null in updateWindow");
+        }
+    }
+
+    /**
+     * Paints the Applet Warning into the passed Graphics2D. This method is
+     * called by the TranslucentWindowPainter before updating the layered
+     * window.
+     *
+     * @param g Graphics context to paint the warning to
+     * @param w the width of the area
+     * @param h the height of the area
+     * @see TranslucentWindowPainter
+     */
+    public void paintAppletWarning(Graphics2D g, int w, int h) {
+        // REMIND: the applet warning needs to be painted here
+    }
+
     /*
      * Static inner class, listens for 'activeWindow' KFM property changes and
      * updates the list of active windows per AppContext, so the latest active
diff -r 6cf33f955d7d src/windows/classes/sun/java2d/opengl/WGLSurfaceData.java
--- openjdk/jdk/src/windows/classes/sun/java2d/opengl/WGLSurfaceData.java	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/opengl/WGLSurfaceData.java	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -72,9 +72,8 @@
         // the OGL pipeline can render directly to the screen and interfere
         // with layered windows, which is why we don't allow accelerated
         // surfaces in this case
-        if (!peer.isAccelCapable())
-        // REMIND: commented until toplevel translucency is implemented
-//            || !SunToolkit.isContainingTopLevelOpaque((Component)peer.getTarget()))
+        if (!peer.isAccelCapable() ||
+            !SunToolkit.isContainingTopLevelOpaque((Component)peer.getTarget()))
         {
             return null;
         }
@@ -93,9 +92,8 @@
         // the OGL pipeline can render directly to the screen and interfere
         // with layered windows, which is why we don't allow accelerated
         // surfaces in this case
-        if (!peer.isAccelCapable())
-        // REMIND: commented until toplevel translucency is implemented
-//            || !SunToolkit.isContainingTopLevelOpaque((Component)peer.getTarget()))
+        if (!peer.isAccelCapable() ||
+            !SunToolkit.isContainingTopLevelOpaque((Component)peer.getTarget()))
         {
             return null;
         }
diff -r 6cf33f955d7d src/windows/native/sun/awt/utility/rect.h
--- openjdk/jdk/src/windows/native/sun/awt/utility/rect.h	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/native/sun/awt/utility/rect.h	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -43,5 +43,15 @@
 
 #define RECT_INC_HEIGHT(r) (r).bottom++
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+int BitmapToYXBandedRectangles(int bitsPerPixel, int width, int height,
+        unsigned char * buf, RECT_T * outBuf);
+
+#if defined(__cplusplus)
+}
+#endif
 
 #endif // _AWT_RECT_H
diff -r 6cf33f955d7d src/windows/native/sun/java2d/d3d/D3DSurfaceData.cpp
--- openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DSurfaceData.cpp	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DSurfaceData.cpp	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -614,17 +614,15 @@
 
     res = pTmpSurface->LockRect(&lockedRect, NULL, D3DLOCK_NOSYSLOCK);
     if (SUCCEEDED(res)) {
-        // REMIND: commented until translucent window support is integrated
-//        hBitmap =
-//            BitmapUtil::CreateBitmapFromARGBPre(w, h,
-//                                                lockedRect.Pitch,
-//                                                (int*)lockedRect.pBits);
+        hBitmap =
+            BitmapUtil::CreateBitmapFromARGBPre(w, h,
+                                                lockedRect.Pitch,
+                                                (int*)lockedRect.pBits);
         pTmpSurface->UnlockRect();
     }
     RETURN_STATUS_IF_NULL(hBitmap, JNI_FALSE);
 
-    // REMIND: commented until translucent window support is integrated
-//    window->UpdateWindow(env, NULL, w, h, hBitmap);
+    window->UpdateWindow(env, NULL, w, h, hBitmap);
 
     // hBitmap is released in UpdateWindow
 
diff -r 6cf33f955d7d src/windows/native/sun/java2d/opengl/WGLSurfaceData.c
--- openjdk/jdk/src/windows/native/sun/java2d/opengl/WGLSurfaceData.c	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/opengl/WGLSurfaceData.c	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -625,17 +625,15 @@
     j2d_glPixelStorei(GL_PACK_ALIGNMENT, 4);
 
     // the pixels read from the surface are already premultiplied
-    // REMIND: commented until translucent window support is integrated
-//    hBitmap = BitmapUtil_CreateBitmapFromARGBPre(w, h, scanStride,
-//                                                 (int*)pDst);
+    hBitmap = BitmapUtil_CreateBitmapFromARGBPre(w, h, scanStride,
+                                                 (int*)pDst);
     free(pDst);
 
     if (hBitmap == NULL) {
         return JNI_FALSE;
     }
 
-    // REMIND: commented until translucent window support is integrated
-    // AwtWindow_UpdateWindow(env, peer, w, h, hBitmap);
+    AwtWindow_UpdateWindow(env, peer, w, h, hBitmap);
 
     // hBitmap is released in UpdateWindow
 
diff -r 6cf33f955d7d src/windows/native/sun/windows/awt_BitmapUtil.cpp
--- openjdk/jdk/src/windows/native/sun/windows/awt_BitmapUtil.cpp	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_BitmapUtil.cpp	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,9 +28,14 @@
 #include <windowsx.h>
 #include <zmouse.h>
 
+#include "GraphicsPrimitiveMgr.h"
+
 #include "awt.h"
 #include "awt_BitmapUtil.h"
 
+// Platform-dependent RECT_[EQ | SET | INC_HEIGHT] macros
+#include "utility/rect.h"
+
 HBITMAP BitmapUtil::CreateTransparencyMaskFromARGB(int width, int height, int* imageData)
 {
     //Scan lines should be aligned to word boundary
@@ -148,3 +153,222 @@
     ::GdiFlush();
     return hBitmap;
 }
+
+/*
+ * Creates 32-bit premultiplied ARGB bitmap from specified ARGBPre data.
+ * This function may not work on OS prior to Win95.
+ * See MSDN articles for CreateDIBitmap, BITMAPINFOHEADER,
+ * BITMAPV4HEADER, BITMAPV5HEADER for additional info.
+ */
+HBITMAP BitmapUtil::CreateBitmapFromARGBPre(int width, int height,
+                                            int srcStride,
+                                            int* imageData)
+{
+    BITMAPINFOHEADER bmi;
+    void *bitmapBits = NULL;
+
+    ZeroMemory(&bmi, sizeof(bmi));
+    bmi.biSize = sizeof(bmi);
+    bmi.biWidth = width;
+    bmi.biHeight = -height;
+    bmi.biPlanes = 1;
+    bmi.biBitCount = 32;
+    bmi.biCompression = BI_RGB;
+
+    HBITMAP hBitmap =
+        ::CreateDIBSection(NULL, (BITMAPINFO *) & bmi, DIB_RGB_COLORS,
+                           &bitmapBits, NULL, 0);
+
+    if (!bitmapBits) {
+        return NULL;
+    }
+
+    int dstStride = width * 4;
+
+    if (srcStride == dstStride) {
+        memcpy(bitmapBits, (void*)imageData, srcStride * height);
+    } else if (height > 0) {
+        void *pSrcPixels = (void*)imageData;
+        void *pDstPixels = bitmapBits;
+        do {
+            memcpy(pDstPixels, pSrcPixels, dstStride);
+            pSrcPixels = PtrAddBytes(pSrcPixels, srcStride);
+            pDstPixels = PtrAddBytes(pDstPixels, dstStride);
+        } while (--height > 0);
+    }
+
+    return hBitmap;
+}
+
+extern "C" {
+
+/**
+ * This method is called from the WGL pipeline when it needs to create a bitmap
+ * needed to update the layered window.
+ */
+HBITMAP BitmapUtil_CreateBitmapFromARGBPre(int width, int height,
+                                           int srcStride,
+                                           int* imageData)
+{
+    return BitmapUtil::CreateBitmapFromARGBPre(width, height,
+                                               srcStride, imageData);
+
+}
+
+}  /* extern "C" */
+
+
+/**
+ * Transforms the given bitmap into an HRGN representing the transparency
+ * of the bitmap. The bitmap MUST BE 32bpp. Alpha value == 0 is considered
+ * transparent, alpha > 0 - opaque.
+ */
+HRGN BitmapUtil::BitmapToRgn(HBITMAP hBitmap)
+{
+    HDC hdc = ::CreateCompatibleDC(NULL);
+    ::SelectObject(hdc, hBitmap);
+
+    BITMAPINFOEX bi;
+    ::ZeroMemory(&bi, sizeof(bi));
+
+    bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+
+    BOOL r = ::GetDIBits(hdc, hBitmap, 0, 0, NULL,
+            reinterpret_cast<BITMAPINFO*>(&bi), DIB_RGB_COLORS);
+
+    if (!r || bi.bmiHeader.biBitCount != 32)
+    {
+        ::DeleteDC(hdc);
+        return NULL;
+    }
+
+    UINT width = bi.bmiHeader.biWidth;
+    UINT height = abs(bi.bmiHeader.biHeight);
+
+    BYTE * buf = (BYTE*)safe_Malloc(bi.bmiHeader.biSizeImage);
+    bi.bmiHeader.biHeight = -height;
+    ::GetDIBits(hdc, hBitmap, 0, height, buf,
+            reinterpret_cast<BITMAPINFO*>(&bi), DIB_RGB_COLORS);
+
+    /* reserving memory for the worst case */
+    RGNDATA * pRgnData = (RGNDATA *) safe_Malloc(sizeof(RGNDATAHEADER) +
+            sizeof(RECT) * (width / 2 + 1) * height);
+    RGNDATAHEADER * pRgnHdr = (RGNDATAHEADER *) pRgnData;
+    pRgnHdr->dwSize = sizeof(RGNDATAHEADER);
+    pRgnHdr->iType = RDH_RECTANGLES;
+    pRgnHdr->nRgnSize = 0;
+    pRgnHdr->rcBound.top = 0;
+    pRgnHdr->rcBound.left = 0;
+    pRgnHdr->rcBound.bottom = height;
+    pRgnHdr->rcBound.right = width;
+
+    pRgnHdr->nCount = BitmapToYXBandedRectangles(32, width, height, buf,
+            (RECT_T *) (((BYTE *) pRgnData) + sizeof(RGNDATAHEADER)));
+
+    HRGN rgn = ::ExtCreateRegion(NULL,
+            sizeof(RGNDATAHEADER) + sizeof(RECT_T) * pRgnHdr->nCount,
+            pRgnData);
+
+    free(pRgnData);
+    ::DeleteDC(hdc);
+    free(buf);
+
+    return rgn;
+}
+
+/**
+ * Makes a copy of the given bitmap. Blends every pixel of the source
+ * with the given blendColor and alpha. If alpha == 0, the function
+ * simply makes a plain copy of the source without any blending.
+ */
+HBITMAP BitmapUtil::BlendCopy(HBITMAP hSrcBitmap, COLORREF blendColor,
+        BYTE alpha)
+{
+    HDC hdc = ::CreateCompatibleDC(NULL);
+    HBITMAP oldBitmap = (HBITMAP)::SelectObject(hdc, hSrcBitmap);
+
+    BITMAPINFOEX bi;
+    ::ZeroMemory(&bi, sizeof(bi));
+
+    bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+
+    BOOL r = ::GetDIBits(hdc, hSrcBitmap, 0, 0, NULL,
+            reinterpret_cast<BITMAPINFO*>(&bi), DIB_RGB_COLORS);
+
+    if (!r || bi.bmiHeader.biBitCount != 32)
+    {
+        ::DeleteDC(hdc);
+        return NULL;
+    }
+
+    UINT width = bi.bmiHeader.biWidth;
+    UINT height = abs(bi.bmiHeader.biHeight);
+
+    BYTE * buf = (BYTE*)safe_Malloc(bi.bmiHeader.biSizeImage);
+    bi.bmiHeader.biHeight = -height;
+    ::GetDIBits(hdc, hSrcBitmap, 0, height, buf,
+            reinterpret_cast<BITMAPINFO*>(&bi), DIB_RGB_COLORS);
+
+    UINT widthBytes = width * bi.bmiHeader.biBitCount / 8;
+    UINT alignedWidth = (((widthBytes - 1) / 4) + 1) * 4;
+    UINT i, j;
+
+    for (j = 0; j < height; j++) {
+        BYTE *pSrc = (BYTE *) buf + j * alignedWidth;
+        for (i = 0; i < width; i++, pSrc += 4) {
+            // Note: if the current alpha is zero, the other three color
+            // components may (theoretically) contain some uninitialized
+            // data. The developer does not expect to display them,
+            // hence we handle this situation differently.
+            if (pSrc[3] == 0) {
+                pSrc[0] = GetBValue(blendColor) * alpha / 255;
+                pSrc[1] = GetGValue(blendColor) * alpha / 255;
+                pSrc[2] = GetRValue(blendColor) * alpha / 255;
+                pSrc[3] = alpha;
+            } else {
+                pSrc[0] = (GetBValue(blendColor) * alpha / 255) +
+                    (pSrc[0] * (255 - alpha) / 255);
+                pSrc[1] = (GetGValue(blendColor) * alpha / 255) +
+                    (pSrc[1] * (255 - alpha) / 255);
+                pSrc[2] = (GetRValue(blendColor) * alpha / 255) +
+                    (pSrc[2] * (255 - alpha) / 255);
+                pSrc[3] = (alpha * alpha / 255) +
+                    (pSrc[3] * (255 - alpha) / 255);
+            }
+        }
+    }
+
+    HBITMAP hDstBitmap = ::CreateDIBitmap(hdc,
+            reinterpret_cast<BITMAPINFOHEADER*>(&bi),
+            CBM_INIT,
+            buf,
+            reinterpret_cast<BITMAPINFO*>(&bi),
+            DIB_RGB_COLORS
+            );
+
+    ::SelectObject(hdc, oldBitmap);
+    ::DeleteDC(hdc);
+    free(buf);
+
+    return hDstBitmap;
+}
+
+/**
+ * Creates a 32 bit ARGB bitmap. Returns the bitmap handle. The *bitmapBits
+ * contains the pointer to the bitmap data or NULL if an error occured.
+ */
+HBITMAP BitmapUtil::CreateARGBBitmap(int width, int height, void ** bitmapBitsPtr)
+{
+    BITMAPINFOHEADER bmi;
+
+    ::ZeroMemory(&bmi, sizeof(bmi));
+    bmi.biSize = sizeof(BITMAPINFOHEADER);
+    bmi.biWidth = width;
+    bmi.biHeight = -height;
+    bmi.biPlanes = 1;
+    bmi.biBitCount = 32;
+    bmi.biCompression = BI_RGB;
+
+    return ::CreateDIBSection(NULL, (BITMAPINFO *) & bmi, DIB_RGB_COLORS,
+                bitmapBitsPtr, NULL, 0);
+}
diff -r 6cf33f955d7d src/windows/native/sun/windows/awt_BitmapUtil.h
--- openjdk/jdk/src/windows/native/sun/windows/awt_BitmapUtil.h	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_BitmapUtil.h	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -45,6 +45,32 @@
      */
     static HBITMAP CreateV4BitmapFromARGB(int width, int height, int* imageData);
 
+    /**
+     * Creates 32-bit premultiplied ARGB V4 Bitmap (Win95-compatible) from
+     * specified ARGB Pre input data.
+     */
+    static HBITMAP CreateBitmapFromARGBPre(int width, int height,
+                                           int srcStride,
+                                           int* imageData);
+
+    /**
+     * Transforms the given bitmap into an HRGN representing the transparency
+     * of the bitmap.
+     */
+    static HRGN BitmapToRgn(HBITMAP hBitmap);
+
+    /**
+     * Makes a copy of the given bitmap. Blends every pixel of the source
+     * with the given blendColor and alpha. If alpha == 0, the function
+     * simply makes a plain copy of the source without any blending.
+     */
+    static HBITMAP BlendCopy(HBITMAP hSrcBitmap, COLORREF blendColor, BYTE alpha);
+
+    /**
+     * Creates a 32 bit ARGB bitmap. Returns the bitmap handle.
+     * The pointer to the bitmap data is stored into bitmapBitsPtr.
+     */
+    static HBITMAP CreateARGBBitmap(int width, int height, void ** bitmapBitsPtr);
 };
 
 #endif
diff -r 6cf33f955d7d src/windows/native/sun/windows/awt_Component.cpp
--- openjdk/jdk/src/windows/native/sun/windows/awt_Component.cpp	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_Component.cpp	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -221,9 +221,6 @@
 BOOL AwtComponent::sm_rtlReadingOrder =
     PRIMARYLANGID(GetInputLanguage()) == LANG_ARABIC;
 
-UINT AwtComponent::sm_95WheelMessage = WM_NULL;
-UINT AwtComponent::sm_95WheelSupport = WM_NULL;
-
 HWND AwtComponent::sm_cursorOn;
 BOOL AwtComponent::m_QueryNewPaletteCalled = FALSE;
 
@@ -4700,6 +4697,25 @@
     return hdc;
 }
 
+void AwtComponent::FillBackground(HDC hMemoryDC, SIZE &size)
+{
+    RECT eraseR = { 0, 0, size.cx, size.cy };
+    VERIFY(::FillRect(hMemoryDC, &eraseR, GetBackgroundBrush()));
+}
+
+void AwtComponent::FillAlpha(void *bitmapBits, SIZE &size, BYTE alpha)
+{
+    if (bitmapBits) {
+        DWORD* dest = (DWORD*)bitmapBits;
+        //XXX: might be optimized to use one loop (cy*cx -> 0).
+        for (int i = 0; i < size.cy; i++ ) {
+            for (int j = 0; j < size.cx; j++ ) {
+                ((BYTE*)(dest++))[3] = alpha;
+            }
+        }
+    }
+}
+
 jintArray AwtComponent::CreatePrintedPixels(SIZE &loc, SIZE &size) {
     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
 
@@ -6276,15 +6292,12 @@
 
     AwtComponent *c = NULL;
 
-
-
     PDATA pData;
     JNI_CHECK_PEER_GOTO(self, ret);
+
     c = (AwtComponent *)pData;
-    if (::IsWindow(c->GetHWnd()))
-    {
+    if (::IsWindow(c->GetHWnd())) {
         HRGN hRgn = NULL;
-
         if (region || x1 || x2 || y1 || y2) {
             // If all the params are zeros, the shape must be simply reset.
             // Otherwise, convert it into a region.
diff -r 6cf33f955d7d src/windows/native/sun/windows/awt_Component.h
--- openjdk/jdk/src/windows/native/sun/windows/awt_Component.h	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_Component.h	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -422,9 +422,6 @@
     /* Functions for MouseWheel support on Windows95
      * These should only be called if running on 95
      */
-    static void Wheel95Init();
-    INLINE static UINT Wheel95GetMsg() {return sm_95WheelMessage;}
-    static UINT Wheel95GetScrLines();
 
     /* Determines whether the component is obscured by another window */
     // Called on Toolkit thread
@@ -714,9 +711,9 @@
     virtual void SetDragCapture(UINT flags);
     virtual void ReleaseDragCapture(UINT flags);
 
-    // 95 support for mouse wheel
-    static UINT sm_95WheelMessage;
-    static UINT sm_95WheelSupport;
+    //These functions are overridden in AwtWindow to handle non-opaque windows.
+    virtual void FillBackground(HDC hMemoryDC, SIZE &size);
+    virtual void FillAlpha(void *bitmapBits, SIZE &size, BYTE alpha);
 
 private:
     BOOL m_bSubclassed;
diff -r 6cf33f955d7d src/windows/native/sun/windows/awt_Window.cpp
--- openjdk/jdk/src/windows/native/sun/windows/awt_Window.cpp	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_Window.cpp	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,8 @@
 
 #include <windowsx.h>
 
+#include <jlong.h>
+
 #include "awt_Component.h"
 #include "awt_Container.h"
 #include "awt_Frame.h"
@@ -87,7 +89,6 @@
     jint x, y;
     jint w, h;
 };
-
 // struct for _SetIconImagesData
 struct SetIconImagesDataStruct {
     jobject window;
@@ -96,7 +97,6 @@
     jintArray smallIconRaster;
     jint smw, smh;
 };
-
 // struct for _SetMinSize() method
 // and other methods setting sizes
 struct SizeStruct {
@@ -113,6 +113,24 @@
     jobject window;
     jlong blockerHWnd;
 };
+// struct for _SetOpacity() method
+struct OpacityStruct {
+    jobject window;
+    jint iOpacity;
+};
+// struct for _SetOpaque() method
+struct OpaqueStruct {
+    jobject window;
+    jboolean isOpaque;
+};
+// struct for _UpdateWindow() method
+struct UpdateWindowStruct {
+    jobject window;
+    jintArray data;
+    HBITMAP hBitmap;
+    jint width, height;
+};
+
 /************************************************************************
  * AwtWindow fields
  */
@@ -164,6 +182,11 @@
             ::SetWindowsHookEx(WH_CBT, (HOOKPROC)AwtWindow::CBTFilter,
                                0, AwtToolkit::MainThread());
     }
+
+    m_opaque = TRUE;
+    m_opacity = 0xff;
+
+    ::InitializeCriticalSection(&contentBitmapCS);
 }
 
 AwtWindow::~AwtWindow()
@@ -1870,6 +1893,216 @@
     //Does nothing for windows, is overriden for frames and dialogs
 }
 
+void AwtWindow::RedrawWindow()
+{
+    if (isOpaque()) {
+        ::RedrawWindow(GetHWnd(), NULL, NULL,
+                RDW_ERASE | RDW_INVALIDATE | RDW_FRAME | RDW_ALLCHILDREN);
+    } else {
+        ::EnterCriticalSection(&contentBitmapCS);
+        if (hContentBitmap != NULL) {
+            UpdateWindowImpl(contentWidth, contentHeight, hContentBitmap);
+        }
+        ::LeaveCriticalSection(&contentBitmapCS);
+    }
+}
+
+void AwtWindow::SetTranslucency(BYTE opacity, BOOL opaque)
+{
+    BYTE old_opacity = getOpacity();
+    BOOL old_opaque = isOpaque();
+
+    if (opacity == old_opacity && opaque == old_opaque) {
+        return;
+    }
+
+    setOpacity(opacity);
+    setOpaque(opaque);
+
+    HWND hwnd = GetHWnd();
+
+    LONG ex_style = ::GetWindowLong(hwnd, GWL_EXSTYLE);
+
+    if (opaque != old_opaque) {
+        ::EnterCriticalSection(&contentBitmapCS);
+        if (hContentBitmap != NULL) {
+            ::DeleteObject(hContentBitmap);
+            hContentBitmap = NULL;
+        }
+        ::LeaveCriticalSection(&contentBitmapCS);
+    }
+
+    if (opaque && opacity == 0xff) {
+        // Turn off all the effects
+        ::SetWindowLong(hwnd, GWL_EXSTYLE, ex_style & ~WS_EX_LAYERED);
+        // Ask the window to repaint itself and all the children
+        RedrawWindow();
+    } else {
+        // We're going to enable some effects
+        if (!(ex_style & WS_EX_LAYERED)) {
+            ::SetWindowLong(hwnd, GWL_EXSTYLE, ex_style | WS_EX_LAYERED);
+        } else {
+            if ((opaque && opacity < 0xff) ^ (old_opaque && old_opacity < 0xff)) {
+                // _One_ of the modes uses the SetLayeredWindowAttributes.
+                // Need to reset the style in this case.
+                // If both modes are simple (i.e. just changing the opacity level),
+                // no need to reset the style.
+                ::SetWindowLong(hwnd, GWL_EXSTYLE, ex_style & ~WS_EX_LAYERED);
+                ::SetWindowLong(hwnd, GWL_EXSTYLE, ex_style | WS_EX_LAYERED);
+            }
+        }
+
+        if (opaque) {
+            // Simple opacity mode
+            ::SetLayeredWindowAttributes(hwnd, RGB(0, 0, 0), opacity, LWA_ALPHA);
+        }
+    }
+}
+
+static HBITMAP CreateBitmapFromRaster(JNIEnv* env, jintArray raster, jint w, jint h)
+{
+    HBITMAP image = NULL;
+    if (raster != NULL) {
+        int* rasterBuffer = NULL;
+        try {
+            rasterBuffer = (int *)env->GetPrimitiveArrayCritical(raster, 0);
+            JNI_CHECK_NULL_GOTO(rasterBuffer, "raster data", done);
+            image = BitmapUtil::CreateBitmapFromARGBPre(w, h, w*4, rasterBuffer);
+        } catch (...) {
+            if (rasterBuffer != NULL) {
+                env->ReleasePrimitiveArrayCritical(raster, rasterBuffer, 0);
+            }
+            throw;
+        }
+        if (rasterBuffer != NULL) {
+            env->ReleasePrimitiveArrayCritical(raster, rasterBuffer, 0);
+        }
+    }
+done:
+    return image;
+}
+
+void AwtWindow::UpdateWindowImpl(int width, int height, HBITMAP hBitmap)
+{
+    if (isOpaque()) {
+        return;
+    }
+
+    HWND hWnd = GetHWnd();
+    HDC hdcDst = ::GetDC(NULL);
+    HDC hdcSrc = ::CreateCompatibleDC(NULL);
+    HBITMAP hOldBitmap = (HBITMAP)::SelectObject(hdcSrc, hBitmap);
+
+    //XXX: this code doesn't paint the children (say, the java.awt.Button)!
+    //So, if we ever want to support HWs here, we need to repaint them
+    //in some other way...
+    //::SendMessage(hWnd, WM_PRINT, (WPARAM)hdcSrc, /*PRF_CHECKVISIBLE |*/
+    //      PRF_CHILDREN /*| PRF_CLIENT | PRF_NONCLIENT*/);
+
+    POINT ptSrc;
+    ptSrc.x = ptSrc.y = 0;
+
+    RECT rect;
+    POINT ptDst;
+    SIZE size;
+
+    ::GetWindowRect(hWnd, &rect);
+    ptDst.x = rect.left;
+    ptDst.y = rect.top;
+    size.cx = width;
+    size.cy = height;
+
+    BLENDFUNCTION bf;
+
+    bf.SourceConstantAlpha = getOpacity();
+    bf.AlphaFormat = AC_SRC_ALPHA;
+    bf.BlendOp = AC_SRC_OVER;
+    bf.BlendFlags = 0;
+
+    ::UpdateLayeredWindow(hWnd, hdcDst, &ptDst, &size, hdcSrc, &ptSrc,
+            RGB(0, 0, 0), &bf, ULW_ALPHA);
+
+    ::ReleaseDC(NULL, hdcDst);
+    ::SelectObject(hdcSrc, hOldBitmap);
+    ::DeleteDC(hdcSrc);
+}
+
+void AwtWindow::UpdateWindow(JNIEnv* env, jintArray data, int width, int height,
+                             HBITMAP hNewBitmap)
+{
+    if (isOpaque()) {
+        return;
+    }
+
+    HBITMAP hBitmap;
+    if (hNewBitmap == NULL) {
+        if (data == NULL) {
+            return;
+        }
+        hBitmap = CreateBitmapFromRaster(env, data, width, height);
+        if (hBitmap == NULL) {
+            return;
+        }
+    } else {
+        hBitmap = hNewBitmap;
+    }
+
+    ::EnterCriticalSection(&contentBitmapCS);
+    if (hContentBitmap != NULL) {
+        ::DeleteObject(hContentBitmap);
+    }
+    hContentBitmap = hBitmap;
+    contentWidth = width;
+    contentHeight = height;
+    UpdateWindowImpl(width, height, hBitmap);
+    ::LeaveCriticalSection(&contentBitmapCS);
+}
+
+void AwtWindow::FillBackground(HDC hMemoryDC, SIZE &size)
+{
+    if (isOpaque()) {
+        AwtCanvas::FillBackground(hMemoryDC, size);
+    }
+}
+
+void AwtWindow::FillAlpha(void *bitmapBits, SIZE &size, BYTE alpha)
+{
+    if (isOpaque()) {
+        AwtCanvas::FillAlpha(bitmapBits, size, alpha);
+    }
+}
+
+/*
+ * Fixed 6353381: it's improved fix for 4792958
+ * which was backed-out to avoid 5059656
+ */
+BOOL AwtWindow::HasValidRect()
+{
+    RECT inside;
+    RECT outside;
+
+    if (::IsIconic(GetHWnd())) {
+        return FALSE;
+    }
+
+    ::GetClientRect(GetHWnd(), &inside);
+    ::GetWindowRect(GetHWnd(), &outside);
+
+    BOOL isZeroClientArea = (inside.right == 0 && inside.bottom == 0);
+    BOOL isInvalidLocation = ((outside.left == -32000 && outside.top == -32000) || // Win2k && WinXP
+                              (outside.left == 32000 && outside.top == 32000) || // Win95 && Win98
+                              (outside.left == 3000 && outside.top == 3000)); // Win95 && Win98
+
+    // the bounds correspond to iconic state
+    if (isZeroClientArea && isInvalidLocation)
+    {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+
 void AwtWindow::_SetIconImagesData(void * param)
 {
     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
@@ -2042,36 +2275,68 @@
     env->DeleteGlobalRef(self);
 }
 
-/*
- * Fixed 6353381: it's improved fix for 4792958
- * which was backed-out to avoid 5059656
- */
-BOOL AwtWindow::HasValidRect()
+void AwtWindow::_SetOpacity(void* param)
 {
-    RECT inside;
-    RECT outside;
-
-    if (::IsIconic(GetHWnd())) {
-        return FALSE;
+    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
+
+    OpacityStruct *os = (OpacityStruct *)param;
+    jobject self = os->window;
+    BYTE iOpacity = (BYTE)os->iOpacity;
+
+    PDATA pData;
+    JNI_CHECK_PEER_GOTO(self, ret);
+    AwtWindow *window = (AwtWindow *)pData;
+
+    window->SetTranslucency(iOpacity, window->isOpaque());
+
+  ret:
+    env->DeleteGlobalRef(self);
+    delete os;
+}
+
+void AwtWindow::_SetOpaque(void* param)
+{
+    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
+
+    OpaqueStruct *os = (OpaqueStruct *)param;
+    jobject self = os->window;
+    BOOL isOpaque = (BOOL)os->isOpaque;
+
+    PDATA pData;
+    JNI_CHECK_PEER_GOTO(self, ret);
+    AwtWindow *window = (AwtWindow *)pData;
+
+    window->SetTranslucency(window->getOpacity(), isOpaque);
+
+  ret:
+    env->DeleteGlobalRef(self);
+    delete os;
+}
+
+void AwtWindow::_UpdateWindow(void* param)
+{
+    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
+
+    UpdateWindowStruct *uws = (UpdateWindowStruct *)param;
+    jobject self = uws->window;
+    jintArray data = uws->data;
+
+    PDATA pData;
+    JNI_CHECK_PEER_GOTO(self, ret);
+    AwtWindow *window = (AwtWindow *)pData;
+
+    window->UpdateWindow(env, data, (int)uws->width, (int)uws->height,
+                         uws->hBitmap);
+
+  ret:
+    env->DeleteGlobalRef(self);
+    if (data != NULL) {
+        env->DeleteGlobalRef(data);
     }
-
-    ::GetClientRect(GetHWnd(), &inside);
-    ::GetWindowRect(GetHWnd(), &outside);
-
-    BOOL isZeroClientArea = (inside.right == 0 && inside.bottom == 0);
-    BOOL isInvalidLocation = ((outside.left == -32000 && outside.top == -32000) || // Win2k && WinXP
-                              (outside.left == 32000 && outside.top == 32000) || // Win95 && Win98
-                              (outside.left == 3000 && outside.top == 3000)); // Win95 && Win98
-
-    // the bounds correspond to iconic state
-    if (isZeroClientArea && isInvalidLocation)
-    {
-        return FALSE;
-    }
-
-    return TRUE;
+    delete uws;
 }
 
+
 extern "C" {
 
 /*
@@ -2527,4 +2792,93 @@
     CATCH_BAD_ALLOC;
 }
 
+/*
+ * Class:     sun_awt_windows_WWindowPeer
+ * Method:    setOpacity
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL
+Java_sun_awt_windows_WWindowPeer_setOpacity(JNIEnv *env, jobject self,
+                                              jint iOpacity)
+{
+    TRY;
+
+    OpacityStruct *os = new OpacityStruct;
+    os->window = env->NewGlobalRef(self);
+    os->iOpacity = iOpacity;
+
+    AwtToolkit::GetInstance().SyncCall(AwtWindow::_SetOpacity, os);
+    // global refs and mds are deleted in _SetMinSize
+
+    CATCH_BAD_ALLOC;
+}
+
+/*
+ * Class:     sun_awt_windows_WWindowPeer
+ * Method:    setOpaqueImpl
+ * Signature: (Z)V
+ */
+JNIEXPORT void JNICALL
+Java_sun_awt_windows_WWindowPeer_setOpaqueImpl(JNIEnv *env, jobject self,
+                                              jboolean isOpaque)
+{
+    TRY;
+
+    OpaqueStruct *os = new OpaqueStruct;
+    os->window = env->NewGlobalRef(self);
+    os->isOpaque = isOpaque;
+
+    AwtToolkit::GetInstance().SyncCall(AwtWindow::_SetOpaque, os);
+    // global refs and mds are deleted in _SetMinSize
+
+    CATCH_BAD_ALLOC;
+}
+
+/*
+ * Class:     sun_awt_windows_WWindowPeer
+ * Method:    updateWindowImpl
+ * Signature: ([III)V
+ */
+JNIEXPORT void JNICALL
+Java_sun_awt_windows_WWindowPeer_updateWindowImpl(JNIEnv *env, jobject self,
+                                                  jintArray data,
+                                                  jint width, jint height)
+{
+    TRY;
+
+    UpdateWindowStruct *uws = new UpdateWindowStruct;
+    uws->window = env->NewGlobalRef(self);
+    uws->data = (jintArray)env->NewGlobalRef(data);
+    uws->hBitmap = NULL;
+    uws->width = width;
+    uws->height = height;
+
+    AwtToolkit::GetInstance().InvokeFunction(AwtWindow::_UpdateWindow, uws);
+    // global refs and mds are deleted in _UpdateWindow
+
+    CATCH_BAD_ALLOC;
+}
+
+/**
+ * This method is called from the WGL pipeline when it needs to update
+ * the layered window WindowPeer's C++ level object.
+ */
+void AwtWindow_UpdateWindow(JNIEnv *env, jobject peer,
+                            jint width, jint height, HBITMAP hBitmap)
+{
+    TRY;
+
+    UpdateWindowStruct *uws = new UpdateWindowStruct;
+    uws->window = env->NewGlobalRef(peer);
+    uws->data = NULL;
+    uws->hBitmap = hBitmap;
+    uws->width = width;
+    uws->height = height;
+
+    AwtToolkit::GetInstance().InvokeFunction(AwtWindow::_UpdateWindow, uws);
+    // global refs and mds are deleted in _UpdateWindow
+
+    CATCH_BAD_ALLOC;
+}
+
 } /* extern "C" */
diff -r 6cf33f955d7d src/windows/native/sun/windows/awt_Window.h
--- openjdk/jdk/src/windows/native/sun/windows/awt_Window.h	Fri Feb 04 16:32:49 2011 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_Window.h	Tue Feb 15 15:12:57 2011 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -188,6 +188,9 @@
 
     void moveToDefaultLocation(); /* moves Window to X,Y specified by Window Manger */
 
+    void UpdateWindow(JNIEnv* env, jintArray data, int width, int height,
+                      HBITMAP hNewBitmap = NULL);
+
     INLINE virtual BOOL IsTopLevel() { return TRUE; }
     static AwtWindow * GetGrabbedWindow() { return m_grabbedWindow; }
 
@@ -210,6 +213,9 @@
     static void _SetModalExcludedNativeProp(void *param);
     static void _ModalDisable(void *param);
     static void _ModalEnable(void *param);
+    static void _SetOpacity(void* param);
+    static void _SetOpaque(void* param);
+    static void _UpdateWindow(void* param);
 
     inline static BOOL IsResizing() {
         return sm_resizing;
@@ -234,6 +240,32 @@
                                        // from its hierarchy when shown. Currently applied to instances of
                                        // javax/swing/Popup$HeavyWeightWindow class.
 
+    BYTE m_opacity;         // The opacity level. == 0xff by default (when opacity mode is disabled)
+    BOOL m_opaque;          // Whether the window uses the perpixel translucency (false), or not (true).
+
+    inline BYTE getOpacity() {
+        return m_opacity;
+    }
+    inline void setOpacity(BYTE opacity) {
+        m_opacity = opacity;
+    }
+
+    inline BOOL isOpaque() {
+        return m_opaque;
+    }
+    inline void setOpaque(BOOL opaque) {
+        m_opaque = opaque;
+    }
+
+    CRITICAL_SECTION contentBitmapCS;
+    HBITMAP hContentBitmap;
+    UINT contentWidth;
+    UINT contentHeight;
+
+    void RedrawWindow();
+    void SetTranslucency(BYTE opacity, BOOL opaque);
+    void UpdateWindowImpl(int width, int height, HBITMAP hBitmap);
+
 protected:
     BOOL m_isResizable;
     static AwtWindow* m_grabbedWindow; // Current grabbing window
@@ -242,6 +274,10 @@
     BOOL m_iconInherited;     /* TRUE if icon is inherited from the owner */
     BOOL m_filterFocusAndActivation; /* Used in the WH_CBT hook */
 
+    //These are used in AwtComponent::CreatePrintedPixels. They are overridden
+    //here to handle non-opaque windows.
+    virtual void FillBackground(HDC hMemoryDC, SIZE &size);
+    virtual void FillAlpha(void *bitmapBits, SIZE &size, BYTE alpha);
 
 private:
     int m_screenNum;
diff -r 6cf33f955d7d test/com/sun/awt/Translucency/TranslucentJAppletTest/TranslucentJAppletTest.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ openjdk/jdk/test/com/sun/awt/Translucency/TranslucentJAppletTest/TranslucentJAppletTest.java	Tue Feb 15 15:12:57 2011 +0000
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2008, 2009, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test %I% %E%
+ * @bug 6683728
+ * @summary Tests that a JApplet in a translucent JFrame works properly
+ * @author Kenneth.Russell@sun.com: area=Graphics
+ * @compile -XDignore.symbol.file=true TranslucentJAppletTest.java
+ * @run main/manual/othervm TranslucentJAppletTest
+ */
+
+import java.awt.*;
+import java.awt.image.*;
+
+import javax.swing.*;
+
+public class TranslucentJAppletTest {
+
+    private static JFrame frame;
+    private static volatile boolean paintComponentCalled = false;
+
+    private static void initAndShowGUI() {
+        frame = new JFrame();
+        JApplet applet = new JApplet();
+        JPanel panel = new JPanel() {
+            protected void paintComponent(Graphics g) {
+                paintComponentCalled = true;
+                g.setColor(Color.RED);
+                g.fillOval(0, 0, getWidth(), getHeight());
+            }
+        };
+        panel.setDoubleBuffered(false);
+        panel.setOpaque(false);
+        applet.add(panel);
+        frame.add(applet);
+        frame.setBounds(100, 100, 200, 200);
+        frame.setUndecorated(true);
+        com.sun.awt.AWTUtilities.setWindowOpaque(frame, false);
+        frame.setVisible(true);
+    }
+
+    public static void main(String[] args)
+        throws Exception
+    {
+        sun.awt.SunToolkit tk = (sun.awt.SunToolkit)Toolkit.getDefaultToolkit();
+
+        Robot r = new Robot();
+        Color color1 = r.getPixelColor(100, 100); // (0, 0) in frame coordinates
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                initAndShowGUI();
+            }
+        });
+        tk.realSync();
+
+        if (!paintComponentCalled) {
+            throw new RuntimeException("Test FAILED: panel's paintComponent() method is not called");
+        }
+
+        Color newColor1 = r.getPixelColor(100, 100);
+        // unfortunately, robot.getPixelColor() doesn't work for some unknown reason
+        // Color newColor2 = r.getPixelColor(200, 200);
+        BufferedImage bim = r.createScreenCapture(new Rectangle(200, 200, 1, 1));
+        Color newColor2 = new Color(bim.getRGB(0, 0));
+
+        // Frame must be transparent at (100, 100) in screen coords
+        if (!color1.equals(newColor1)) {
+            System.err.println("color1 = " + color1);
+            System.err.println("newColor1 = " + newColor1);
+            throw new RuntimeException("Test FAILED: frame pixel at (0, 0) is not transparent");
+        }
+
+        // Frame must be RED at (200, 200) in screen coords
+        if (!newColor2.equals(Color.RED)) {
+            System.err.println("newColor2 = " + newColor2);
+            throw new RuntimeException("Test FAILED: frame pixel at (100, 100) is not red (transparent?)");
+        }
+
+        System.out.println("Test PASSED");
+    }
+}
diff -r 6cf33f955d7d test/com/sun/awt/Translucency/TranslucentShapedFrameTest/TSFrame.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ openjdk/jdk/test/com/sun/awt/Translucency/TranslucentShapedFrameTest/TSFrame.java	Tue Feb 15 15:12:57 2011 +0000
@@ -0,0 +1,306 @@
+/*
+ * Copyright (c) 2008, 2009, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import com.sun.awt.AWTUtilities;
+import static com.sun.awt.AWTUtilities.Translucency.*;
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsEnvironment;
+import java.awt.RenderingHints;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.awt.Canvas;
+import java.awt.Component;
+import java.awt.GradientPaint;
+import java.awt.Graphics2D;
+import java.awt.Paint;
+import java.util.Random;
+import java.awt.geom.Ellipse2D;
+import javax.swing.JApplet;
+import javax.swing.JButton;
+import javax.swing.JComponent;
+import javax.swing.JFrame;
+import javax.swing.JPanel;
+import javax.swing.SwingUtilities;
+
+public class TSFrame {
+
+    static volatile boolean done = false;
+
+    static final boolean useSwing = System.getProperty("useswing") != null;
+    static final boolean useShape = System.getProperty("useshape") != null;
+    static final boolean useTransl = System.getProperty("usetransl") != null;
+    static final boolean useNonOpaque = System.getProperty("usenonop") != null;
+
+    static final Random rnd = new Random();
+    private static void render(Graphics g, int w, int h, boolean useNonOpaque) {
+        if (useNonOpaque) {
+            Graphics2D g2d = (Graphics2D)g;
+            GradientPaint p =
+                new GradientPaint(0.0f, 0.0f,
+                                  new Color(rnd.nextInt(0xffffff)),
+                                  w, h,
+                                  new Color(rnd.nextInt(0xff),
+                                            rnd.nextInt(0xff),
+                                            rnd.nextInt(0xff), 0),
+                                  true);
+            g2d.setPaint(p);
+            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
+                                 RenderingHints.VALUE_ANTIALIAS_ON);
+            g2d.fillOval(0, 0, w, h);
+        } else {
+            g.setColor(new Color(rnd.nextInt(0xffffff)));
+            g.fillRect(0, 0, w, h);
+        }
+    }
+
+    private static class MyCanvas extends Canvas {
+        @Override
+        public void paint(Graphics g) {
+            render(g, getWidth(), getHeight(), false);
+        }
+        @Override
+        public Dimension getPreferredSize() {
+            return new Dimension(200, 100);
+        }
+    }
+    private static class NonOpaqueJFrame extends JFrame {
+        NonOpaqueJFrame(GraphicsConfiguration gc) {
+            super("NonOpaque Swing JFrame", gc);
+            JPanel p = new JPanel() {
+                public void paintComponent(Graphics g) {
+                    super.paintComponent(g);
+                    render(g, getWidth(), getHeight(), true);
+                    g.setColor(Color.red);
+                    g.drawString("Non-Opaque Swing JFrame", 10, 15);
+                }
+            };
+            p.setDoubleBuffered(false);
+            p.setOpaque(false);
+            add(p);
+            setUndecorated(true);
+        }
+    }
+    private static class NonOpaqueJAppletFrame extends JFrame {
+        JPanel p;
+        NonOpaqueJAppletFrame(GraphicsConfiguration gc) {
+            super("NonOpaque Swing JAppletFrame", gc);
+            JApplet ja = new JApplet() {
+                public void paint(Graphics g) {
+                    super.paint(g);
+                    System.err.println("JAppletFrame paint called");
+                }
+            };
+            p = new JPanel() {
+                public void paintComponent(Graphics g) {
+                    super.paintComponent(g);
+                    render(g, getWidth(), getHeight(), true);
+                    g.setColor(Color.red);
+                    g.drawString("Non-Opaque Swing JFrame", 10, 15);
+                }
+            };
+            p.setDoubleBuffered(false);
+            p.setOpaque(false);
+            ja.add(p);
+            add(ja);
+            setUndecorated(true);
+        }
+    }
+    private static class NonOpaqueFrame extends Frame {
+        NonOpaqueFrame(GraphicsConfiguration gc) {
+            super("NonOpaque AWT Frame", gc);
+            // uncomment to test with hw child
+//            setLayout(null);
+//            Component c = new Panel() {
+//                public void paint(Graphics g) {
+//                    g.setColor(new Color(1.0f, 1.0f, 1.0f, 0.5f));
+//                    g.fillRect(0, 0, getWidth(), getHeight());
+//                }
+//            };
+//            c.setSize(100, 100);
+//            c.setBackground(Color.red);
+//            c.setForeground(Color.red);
+//            add(c);
+//            c.setLocation(130, 130);
+        }
+        @Override
+        public void paint(Graphics g) {
+            render(g, getWidth(), getHeight(), true);
+            g.setColor(Color.red);
+            g.drawString("Non-Opaque AWT Frame", 10, 15);
+        }
+    }
+
+    private static class MyJPanel extends JPanel {
+        @Override
+        public void paintComponent(Graphics g) {
+            render(g, getWidth(), getHeight(), false);
+        }
+    }
+
+    public static Frame createGui(GraphicsConfiguration gc,
+                                  final boolean useSwing,
+                                  final boolean useShape,
+                                  final boolean useTransl,
+                                  final boolean useNonOpaque,
+                                  final float factor)
+    {
+        Frame frame;
+        done = false;
+
+        if (gc == null) {
+            gc = GraphicsEnvironment.getLocalGraphicsEnvironment().
+                    getDefaultScreenDevice().getDefaultConfiguration();
+        }
+
+        if (useNonOpaque) {
+            if (useSwing) {
+                frame = new NonOpaqueJFrame(gc);
+//                frame = new NonOpaqueJAppletFrame(gc);
+            } else {
+                frame = new NonOpaqueFrame(gc);
+            }
+            animateComponent(frame);
+        } else if (useSwing) {
+            frame = new JFrame("Swing Frame", gc);
+            JComponent p = new JButton("Swing!");
+            p.setPreferredSize(new Dimension(200, 100));
+            frame.add("North", p);
+            p = new MyJPanel();
+            animateComponent(p);
+            frame.add("Center", p);
+        } else {
+            frame = new Frame("AWT Frame", gc) {
+                public void paint(Graphics g) {
+                    g.setColor(Color.red);
+                    g.fillRect(0, 0, 100, 100);
+                }
+            };
+            frame.setLayout(new BorderLayout());
+            Canvas c = new MyCanvas();
+            frame.add("North", c);
+            animateComponent(c);
+            c = new MyCanvas();
+            frame.add("Center", c);
+            animateComponent(c);
+            c = new MyCanvas();
+            frame.add("South", c);
+            animateComponent(c);
+        }
+        final Frame finalFrame = frame;
+        frame.addWindowListener(new WindowAdapter() {
+            @Override
+            public void windowClosing(WindowEvent e) {
+                finalFrame.dispose();
+                done = true;
+            }
+        });
+        frame.addMouseListener(new MouseAdapter() {
+            @Override
+            public void mouseClicked(MouseEvent e) {
+                finalFrame.dispose();
+                done = true;
+            }
+        });
+        frame.setPreferredSize(new Dimension(800, 600));
+
+        if (useShape) {
+            frame.setUndecorated(true);
+        }
+
+        frame.setLocation(450, 10);
+        frame.pack();
+
+        if (useShape) {
+            if (AWTUtilities.isTranslucencySupported(PERPIXEL_TRANSPARENT)) {
+                System.out.println("applying PERPIXEL_TRANSPARENT");
+                AWTUtilities.setWindowShape(frame,
+                    new Ellipse2D.Double(0, 0, frame.getWidth(),
+                                               frame.getHeight()/3));
+                frame.setTitle("PERPIXEL_TRANSPARENT");
+            } else {
+                System.out.println("Passed: PERPIXEL_TRANSPARENT unsupported");
+            }
+        }
+        if (useTransl) {
+            if (AWTUtilities.isTranslucencySupported(TRANSLUCENT)) {
+                System.out.println("applying TRANSLUCENT");
+                AWTUtilities.setWindowOpacity(frame, factor);
+                frame.setTitle("TRANSLUCENT");
+            } else {
+                System.out.println("Passed: TRANSLUCENT unsupported");
+            }
+        }
+        if (useNonOpaque) {
+            if (AWTUtilities.isTranslucencySupported(PERPIXEL_TRANSLUCENT) &&
+                AWTUtilities.isTranslucencyCapable(gc))
+            {
+                System.out.println("applying PERPIXEL_TRANSLUCENT");
+                AWTUtilities.setWindowOpaque(frame, false);
+                frame.setTitle("PERPIXEL_TRANSLUCENT");
+            } else {
+                System.out.println("Passed: PERPIXEL_TRANSLUCENT unsupported");
+            }
+        }
+        frame.setVisible(true);
+        return frame;
+    }
+
+    public static void stopThreads() {
+        done = true;
+    }
+
+    private static void animateComponent(final Component comp) {
+        Thread t = new Thread(new Runnable() {
+            public void run() {
+                do {
+                    try {
+                        Thread.sleep(50);
+                    } catch (InterruptedException ex) {}
+                    comp.repaint();
+                } while (!done);
+            }
+        });
+        t.start();
+    }
+
+    public static void main(String[] args) throws Exception {
+        SwingUtilities.invokeLater(new Runnable() {
+            public void run() {
+                TSFrame.createGui(null, useSwing,
+                                  useShape,
+                                  useTransl,
+                                  useNonOpaque,
+                                  0.7f);
+            }
+        });
+    }
+}
diff -r 6cf33f955d7d test/com/sun/awt/Translucency/TranslucentShapedFrameTest/TranslucentShapedFrameTest.form
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ openjdk/jdk/test/com/sun/awt/Translucency/TranslucentShapedFrameTest/TranslucentShapedFrameTest.form	Tue Feb 15 15:12:57 2011 +0000
@@ -0,0 +1,230 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<Form version="1.3" type="org.netbeans.modules.form.forminfo.JFrameFormInfo">
+  <NonVisualComponents>
+    <Component class="javax.swing.ButtonGroup" name="createDisposeGrp">
+    </Component>
+  </NonVisualComponents>
+  <Properties>
+    <Property name="defaultCloseOperation" type="int" value="3"/>
+    <Property name="title" type="java.lang.String" value="TranslucentShapedFrameTest"/>
+  </Properties>
+  <SyntheticProperties>
+    <SyntheticProperty name="formSizePolicy" type="int" value="1"/>
+  </SyntheticProperties>
+  <AuxValues>
+    <AuxValue name="FormSettings_generateMnemonicsCode" type="java.lang.Boolean" value="false"/>
+    <AuxValue name="FormSettings_i18nAutoMode" type="java.lang.Boolean" value="false"/>
+    <AuxValue name="FormSettings_layoutCodeTarget" type="java.lang.Integer" value="1"/>
+    <AuxValue name="FormSettings_listenerGenerationStyle" type="java.lang.Integer" value="0"/>
+    <AuxValue name="FormSettings_variablesLocal" type="java.lang.Boolean" value="false"/>
+    <AuxValue name="FormSettings_variablesModifier" type="java.lang.Integer" value="2"/>
+  </AuxValues>
+
+  <Layout>
+    <DimensionLayout dim="0">
+      <Group type="103" groupAlignment="0" attributes="0">
+          <Group type="102" attributes="0">
+              <EmptySpace max="-2" attributes="0"/>
+              <Group type="103" groupAlignment="0" attributes="0">
+                  <Group type="102" alignment="0" attributes="0">
+                      <Component id="transparencySld" pref="375" max="32767" attributes="0"/>
+                      <EmptySpace max="-2" attributes="0"/>
+                  </Group>
+                  <Component id="jLabel1" alignment="0" min="-2" max="-2" attributes="0"/>
+                  <Group type="102" alignment="0" attributes="0">
+                      <Component id="shapedCb" min="-2" max="-2" attributes="0"/>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Component id="nonOpaqueChb" min="-2" max="-2" attributes="0"/>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Component id="useSwingCb" min="-2" max="-2" attributes="0"/>
+                      <EmptySpace pref="102" max="32767" attributes="0"/>
+                  </Group>
+                  <Group type="102" alignment="0" attributes="0">
+                      <Group type="103" groupAlignment="0" attributes="0">
+                          <Group type="102" alignment="0" attributes="0">
+                              <Component id="jLabel2" min="-2" max="-2" attributes="0"/>
+                              <EmptySpace pref="314" max="-2" attributes="0"/>
+                          </Group>
+                          <Group type="102" alignment="0" attributes="0">
+                              <Component id="passedBtn" min="-2" max="-2" attributes="0"/>
+                              <EmptySpace max="-2" attributes="0"/>
+                              <Component id="failedBtn" min="-2" max="-2" attributes="0"/>
+                              <EmptySpace pref="241" max="-2" attributes="0"/>
+                          </Group>
+                          <Component id="jScrollPane1" alignment="1" pref="375" max="32767" attributes="0"/>
+                          <Group type="102" alignment="0" attributes="0">
+                              <Component id="createFrameBtn" min="-2" pref="187" max="-2" attributes="0"/>
+                              <EmptySpace max="-2" attributes="0"/>
+                              <Component id="disposeFrameBtn" min="-2" pref="182" max="-2" attributes="0"/>
+                          </Group>
+                      </Group>
+                      <EmptySpace max="-2" attributes="0"/>
+                  </Group>
+              </Group>
+          </Group>
+      </Group>
+    </DimensionLayout>
+    <DimensionLayout dim="1">
+      <Group type="103" groupAlignment="0" attributes="0">
+          <Group type="102" alignment="0" attributes="0">
+              <EmptySpace max="-2" attributes="0"/>
+              <Component id="jLabel1" min="-2" max="-2" attributes="0"/>
+              <EmptySpace max="-2" attributes="0"/>
+              <Component id="transparencySld" min="-2" max="-2" attributes="0"/>
+              <EmptySpace max="-2" attributes="0"/>
+              <Group type="103" groupAlignment="3" attributes="0">
+                  <Component id="shapedCb" alignment="3" min="-2" max="-2" attributes="0"/>
+                  <Component id="nonOpaqueChb" alignment="3" min="-2" max="-2" attributes="0"/>
+                  <Component id="useSwingCb" alignment="3" min="-2" max="-2" attributes="0"/>
+              </Group>
+              <EmptySpace max="-2" attributes="0"/>
+              <Group type="103" groupAlignment="3" attributes="0">
+                  <Component id="disposeFrameBtn" alignment="3" min="-2" max="-2" attributes="0"/>
+                  <Component id="createFrameBtn" alignment="3" min="-2" max="-2" attributes="0"/>
+              </Group>
+              <EmptySpace min="-2" pref="17" max="-2" attributes="0"/>
+              <Component id="jLabel2" min="-2" max="-2" attributes="0"/>
+              <EmptySpace max="-2" attributes="0"/>
+              <Component id="jScrollPane1" min="-2" pref="148" max="-2" attributes="0"/>
+              <EmptySpace max="-2" attributes="0"/>
+              <Group type="103" groupAlignment="3" attributes="0">
+                  <Component id="passedBtn" alignment="3" min="-2" max="-2" attributes="0"/>
+                  <Component id="failedBtn" alignment="3" min="-2" max="-2" attributes="0"/>
+              </Group>
+              <EmptySpace max="32767" attributes="0"/>
+          </Group>
+      </Group>
+    </DimensionLayout>
+  </Layout>
+  <SubComponents>
+    <Component class="javax.swing.JLabel" name="jLabel1">
+      <Properties>
+        <Property name="text" type="java.lang.String" value="Frame Opacity:"/>
+      </Properties>
+    </Component>
+    <Component class="javax.swing.JSlider" name="transparencySld">
+      <Properties>
+        <Property name="majorTickSpacing" type="int" value="10"/>
+        <Property name="minorTickSpacing" type="int" value="5"/>
+        <Property name="paintLabels" type="boolean" value="true"/>
+        <Property name="paintTicks" type="boolean" value="true"/>
+        <Property name="value" type="int" value="100"/>
+      </Properties>
+      <Events>
+        <EventHandler event="stateChanged" listener="javax.swing.event.ChangeListener" parameters="javax.swing.event.ChangeEvent" handler="transparencySldStateChanged"/>
+      </Events>
+    </Component>
+    <Component class="javax.swing.JCheckBox" name="shapedCb">
+      <Properties>
+        <Property name="text" type="java.lang.String" value="Shaped Frame"/>
+        <Property name="border" type="javax.swing.border.Border" editor="org.netbeans.modules.form.editors2.BorderEditor">
+          <Border info="org.netbeans.modules.form.compat2.border.EmptyBorderInfo">
+            <EmptyBorder bottom="0" left="0" right="0" top="0"/>
+          </Border>
+        </Property>
+        <Property name="margin" type="java.awt.Insets" editor="org.netbeans.beaninfo.editors.InsetsEditor">
+          <Insets value="[0, 0, 0, 0]"/>
+        </Property>
+      </Properties>
+      <Events>
+        <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="shapedCbActionPerformed"/>
+      </Events>
+    </Component>
+    <Component class="javax.swing.JCheckBox" name="nonOpaqueChb">
+      <Properties>
+        <Property name="text" type="java.lang.String" value="Non Opaque Frame"/>
+        <Property name="border" type="javax.swing.border.Border" editor="org.netbeans.modules.form.editors2.BorderEditor">
+          <Border info="org.netbeans.modules.form.compat2.border.EmptyBorderInfo">
+            <EmptyBorder bottom="0" left="0" right="0" top="0"/>
+          </Border>
+        </Property>
+        <Property name="margin" type="java.awt.Insets" editor="org.netbeans.beaninfo.editors.InsetsEditor">
+          <Insets value="[0, 0, 0, 0]"/>
+        </Property>
+      </Properties>
+      <Events>
+        <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="nonOpaqueChbActionPerformed"/>
+      </Events>
+    </Component>
+    <Container class="javax.swing.JScrollPane" name="jScrollPane1">
+      <AuxValues>
+        <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
+      </AuxValues>
+
+      <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
+      <SubComponents>
+        <Component class="javax.swing.JTextArea" name="jTextArea1">
+          <Properties>
+            <Property name="columns" type="int" value="20"/>
+            <Property name="rows" type="int" value="5"/>
+            <Property name="text" type="java.lang.String" value="Create translucent and/or shaped, or&#xa;non-opaque frame. Make sure it behaves&#xa;correctly (no artifacts left on the screen&#xa;when dragging - if dragging is possible).&#xa;Click &quot;Passed&quot; if the test behaves correctly,&#xa;&quot;Falied&quot; otherwise."/>
+          </Properties>
+        </Component>
+      </SubComponents>
+    </Container>
+    <Component class="javax.swing.JLabel" name="jLabel2">
+      <Properties>
+        <Property name="text" type="java.lang.String" value="Instructions:"/>
+      </Properties>
+    </Component>
+    <Component class="javax.swing.JButton" name="passedBtn">
+      <Properties>
+        <Property name="background" type="java.awt.Color" editor="org.netbeans.beaninfo.editors.ColorEditor">
+          <Color blue="64" green="ff" red="81" type="rgb"/>
+        </Property>
+        <Property name="text" type="java.lang.String" value="Passed"/>
+      </Properties>
+      <Events>
+        <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="passedBtnActionPerformed"/>
+      </Events>
+    </Component>
+    <Component class="javax.swing.JButton" name="failedBtn">
+      <Properties>
+        <Property name="background" type="java.awt.Color" editor="org.netbeans.beaninfo.editors.ColorEditor">
+          <Color blue="0" green="0" id="red" palette="1" red="ff" type="palette"/>
+        </Property>
+        <Property name="text" type="java.lang.String" value="Failed"/>
+      </Properties>
+      <Events>
+        <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="failedBtnActionPerformed"/>
+      </Events>
+    </Component>
+    <Component class="javax.swing.JToggleButton" name="createFrameBtn">
+      <Properties>
+        <Property name="buttonGroup" type="javax.swing.ButtonGroup" editor="org.netbeans.modules.form.RADComponent$ButtonGroupPropertyEditor">
+          <ComponentRef name="createDisposeGrp"/>
+        </Property>
+        <Property name="text" type="java.lang.String" value="Create Frame"/>
+      </Properties>
+      <Events>
+        <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="createFrameBtnActionPerformed"/>
+      </Events>
+    </Component>
+    <Component class="javax.swing.JToggleButton" name="disposeFrameBtn">
+      <Properties>
+        <Property name="buttonGroup" type="javax.swing.ButtonGroup" editor="org.netbeans.modules.form.RADComponent$ButtonGroupPropertyEditor">
+          <ComponentRef name="createDisposeGrp"/>
+        </Property>
+        <Property name="selected" type="boolean" value="true"/>
+        <Property name="text" type="java.lang.String" value="Dispose Frame"/>
+      </Properties>
+      <Events>
+        <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="disposeFrameBtnActionPerformed"/>
+      </Events>
+    </Component>
+    <Component class="javax.swing.JCheckBox" name="useSwingCb">
+      <Properties>
+        <Property name="text" type="java.lang.String" value="Use JFrame"/>
+        <Property name="border" type="javax.swing.border.Border" editor="org.netbeans.modules.form.editors2.BorderEditor">
+          <Border info="org.netbeans.modules.form.compat2.border.EmptyBorderInfo">
+            <EmptyBorder bottom="0" left="0" right="0" top="0"/>
+          </Border>
+        </Property>
+        <Property name="margin" type="java.awt.Insets" editor="org.netbeans.beaninfo.editors.InsetsEditor">
+          <Insets value="[0, 0, 0, 0]"/>
+        </Property>
+      </Properties>
+    </Component>
+  </SubComponents>
+</Form>
diff -r 6cf33f955d7d test/com/sun/awt/Translucency/TranslucentShapedFrameTest/TranslucentShapedFrameTest.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ openjdk/jdk/test/com/sun/awt/Translucency/TranslucentShapedFrameTest/TranslucentShapedFrameTest.java	Tue Feb 15 15:12:57 2011 +0000
@@ -0,0 +1,359 @@
+/*
+ * Copyright (c) 2008, 2009, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test %I% %E%
+ * @bug 6655001 6670649 6687141
+ * @summary Tests that hw acceleration doesn't affect translucent/shaped windows
+ * @author Dmitri.Trembovetski@sun.com: area=Graphics
+ * @compile -XDignore.symbol.file=true TranslucentShapedFrameTest.java
+ * @compile -XDignore.symbol.file=true TSFrame.java
+ * @run main/manual/othervm TranslucentShapedFrameTest
+ * @run main/manual/othervm -Dsun.java2d.noddraw=true TranslucentShapedFrameTest
+ * @run main/manual/othervm -Dsun.java2d.opengl=True TranslucentShapedFrameTest
+ */
+import com.sun.awt.AWTUtilities;
+import static com.sun.awt.AWTUtilities.Translucency.*;
+import java.awt.Frame;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+import java.awt.Shape;
+import java.awt.geom.Ellipse2D;
+import java.util.concurrent.CountDownLatch;
+import javax.swing.JSlider;
+import javax.swing.SwingUtilities;
+import javax.swing.UIManager;
+import javax.swing.UnsupportedLookAndFeelException;
+
+public class TranslucentShapedFrameTest extends javax.swing.JFrame {
+    Frame testFrame;
+    static CountDownLatch done;
+    static volatile boolean failed = false;
+    GraphicsConfiguration gcToUse = null;
+
+    /**
+     * Creates new form TranslucentShapedFrameTest
+     */
+    public TranslucentShapedFrameTest() {
+        // not necessary, but we just look nicer
+        try {
+            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
+        } catch (Exception ex) {}
+
+        initComponents();
+        checkEffects();
+
+        SwingUtilities.updateComponentTreeUI(this);
+    }
+
+    /** This method is called from within the constructor to
+     * initialize the form.
+     * WARNING: Do NOT modify this code. The content of this method is
+     * always regenerated by the Form Editor.
+     */
+    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
+    private void initComponents() {
+        createDisposeGrp = new javax.swing.ButtonGroup();
+        jLabel1 = new javax.swing.JLabel();
+        transparencySld = new javax.swing.JSlider();
+        shapedCb = new javax.swing.JCheckBox();
+        nonOpaqueChb = new javax.swing.JCheckBox();
+        jScrollPane1 = new javax.swing.JScrollPane();
+        jTextArea1 = new javax.swing.JTextArea();
+        jLabel2 = new javax.swing.JLabel();
+        passedBtn = new javax.swing.JButton();
+        failedBtn = new javax.swing.JButton();
+        createFrameBtn = new javax.swing.JToggleButton();
+        disposeFrameBtn = new javax.swing.JToggleButton();
+        useSwingCb = new javax.swing.JCheckBox();
+
+        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
+        setTitle("TranslucentShapedFrameTest");
+        jLabel1.setText("Frame Opacity:");
+
+        transparencySld.setMajorTickSpacing(10);
+        transparencySld.setMinorTickSpacing(5);
+        transparencySld.setPaintLabels(true);
+        transparencySld.setPaintTicks(true);
+        transparencySld.setValue(100);
+        transparencySld.addChangeListener(new javax.swing.event.ChangeListener() {
+            public void stateChanged(javax.swing.event.ChangeEvent evt) {
+                transparencySldStateChanged(evt);
+            }
+        });
+
+        shapedCb.setText("Shaped Frame");
+        shapedCb.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
+        shapedCb.setMargin(new java.awt.Insets(0, 0, 0, 0));
+        shapedCb.addActionListener(new java.awt.event.ActionListener() {
+            public void actionPerformed(java.awt.event.ActionEvent evt) {
+                shapedCbActionPerformed(evt);
+            }
+        });
+
+        nonOpaqueChb.setText("Non Opaque Frame");
+        nonOpaqueChb.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
+        nonOpaqueChb.setMargin(new java.awt.Insets(0, 0, 0, 0));
+        nonOpaqueChb.addActionListener(new java.awt.event.ActionListener() {
+            public void actionPerformed(java.awt.event.ActionEvent evt) {
+                nonOpaqueChbActionPerformed(evt);
+            }
+        });
+
+        jTextArea1.setColumns(20);
+        jTextArea1.setRows(5);
+        jTextArea1.setText("Create translucent and/or shaped, or\nnon-opaque frame. Make sure it behaves\ncorrectly (no artifacts left on the screen\nwhen dragging - if dragging is possible).\nClick \"Passed\" if the test behaves correctly,\n\"Falied\" otherwise.");
+        jScrollPane1.setViewportView(jTextArea1);
+
+        jLabel2.setText("Instructions:");
+
+        passedBtn.setBackground(new java.awt.Color(129, 255, 100));
+        passedBtn.setText("Passed");
+        passedBtn.addActionListener(new java.awt.event.ActionListener() {
+            public void actionPerformed(java.awt.event.ActionEvent evt) {
+                passedBtnActionPerformed(evt);
+            }
+        });
+
+        failedBtn.setBackground(java.awt.Color.red);
+        failedBtn.setText("Failed");
+        failedBtn.addActionListener(new java.awt.event.ActionListener() {
+            public void actionPerformed(java.awt.event.ActionEvent evt) {
+                failedBtnActionPerformed(evt);
+            }
+        });
+
+        createDisposeGrp.add(createFrameBtn);
+        createFrameBtn.setText("Create Frame");
+        createFrameBtn.addActionListener(new java.awt.event.ActionListener() {
+            public void actionPerformed(java.awt.event.ActionEvent evt) {
+                createFrameBtnActionPerformed(evt);
+            }
+        });
+
+        createDisposeGrp.add(disposeFrameBtn);
+        disposeFrameBtn.setSelected(true);
+        disposeFrameBtn.setText("Dispose Frame");
+        disposeFrameBtn.addActionListener(new java.awt.event.ActionListener() {
+            public void actionPerformed(java.awt.event.ActionEvent evt) {
+                disposeFrameBtnActionPerformed(evt);
+            }
+        });
+
+        useSwingCb.setText("Use JFrame");
+        useSwingCb.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
+        useSwingCb.setMargin(new java.awt.Insets(0, 0, 0, 0));
+
+        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
+        getContentPane().setLayout(layout);
+        layout.setHorizontalGroup(
+            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
+            .addGroup(layout.createSequentialGroup()
+                .addContainerGap()
+                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
+                    .addGroup(layout.createSequentialGroup()
+                        .addComponent(transparencySld, javax.swing.GroupLayout.DEFAULT_SIZE, 375, Short.MAX_VALUE)
+                        .addContainerGap())
+                    .addComponent(jLabel1)
+                    .addGroup(layout.createSequentialGroup()
+                        .addComponent(shapedCb)
+                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
+                        .addComponent(nonOpaqueChb)
+                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
+                        .addComponent(useSwingCb)
+                        .addContainerGap(102, Short.MAX_VALUE))
+                    .addGroup(layout.createSequentialGroup()
+                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
+                            .addGroup(layout.createSequentialGroup()
+                                .addComponent(jLabel2)
+                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 314, javax.swing.GroupLayout.PREFERRED_SIZE))
+                            .addGroup(layout.createSequentialGroup()
+                                .addComponent(passedBtn)
+                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
+                                .addComponent(failedBtn)
+                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 241, javax.swing.GroupLayout.PREFERRED_SIZE))
+                            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 375, Short.MAX_VALUE)
+                            .addGroup(layout.createSequentialGroup()
+                                .addComponent(createFrameBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 187, javax.swing.GroupLayout.PREFERRED_SIZE)
+                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
+                                .addComponent(disposeFrameBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 182, javax.swing.GroupLayout.PREFERRED_SIZE)))
+                        .addContainerGap())))
+        );
+        layout.setVerticalGroup(
+            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
+            .addGroup(layout.createSequentialGroup()
+                .addContainerGap()
+                .addComponent(jLabel1)
+                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
+                .addComponent(transparencySld, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
+                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
+                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
+                    .addComponent(shapedCb)
+                    .addComponent(nonOpaqueChb)
+                    .addComponent(useSwingCb))
+                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
+                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
+                    .addComponent(disposeFrameBtn)
+                    .addComponent(createFrameBtn))
+                .addGap(17, 17, 17)
+                .addComponent(jLabel2)
+                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
+                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 148, javax.swing.GroupLayout.PREFERRED_SIZE)
+                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
+                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
+                    .addComponent(passedBtn)
+                    .addComponent(failedBtn))
+                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
+        );
+        pack();
+    }// </editor-fold>//GEN-END:initComponents
+
+    private void nonOpaqueChbActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nonOpaqueChbActionPerformed
+        if (testFrame != null) {
+            // REMIND: this path in the test doesn't work well (test bug)
+//            AWTUtilities.setWindowOpaque(testFrame, !nonOpaqueChb.isSelected());
+        }
+    }//GEN-LAST:event_nonOpaqueChbActionPerformed
+
+    private void shapedCbActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_shapedCbActionPerformed
+        if (testFrame != null) {
+            Shape s = null;
+            if (shapedCb.isSelected()) {
+                s = new Ellipse2D.Double(0, 0,
+                                         testFrame.getWidth(),
+                                         testFrame.getHeight());
+            }
+            AWTUtilities.setWindowShape(testFrame, s);
+        }
+    }//GEN-LAST:event_shapedCbActionPerformed
+
+    private void transparencySldStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_transparencySldStateChanged
+        JSlider source = (JSlider)evt.getSource();
+            int transl = transparencySld.getValue();
+            if (testFrame != null) {
+                AWTUtilities.setWindowOpacity(testFrame, (float)transl/100f);
+            }
+    }//GEN-LAST:event_transparencySldStateChanged
+
+    private void failedBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_failedBtnActionPerformed
+        disposeFrameBtnActionPerformed(evt);
+        dispose();
+        failed = true;
+        done.countDown();
+    }//GEN-LAST:event_failedBtnActionPerformed
+
+    private void disposeFrameBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_disposeFrameBtnActionPerformed
+        TSFrame.stopThreads();
+        if (testFrame != null) {
+            testFrame.dispose();
+            testFrame = null;
+        }
+    }//GEN-LAST:event_disposeFrameBtnActionPerformed
+
+    private void createFrameBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_createFrameBtnActionPerformed
+        disposeFrameBtnActionPerformed(evt);
+        int transl = transparencySld.getValue();
+        testFrame = TSFrame.createGui(gcToUse,
+                useSwingCb.isSelected(), shapedCb.isSelected(),
+                (transl < 100), nonOpaqueChb.isSelected(),
+                (float)transl/100f);
+    }//GEN-LAST:event_createFrameBtnActionPerformed
+
+    private void passedBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_passedBtnActionPerformed
+        disposeFrameBtnActionPerformed(evt);
+        dispose();
+        done.countDown();
+    }//GEN-LAST:event_passedBtnActionPerformed
+
+    /**
+     * @param args the command line arguments
+     */
+    public static void main(String args[]) {
+        done = new CountDownLatch(1);
+        java.awt.EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                new TranslucentShapedFrameTest().setVisible(true);
+            }
+        });
+        try {
+            done.await();
+        } catch (InterruptedException ex) {}
+        if (failed) {
+            throw new RuntimeException("Test FAILED");
+        }
+        System.out.println("Test PASSED");
+    }
+
+    private void checkEffects() {
+        if (!AWTUtilities.isTranslucencySupported(PERPIXEL_TRANSPARENT)) {
+            shapedCb.setEnabled(false);
+        }
+
+        if (!AWTUtilities.isTranslucencySupported(TRANSLUCENT)) {
+            transparencySld.setEnabled(false);
+        }
+
+        GraphicsConfiguration gc = null;
+        if (AWTUtilities.isTranslucencySupported(PERPIXEL_TRANSLUCENT)) {
+            gc = findGraphicsConfig();
+            if (gc == null) {
+                nonOpaqueChb.setEnabled(false);
+            }
+        }
+
+        gcToUse = gc;
+    }
+
+    private GraphicsConfiguration findGraphicsConfig() {
+        GraphicsDevice gd =
+            GraphicsEnvironment.getLocalGraphicsEnvironment().
+                getDefaultScreenDevice();
+        GraphicsConfiguration gcs[] = gd.getConfigurations();
+        for (GraphicsConfiguration gc : gcs) {
+            if (AWTUtilities.isTranslucencyCapable(gc)) {
+                return gc;
+            }
+        }
+        return null;
+    }
+
+    // Variables declaration - do not modify//GEN-BEGIN:variables
+    private javax.swing.ButtonGroup createDisposeGrp;
+    private javax.swing.JToggleButton createFrameBtn;
+    private javax.swing.JToggleButton disposeFrameBtn;
+    private javax.swing.JButton failedBtn;
+    private javax.swing.JLabel jLabel1;
+    private javax.swing.JLabel jLabel2;
+    private javax.swing.JScrollPane jScrollPane1;
+    private javax.swing.JTextArea jTextArea1;
+    private javax.swing.JCheckBox nonOpaqueChb;
+    private javax.swing.JButton passedBtn;
+    private javax.swing.JCheckBox shapedCb;
+    private javax.swing.JSlider transparencySld;
+    private javax.swing.JCheckBox useSwingCb;
+    // End of variables declaration//GEN-END:variables
+
+}
diff -r 6cf33f955d7d test/com/sun/awt/Translucency/WindowOpacity.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ openjdk/jdk/test/com/sun/awt/Translucency/WindowOpacity.java	Tue Feb 15 15:12:57 2011 +0000
@@ -0,0 +1,461 @@
+/*
+ * Copyright (c) 2008, 2009, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+  @test %W% %E%
+  @bug 6594131
+  @summary Tests the AWTUtilities.get/setWindowOpacity() methods
+  @author anthony.petrov@...: area=awt.toplevel
+  @run main WindowOpacity
+*/
+
+import java.awt.*;
+import java.awt.event.*;
+
+import com.sun.awt.AWTUtilities;
+import sun.awt.SunToolkit;
+
+public class WindowOpacity
+{
+    //*** test-writer defined static variables go here ***
+
+    private static void realSync() {
+        ((SunToolkit)Toolkit.getDefaultToolkit()).realSync();
+    }
+
+
+    private static void init()
+    {
+        //*** Create instructions for the user here ***
+        String[] instructions =
+        {
+            "This is an AUTOMATIC test, simply wait until it is done.",
+            "The result (passed or failed) will be shown in the",
+            "message window below."
+        };
+        Sysout.createDialog( );
+        Sysout.printInstructions( instructions );
+
+        if (!AWTUtilities.isTranslucencySupported(AWTUtilities.Translucency.TRANSLUCENT)) {
+            System.out.println("Either the Toolkit or the native system does not support controlling the window opacity level.");
+            pass();
+        }
+
+        boolean passed;
+
+        Frame f = new Frame("Opacity test");
+
+        passed = false;
+        try {
+            AWTUtilities.getWindowOpacity(null);
+        } catch (NullPointerException e) {
+            passed = true;
+        }
+        if (!passed) {
+            fail("getWindowOpacity() allows passing null.");
+        }
+
+
+        passed = false;
+        try {
+            AWTUtilities.setWindowOpacity(null, 0.5f);
+        } catch (NullPointerException e) {
+            passed = true;
+        }
+        if (!passed) {
+            fail("setWindowOpacity() allows passing null.");
+        }
+
+
+        float curOpacity = AWTUtilities.getWindowOpacity(f);
+        if (curOpacity < 1.0f || curOpacity > 1.0f) {
+            fail("getWindowOpacity() reports the initial opacity level other than 1.0: " + curOpacity);
+        }
+
+
+
+        passed = false;
+        try {
+            AWTUtilities.setWindowOpacity(f, -0.5f);
+        } catch (IllegalArgumentException e) {
+            passed = true;
+        }
+        if (!passed) {
+            fail("setWindowOpacity() allows passing negative opacity level.");
+        }
+
+
+
+        passed = false;
+        try {
+            AWTUtilities.setWindowOpacity(f, 1.5f);
+        } catch (IllegalArgumentException e) {
+            passed = true;
+        }
+        if (!passed) {
+            fail("setWindowOpacity() allows passing opacity level greater than 1.0.");
+        }
+
+
+        AWTUtilities.setWindowOpacity(f, 0.5f);
+
+        curOpacity = AWTUtilities.getWindowOpacity(f);
+        if (curOpacity < 0.5f || curOpacity > 0.5f) {
+            fail("getWindowOpacity() reports the opacity level that differs from the value set with setWindowOpacity: " + curOpacity);
+        }
+
+
+        AWTUtilities.setWindowOpacity(f, 0.75f);
+
+        curOpacity = AWTUtilities.getWindowOpacity(f);
+        if (curOpacity < 0.75f || curOpacity > 0.75f) {
+            fail("getWindowOpacity() reports the opacity level that differs from the value set with setWindowOpacity the second time: " + curOpacity);
+        }
+
+
+        f.setBounds(100, 100, 300, 200);
+        f.setVisible(true);
+
+        realSync();
+
+        curOpacity = AWTUtilities.getWindowOpacity(f);
+        if (curOpacity < 0.75f || curOpacity > 0.75f) {
+            fail("getWindowOpacity() reports the opacity level that differs from the value set with setWindowOpacity before showing the frame: " + curOpacity);
+        }
+
+
+
+        AWTUtilities.setWindowOpacity(f, 0.5f);
+        realSync();
+
+        curOpacity = AWTUtilities.getWindowOpacity(f);
+        if (curOpacity < 0.5f || curOpacity > 0.5f) {
+            fail("getWindowOpacity() reports the opacity level that differs from the value set with setWindowOpacity after showing the frame: " + curOpacity);
+        }
+
+        WindowOpacity.pass();
+
+    }//End  init()
+
+
+
+    /*****************************************************
+     * Standard Test Machinery Section
+     * DO NOT modify anything in this section -- it's a
+     * standard chunk of code which has all of the
+     * synchronisation necessary for the test harness.
+     * By keeping it the same in all tests, it is easier
+     * to read and understand someone else's test, as
+     * well as insuring that all tests behave correctly
+     * with the test harness.
+     * There is a section following this for test-
+     * classes
+     ******************************************************/
+    private static boolean theTestPassed = false;
+    private static boolean testGeneratedInterrupt = false;
+    private static String failureMessage = "";
+
+    private static Thread mainThread = null;
+
+    private static int sleepTime = 300000;
+
+    // Not sure about what happens if multiple of this test are
+    //  instantiated in the same VM.  Being static (and using
+    //  static vars), it aint gonna work.  Not worrying about
+    //  it for now.
+    public static void main( String args[] ) throws InterruptedException
+    {
+        mainThread = Thread.currentThread();
+        try
+        {
+            init();
+        }
+        catch( TestPassedException e )
+        {
+            //The test passed, so just return from main and harness will
+            // interepret this return as a pass
+            return;
+        }
+        //At this point, neither test pass nor test fail has been
+        // called -- either would have thrown an exception and ended the
+        // test, so we know we have multiple threads.
+
+        //Test involves other threads, so sleep and wait for them to
+        // called pass() or fail()
+        try
+        {
+            Thread.sleep( sleepTime );
+            //Timed out, so fail the test
+            throw new RuntimeException( "Timed out after " + sleepTime/1000 + " seconds" );
+        }
+        catch (InterruptedException e)
+        {
+            //The test harness may have interrupted the test.  If so, rethrow the exception
+            // so that the harness gets it and deals with it.
+            if( ! testGeneratedInterrupt ) throw e;
+
+            //reset flag in case hit this code more than once for some reason (just safety)
+            testGeneratedInterrupt = false;
+
+            if ( theTestPassed == false )
+            {
+                throw new RuntimeException( failureMessage );
+            }
+        }
+
+    }//main
+
+    public static synchronized void setTimeoutTo( int seconds )
+    {
+        sleepTime = seconds * 1000;
+    }
+
+    public static synchronized void pass()
+    {
+        Sysout.println( "The test passed." );
+        Sysout.println( "The test is over, hit  Ctl-C to stop Java VM" );
+        //first check if this is executing in main thread
+        if ( mainThread == Thread.currentThread() )
+        {
+            //Still in the main thread, so set the flag just for kicks,
+            // and throw a test passed exception which will be caught
+            // and end the test.
+            theTestPassed = true;
+            throw new TestPassedException();
+        }
+        theTestPassed = true;
+        testGeneratedInterrupt = true;
+        mainThread.interrupt();
+    }//pass()
+
+    public static synchronized void fail()
+    {
+        //test writer didn't specify why test failed, so give generic
+        fail( "it just plain failed! :-)" );
+    }
+
+    public static synchronized void fail( String whyFailed )
+    {
+        Sysout.println( "The test failed: " + whyFailed );
+        Sysout.println( "The test is over, hit  Ctl-C to stop Java VM" );
+        //check if this called from main thread
+        if ( mainThread == Thread.currentThread() )
+        {
+            //If main thread, fail now 'cause not sleeping
+            throw new RuntimeException( whyFailed );
+        }
+        theTestPassed = false;
+        testGeneratedInterrupt = true;
+        failureMessage = whyFailed;
+        mainThread.interrupt();
+    }//fail()
+
+}// class WindowOpacity
+
+//This exception is used to exit from any level of call nesting
+// when it's determined that the test has passed, and immediately
+// end the test.
+class TestPassedException extends RuntimeException
+{
+}
+
+//*********** End Standard Test Machinery Section **********
+
+
+//************ Begin classes defined for the test ****************
+
+// if want to make listeners, here is the recommended place for them, then instantiate
+//  them in init()
+
+/* Example of a class which may be written as part of a test
+class NewClass implements anInterface
+ {
+   static int newVar = 0;
+
+   public void eventDispatched(AWTEvent e)
+    {
+      //Counting events to see if we get enough
+      eventCount++;
+
+      if( eventCount == 20 )
+       {
+         //got enough events, so pass
+
+         WindowOpacity.pass();
+       }
+      else if( tries == 20 )
+       {
+         //tried too many times without getting enough events so fail
+
+         WindowOpacity.fail();
+       }
+
+    }// eventDispatched()
+
+ }// NewClass class
+
+*/
+
+
+//************** End classes defined for the test *******************
+
+
+
+
+/****************************************************
+ Standard Test Machinery
+ DO NOT modify anything below -- it's a standard
+  chunk of code whose purpose is to make user
+  interaction uniform, and thereby make it simpler
+  to read and understand someone else's test.
+ ****************************************************/
+
+/**
+ This is part of the standard test machinery.
+ It creates a dialog (with the instructions), and is the interface
+  for sending text messages to the user.
+ To print the instructions, send an array of strings to Sysout.createDialog
+  WithInstructions method.  Put one line of instructions per array entry.
+ To display a message for the tester to see, simply call Sysout.println
+  with the string to be displayed.
+ This mimics System.out.println but works within the test harness as well
+  as standalone.
+ */
+
+class Sysout
+{
+    private static TestDialog dialog;
+
+    public static void createDialogWithInstructions( String[] instructions )
+    {
+        dialog = new TestDialog( new Frame(), "Instructions" );
+        dialog.printInstructions( instructions );
+        dialog.setVisible(true);
+        println( "Any messages for the tester will display here." );
+    }
+
+    public static void createDialog( )
+    {
+        dialog = new TestDialog( new Frame(), "Instructions" );
+        String[] defInstr = { "Instructions will appear here. ", "" } ;
+        dialog.printInstructions( defInstr );
+        dialog.setVisible(true);
+        println( "Any messages for the tester will display here." );
+    }
+
+
+    public static void printInstructions( String[] instructions )
+    {
+        dialog.printInstructions( instructions );
+    }
+
+
+    public static void println( String messageIn )
+    {
+        dialog.displayMessage( messageIn );
+        System.out.println(messageIn);
+    }
+
+}// Sysout  class
+
+/**
+  This is part of the standard test machinery.  It provides a place for the
+   test instructions to be displayed, and a place for interactive messages
+   to the user to be displayed.
+  To have the test instructions displayed, see Sysout.
+  To have a message to the user be displayed, see Sysout.
+  Do not call anything in this dialog directly.
+  */
+class TestDialog extends Dialog
+{
+
+    TextArea instructionsText;
+    TextArea messageText;
+    int maxStringLength = 80;
+
+    //DO NOT call this directly, go through Sysout
+    public TestDialog( Frame frame, String name )
+    {
+        super( frame, name );
+        int scrollBoth = TextArea.SCROLLBARS_BOTH;
+        instructionsText = new TextArea( "", 15, maxStringLength, scrollBoth );
+        add( "North", instructionsText );
+
+        messageText = new TextArea( "", 5, maxStringLength, scrollBoth );
+        add("Center", messageText);
+
+        pack();
+
+        setVisible(true);
+    }// TestDialog()
+
+    //DO NOT call this directly, go through Sysout
+    public void printInstructions( String[] instructions )
+    {
+        //Clear out any current instructions
+        instructionsText.setText( "" );
+
+        //Go down array of instruction strings
+
+        String printStr, remainingStr;
+        for( int i=0; i < instructions.length; i++ )
+        {
+            //chop up each into pieces maxSringLength long
+            remainingStr = instructions[ i ];
+            while( remainingStr.length() > 0 )
+            {
+                //if longer than max then chop off first max chars to print
+                if( remainingStr.length() >= maxStringLength )
+                {
+                    //Try to chop on a word boundary
+                    int posOfSpace = remainingStr.
+                        lastIndexOf( ' ', maxStringLength - 1 );
+
+                    if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;
+
+                    printStr = remainingStr.substring( 0, posOfSpace + 1 );
+                    remainingStr = remainingStr.substring( posOfSpace + 1 );
+                }
+                //else just print
+                else
+                {
+                    printStr = remainingStr;
+                    remainingStr = "";
+                }
+
+                instructionsText.append( printStr + "\n" );
+
+            }// while
+
+        }// for
+
+    }//printInstructions()
+
+    //DO NOT call this directly, go through Sysout
+    public void displayMessage( String messageIn )
+    {
+        messageText.append( messageIn + "\n" );
+        System.out.println(messageIn);
+    }
+
+}// TestDialog  class
diff -r 6cf33f955d7d test/sun/java2d/pipe/RegionOps.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ openjdk/jdk/test/sun/java2d/pipe/RegionOps.java	Tue Feb 15 15:12:57 2011 +0000
@@ -0,0 +1,533 @@
+/*
+ * Copyright (c) 2009, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test %W% %E%
+ * @bug 6504874
+ * @summary This test verifies the operation (and performance) of the
+ *          various CAG operations on the internal Region class.
+ * @run main RegionOps
+ */
+
+import java.awt.Rectangle;
+import java.awt.geom.Area;
+import java.awt.geom.AffineTransform;
+import java.awt.image.BufferedImage;
+import java.util.Random;
+import sun.java2d.pipe.Region;
+
+public class RegionOps {
+    public static final int DEFAULT_NUMREGIONS = 50;
+    public static final int DEFAULT_MINSUBRECTS = 1;
+    public static final int DEFAULT_MAXSUBRECTS = 10;
+
+    public static final int MINCOORD = -20;
+    public static final int MAXCOORD = 20;
+
+    public static boolean useArea;
+
+    static int numops;
+    static int numErrors;
+    static Random rand = new Random();
+    static boolean skipCheck;
+    static boolean countErrors;
+
+    static {
+        // Instantiating BufferedImage initializes sun.java2d
+        BufferedImage bimg =
+            new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);
+    }
+
+    public static void usage(String error) {
+        if (error != null) {
+            System.err.println("Error: "+error);
+        }
+        System.err.println("Usage: java RegionOps "+
+                           "[-regions N] [-rects M] "+
+                           "[-[min|max]rects M] [-area]");
+        System.err.println("                      "+
+                           "[-add|union] [-sub|diff] "+
+                           "[-int[ersect]] [-xor]");
+        System.err.println("                      "+
+                           "[-seed S] [-nocheck] [-count[errors]] [-help]");
+        System.exit((error != null) ? 1 : 0);
+    }
+
+    public static void error(RectListImpl a, RectListImpl b, String problem) {
+        System.err.println("Operating on:  "+a);
+        if (b != null) {
+            System.err.println("and:  "+b);
+        }
+        if (countErrors) {
+            System.err.println(problem);
+            numErrors++;
+        } else {
+            throw new RuntimeException(problem);
+        }
+    }
+
+    public static void main(String argv[]) {
+        int numregions = DEFAULT_NUMREGIONS;
+        int minsubrects = DEFAULT_MINSUBRECTS;
+        int maxsubrects = DEFAULT_MAXSUBRECTS;
+        boolean doUnion = false;
+        boolean doIntersect = false;
+        boolean doSubtract = false;
+        boolean doXor = false;
+
+        for (int i = 0; i < argv.length; i++) {
+            String arg = argv[i];
+            if (arg.equalsIgnoreCase("-regions")) {
+                if (i+1 >= argv.length) {
+                    usage("missing arg for -regions");
+                }
+                numregions = Integer.parseInt(argv[++i]);
+            } else if (arg.equalsIgnoreCase("-rects")) {
+                if (i+1 >= argv.length) {
+                    usage("missing arg for -rects");
+                }
+                minsubrects = maxsubrects = Integer.parseInt(argv[++i]);
+            } else if (arg.equalsIgnoreCase("-minrects")) {
+                if (i+1 >= argv.length) {
+                    usage("missing arg for -minrects");
+                }
+                minsubrects = Integer.parseInt(argv[++i]);
+            } else if (arg.equalsIgnoreCase("-maxrects")) {
+                if (i+1 >= argv.length) {
+                    usage("missing arg for -maxrects");
+                }
+                maxsubrects = Integer.parseInt(argv[++i]);
+            } else if (arg.equalsIgnoreCase("-area")) {
+                useArea = true;
+            } else if (arg.equalsIgnoreCase("-add") ||
+                       arg.equalsIgnoreCase("-union"))
+            {
+                doUnion = true;
+            } else if (arg.equalsIgnoreCase("-sub") ||
+                       arg.equalsIgnoreCase("-diff"))
+            {
+                doSubtract = true;
+            } else if (arg.equalsIgnoreCase("-int") ||
+                       arg.equalsIgnoreCase("-intersect"))
+            {
+                doIntersect = true;
+            } else if (arg.equalsIgnoreCase("-xor")) {
+                doXor = true;
+            } else if (arg.equalsIgnoreCase("-seed")) {
+                if (i+1 >= argv.length) {
+                    usage("missing arg for -seed");
+                }
+                rand.setSeed(Long.decode(argv[++i]).longValue());
+            } else if (arg.equalsIgnoreCase("-nocheck")) {
+                skipCheck = true;
+            } else if (arg.equalsIgnoreCase("-count") ||
+                       arg.equalsIgnoreCase("-counterrors"))
+            {
+                countErrors = true;
+            } else if (arg.equalsIgnoreCase("-help")) {
+                usage(null);
+            } else {
+                usage("Unknown argument: "+arg);
+            }
+        }
+
+        if (maxsubrects < minsubrects) {
+            usage("maximum number of subrectangles less than minimum");
+        }
+
+        if (minsubrects <= 0) {
+            usage("minimum number of subrectangles must be positive");
+        }
+
+        if (!doUnion && !doSubtract && !doIntersect && !doXor) {
+            doUnion = doSubtract = doIntersect = doXor = true;
+        }
+
+        long start = System.currentTimeMillis();
+        RectListImpl rlist[] = new RectListImpl[numregions];
+        int totalrects = 0;
+        for (int i = 0; i < rlist.length; i++) {
+            RectListImpl rli = RectListImpl.getInstance();
+            int numsubrects =
+                minsubrects + rand.nextInt(maxsubrects - minsubrects + 1);
+            for (int j = 0; j < numsubrects; j++) {
+                addRectTo(rli);
+                totalrects++;
+            }
+            rlist[i] = rli;
+        }
+        long end = System.currentTimeMillis();
+        System.out.println((end-start)+"ms to create "+
+                           rlist.length+" regions containing "+
+                           totalrects+" subrectangles");
+
+        start = System.currentTimeMillis();
+        for (int i = 0; i < rlist.length; i++) {
+            RectListImpl a = rlist[i];
+            testTranslate(a);
+            for (int j = i; j < rlist.length; j++) {
+                RectListImpl b = rlist[j];
+                if (doUnion) testUnion(a, b);
+                if (doSubtract) testDifference(a, b);
+                if (doIntersect) testIntersection(a, b);
+                if (doXor) testExclusiveOr(a, b);
+            }
+        }
+        end = System.currentTimeMillis();
+        System.out.println(numops+" ops took "+(end-start)+"ms");
+
+        if (numErrors > 0) {
+            throw new RuntimeException(numErrors+" errors encountered");
+        }
+    }
+
+    public static void addRectTo(RectListImpl rli) {
+        int lox = MINCOORD + rand.nextInt(MAXCOORD - MINCOORD + 1);
+        int hix = MINCOORD + rand.nextInt(MAXCOORD - MINCOORD + 1);
+        int loy = MINCOORD + rand.nextInt(MAXCOORD - MINCOORD + 1);
+        int hiy = MINCOORD + rand.nextInt(MAXCOORD - MINCOORD + 1);
+        rli.addRect(lox, loy, hix, hiy);
+    }
+
+    public static void checkEqual(RectListImpl a, RectListImpl b,
+                                  String optype)
+    {
+        if (a.hashCode() != b.hashCode()) {
+            error(a, b, "hashcode failed for "+optype);
+        }
+        if (!a.equals(b)) {
+            error(a, b, "equals failed for "+optype);
+        }
+    }
+
+    public static void testTranslate(RectListImpl a) {
+        RectListImpl maxTrans =
+            a.getTranslation(Integer.MAX_VALUE, Integer.MAX_VALUE)
+            .getTranslation(Integer.MAX_VALUE, Integer.MAX_VALUE)
+            .getTranslation(Integer.MAX_VALUE, Integer.MAX_VALUE);
+        if (!maxTrans.checkTransEmpty()) {
+            error(maxTrans, null, "overflow translated RectList not empty");
+        }
+        RectListImpl minTrans =
+            a.getTranslation(Integer.MIN_VALUE, Integer.MIN_VALUE)
+            .getTranslation(Integer.MIN_VALUE, Integer.MIN_VALUE)
+            .getTranslation(Integer.MIN_VALUE, Integer.MIN_VALUE);
+        if (!minTrans.checkTransEmpty()) {
+            error(minTrans, null, "overflow translated RectList not empty");
+        }
+        testTranslate(a, Integer.MAX_VALUE, Integer.MAX_VALUE, false,
+                      MINCOORD, 0, MINCOORD, 0);
+        testTranslate(a, Integer.MAX_VALUE, Integer.MIN_VALUE, false,
+                      MINCOORD, 0, 0, MAXCOORD);
+        testTranslate(a, Integer.MIN_VALUE, Integer.MAX_VALUE, false,
+                      0, MAXCOORD, MINCOORD, 0);
+        testTranslate(a, Integer.MIN_VALUE, Integer.MIN_VALUE, false,
+                      0, MAXCOORD, 0, MAXCOORD);
+        for (int dy = -100; dy <= 100; dy += 50) {
+            for (int dx = -100; dx <= 100; dx += 50) {
+                testTranslate(a, dx, dy, true,
+                              MINCOORD, MAXCOORD,
+                              MINCOORD, MAXCOORD);
+            }
+        }
+    }
+
+    public static void testTranslate(RectListImpl a, int dx, int dy,
+                                     boolean isNonDestructive,
+                                     int xmin, int xmax,
+                                     int ymin, int ymax)
+    {
+        RectListImpl theTrans = a.getTranslation(dx, dy); numops++;
+        if (skipCheck) return;
+        RectListImpl unTrans = theTrans.getTranslation(-dx, -dy);
+        if (isNonDestructive) checkEqual(a, unTrans, "Translate");
+        for (int x = xmin; x < xmax; x++) {
+            for (int y = ymin; y < ymax; y++) {
+                boolean inside = a.contains(x, y);
+                if (theTrans.contains(x+dx, y+dy) != inside) {
+                    error(a, null, "translation failed for "+
+                          dx+", "+dy+" at "+x+", "+y);
+                }
+            }
+        }
+    }
+
+    public static void testUnion(RectListImpl a, RectListImpl b) {
+        RectListImpl aUb = a.getUnion(b); numops++;
+        RectListImpl bUa = b.getUnion(a); numops++;
+        if (skipCheck) return;
+        checkEqual(aUb, bUa, "Union");
+        testUnion(a, b, aUb);
+        testUnion(a, b, bUa);
+    }
+
+    public static void testUnion(RectListImpl a, RectListImpl b,
+                                 RectListImpl theUnion)
+    {
+        for (int x = MINCOORD; x < MAXCOORD; x++) {
+            for (int y = MINCOORD; y < MAXCOORD; y++) {
+                boolean inside = (a.contains(x, y) || b.contains(x, y));
+                if (theUnion.contains(x, y) != inside) {
+                    error(a, b, "union failed at "+x+", "+y);
+                }
+            }
+        }
+    }
+
+    public static void testDifference(RectListImpl a, RectListImpl b) {
+        RectListImpl aDb = a.getDifference(b); numops++;
+        RectListImpl bDa = b.getDifference(a); numops++;
+        if (skipCheck) return;
+        // Note that difference is not commutative so we cannot check equals
+        // checkEqual(a, b, "Difference");
+        testDifference(a, b, aDb);
+        testDifference(b, a, bDa);
+    }
+
+    public static void testDifference(RectListImpl a, RectListImpl b,
+                                      RectListImpl theDifference)
+    {
+        for (int x = MINCOORD; x < MAXCOORD; x++) {
+            for (int y = MINCOORD; y < MAXCOORD; y++) {
+                boolean inside = (a.contains(x, y) && !b.contains(x, y));
+                if (theDifference.contains(x, y) != inside) {
+                    error(a, b, "difference failed at "+x+", "+y);
+                }
+            }
+        }
+    }
+
+    public static void testIntersection(RectListImpl a, RectListImpl b) {
+        RectListImpl aIb = a.getIntersection(b); numops++;
+        RectListImpl bIa = b.getIntersection(a); numops++;
+        if (skipCheck) return;
+        checkEqual(aIb, bIa, "Intersection");
+        testIntersection(a, b, aIb);
+        testIntersection(a, b, bIa);
+    }
+
+    public static void testIntersection(RectListImpl a, RectListImpl b,
+                                        RectListImpl theIntersection)
+    {
+        for (int x = MINCOORD; x < MAXCOORD; x++) {
+            for (int y = MINCOORD; y < MAXCOORD; y++) {
+                boolean inside = (a.contains(x, y) && b.contains(x, y));
+                if (theIntersection.contains(x, y) != inside) {
+                    error(a, b, "intersection failed at "+x+", "+y);
+                }
+            }
+        }
+    }
+
+    public static void testExclusiveOr(RectListImpl a, RectListImpl b) {
+        RectListImpl aXb = a.getExclusiveOr(b); numops++;
+        RectListImpl bXa = b.getExclusiveOr(a); numops++;
+        if (skipCheck) return;
+        checkEqual(aXb, bXa, "ExclusiveOr");
+        testExclusiveOr(a, b, aXb);
+        testExclusiveOr(a, b, bXa);
+    }
+
+    public static void testExclusiveOr(RectListImpl a, RectListImpl b,
+                                       RectListImpl theExclusiveOr)
+    {
+        for (int x = MINCOORD; x < MAXCOORD; x++) {
+            for (int y = MINCOORD; y < MAXCOORD; y++) {
+                boolean inside = (a.contains(x, y) != b.contains(x, y));
+                if (theExclusiveOr.contains(x, y) != inside) {
+                    error(a, b, "xor failed at "+x+", "+y);
+                }
+            }
+        }
+    }
+
+    public abstract static class RectListImpl {
+        public static RectListImpl getInstance() {
+            if (useArea) {
+                return new AreaImpl();
+            } else {
+                return new RegionImpl();
+            }
+        }
+
+        public abstract void addRect(int lox, int loy, int hix, int hiy);
+
+        public abstract RectListImpl getTranslation(int dx, int dy);
+
+        public abstract RectListImpl getIntersection(RectListImpl rli);
+        public abstract RectListImpl getExclusiveOr(RectListImpl rli);
+        public abstract RectListImpl getDifference(RectListImpl rli);
+        public abstract RectListImpl getUnion(RectListImpl rli);
+
+        // Used for making sure that 3xMAX translates yields an empty region
+        public abstract boolean checkTransEmpty();
+
+        public abstract boolean contains(int x, int y);
+
+        public abstract int hashCode();
+        public abstract boolean equals(RectListImpl other);
+    }
+
+    public static class AreaImpl extends RectListImpl {
+        Area theArea;
+
+        public AreaImpl() {
+        }
+
+        public AreaImpl(Area a) {
+            theArea = a;
+        }
+
+        public void addRect(int lox, int loy, int hix, int hiy) {
+            Area a2 = new Area(new Rectangle(lox, loy, hix-lox, hiy-loy));
+            if (theArea == null) {
+                theArea = a2;
+            } else {
+                theArea.add(a2);
+            }
+        }
+
+        public RectListImpl getTranslation(int dx, int dy) {
+            AffineTransform at = AffineTransform.getTranslateInstance(dx, dy);
+            return new AreaImpl(theArea.createTransformedArea(at));
+        }
+
+        public RectListImpl getIntersection(RectListImpl rli) {
+            Area a2 = new Area(theArea);
+            a2.intersect(((AreaImpl) rli).theArea);
+            return new AreaImpl(a2);
+        }
+
+        public RectListImpl getExclusiveOr(RectListImpl rli) {
+            Area a2 = new Area(theArea);
+            a2.exclusiveOr(((AreaImpl) rli).theArea);
+            return new AreaImpl(a2);
+        }
+
+        public RectListImpl getDifference(RectListImpl rli) {
+            Area a2 = new Area(theArea);
+            a2.subtract(((AreaImpl) rli).theArea);
+            return new AreaImpl(a2);
+        }
+
+        public RectListImpl getUnion(RectListImpl rli) {
+            Area a2 = new Area(theArea);
+            a2.add(((AreaImpl) rli).theArea);
+            return new AreaImpl(a2);
+        }
+
+        // Used for making sure that 3xMAX translates yields an empty region
+        public boolean checkTransEmpty() {
+            // Area objects will actually survive 3 MAX translates so just
+            // pretend that it had the intended effect...
+            return true;
+        }
+
+        public boolean contains(int x, int y) {
+            return theArea.contains(x, y);
+        }
+
+        public int hashCode() {
+            // Area does not override hashCode...
+            return 0;
+        }
+
+        public boolean equals(RectListImpl other) {
+            return theArea.equals(((AreaImpl) other).theArea);
+        }
+
+        public String toString() {
+            return theArea.toString();
+        }
+    }
+
+    public static class RegionImpl extends RectListImpl {
+        Region theRegion;
+
+        public RegionImpl() {
+        }
+
+        public RegionImpl(Region r) {
+            theRegion = r;
+        }
+
+        public void addRect(int lox, int loy, int hix, int hiy) {
+            Region r2 = Region.getInstanceXYXY(lox, loy, hix, hiy);
+            if (theRegion == null) {
+                theRegion = r2;
+            } else {
+                theRegion = theRegion.getUnion(r2);
+            }
+        }
+
+        public RectListImpl getTranslation(int dx, int dy) {
+            return new RegionImpl(theRegion.getTranslatedRegion(dx, dy));
+        }
+
+        public RectListImpl getIntersection(RectListImpl rli) {
+            Region r2 = ((RegionImpl) rli).theRegion;
+            r2 = theRegion.getIntersection(r2);
+            return new RegionImpl(r2);
+        }
+
+        public RectListImpl getExclusiveOr(RectListImpl rli) {
+            Region r2 = ((RegionImpl) rli).theRegion;
+            r2 = theRegion.getExclusiveOr(r2);
+            return new RegionImpl(r2);
+        }
+
+        public RectListImpl getDifference(RectListImpl rli) {
+            Region r2 = ((RegionImpl) rli).theRegion;
+            r2 = theRegion.getDifference(r2);
+            return new RegionImpl(r2);
+        }
+
+        public RectListImpl getUnion(RectListImpl rli) {
+            Region r2 = ((RegionImpl) rli).theRegion;
+            r2 = theRegion.getUnion(r2);
+            return new RegionImpl(r2);
+        }
+
+        // Used for making sure that 3xMAX translates yields an empty region
+        public boolean checkTransEmpty() {
+            // Region objects should be empty after 3 MAX translates...
+            return theRegion.isEmpty();
+        }
+
+        public boolean contains(int x, int y) {
+            return theRegion.contains(x, y);
+        }
+
+        public int hashCode() {
+            return theRegion.hashCode();
+        }
+
+        public boolean equals(RectListImpl other) {
+            return theRegion.equals(((RegionImpl) other).theRegion);
+        }
+
+        public String toString() {
+            return theRegion.toString();
+        }
+    }
+}
